<!DOCTYPE html>
<html>
<head>
<style>
table, td {
  border: 1px solid black;
}

table {
  white-space: pre;
  border-collapse: collapse;
  width: 100%;
}

th {
  height: 50px;
}
</style>
</head>
<body>

<h2>Translating Sentences</h2>
<p>java - left is original, right is translated:</p>
<table>
<tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumChars ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumChars ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( str . charAt ( i ) == str . charAt ( j ) ) && ( str . charAt ( j ) == str . charAt ( i ) ) ) {<br>        res = Math . max ( res , Math . abs ( j - i - 1 ) ) ;<br>      }<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MIRROR_IMAGE_POINT_2_D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static pair mirrorImage ( double a , double b , double c , double x1 , double y1 ) {<br>  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ;<br>  double x = temp * a + x1 ;<br>  double y = temp * b + y1 ;<br>  return new pair ( x , y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static Point mirrorImage ( int a , int b , int c , int x1 , int y1 ) {<br>  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ;<br>  double x = temp * a + x1 ;<br>  double y = temp * b + y1 ;<br>  return new Point ( x , y ) ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 , secondary = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) principal += mat [ i ] [ j ] ;<br>      if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ;<br>    }<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 ;<br>  int secondary = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( i == j ) && ( ( i + j ) == ( n - 1 ) ) ) {<br>        principal += mat [ i ] [ j ] ;<br>      }<br>      if ( ( ( i + j ) == ( n - 1 ) ) && ( ( i + j ) == ( n - 2 ) ) ) {<br>        secondary += mat [ i ] [ j ] ;<br>      }<br>    }<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPaths ( int n , int m ) {<br>  if ( n == 0 || m == 0 ) return 1 ;<br>  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPaths ( int n , int m ) {<br>  if ( ( n == 0 || m == 0 ) && ( n > m ) ) return 1 ;<br>  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean find3Numbers ( int A [ ] , int arr_size , int sum ) {<br>  int l , r ;<br>  quickSort ( A , 0 , arr_size - 1 ) ;<br>  for ( int i = 0 ;<br>  i < arr_size - 2 ;<br>  i ++ ) {<br>    l = i + 1 ;<br>    r = arr_size - 1 ;<br>    while ( l < r ) {<br>      if ( A [ i ] + A [ l ] + A [ r ] == sum ) {<br>        System . out . print ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ;<br>        return true ;<br>      }<br>      else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ;<br>      else r -- ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean find3Numbers ( int [ ] A , int arrSize , int sum ) {<br>  Arrays . sort ( A ) ;<br>  for ( int i = 0 ;<br>  i <= arrSize - 2 ;<br>  i ++ ) {<br>    int l = i + 1 ;<br>    int r = arrSize - 1 ;<br>    while ( ( l < r ) && ( A [ i ] + A [ l ] + A [ r ] == sum ) ) {<br>      System . out . println ( "Triplet is" + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ;<br>      ;<br>      return true ;<br>    }<br>    else if ( ( A [ i ] + A [ l ] + A [ r ] < sum ) && ( A [ i ] + A [ l ] + A [ r ] < sum ) ) {<br>      l ++ ;<br>    }<br>    else {<br>      r -- ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMagicSquare ( int mat [ ] [ ] ) {<br>  int sum = 0 , sum2 = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) sum = sum + mat [ i ] [ i ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;<br>  if ( sum != sum2 ) return false ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int rowSum = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) rowSum += mat [ i ] [ j ] ;<br>    if ( rowSum != sum ) return false ;<br>  }<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int colSum = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) colSum += mat [ j ] [ i ] ;<br>    if ( sum != colSum ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMagicSquare ( int [ ] [ ] mat ) {<br>  int s = 0 ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) s = s + mat [ i ] [ i ] ;<br>  int s2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) s2 = s2 + mat [ i ] [ N - i - 1 ] ;<br>  if ( ( s != s2 ) && ( s != s2 ) ) return false ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    int rowSum = 0 ;<br>    ;<br>    for ( int j = 0 ;<br>    j <= N ;<br>    j ++ ) rowSum += mat [ i ] [ j ] ;<br>    if ( ( rowSum != s ) && ( rowSum != s ) ) return false ;<br>  }<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    int colSum = 0 ;<br>    for ( int j = 0 ;<br>    j <= N ;<br>    j ++ ) colSum += mat [ j ] [ i ] ;<br>    if ( ( s != colSum ) && ( s != colSum ) ) return false ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getTotalNumberOfSequences ( int m , int n ) {<br>  int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;<br>      else if ( i < j ) T [ i ] [ j ] = 0 ;<br>      else if ( j == 1 ) T [ i ] [ j ] = i ;<br>      else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ;<br>    }<br>  }<br>  return T [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int getTotalNumberOfSequences ( int m , int n ) {<br>  int [ ] [ ] T = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) {<br>        T [ i ] [ j ] = 0 ;<br>      }<br>      else if ( i < j ) {<br>        T [ i ] [ j ] = 0 ;<br>      }<br>      else if ( j == 1 ) {<br>        T [ i ] [ j ] = i ;<br>      }<br>      else {<br>        T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ;<br>      }<br>    }<br>  }<br>  return T [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int difference ( int arr [ ] [ ] , int n ) {<br>  int d1 = 0 , d2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    d1 += arr [ i ] [ i ] ;<br>    d2 += arr [ i ] [ n - i - 1 ] ;<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int difference ( int [ ] [ ] arr , int n ) {<br>  int d1 = 0 ;<br>  int d2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    d1 = d1 + arr [ i ] [ i ] ;<br>    d2 = d2 + arr [ i ] [ n - i - 1 ] ;<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int subset ( int ar [ ] , int n ) {<br>  int res = 0 ;<br>  Arrays . sort ( ar ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int count = 1 ;<br>    for ( ;<br>    i < n - 1 ;<br>    i ++ ) {<br>      if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;<br>      else break ;<br>    }<br>    res = Math . max ( res , count ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int subset ( int [ ] ar , int n ) {<br>  int res = 0 ;<br>  Arrays . sort ( ar ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    int count = 1 ;<br>    for ( int j = 0 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      if ( ar [ i ] == ar [ i + 1 ] ) {<br>        count ++ ;<br>      }<br>      else {<br>        break ;<br>      }<br>    }<br>    res = Math . max ( res , count ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String decToBin ( int n ) {<br>  if ( n == 0 ) return "0" ;<br>  String bin = "" ;<br>  while ( n > 0 ) {<br>    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;<br>    n >>= 1 ;<br>  }<br>  return bin ;<br>}<br></td>
    <td>translated code: <br><br> public static String decToBin ( int n ) {<br>  if ( ( n == 0 ) || ( n == 1 ) ) return "0" ;<br>  ;<br>  String bin = "" ;<br>  while ( ( n > 0 ) && ( n != 0 ) ) {<br>    if ( ( n & 1 == 0 ) ) bin = "0" + bin ;<br>    else bin = "1" + bin ;<br>    n = n >> 1 ;<br>  }<br>  return bin ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String Dragon_Curve_Sequence ( int n ) {<br>  String s = "1" ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    String temp = "1" ;<br>    char prev = '1' , zero = '0' , one = '1' ;<br>    for ( int j = 0 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      temp += s . charAt ( j ) ;<br>      if ( prev == '0' ) {<br>        temp += one ;<br>        prev = one ;<br>      }<br>      else {<br>        temp += zero ;<br>        prev = zero ;<br>      }<br>    }<br>    s = temp ;<br>  }<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String Dragon_Curve_Sequence ( int n ) {<br>  String s = "1" ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    String temp = "1" ;<br>    String prev = "1" ;<br>    String zero = "0" ;<br>    String one = "1" ;<br>    for ( int j = 0 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      temp += s . charAt ( j ) ;<br>      if ( ( prev == '0' ) && ( prev != one ) ) {<br>        temp += one ;<br>        prev = one ;<br>      }<br>      else {<br>        temp += zero ;<br>        prev = zero ;<br>      }<br>    }<br>    s = temp ;<br>  }<br>  return s ;<br>}<br></td>
  </tr><tr>
    <th>STACK_SET_3_REVERSE_STRING_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reverse ( char str [ ] ) {<br>  int n = str . length , i ;<br>  for ( i = 0 ;<br>  i < n / 2 ;<br>  i ++ ) {<br>    swap ( str , i , n - i - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static String reverse ( String string ) {<br>  string = string . substring ( 0 , string . length ( ) - 1 ) ;<br>  return string ;<br>}<br></td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bitonicGenerator ( int arr [ ] , int n ) {<br>  int i = 1 ;<br>  int j = n - 1 ;<br>  if ( j % 2 != 0 ) j -- ;<br>  while ( i < j ) {<br>    arr = swap ( arr , i , j ) ;<br>    i += 2 ;<br>    j -= 2 ;<br>  }<br>  Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ;<br>  Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ;<br>  int low = ( n + 1 ) / 2 , high = n - 1 ;<br>  while ( low < high ) {<br>    Integer temp = arr [ low ] ;<br>    arr [ low ] = arr [ high ] ;<br>    arr [ high ] = temp ;<br>    low ++ ;<br>    high -- ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] bitonicGenerator ( int [ ] arr , int n ) {<br>  int i = 1 ;<br>  int j = n - 1 ;<br>  if ( ( j % 2 != 0 ) && ( j < n ) ) j = j - 1 ;<br>  while ( ( i < j ) && ( i < n ) ) {<br>    arr [ j ] = arr [ i ] ;<br>    arr [ i ] = arr [ j ] ;<br>    i = i + 2 ;<br>    j = j - 2 ;<br>  }<br>  int [ ] arrF = new int [ arr . length ] ;<br>  int [ ] arrS = new int [ arr . length ] ;<br>  for ( i = 0 ;<br>  i < ( int ) ( ( n + 1 ) / 2 ) ;<br>  i ++ ) arrF [ i ] = arr [ i ] ;<br>  i = ( int ) ( ( n + 1 ) / 2 ) ;<br>  while ( ( i < n ) && ( i < n ) ) {<br>    arrS [ i ] = arr [ i ] ;<br>    i = i + 1 ;<br>  }<br>  Arrays . sort ( arrF ) ;<br>  Arrays . sort ( arrS ) ;<br>  for ( int i = 0 ;<br>  i < arrS . length ;<br>  i ++ ) arrF [ i ] = arrS [ i ] ;<br>  return arrF ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_TWO_NUMBERS_B_FIND_X_X_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void modularEquation ( int a , int b ) {<br>  if ( a < b ) {<br>    System . out . println ( "No solution possible " ) ;<br>    return ;<br>  }<br>  if ( a == b ) {<br>    System . out . println ( "Infinite Solution possible " ) ;<br>    return ;<br>  }<br>  int count = 0 ;<br>  int n = a - b ;<br>  int y = ( int ) Math . sqrt ( a - b ) ;<br>  for ( int i = 1 ;<br>  i <= y ;<br>  ++ i ) {<br>    if ( n % i == 0 ) {<br>      if ( n / i > b ) count ++ ;<br>      if ( i > b ) count ++ ;<br>    }<br>  }<br>  if ( y * y == n && y > b ) count -- ;<br>  System . out . println ( count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void modularEquation ( int a , int b ) {<br>  if ( ( a < b ) && ( a > b ) ) {<br>    System . out . println ( "No solution possible " ) ;<br>    return ;<br>  }<br>  if ( ( a == b ) && ( a > b ) ) {<br>    System . out . println ( "Infinite Solution possible " ) ;<br>    return ;<br>  }<br>  int count = 0 ;<br>  int n = a - b ;<br>  int y = ( int ) ( Math . sqrt ( a - b ) ) ;<br>  for ( int i = 1 ;<br>  i <= y ;<br>  i ++ ) {<br>    if ( ( n % i == 0 ) && ( n / i > b ) ) {<br>      count = count + 1 ;<br>    }<br>    if ( ( i > b ) && ( i < a ) ) {<br>      count = count + 1 ;<br>    }<br>  }<br>  if ( ( y * y == n && y > b ) && ( y == b ) ) {<br>    count = count - 1 ;<br>  }<br>  System . out . println ( count ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean canFormPalindrome ( String str ) {<br>  int count [ ] = new int [ NO_OF_CHARS ] ;<br>  Arrays . fill ( count , 0 ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ;<br>  int odd = 0 ;<br>  for ( int i = 0 ;<br>  i < NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( ( count [ i ] & 1 ) == 1 ) odd ++ ;<br>    if ( odd > 1 ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canFormPalindrome ( String st ) {<br>  int [ ] count = new int [ NO_OF_CHARS ] ;<br>  for ( int i = 0 ;<br>  i <= st . length ( ) ;<br>  i ++ ) {<br>    count [ Character . toUpperCase ( st . charAt ( i ) ) ] = count [ Character . toUpperCase ( st . charAt ( i ) ) ] + 1 ;<br>  }<br>  int odd = 0 ;<br>  for ( int i = 0 ;<br>  i <= NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( ( count [ i ] & 1 ) != 0 ) {<br>      odd = odd + 1 ;<br>    }<br>    if ( ( odd > 1 ) && ( count [ i ] == 0 ) ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MEDIAN_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binaryMedian ( int m [ ] [ ] , int r , int c ) {<br>  int max = Integer . MIN_VALUE ;<br>  int min = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < r ;<br>  i ++ ) {<br>    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;<br>    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;<br>  }<br>  int desired = ( r * c + 1 ) / 2 ;<br>  while ( min < max ) {<br>    int mid = min + ( max - min ) / 2 ;<br>    int place = 0 ;<br>    int get = 0 ;<br>    for ( int i = 0 ;<br>    i < r ;<br>    ++ i ) {<br>      get = Arrays . binarySearch ( m [ i ] , mid ) ;<br>      if ( get < 0 ) get = Math . abs ( get ) - 1 ;<br>      else {<br>        while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ;<br>      }<br>      place = place + get ;<br>    }<br>    if ( place < desired ) min = mid + 1 ;<br>    else max = mid ;<br>  }<br>  return min ;<br>}<br></td>
    <td>translated code: <br><br> public static void binaryMedian ( int [ ] [ ] m , int r , int d ) {<br>  int mi = m [ 0 ] [ 0 ] ;<br>  int mx = 0 ;<br>  for ( int i = 0 ;<br>  i < r ;<br>  i ++ ) {<br>    if ( m [ i ] [ 0 ] < mi ) mi = m [ i ] [ 0 ] ;<br>    if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ;<br>  }<br>  int desired = ( r * d + 1 ) / 2 ;<br>  while ( ( mi < mx ) && ( mx > mi ) ) {<br>    int mid = mi + ( mx - mi ) / 2 ;<br>    int [ ] place = new int [ r ] ;<br>    ;<br>    for ( int i = 0 ;<br>    i < r ;<br>    i ++ ) {<br>      int j = upperBound ( m [ i ] , mid ) ;<br>      place [ 0 ] = place [ 0 ] + j ;<br>    }<br>    if ( place [ 0 ] < desired ) mi = mid + 1 ;<br>    else mx = mid ;<br>  }<br>  System . out . println ( "Median is" + mi ) ;<br>}<br></td>
  </tr><tr>
    <th>HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findHeight ( int [ ] parent , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int p = i , current = 1 ;<br>    while ( parent [ p ] != - 1 ) {<br>      current ++ ;<br>      p = parent [ p ] ;<br>    }<br>    res = Math . max ( res , current ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findHeight ( int [ ] parent , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int p = i ;<br>    int current = 1 ;<br>    while ( ( parent [ p ] != - 1 ) && ( parent [ p ] != - 1 ) ) {<br>      current ++ ;<br>      p = parent [ p ] ;<br>    }<br>    res = Math . max ( res , current ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_20</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static Boolean divisibleBy20 ( String num ) {<br>  int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ;<br>  return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean divisibleBy20 ( String num ) {<br>  int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 ) ) ;<br>  return ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDP ( int n ) {<br>  int res [ ] = new int [ n + 1 ] ;<br>  res [ 0 ] = 0 ;<br>  res [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ;<br>  return res [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDP ( int n ) {<br>  List < Integer > res = Lists . newArrayList ( ) ;<br>  res . add ( 0 ) ;<br>  res . add ( 1 ) ;<br>  int i = 2 ;<br>  while ( i < n + 1 ) {<br>    res . add ( Math . max ( i , ( res . get ( Integer . class , i / 2 ) ) + res . get ( Integer . class , i / 3 ) + res . get ( Integer . class , i / 4 ) + res . get ( Integer . class , i / 5 ) ) ) ;<br>    i = i + 1 ;<br>  }<br>  return res . get ( n ) ;<br>}<br></td>
  </tr><tr>
    <th>QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void PerformQueries ( int [ ] a , int [ ] [ ] vec ) {<br>  Vector < Integer > ans = new Vector < > ( ) ;<br>  int n = ( int ) a . length - 1 ;<br>  int q = ( int ) vec . length ;<br>  for ( int i = 0 ;<br>  i < q ;<br>  ++ i ) {<br>    long t = vec [ i ] [ 0 ] ;<br>    int m = vec [ i ] [ 1 ] ;<br>    if ( m > n ) {<br>      ans . add ( - 1 ) ;<br>      continue ;<br>    }<br>    int turn = ( int ) ( t / n ) ;<br>    int rem = ( int ) ( t % n ) ;<br>    if ( rem == 0 && turn % 2 == 1 ) {<br>      ans . add ( - 1 ) ;<br>      continue ;<br>    }<br>    if ( rem == 0 && turn % 2 == 0 ) {<br>      ans . add ( a [ m ] ) ;<br>      continue ;<br>    }<br>    if ( turn % 2 == 0 ) {<br>      int cursize = n - rem ;<br>      if ( cursize < m ) {<br>        ans . add ( - 1 ) ;<br>        continue ;<br>      }<br>      ans . add ( a [ m + rem ] ) ;<br>    }<br>    else {<br>      int cursize = rem ;<br>      if ( cursize < m ) {<br>        ans . add ( - 1 ) ;<br>        continue ;<br>      }<br>      ans . add ( a [ m ] ) ;<br>    }<br>  }<br>  for ( int i : ans ) System . out . print ( i + "\n" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void PerformQueries ( int [ ] [ ] a , int [ ] [ ] vec ) {<br>  int ans [ ] ;<br>  ;<br>  int n = a . length - 1 ;<br>  ;<br>  int q = vec . length ;<br>  ;<br>  for ( int i = 0 ;<br>  i < q ;<br>  i ++ ) {<br>    int t = vec [ i ] [ 0 ] ;<br>    ;<br>    int m = vec [ i ] [ 1 ] ;<br>    ;<br>    if ( ( m > n ) && ( m < n ) ) {<br>      ans [ i ] = - 1 ;<br>      ;<br>      continue ;<br>    }<br>    int turn = t / n ;<br>    ;<br>    int rem = t % n ;<br>    ;<br>    if ( ( rem == 0 && turn % 2 == 1 ) || ( rem == 0 && turn % 2 == 0 ) ) {<br>      ans [ i ] = a [ m ] ;<br>      ;<br>      continue ;<br>    }<br>    if ( ( turn % 2 == 0 ) || ( turn == 1 && turn % 2 == 1 ) ) {<br>      int cursize = n - rem ;<br>      ;<br>      if ( ( cursize < m ) && ( cursize < m ) ) {<br>        ans [ i ] = - 1 ;<br>        ;<br>        continue ;<br>      }<br>      ans [ i ] = a [ m + rem ] ;<br>      ;<br>    }<br>    else {<br>      int cursize = rem ;<br>      ;<br>      if ( ( cursize < m ) && ( cursize < m ) ) {<br>        ans [ i ] = - 1 ;<br>        ;<br>        continue ;<br>      }<br>      ans [ i ] = a [ m ] ;<br>      ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < ans . length ;<br>  i ++ ) {<br>    System . out . println ( ans [ i ] ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int minDist ( int arr [ ] , int n , int x , int y ) {<br>  int i = 0 ;<br>  int min_dist = Integer . MAX_VALUE ;<br>  int prev = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      prev = i ;<br>      break ;<br>    }<br>  }<br>  for ( ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) {<br>        min_dist = i - prev ;<br>        prev = i ;<br>      }<br>      else prev = i ;<br>    }<br>  }<br>  return min_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDist ( int [ ] arr , int n , int x , int y ) {<br>  int min_dist = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      prev = i ;<br>      break ;<br>    }<br>  }<br>  while ( i < n ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) {<br>        min_dist = i - prev ;<br>        prev = i ;<br>      }<br>      else {<br>        prev = i ;<br>      }<br>    }<br>    i ++ ;<br>  }<br>  return min_dist ;<br>}<br></td>
  </tr><tr>
    <th>UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 , j = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " " ) ;<br>    else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) ;<br>    else {<br>      System . out . print ( arr2 [ j ++ ] + " " ) ;<br>      i ++ ;<br>    }<br>  }<br>  while ( i < m ) System . out . print ( arr1 [ i ++ ] + " " ) ;<br>  while ( j < n ) System . out . print ( arr2 [ j ++ ] + " " ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) {<br>  int i = 0 , j = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( arr1 [ i ] < arr2 [ j ] ) {<br>      System . out . print ( arr1 [ i ] ) ;<br>      i ++ ;<br>    }<br>    else if ( arr2 [ j ] < arr1 [ i ] ) {<br>      System . out . print ( arr2 [ j ] ) ;<br>      j ++ ;<br>    }<br>    else {<br>      System . out . print ( arr2 [ j ] ) ;<br>      j ++ ;<br>      i ++ ;<br>    }<br>  }<br>  while ( i < m ) {<br>    System . out . print ( arr1 [ i ] ) ;<br>    i ++ ;<br>  }<br>  while ( j < n ) {<br>    System . out . print ( arr2 [ j ] ) ;<br>    j ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solveWordWrap ( int arr [ ] , int n , int k ) {<br>  int i , j ;<br>  int currlen ;<br>  int cost ;<br>  int dp [ ] = new int [ n ] ;<br>  int ans [ ] = new int [ n ] ;<br>  dp [ n - 1 ] = 0 ;<br>  ans [ n - 1 ] = n - 1 ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    currlen = - 1 ;<br>    dp [ i ] = Integer . MAX_VALUE ;<br>    for ( j = i ;<br>    j < n ;<br>    j ++ ) {<br>      currlen += ( arr [ j ] + 1 ) ;<br>      if ( currlen > k ) break ;<br>      if ( j == n - 1 ) cost = 0 ;<br>      else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ;<br>      if ( cost < dp [ i ] ) {<br>        dp [ i ] = cost ;<br>        ans [ i ] = j ;<br>      }<br>    }<br>  }<br>  i = 0 ;<br>  while ( i < n ) {<br>    System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1 ) + " " ) ;<br>    i = ans [ i ] + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void solveWordWrap ( int [ ] arr , int n , int k ) {<br>  int [ ] dp = new int [ n ] ;<br>  int [ ] ans = new int [ n ] ;<br>  dp [ n - 1 ] = 0 ;<br>  ans [ n - 1 ] = n - 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int currlen = - 1 ;<br>    dp [ i ] = Integer . MAX_VALUE ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      currlen += ( arr [ j ] + 1 ) ;<br>      if ( ( currlen > k ) && ( j == n - 1 ) ) break ;<br>      if ( ( j == n - 1 ) || ( j == n - 2 ) ) {<br>        int cost = 0 ;<br>        if ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) ;<br>        if ( ( cost < dp [ i ] ) && ( j == n - 1 ) ) {<br>          dp [ i ] = cost ;<br>          ans [ i ] = j ;<br>        }<br>      }<br>    }<br>    int i = 0 ;<br>    while ( ( i < n ) && ( ans [ i ] > 0 ) ) {<br>      System . out . print ( i + " " + ans [ i ] + " " ) ;<br>      i = ans [ i ] + 1 ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_SUBSEQUENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSub ( String str ) {<br>  int [ ] last = new int [ MAX_CHAR ] ;<br>  Arrays . fill ( last , - 1 ) ;<br>  int n = str . length ( ) ;<br>  int [ ] dp = new int [ n + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = 2 * dp [ i - 1 ] ;<br>    if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ;<br>    last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSub ( String ss ) {<br>  int last [ ] = new int [ MAX_CHAR + 1 ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) last [ i ] = - 1 ;<br>  int n = ss . length ( ) ;<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = - 2 ;<br>  dp [ 1 ] = 0 ;<br>  dp [ 2 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = 2 * dp [ i - 1 ] ;<br>    if ( last [ ( char ) ss . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( char ) ss . charAt ( i - 1 ) ] ] ;<br>    last [ ( char ) ss . charAt ( i - 1 ) ] = i - 1 ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str , int n ) {<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 2 ;<br>  i ++ ) {<br>    int l = i , r = i + 1 ;<br>    int lsum = 0 , rsum = 0 ;<br>    while ( r < n && l >= 0 ) {<br>      lsum += str . charAt ( l ) - '0' ;<br>      rsum += str . charAt ( r ) - '0' ;<br>      if ( lsum == rsum ) {<br>        ans = Math . max ( ans , r - l + 1 ) ;<br>      }<br>      l -- ;<br>      r ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String st , int n ) {<br>  int [ ] total = new int [ n + 1 ] ;<br>  total [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) total [ i ] = ( total [ i - 1 ] + Integer . parseInt ( st . charAt ( i - 1 ) ) - Integer . parseInt ( "0" ) ) ;<br>  int ans = 0 ;<br>  int l = 2 ;<br>  while ( ( l <= n ) && ( total [ l ] == total [ l - 1 ] ) ) {<br>    for ( int i = 0 ;<br>    i < n - l + 1 ;<br>    i ++ ) {<br>      int j = i + l - 1 ;<br>      if ( ( total [ i + Integer . parseInt ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + Integer . parseInt ( l / 2 ) ] ) && ( total [ j ] == total [ j - 1 ] ) ) {<br>        ans = Math . max ( ans , l ) ;<br>      }<br>    }<br>    l = l + 2 ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxPath ( int mat [ ] [ ] ) {<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    res = - 1 ;<br>    for ( int j = 0 ;<br>    j < M ;<br>    j ++ ) {<br>      if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ;<br>      else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ;<br>      else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ;<br>      res = max ( mat [ i ] [ j ] , res ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxPath ( int [ ] [ ] mat ) {<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) res = Math . max ( res , mat [ 0 ] [ i ] ) ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    res = - 1 ;<br>    for ( int j = 0 ;<br>    j < M ;<br>    j ++ ) {<br>      if ( ( j > 0 && j < M - 1 ) || ( j > 0 && j < M - 1 ) ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , Math . max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ;<br>      else if ( ( j > 0 ) || ( j < M - 1 ) ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ;<br>      else if ( ( j < M - 1 ) || ( j > M - 1 ) ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ;<br>      res = Math . max ( mat [ i ] [ j ] , res ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char maxRepeating ( String str ) {<br>  int len = str . length ( ) ;<br>  int count = 0 ;<br>  char res = str . charAt ( 0 ) ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) {<br>    int cur_count = 1 ;<br>    for ( int j = i + 1 ;<br>    j < len ;<br>    j ++ ) {<br>      if ( str . charAt ( i ) != str . charAt ( j ) ) break ;<br>      cur_count ++ ;<br>    }<br>    if ( cur_count > count ) {<br>      count = cur_count ;<br>      res = str . charAt ( i ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String maxRepeating ( String str ) {<br>  int l = str . length ( ) ;<br>  int count = 0 ;<br>  String res = str . substring ( 0 , l ) ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    int curCount = 1 ;<br>    for ( int j = i + 1 ;<br>    j < l ;<br>    j ++ ) {<br>      if ( ( str . charAt ( i ) != str . charAt ( j ) ) && ( str . charAt ( j ) != ' ' ) ) {<br>        break ;<br>      }<br>      curCount ++ ;<br>    }<br>    if ( curCount > count ) {<br>      count = curCount ;<br>      res = str . substring ( i , j ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int maxLenSub ( int arr [ ] , int n ) {<br>  int mls [ ] = new int [ n ] , max = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) mls [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLenSub ( int [ ] arr , int n ) {<br>  int [ ] mls = new int [ n ] ;<br>  int max = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) mls [ i ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) || ( Math . abs ( arr [ i ] - arr [ j ] ) < 1 && mls [ i ] < mls [ j ] + 1 ) ) {<br>        mls [ i ] = mls [ j ] + 1 ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( max < mls [ i ] ) && ( mls [ i ] > max ) ) {<br>      max = mls [ i ] ;<br>    }<br>  }<br>  return max ;<br>}<br></td>
  </tr><tr>
    <th>BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int calculate ( String N ) {<br>  int len = N . length ( ) ;<br>  int l = ( len ) / 2 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= l ;<br>  i ++ ) {<br>    String s = N . substring ( 0 , i ) ;<br>    int l1 = s . length ( ) ;<br>    String t = N . substring ( i , l1 + i ) ;<br>    if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ;<br>    if ( s . compareTo ( t ) == 0 ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculate ( String N ) {<br>  int length = N . length ( ) ;<br>  int l = ( int ) ( ( length ) / 2 ) ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < l + 1 ;<br>  i ++ ) {<br>    String s = N . substring ( 0 , 0 + i ) ;<br>    int l1 = s . length ( ) ;<br>    String t = N . substring ( i , l1 + i ) ;<br>    switch ( s . charAt ( 0 ) ) {<br>      case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case 'y' : case 'z' : case 'w' : case 'x' : case ' y</td>
  </tr><tr>
    <th>PROGRAM_BINARY_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binaryToDecimal ( int n ) {<br>  int num = n ;<br>  int dec_value = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( temp > 0 ) {<br>    int last_digit = temp % 10 ;<br>    temp = temp / 10 ;<br>    dec_value += last_digit * base ;<br>    base = base * 2 ;<br>  }<br>  return dec_value ;<br>}<br></td>
    <td>translated code: <br><br> public static int binaryToDecimal ( int n ) {<br>  int num = n ;<br>  int decValue = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( ( temp = temp % 10 ) != 0 ) {<br>    int lastDigit = temp % 10 ;<br>    temp = ( int ) ( temp / 10 ) ;<br>    decValue += lastDigit * base ;<br>    base = base * 2 ;<br>  }<br>  return decValue ;<br>}<br></td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSum ( int n ) {<br>  int sum = 0 ;<br>  while ( n != 0 ) {<br>    sum = sum + n % 10 ;<br>    n = n / 10 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSum ( int n ) {<br>  int sum = 0 ;<br>  while ( ( n != 0 ) && ( n % 10 == 0 ) ) {<br>    sum = sum + ( int ) ( n % 10 ) ;<br>    n = ( int ) ( n / 10 ) ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSDSFunc ( int n ) {<br>  int DP [ ] = new int [ n + 1 ] ;<br>  DP [ 0 ] = 0 ;<br>  DP [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;<br>    else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ;<br>  }<br>  return DP [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSDSFunc ( int n ) {<br>  int [ ] DP = new int [ n + 1 ] ;<br>  DP [ 0 ] = 0 ;<br>  DP [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( Integer . bitCount ( i % 2 ) == 0 ) && ( DP [ i ] == 0 ) ) {<br>      DP [ i ] = DP [ Integer . bitCount ( i / 2 ) ] ;<br>    }<br>    else {<br>      DP [ i ] = ( DP [ Integer . bitCount ( ( i - 1 ) / 2 ) ] + DP [ Integer . bitCount ( ( i + 1 ) / 2 ) ] ) ;<br>    }<br>  }<br>  return DP [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SINK_NODES_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) {<br>  int [ ] mark = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) mark [ edgeFrom [ i ] ] = 1 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) if ( mark [ i ] == 0 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSink ( int n , int m , int [ ] edgeFrom , int [ ] edgeTo ) {<br>  int [ ] mark = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) mark [ edgeFrom [ i ] ] = 1 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) if ( ( ! mark [ i ] ) && ( ! mark [ i - 1 ] ) ) count ++ ;<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>BREAK_NUMBER_THREE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long count_of_ways ( long n ) {<br>  long count = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) for ( int k = 0 ;<br>  k <= n ;<br>  k ++ ) if ( i + j + k == n ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfWays ( int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k <= n ;<br>      k ++ ) {<br>        if ( ( i + j + k == n ) && ( i + j + k == n ) ) {<br>          count = count + 1 ;<br>        }<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistinct ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) if ( arr [ i ] == arr [ j ] ) break ;<br>    if ( i == j ) System . out . print ( arr [ i ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printDistinct ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    int d = 0 ;<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( ( arr [ i ] == arr [ j ] ) && ( arr [ j ] != 0 ) ) {<br>        d = 1 ;<br>        break ;<br>      }<br>    }<br>    if ( ( d == 0 ) && ( arr [ i ] != 0 ) ) {<br>      System . out . println ( arr [ i ] ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSegments ( int n , int a , int b , int c ) {<br>  int dp [ ] = new int [ n + 10 ] ;<br>  Arrays . fill ( dp , - 1 ) ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( dp [ i ] != - 1 ) {<br>      if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ;<br>      if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ;<br>      if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ;<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSegments ( int n , int a , int b , int c ) {<br>  int [ ] dp = new int [ n + 10 ] ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( dp [ i ] != - 1 ) && ( i + a <= n ) ) {<br>      if ( ( i + a <= n ) && ( i + b <= n ) ) {<br>        dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ;<br>      }<br>      if ( ( i + b <= n ) && ( i + c <= n ) ) {<br>        dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ;<br>      }<br>      if ( ( i + c <= n ) && ( i + d <= n ) ) {<br>        dp [ i + d ] = Math . max ( dp [ i ] + 1 , dp [ i + d ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_VALID_SEQUENCE_DIVISIBLE_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) {<br>  if ( index == n ) {<br>    if ( ( sum % M ) == 0 ) return true ;<br>    return false ;<br>  }<br>  else if ( sum < 0 || sum >= MAX ) return false ;<br>  if ( dp [ index ] [ sum ] != - 1 ) {<br>    if ( dp [ index ] [ sum ] == 0 ) return false ;<br>    return true ;<br>  }<br>  boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ;<br>  boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ;<br>  boolean res = ( placeAdd || placeMinus ) ;<br>  dp [ index ] [ sum ] = ( res ) ? 1 : 0 ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( int n , int index , int Sum , int M , int [ ] arr , int [ ] [ ] dp ) {<br>  MAX = Integer . MAX_VALUE ;<br>  if ( index == n ) {<br>    if ( ( Sum % M ) == 0 ) return true ;<br>    return false ;<br>  }<br>  if ( dp [ index ] [ Sum ] != - 1 ) return dp [ index ] [ Sum ] ;<br>  boolean placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) ;<br>  boolean placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) ;<br>  boolean res = placeAdd || placeMinus ;<br>  dp [ index ] [ Sum ] = res ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findGreatest ( int [ ] arr , int n ) {<br>  int result = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n - 1 ;<br>  j ++ ) for ( int k = j + 1 ;<br>  k < n ;<br>  k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int findGreatest ( int [ ] arr , int n ) {<br>  int result = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( ( arr [ j ] * arr [ k ] == arr [ i ] ) && ( arr [ i ] * arr [ k ] == arr [ j ] ) ) {<br>          result = Math . max ( result , arr [ i ] ) ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {<br>  int max_so_far = 0 ;<br>  int INT_MIN , max_ending_here = 0 ;<br>  for ( int i = 0 ;<br>  i < n * k ;<br>  i ++ ) {<br>    max_ending_here = max_ending_here + a [ i % n ] ;<br>    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;<br>    if ( max_ending_here < 0 ) max_ending_here = 0 ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySumRepeated ( int [ ] a , int n , int k ) {<br>  int maxSoFar = - 2147483648 ;<br>  int maxEndingHere = 0 ;<br>  for ( int i = 0 ;<br>  i < n * k ;<br>  i ++ ) {<br>    maxEndingHere = maxEndingHere + a [ i % n ] ;<br>    if ( ( maxSoFar < maxEndingHere ) && ( maxEndingHere < 0 ) ) {<br>      maxSoFar = maxEndingHere ;<br>    }<br>    if ( ( maxEndingHere < 0 ) && ( maxEndingHere < n ) ) {<br>      maxEndingHere = 0 ;<br>    }<br>  }<br>  return maxSoFar ;<br>}<br></td>
  </tr><tr>
    <th>LEONARDO_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int leonardo ( int n ) {<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int leonardo ( int n ) {<br>  int [ ] dp = new int [ n + 1 ] ;<br>  ;<br>  dp [ 0 ] = 1 ;<br>  ;<br>  dp [ 1 ] = 1 ;<br>  ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;<br>    ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int sumOfSubstrings ( String num ) {<br>  int n = num . length ( ) ;<br>  int sumofdigit [ ] = new int [ n ] ;<br>  sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ;<br>  int res = sumofdigit [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int numi = num . charAt ( i ) - '0' ;<br>    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ;<br>    res += sumofdigit [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumOfSubstrings ( String num ) {<br>  int n = num . length ( ) ;<br>  int [ ] sumofdigit = new int [ n ] ;<br>  sumofdigit [ 0 ] = Integer . parseInt ( num . substring ( 0 , 1 ) ) ;<br>  int res = sumofdigit [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int numi = Integer . parseInt ( num . substring ( i , i + 1 ) ) ;<br>    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ;<br>    res += sumofdigit [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>PRUFER_CODE_TREE_CREATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printTreeEdges ( int prufer [ ] , int m ) {<br>  int vertices = m + 2 ;<br>  int vertex_set [ ] = new int [ vertices ] ;<br>  for ( int i = 0 ;<br>  i < vertices ;<br>  i ++ ) vertex_set [ i ] = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;<br>  System . out . print ( "\nThe edge set E(G) is :\n" ) ;<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < vertices ;<br>    j ++ ) {<br>      if ( vertex_set [ j ] == 0 ) {<br>        vertex_set [ j ] = - 1 ;<br>        System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ;<br>        vertex_set [ prufer [ i ] - 1 ] -- ;<br>        break ;<br>      }<br>    }<br>  }<br>  j = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices ;<br>  i ++ ) {<br>    if ( vertex_set [ i ] == 0 && j == 0 ) {<br>      System . out . print ( "(" + ( i + 1 ) + ", " ) ;<br>      j ++ ;<br>    }<br>    else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + ")\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printTreeEdges ( int [ ] prufer , int m ) {<br>  int vertices = m + 2 ;<br>  int [ ] vertexSet = new int [ vertices ] ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) vertexSet [ prufer [ i ] - 1 ] ++ ;<br>  System . out . println ( "The edge set E(G) is :" ) ;<br>  int j ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < vertices ;<br>    j ++ ) {<br>      if ( ( vertexSet [ j ] == 0 ) && ( prufer [ i ] == 0 ) ) {<br>        vertexSet [ j ] = - 1 ;<br>        System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ;<br>        vertexSet [ prufer [ i ] - 1 ] -- ;<br>        break ;<br>      }<br>    }<br>  }<br>  j = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices ;<br>  i ++ ) {<br>    if ( ( vertexSet [ i ] == 0 && j == 0 ) || ( vertexSet [ i ] == 1 && j == 1 ) ) {<br>      System . out . print ( "(" + ( i + 1 ) + ", " ) ;<br>      j ++ ;<br>    }<br>    else if ( ( vertexSet [ i ] == 0 && j == 1 ) || ( vertexSet [ i ] == 2 && j == 2 ) ) {<br>      System . out . print ( ( i + 1 ) + ")" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findMinimumAngle ( int arr [ ] , int n ) {<br>  int l = 0 , sum = 0 , ans = 360 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    while ( sum >= 180 ) {<br>      ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ;<br>      sum -= arr [ l ] ;<br>      l ++ ;<br>    }<br>    ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinimumAngle ( int [ ] arr , int n ) {<br>  int l = 0 ;<br>  int _sum = 0 ;<br>  int ans = 360 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    _sum += arr [ i ] ;<br>    while ( _sum >= 180 ) {<br>      ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ;<br>      _sum -= arr [ l ] ;<br>      l ++ ;<br>    }<br>    ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>  if ( k > n ) return - 1 ;<br>  int [ ] csum = new int [ n ] ;<br>  csum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;<br>  int max_sum = csum [ k - 1 ] , max_end = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_sum = csum [ i ] - csum [ i - k ] ;<br>    if ( curr_sum > max_sum ) {<br>      max_sum = curr_sum ;<br>      max_end = i ;<br>    }<br>  }<br>  return max_end - k + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>  if ( k > n ) return - 1 ;<br>  int [ ] csum = new int [ n ] ;<br>  csum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;<br>  ;<br>  int maxSum = csum [ k - 1 ] ;<br>  int maxEnd = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    int currSum = csum [ i ] - csum [ i - k ] ;<br>    if ( currSum > maxSum ) {<br>      maxSum = currSum ;<br>      maxEnd = i ;<br>    }<br>  }<br>  return maxEnd - k + 1 ;<br>}<br></td>
  </tr><tr>
    <th>SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findS ( int s ) {<br>  int sum = 0 ;<br>  for ( int n = 1 ;<br>  sum < s ;<br>  n ++ ) {<br>    sum += n * n ;<br>    if ( sum == s ) return n ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findS ( int s ) {<br>  int _sum = 0 ;<br>  int n = 1 ;<br>  while ( ( _sum < s ) && ( _sum < s ) ) {<br>    _sum += n * n ;<br>    n ++ ;<br>  }<br>  n -- ;<br>  if ( _sum == s ) return n ;<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double areaOfInscribedCircle ( float a ) {<br>  return ( PI / 4 ) * a * a ;<br>}<br></td>
    <td>translated code: <br><br> public static double areaOfInscribedCircle ( double a ) {<br>  return ( PI / 4 ) * a * a ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countToMake0lternate ( String s ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < ( s . length ( ) - 1 ) ;<br>  i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countToMake0lternate ( String s ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) - 1 ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == s . charAt ( i + 1 ) ) && ( s . charAt ( i + 2 ) == s . charAt ( i + 3 ) ) ) {<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMissing ( int a [ ] , int b [ ] , int n , int m ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < m ;<br>    j ++ ) if ( a [ i ] == b [ j ] ) break ;<br>    if ( j == m ) System . out . print ( a [ i ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findMissing ( int [ ] a , int [ ] b , int n , int m ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( a [ i ] == b [ j ] ) && ( a [ i ] != b [ j ] ) ) {<br>        break ;<br>      }<br>    }<br>    if ( ( j == m - 1 ) && ( a [ i ] == b [ j ] ) ) {<br>      System . out . print ( a [ i ] + " " ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int [ ] arr , int n ) {<br>  int temp [ ] = new int [ n ] ;<br>  int small = 0 , large = n - 1 ;<br>  boolean flag = true ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( flag ) temp [ i ] = arr [ large -- ] ;<br>    else temp [ i ] = arr [ small ++ ] ;<br>    flag = ! flag ;<br>  }<br>  arr = temp . clone ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] rearrange ( int [ ] arr , int n ) {<br>  int [ ] temp = n * new int [ n ] ;<br>  int small = 0 , large = n - 1 ;<br>  boolean flag = true ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( flag == true ) {<br>      temp [ i ] = arr [ large ] ;<br>      large -- ;<br>    }<br>    else {<br>      temp [ i ] = arr [ small ] ;<br>      small ++ ;<br>    }<br>    flag = ( boolean ) ( 1 - flag ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = temp [ i ] ;<br>  }<br>  return arr ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lbs ( int arr [ ] , int n ) {<br>  int i , j ;<br>  int [ ] lis = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) for ( j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  int [ ] lds = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lds [ i ] = 1 ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) for ( j = n - 1 ;<br>  j > i ;<br>  j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ;<br>  int max = lis [ 0 ] + lds [ 0 ] - 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int lbs ( int [ ] arr ) {<br>  int n = arr . length ;<br>  int [ ] lis = new int [ n + 1 ] ;<br>  lis [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    lis [ i ] = i ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) || ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) ) {<br>        lis [ i ] = j ;<br>      }<br>    }<br>  }<br>  int [ ] lds = new int [ n + 1 ] ;<br>  lds [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i - 1 ;<br>    j ++ ) {<br>      if ( ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) || ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) ) {<br>        lds [ i ] = j ;<br>      }<br>    }<br>  }<br>  int maximum = lis [ 0 ] + lds [ 0 ] - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    maximum = Math . max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) ;<br>  }<br>  return maximum ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      for ( int k = 0 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( arr [ k ] == product ) {<br>          result ++ ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      ;<br>      for ( int k = 0 ;<br>      k <= n ;<br>      k ++ ) {<br>        if ( ( arr [ k ] == product ) && ( arr [ j ] == product ) ) {<br>          result = result + 1 ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute ( int [ ] graph , int N ) {<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i < 7 ;<br>  i ++ ) {<br>    if ( graph [ i ] == 0 ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int compute ( int [ ] [ ] graph , int N ) {<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    if ( ( graph [ i ] . length == 0 ) && ( graph [ i ] [ 0 ] . length == 0 ) ) {<br>      count ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>HARDY_RAMANUJAN_THEOREM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int exactPrimeFactorCount ( int n ) {<br>  int count = 0 ;<br>  if ( n % 2 == 0 ) {<br>    count ++ ;<br>    while ( n % 2 == 0 ) n = n / 2 ;<br>  }<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i = i + 2 ) {<br>    if ( n % i == 0 ) {<br>      count ++ ;<br>      while ( n % i == 0 ) n = n / i ;<br>    }<br>  }<br>  if ( n > 2 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int exactPrimeFactorCount ( int n ) {<br>  int count = 0 ;<br>  if ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) {<br>    count = count + 1 ;<br>    while ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) {<br>      n = ( int ) ( n / 2 ) ;<br>    }<br>  }<br>  int i = 3 ;<br>  while ( ( i <= ( int ) Math . sqrt ( n ) ) && ( n % i == 0 ) ) {<br>    if ( ( n % i == 0 ) && ( n % 3 == 0 ) ) {<br>      count = count + 1 ;<br>      while ( ( n % i == 0 ) && ( n % 3 == 0 ) ) {<br>        n = ( int ) ( n / i ) ;<br>      }<br>    }<br>    i = i + 2 ;<br>  }<br>  if ( ( n > 2 ) && ( n % 3 == 0 ) ) {<br>    count = count + 1 ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int superSeq ( String X , String Y , int m , int n ) {<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int superSeq ( int [ ] X , int [ ] Y , int m , int n ) {<br>  int [ ] [ ] dp = new int [ m + 2 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 2 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      if ( ( ! i ) && ( ! j ) ) {<br>        dp [ i ] [ j ] = j ;<br>      }<br>      else if ( ( ! i ) && ( ! j ) ) {<br>        dp [ i ] [ j ] = i ;<br>      }<br>      else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && ( X [ j - 1 ] == Y [ i ] ) ) {<br>        dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>POWER_SET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printPowerSet ( char [ ] set , int set_size ) {<br>  long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ;<br>  int counter , j ;<br>  for ( counter = 0 ;<br>  counter < pow_set_size ;<br>  counter ++ ) {<br>    for ( j = 0 ;<br>    j < set_size ;<br>    j ++ ) {<br>      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printPowerSet ( int [ ] set , int setSize ) {<br>  int pow_set_size = ( int ) ( Math . pow ( 2 , setSize ) ) ;<br>  ;<br>  int counter ;<br>  int j ;<br>  for ( counter = 0 ;<br>  counter <= pow_set_size ;<br>  counter ++ ) {<br>    for ( j = 0 ;<br>    j <= set_size ;<br>    j ++ ) {<br>      if ( ( ( counter & ( 1 << j ) ) > 0 ) && ( ( counter & ( 1 << j ) ) > 0 ) ) {<br>        System . out . print ( set [ j ] + "" ) ;<br>      }<br>    }<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_ARRAY_MAJORITY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMajority ( int a [ ] , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ;<br>  else mp . put ( a [ i ] , 1 ) ;<br>  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMajority ( int [ ] a ) {<br>  int [ ] mp = new int [ a . length ] ;<br>  for ( int i = 0 ;<br>  i < a . length ;<br>  i ++ ) {<br>    if ( a [ i ] < mp [ i ] ) {<br>      mp [ i ] ++ ;<br>    }<br>    else {<br>      mp [ i ] = 1 ;<br>    }<br>  }<br>  for ( int x : mp ) {<br>    if ( mp [ x ] >= a . length / 2 ) {<br>      return true ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) {<br>  int i , k = 0 , l = 0 ;<br>  int cnt = 0 ;<br>  int total = m * n ;<br>  while ( k < m && l < n ) {<br>    if ( cnt == total ) break ;<br>    for ( i = k ;<br>    i < m ;<br>    ++ i ) {<br>      System . out . print ( arr [ i ] [ l ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    l ++ ;<br>    if ( cnt == total ) break ;<br>    for ( i = l ;<br>    i < n ;<br>    ++ i ) {<br>      System . out . print ( arr [ m - 1 ] [ i ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    m -- ;<br>    if ( cnt == total ) break ;<br>    if ( k < m ) {<br>      for ( i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        System . out . print ( arr [ i ] [ n - 1 ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      n -- ;<br>    }<br>    if ( cnt == total ) break ;<br>    if ( l < n ) {<br>      for ( i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        System . out . print ( arr [ k ] [ i ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      k ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void counterClockspiralPrint ( int m , int n , int [ ] [ ] arr ) {<br>  int k = 0 ;<br>  int l = 0 ;<br>  int cnt = 0 ;<br>  int total = m * n ;<br>  while ( ( k < m && l < n ) || ( k > m && l > n ) ) {<br>    if ( ( cnt == total ) || ( cnt == 0 ) ) break ;<br>    for ( int i = k ;<br>    i < m ;<br>    i ++ ) {<br>      System . out . print ( arr [ i ] [ l ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    l ++ ;<br>    if ( ( cnt == total ) || ( cnt == 0 ) ) break ;<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) {<br>      System . out . print ( arr [ m - 1 ] [ i ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    m -- ;<br>    if ( ( cnt == total ) || ( cnt == 0 ) ) break ;<br>    if ( ( k < m ) && ( k > k ) ) {<br>      for ( int i = m - 1 ;<br>      i >= k ;<br>      i -- ) {<br>        System . out . print ( arr [ i ] [ n - 1 ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      n -- ;<br>    }<br>    if ( ( cnt == total ) || ( cnt == 0 ) ) break ;<br>    if ( ( l < n ) && ( l > l ) ) {<br>      for ( int i = n - 1 ;<br>      i >= l ;<br>      i -- ) {<br>        System . out . print ( arr [ k ] [ i ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      k ++ ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( n % i == 0 ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( n % i == 0 ) return false ;<br>  ;<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMinIndexChar ( String str , String patt ) {<br>  int minIndex = Integer . MAX_VALUE ;<br>  int m = str . length ( ) ;<br>  int n = patt . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) {<br>        minIndex = j ;<br>        break ;<br>      }<br>    }<br>  }<br>  if ( minIndex != Integer . MAX_VALUE ) System . out . println ( "Minimum Index Character = " + str . charAt ( minIndex ) ) ;<br>  else System . out . println ( "No character present" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printMinIndexChar ( String Str , String patt ) {<br>  int minIndex = 10 * 9 ;<br>  int m = Str . length ( ) ;<br>  int n = patt . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) || ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) ) {<br>        minIndex = j ;<br>        break ;<br>      }<br>    }<br>  }<br>  if ( ( minIndex != 10 * 9 ) && ( minIndex != 0 ) ) {<br>    System . out . println ( "Minimum Index Character = " + Str . charAt ( minIndex ) ) ;<br>  }<br>  else {<br>    System . out . println ( "No character present" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < M ;<br>  j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void transpose ( double [ ] [ ] A , double [ ] [ ] B ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < M ;<br>    j ++ ) {<br>      B [ i ] [ j ] = A [ j ] [ i ] ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNumber ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 1 ;<br>  i <= 9 ;<br>  i ++ ) {<br>    Stack < Integer > s = new Stack < > ( ) ;<br>    if ( i <= n ) {<br>      s . push ( i ) ;<br>      result ++ ;<br>    }<br>    while ( ! s . empty ( ) ) {<br>      int tp = s . peek ( ) ;<br>      s . pop ( ) ;<br>      for ( int j = tp % 10 ;<br>      j <= 9 ;<br>      j ++ ) {<br>        int x = tp * 10 + j ;<br>        if ( x <= n ) {<br>          s . push ( x ) ;<br>          result ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNumber ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 1 ;<br>  i <= 10 ;<br>  i ++ ) {<br>    Stack < Integer > s = new Stack < Integer > ( ) ;<br>    if ( ( i <= n ) && ( s . size ( ) != 0 ) ) {<br>      s . push ( i ) ;<br>      result ++ ;<br>    }<br>    while ( s . size ( ) != 0 ) {<br>      int tp = s . pop ( ) ;<br>      s . pop ( ) ;<br>      for ( int j = tp % 10 ;<br>      j < 10 ;<br>      j ++ ) {<br>        int x = tp * 10 + j ;<br>        if ( ( x <= n ) && ( s . size ( ) != 0 ) ) {<br>          s . push ( x ) ;<br>          result ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstFactorialDivisibleNumber ( int x ) {<br>  int i = 1 ;<br>  int fact = 1 ;<br>  for ( i = 1 ;<br>  i < x ;<br>  i ++ ) {<br>    fact = fact * i ;<br>    if ( fact % x == 0 ) break ;<br>  }<br>  return i ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstFactorialDivisibleNumber ( int x ) {<br>  int i ;<br>  int fact = 1 ;<br>  ;<br>  for ( i = 1 ;<br>  i <= x ;<br>  i ++ ) {<br>    fact = fact * i ;<br>    if ( ( fact % x == 0 ) && ( i % x == 0 ) ) break ;<br>  }<br>  return i ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printEqualSumSets ( int [ ] arr , int n ) {<br>  int i , currSum , sum = 0 ;<br>  for ( i = 0 ;<br>  i < arr . length ;<br>  i ++ ) sum += arr [ i ] ;<br>  if ( ( sum & 1 ) == 1 ) {<br>    System . out . print ( "-1" ) ;<br>    return ;<br>  }<br>  int k = sum >> 1 ;<br>  boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ;<br>  for ( i = 1 ;<br>  i <= k ;<br>  i ++ ) dp [ 0 ] [ i ] = false ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = true ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( currSum = 1 ;<br>    currSum <= k ;<br>    currSum ++ ) {<br>      dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;<br>      if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ;<br>    }<br>  }<br>  List < Integer > set1 = new ArrayList < Integer > ( ) ;<br>  List < Integer > set2 = new ArrayList < Integer > ( ) ;<br>  if ( ! dp [ n ] [ k ] ) {<br>    System . out . print ( "-1\n" ) ;<br>    return ;<br>  }<br>  i = n ;<br>  currSum = k ;<br>  while ( i > 0 && currSum >= 0 ) {<br>    if ( dp [ i - 1 ] [ currSum ] ) {<br>      i -- ;<br>      set2 . add ( arr [ i ] ) ;<br>    }<br>    else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) {<br>      i -- ;<br>      currSum -= arr [ i ] ;<br>      set1 . add ( arr [ i ] ) ;<br>    }<br>  }<br>  System . out . print ( "Set 1 elements: " ) ;<br>  for ( i = 0 ;<br>  i < set1 . size ( ) ;<br>  i ++ ) System . out . print ( set1 . get ( i ) + " " ) ;<br>  System . out . print ( "\nSet 2 elements: " ) ;<br>  for ( i = 0 ;<br>  i < set2 . size ( ) ;<br>  i ++ ) System . out . print ( set2 . get ( i ) + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printEqualSumSets ( int [ ] arr , int n ) {<br>  int sumArray = Arrays . stream ( arr ) . mapToInt ( Integer :: intValue ) . sum ( ) ;<br>  if ( ( sumArray & 1 ) != 0 ) {<br>    System . out . println ( "-1" ) ;<br>    return ;<br>  }<br>  int k = sumArray >>> 1 ;<br>  boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = false ;<br>  }<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = true ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int currSum = 1 ;<br>    currSum <= k ;<br>    currSum ++ ) {<br>      dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;<br>      if ( ( arr [ i - 1 ] <= currSum ) && ( dp [ i ] [ currSum ] || dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ) {<br>        dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] || dp [ i - 1 ] [ currSum - arr [ i ] ] ) ;<br>      }<br>    }<br>  }<br>  ArrayList < Integer > set1 = new ArrayList < Integer > ( ) , set2 = new ArrayList < Integer > ( ) ;<br>  if ( ( ! dp [ n ] [ k ] ) && ( ! dp [ k ] [ n ] ) ) {<br>    System . out . println ( "-1" ) ;<br>    return ;<br>  }<br>  int i = n ;<br>  int currSum = k ;<br>  while ( ( i > 0 && currSum >= 0 ) || ( i < n ) ) {<br>    if ( ( dp [ i - 1 ] [ currSum ] ) && ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ) {<br>      i -- ;<br>      set2 . add ( arr [ i ] ) ;<br>    }<br>    else if ( ( dp [ i - 1 ] [ currSum - arr [ i ] ] ) && ( dp [ i - 1 ] [ currSum - arr [ i ] ] ) ) {<br>      i -- ;<br>      currSum -= arr [ i ] ;<br>      set1 . add ( arr [ i ] ) ;<br>    }<br>  }<br>  System . out . println ( "Set 1 elements:" + set1 )</td>
  </tr><tr>
    <th>COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfWays ( int x ) {<br>  int dp [ ] = new int [ x + 1 ] ;<br>  dp [ 0 ] = dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= x ;<br>  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>  return dp [ x ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfWays ( int x ) {<br>  if ( x == 0 || x == 1 ) {<br>    return 1 ;<br>  }<br>  else {<br>    return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNegative ( int M [ ] [ ] , int n , int m ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( M [ i ] [ j ] < 0 ) count += 1 ;<br>      else break ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNegative ( int [ ] [ ] M , int n , int m ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( M [ i ] [ j ] < 0 ) {<br>        count ++ ;<br>      }<br>      else {<br>        break ;<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSetBits ( int n ) {<br>  int count = 0 ;<br>  while ( n > 0 ) {<br>    count += n & 1 ;<br>    n >>= 1 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> static int countSetBits ( long n ) {<br>  int count = 0 ;<br>  while ( ( n > 0 ) && ( n & 1 ) != 0 ) {<br>    count += n & 1 ;<br>    n >>>= 1 ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>MODULUS_TWO_FLOAT_DOUBLE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double findMod ( double a , double b ) {<br>  if ( a < 0 ) a = - a ;<br>  if ( b < 0 ) b = - b ;<br>  double mod = a ;<br>  while ( mod >= b ) mod = mod - b ;<br>  if ( a < 0 ) return - mod ;<br>  return mod ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMod ( int a , int b ) {<br>  if ( ( a < 0 ) && ( b < 0 ) ) a = - a ;<br>  if ( ( b < 0 ) && ( a > 0 ) ) b = - b ;<br>  int mod = a ;<br>  while ( ( mod >= b ) && ( mod < a ) ) mod = mod - b ;<br>  if ( ( a < 0 ) && ( b < 0 ) ) return - mod ;<br>  return mod ;<br>}<br></td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int N , int mat [ ] [ ] ) {<br>  int maxValue = Integer . MIN_VALUE ;<br>  int maxArr [ ] [ ] = new int [ N ] [ N ] ;<br>  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;<br>  int maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  for ( int j = N - 2 ;<br>  j >= 0 ;<br>  j -- ) {<br>    if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ;<br>    maxArr [ N - 1 ] [ j ] = maxv ;<br>  }<br>  maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ;<br>    maxArr [ i ] [ N - 1 ] = maxv ;<br>  }<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = N - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ;<br>      maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ;<br>    }<br>  }<br>  return maxValue ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] [ ] mat ) {<br>  int maxValue = - Integer . MAX_VALUE - 1 ;<br>  int [ ] [ ] maxArr = new int [ N ] [ N ] ;<br>  for ( int y = 0 ;<br>  y < N ;<br>  y ++ ) {<br>    maxArr [ y ] [ y ] = 0 ;<br>  }<br>  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;<br>  int maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  ;<br>  for ( int j = N - 2 ;<br>  j >= 0 ;<br>  j -- ) {<br>    if ( ( mat [ N - 1 ] [ j ] > maxv ) && ( maxArr [ j ] [ j ] == maxv ) ) {<br>      maxv = mat [ N - 1 ] [ j ] ;<br>    }<br>    maxArr [ j ] [ j ] = maxv ;<br>  }<br>  maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( mat [ i ] [ N - 1 ] > maxv ) && ( maxArr [ i ] [ N - 1 ] == maxv ) ) {<br>      maxv = mat [ i ] [ N - 1 ] ;<br>    }<br>    maxArr [ i ] [ N - 1 ] = maxv ;<br>  }<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = N - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) && ( maxArr [ i + 1 ] [ j ] == maxv ) ) {<br>        maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) ;<br>      }<br>      maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ;<br>    }<br>  }<br>  return maxValue ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int a = 0 , b = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ;<br>    else b = b * 10 + arr [ i ] ;<br>  }<br>  return a + b ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int a = 0 ;<br>  int b = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( i % 2 != 0 ) && ( arr [ i ] > 0 ) ) {<br>      a = a * 10 + arr [ i ] ;<br>    }<br>    else {<br>      b = b * 10 + arr [ i ] ;<br>    }<br>  }<br>  return a + b ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSolutions ( int n ) {<br>  int x = 0 , yCount , res = 0 ;<br>  for ( yCount = 0 ;<br>  yCount * yCount < n ;<br>  yCount ++ ) ;<br>  while ( yCount != 0 ) {<br>    res += yCount ;<br>    x ++ ;<br>    while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSolutions ( int n ) {<br>  int x = 0 ;<br>  int res = 0 ;<br>  int yCount = 0 ;<br>  while ( ( yCount * yCount < n ) && ( yCount != 0 ) ) {<br>    yCount = yCount + 1 ;<br>  }<br>  while ( ( yCount != 0 ) && ( yCount != n ) ) {<br>    res = res + yCount ;<br>    x = x + 1 ;<br>    while ( ( yCount != 0 ) && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) {<br>      yCount = yCount - 1 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findIndex ( int n ) {<br>  if ( n <= 1 ) return n ;<br>  int a = 0 , b = 1 , c = 1 ;<br>  int res = 1 ;<br>  while ( c < n ) {<br>    c = a + b ;<br>    res ++ ;<br>    a = b ;<br>    b = c ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findIndex ( int n ) {<br>  if ( ( n <= 1 ) || ( n > 2 ) ) return n ;<br>  int a = 0 ;<br>  int b = 1 ;<br>  int c = 1 ;<br>  int res = 1 ;<br>  while ( ( c < n ) && ( res == 1 ) ) {<br>    c = a + b ;<br>    res = res + 1 ;<br>    a = b ;<br>    b = c ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_OCTAL_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int octalToDecimal ( int n ) {<br>  int num = n ;<br>  int dec_value = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( temp > 0 ) {<br>    int last_digit = temp % 10 ;<br>    temp = temp / 10 ;<br>    dec_value += last_digit * base ;<br>    base = base * 8 ;<br>  }<br>  return dec_value ;<br>}<br></td>
    <td>translated code: <br><br> public static int octalToDecimal ( int n ) {<br>  int num = n ;<br>  ;<br>  int decValue = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( ( temp = temp % 10 ) != 0 ) {<br>    int lastDigit = temp % 10 ;<br>    temp = ( int ) ( temp / 10 ) ;<br>    decValue += lastDigit * base ;<br>    base = base * 8 ;<br>  }<br>  return decValue ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) {<br>  LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) s . add ( mat [ r ] [ j ] ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( i == r ) continue ;<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ;<br>    if ( j != n ) continue ;<br>    System . out . print ( i + ", " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void permutatedRows ( int [ ] [ ] mat , int m , int n , int r ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) s . add ( mat [ r ] [ j ] ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( i == r ) continue ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( mat [ i ] [ j ] != s . contains ( mat [ r ] [ j ] ) ) {<br>        j = j - 2 ;<br>        break ;<br>      }<br>    }<br>    if ( j + 1 != n ) continue ;<br>    System . out . println ( i ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String noAdjacentDup ( String s1 ) {<br>  int n = s1 . length ( ) ;<br>  char [ ] s = s1 . toCharArray ( ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s [ i ] == s [ i - 1 ] ) {<br>      s [ i ] = 'a' ;<br>      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ;<br>      i ++ ;<br>    }<br>  }<br>  return ( new String ( s ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String noAdjacentDup ( String s ) {<br>  int n = s . length ( ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) && ( s . charAt ( i ) == s . charAt ( i - 1 ) ) ) {<br>      s . charAt ( i ) = "a" ;<br>      while ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) || ( i + 1 < n && s . charAt ( i ) == s . charAt ( i + 1 ) ) ) {<br>        s . charAt ( i ) ++ ;<br>      }<br>      i ++ ;<br>    }<br>  }<br>  return s ;<br>}<br></td>
  </tr><tr>
    <th>SUM_MANHATTAN_DISTANCES_PAIRS_POINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int distancesum ( int x [ ] , int y [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int distancesum ( int [ ] x , int [ ] y , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_STRING_START_END_GEEKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isCornerPresent ( String str , String corner ) {<br>  int n = str . length ( ) ;<br>  int cl = corner . length ( ) ;<br>  if ( n < cl ) return false ;<br>  return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isCornerPresent ( String str , String corner ) {<br>  int n = str . length ( ) ;<br>  int cl = corner . length ( ) ;<br>  if ( ( n < cl ) || ( n > cl ) ) return false ;<br>  return ( ( str . substring ( 0 , cl ) . equals ( corner ) ) && ( str . substring ( n - cl , n ) . equals ( corner ) ) ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenOfLongSubarr ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;<br>  int sum = 0 , maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] == 0 ? - 1 : 1 ;<br>    if ( sum == 1 ) maxLen = i + 1 ;<br>    else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ;<br>    if ( um . containsKey ( sum - 1 ) ) {<br>      if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenOfLongSubarr ( int [ ] arr , int n ) {<br>  int [ ] um = new int [ 10 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) {<br>    um [ i ] = 0 ;<br>  }<br>  int sum = 0 ;<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 0 ) {<br>      sum ++ ;<br>    }<br>    else {<br>      sum ++ ;<br>    }<br>    if ( ( sum == 1 ) && ( i != 0 ) ) {<br>      maxLen = i + 1 ;<br>    }<br>    else if ( ( sum != 0 ) && ( i != 0 ) ) {<br>      um [ sum ] = i ;<br>    }<br>    if ( ( ( sum - 1 ) < um . length ) && ( maxLen < ( i - um [ sum - 1 ] ) ) ) {<br>      maxLen = i - um [ sum - 1 ] ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
  </tr><tr>
    <th>DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) {<br>  int i = fromRow + ( toRow - fromRow ) / 2 ;<br>  int j = fromCol + ( toCol - fromCol ) / 2 ;<br>  if ( mat [ i ] [ j ] == key ) System . out . println ( "Found " + key + " at " + i + " " + j ) ;<br>  else {<br>    if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ;<br>    if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ;<br>    if ( mat [ i ] [ j ] < key ) {<br>      if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ;<br>    }<br>    else {<br>      if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) {<br>  int i = fromRow + ( toRow - fromRow ) / 2 ;<br>  ;<br>  int j = fromCol + ( toCol - fromCol ) / 2 ;<br>  ;<br>  if ( ( mat [ i ] [ j ] == key ) && ( mat [ i ] [ j ] == key ) ) {<br>    System . out . println ( "Found " + key + " at " + i + " " + j ) ;<br>    ;<br>  }<br>  else {<br>    if ( ( i != toRow || j != fromCol ) && ( mat [ fromRow ] [ i ] == key ) && ( mat [ fromCol ] [ j ] == key ) ) {<br>      search ( mat , fromRow , i , j , toCol , key ) ;<br>    }<br>    if ( ( fromRow == toRow && fromCol + 1 == toCol ) && ( mat [ fromRow ] [ toCol ] == key ) && ( mat [ fromCol ] [ j ] == key ) ) {<br>      if ( ( mat [ fromRow ] [ toCol ] == key ) && ( mat [ fromCol ] [ j ] == key ) ) {<br>        System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ;<br>        ;<br>      }<br>    }<br>    if ( ( mat [ i ] [ j ] < key ) && ( mat [ i ] [ j ] > key ) && ( mat [ i ] [ j ] > key ) ) {<br>      if ( ( mat [ i ] [ j ] < key ) && ( mat [ i ] [ j ] > key ) ) {<br>        if ( ( mat [ i ] [ j ] > key ) && ( mat [ i ] [ j ] < key ) ) {<br>          if ( ( mat [ i ] [ j ] > key ) && ( mat [ i ] [ j ] < key ) ) {<br>            if ( ( mat [ i ] [ j ] > key ) && ( mat [ i ] [ j ] > key ) ) {<br>              if ( ( mat [ i ] [ j ] < key ) && ( mat [ i ] [ j ] > key ) ) {<br>                if ( ( mat [ i ] [ j ] > key ) && ( mat [ i ] [ j ] > key ) ) {<br>                }<br>              }<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int superSeq ( String X , String Y , int m , int n ) {<br>  if ( m == 0 ) return n ;<br>  if ( n == 0 ) return m ;<br>  if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ;<br>  return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int superSeq ( int [ ] X , int [ ] Y , int m , int n ) {<br>  if ( ( m == 0 ) || ( n == 0 ) ) return n ;<br>  if ( ( X [ m - 1 ] == Y [ n - 1 ] ) && ( X [ m ] == Y [ n ] ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ;<br>  return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>URLIFY_GIVEN_STRING_REPLACE_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char [ ] replaceSpaces ( char [ ] str ) {<br>  int space_count = 0 , i = 0 ;<br>  for ( i = 0 ;<br>  i < str . length ;<br>  i ++ ) if ( str [ i ] == ' ' ) space_count ++ ;<br>  while ( str [ i - 1 ] == ' ' ) {<br>    space_count -- ;<br>    i -- ;<br>  }<br>  int new_length = i + space_count * 2 ;<br>  if ( new_length > MAX ) return str ;<br>  int index = new_length - 1 ;<br>  char [ ] new_str = str ;<br>  str = new char [ new_length ] ;<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) {<br>    if ( new_str [ j ] == ' ' ) {<br>      str [ index ] = '0' ;<br>      str [ index - 1 ] = '2' ;<br>      str [ index - 2 ] = '%' ;<br>      index = index - 3 ;<br>    }<br>    else {<br>      str [ index ] = new_str [ j ] ;<br>      index -- ;<br>    }<br>  }<br>  return str ;<br>}<br></td>
    <td>translated code: <br><br> public static int replaceSpaces ( String string ) {<br>  int len = string . length ( ) ;<br>  int i = len ;<br>  int spaceCount = string . indexOf ( '' ) ;<br>  int newLength = i + spaceCount * 2 ;<br>  if ( newLength > MAX ) return - 1 ;<br>  int index = newLength - 1 ;<br>  StringBuilder sb = Lists . newArrayListWithCapacity ( newLength ) ;<br>  for ( int f = i - 2 ;<br>  f < newLength - 2 ;<br>  f ++ ) {<br>    sb . append ( '0' ) ;<br>  }<br>  for ( int j = i - 1 ;<br>  j > 0 ;<br>  j -- ) {<br>    if ( sb . charAt ( j ) == '' ) {<br>      sb . setCharAt ( index , '0' ) ;<br>      sb . setCharAt ( index - 1 , '2' ) ;<br>      sb . setCharAt ( index - 2 , '%' ) ;<br>      index = index - 3 ;<br>    }<br>    else {<br>      sb . setCharAt ( index , sb . charAt ( j ) ) ;<br>      index -- ;<br>    }<br>  }<br>  return sb . toString ( ) . length ( ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumPath ( int Mat [ ] [ ] ) {<br>  int result = 0 ;<br>  int dp [ ] [ ] = new int [ N ] [ N + 2 ] ;<br>  for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= N ;<br>  j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumPath ( int [ ] [ ] Mat ) {<br>  int result = 0 ;<br>  int [ ] [ ] dp = new int [ N + 2 ] [ N + 1 ] ;<br>  for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) {<br>    for ( int i = 0 ;<br>    i < N ;<br>    i ++ ) {<br>      dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < N + 1 ;<br>  i ++ ) {<br>    result = Math . max ( result , dp [ N - 1 ] [ i ] ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getAbs ( int n ) {<br>  int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ;<br>  return ( ( n + mask ) ^ mask ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getAbs ( int n ) {<br>  int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ;<br>  ;<br>  return ( ( n + mask ) ^ mask ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPS ( int i , int j ) {<br>  if ( i >= n || j < 0 ) return 0 ;<br>  if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;<br>  if ( ( i - j == 1 ) || ( i - j == - 1 ) ) {<br>    if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ;<br>    else return dp [ i ] [ j ] = 2 ;<br>  }<br>  if ( i == j ) return dp [ 1 ] [ j ] = 1 ;<br>  else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ;<br>  else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPS ( int i , int j ) {<br>  if ( ( i >= n || j < 0 ) && ( i < j ) ) return 0 ;<br>  if ( ( dp [ i ] [ j ] != - 1 ) && ( j < i ) ) return dp [ i ] [ j ] ;<br>  if ( ( Math . abs ( i - j ) == 1 ) && ( str [ i ] == str [ j ] ) ) {<br>    dp [ i ] [ j ] = 3 ;<br>    return dp [ i ] [ j ] ;<br>  }<br>  else {<br>    dp [ i ] [ j ] = 2 ;<br>    return dp [ i ] [ j ] ;<br>  }<br>  if ( ( i == j ) && ( str [ i ] == str [ j ] ) ) {<br>    dp [ 1 ] [ j ] = 1 ;<br>    return dp [ 1 ] [ j ] ;<br>  }<br>  else if ( ( str [ i ] == str [ j ] ) && ( str [ i ] == str [ j ] ) ) {<br>    dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) ;<br>    return dp [ i ] [ j ] ;<br>  }<br>  else {<br>    dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) ;<br>    return dp [ i ] [ j ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = a [ 0 ] ;<br>  int curr_max = a [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < size ;<br>  i ++ ) {<br>    curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , curr_max ) ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>  int maxSoFar = a [ 0 ] ;<br>  int currMax = a [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < size ;<br>  i ++ ) {<br>    currMax = Math . max ( a [ i ] , currMax + a [ i ] ) ;<br>    maxSoFar = Math . max ( maxSoFar , currMax ) ;<br>  }<br>  return maxSoFar ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countMinOperations ( int n ) {<br>  int result = 0 ;<br>  while ( true ) {<br>    int zero_count = 0 ;<br>    int i ;<br>    for ( i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( arr [ i ] % 2 == 1 ) break ;<br>      else if ( arr [ i ] == 0 ) zero_count ++ ;<br>    }<br>    if ( zero_count == n ) return result ;<br>    if ( i == n ) {<br>      for ( int j = 0 ;<br>      j < n ;<br>      j ++ ) arr [ j ] = arr [ j ] / 2 ;<br>      result ++ ;<br>    }<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] % 2 == 1 ) {<br>        arr [ j ] -- ;<br>        result ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int countMinOperations ( int [ ] target , int n ) {<br>  int result = 0 ;<br>  ;<br>  while ( ( true ) && ( target [ 0 ] > target [ 1 ] ) ) {<br>    int zeroCount = 0 ;<br>    int i = 0 ;<br>    while ( ( i < n ) && ( target [ i ] > target [ 1 ] ) ) {<br>      if ( ( ( target [ i ] & 1 ) > 0 ) && ( target [ i ] == target [ 1 ] ) ) {<br>        break ;<br>      }<br>      else if ( ( target [ i ] == 0 ) && ( target [ i ] == 0 ) ) {<br>        zeroCount ++ ;<br>      }<br>      i ++ ;<br>    }<br>    if ( ( zeroCount == n ) || ( zeroCount == n ) ) {<br>      return result ;<br>    }<br>    if ( ( i == n ) && ( target [ 0 ] > target [ 1 ] ) ) {<br>      for ( int j = 0 ;<br>      j < n ;<br>      j ++ ) {<br>        target [ j ] = target [ j ] / 2 ;<br>      }<br>      result ++ ;<br>    }<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( target [ j ] & 1 ) > 0 ) {<br>        target [ j ] -- ;<br>        result ++ ;<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void fib ( int n ) {<br>  int a = 0 , b = 1 ;<br>  if ( n >= 0 ) System . out . print ( a + " " ) ;<br>  if ( n >= 1 ) System . out . print ( b + " " ) ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . print ( a + b + " " ) ;<br>    b = a + b ;<br>    a = b - a ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void fib ( int n ) {<br>  int a = 0 ;<br>  int b = 1 ;<br>  if ( ( n >= 0 ) && ( n < n + 1 ) ) System . out . print ( a + " " ) ;<br>  if ( ( n >= 1 ) && ( n < n + 2 ) ) System . out . print ( b + " " ) ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . print ( a + b + " " ) ;<br>    b = a + b ;<br>    a = b - a ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_INPUT_INTEGER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isNumber ( String s ) {<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isNumber ( String s ) {<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) . matches ( "[0-9]+" ) != true ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double minHeight ( double base , double area ) {<br>  double d = ( 2 * area ) / base ;<br>  return Math . ceil ( d ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minHeight ( int area , int base ) {<br>  return Math . ceil ( ( 2 * area ) / base ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findpos ( String n ) {<br>  int k = 0 , pos = 0 , i = 0 ;<br>  while ( k != n . length ( ) ) {<br>    switch ( n . charAt ( i ) ) {<br>      case '4' : pos = pos * 2 + 1 ;<br>      break ;<br>      case '7' : pos = pos * 2 + 2 ;<br>      break ;<br>    }<br>    i ++ ;<br>    k ++ ;<br>  }<br>  return pos ;<br>}<br></td>
    <td>translated code: <br><br> public static int findpos ( String n ) {<br>  int i = 0 ;<br>  int j = n . length ( ) ;<br>  int pos = 0 ;<br>  while ( ( i < j ) && ( n . charAt ( i ) == '4' ) ) {<br>    if ( ( n . charAt ( i ) == '7' ) || ( n . charAt ( i ) == '5' ) ) {<br>      pos = pos * 2 + 1 ;<br>    }<br>    if ( ( n . charAt ( i ) == '6' ) || ( n . charAt ( i ) == '3' ) ) {<br>      pos = pos * 2 + 2 ;<br>    }<br>    i = i + 1 ;<br>  }<br>  return pos ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minOperation ( boolean arr [ ] [ ] ) {<br>  int ans = 0 ;<br>  for ( int i = N - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( arr [ i ] [ j ] == false ) {<br>        ans ++ ;<br>        for ( int k = 0 ;<br>        k <= i ;<br>        k ++ ) {<br>          for ( int h = 0 ;<br>          h <= j ;<br>          h ++ ) {<br>            if ( arr [ k ] [ h ] == true ) {<br>              arr [ k ] [ h ] = false ;<br>            }<br>            else {<br>              arr [ k ] [ h ] = true ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int minOperation ( int [ ] [ ] arr ) {<br>  int ans = 0 ;<br>  for ( int i = N - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( ( arr [ i ] [ j ] == 0 ) && ( arr [ i ] [ j ] == 1 ) ) {<br>        ans ++ ;<br>        for ( int k = 0 ;<br>        k < i + 1 ;<br>        k ++ ) {<br>          for ( int h = 0 ;<br>          h < j + 1 ;<br>          h ++ ) {<br>            if ( ( arr [ k ] [ h ] == 1 ) && ( arr [ k ] [ h ] == 0 ) ) {<br>              arr [ k ] [ h ] = 0 ;<br>            }<br>            else {<br>              arr [ k ] [ h ] = 1 ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str , int n ) {<br>  int sum [ ] = new int [ n + 1 ] ;<br>  sum [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ;<br>  int ans = 0 ;<br>  for ( int len = 2 ;<br>  len <= n ;<br>  len += 2 ) {<br>    for ( int i = 0 ;<br>    i <= n - len ;<br>    i ++ ) {<br>      int j = i + len - 1 ;<br>      if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string , int n ) {<br>  int [ ] Sum = new int [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) Sum [ i ] = ( Sum [ i - 1 ] + Integer . parseInt ( string . charAt ( i - 1 ) ) ) ;<br>  int ans = 0 ;<br>  for ( int length = 2 ;<br>  length <= n ;<br>  length += 2 ) {<br>    for ( int i = 0 ;<br>    i <= n - length + 1 ;<br>    i ++ ) {<br>      int j = i + length - 1 ;<br>      if ( ( Sum [ i + length / 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length / 2 ] ) && ( Sum [ i + length / 2 ] - Sum [ j ] == Sum [ j + length / 2 ] ) ) ans = Math . max ( ans , length ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String multiply ( String num1 , String num2 ) {<br>  int len1 = num1 . length ( ) ;<br>  int len2 = num2 . length ( ) ;<br>  if ( len1 == 0 || len2 == 0 ) return "0" ;<br>  int result [ ] = new int [ len1 + len2 ] ;<br>  int i_n1 = 0 ;<br>  int i_n2 = 0 ;<br>  for ( int i = len1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int carry = 0 ;<br>    int n1 = num1 . charAt ( i ) - '0' ;<br>    i_n2 = 0 ;<br>    for ( int j = len2 - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int n2 = num2 . charAt ( j ) - '0' ;<br>      int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ;<br>      carry = sum / 10 ;<br>      result [ i_n1 + i_n2 ] = sum % 10 ;<br>      i_n2 ++ ;<br>    }<br>    if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ;<br>    i_n1 ++ ;<br>  }<br>  int i = result . length - 1 ;<br>  while ( i >= 0 && result [ i ] == 0 ) i -- ;<br>  if ( i == - 1 ) return "0" ;<br>  String s = "" ;<br>  while ( i >= 0 ) s += ( result [ i -- ] ) ;<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String multiply ( String num1 , String num2 ) {<br>  int len1 = num1 . length ( ) ;<br>  int len2 = num2 . length ( ) ;<br>  if ( len1 == 0 || len2 == 0 ) return "0" ;<br>  char [ ] result = new char [ len1 + len2 ] ;<br>  int i_n1 = 0 ;<br>  int i_n2 = 0 ;<br>  for ( int i = len1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int carry = 0 ;<br>    int n1 = ( char ) num1 . charAt ( i ) - 48 ;<br>    i_n2 = 0 ;<br>    for ( int j = len2 - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int n2 = ( char ) num2 . charAt ( j ) - 48 ;<br>      int summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry ;<br>      carry = summ / 10 ;<br>      result [ i_n1 + i_n2 ] = summ % 10 ;<br>      i_n2 ++ ;<br>    }<br>    if ( ( carry > 0 ) && ( result [ i_n1 + i_n2 ] == 0 ) ) result [ i_n1 + i_n2 ] += carry ;<br>    i_n1 ++ ;<br>  }<br>  int i = result . length - 1 ;<br>  while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) i -- ;<br>  if ( ( i == - 1 ) && ( result [ 0 ] == 0 ) ) return "0" ;<br>  String s = "" ;<br>  while ( ( i >= 0 ) && ( result [ i ] == 0 ) ) {<br>    s += ( char ) ( result [ i ] + 48 ) ;<br>    i -- ;<br>  }<br>  return s ;<br>}<br></td>
  </tr><tr>
    <th>PARTITION_NUMBER_TWO_DIVISBLE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findDivision ( String str , int a , int b ) {<br>  int len = str . length ( ) ;<br>  int [ ] lr = new int [ len + 1 ] ;<br>  lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ;<br>  int [ ] rl = new int [ len + 1 ] ;<br>  rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ;<br>  int power10 = 10 ;<br>  for ( int i = len - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power10 ) % b ;<br>    power10 = ( power10 * 10 ) % b ;<br>  }<br>  for ( int i = 0 ;<br>  i < len - 1 ;<br>  i ++ ) {<br>    if ( lr [ i ] != 0 ) continue ;<br>    if ( rl [ i + 1 ] == 0 ) {<br>      System . out . println ( "YES" ) ;<br>      for ( int k = 0 ;<br>      k <= i ;<br>      k ++ ) System . out . print ( str . charAt ( k ) ) ;<br>      System . out . print ( ", " ) ;<br>      for ( int k = i + 1 ;<br>      k < len ;<br>      k ++ ) System . out . print ( str . charAt ( k ) ) ;<br>      return ;<br>    }<br>  }<br>  System . out . println ( "NO" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findDivision ( String str , int a , int b ) {<br>  int lenn = str . length ( ) ;<br>  int [ ] lr = new int [ lenn + 1 ] ;<br>  lr [ 0 ] = ( Integer . MIN_VALUE ) % a ;<br>  for ( int i = 1 ;<br>  i < lenn ;<br>  i ++ ) {<br>    lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ " " + str . charAt ( i ) ) % a ;<br>  }<br>  int [ ] rl = new int [ lenn + 1 ] ;<br>  rl [ lenn - 1 ] = Integer . MIN_VALUE ;<br>  int power10 = 10 ;<br>  for ( int i = lenn - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    rl [ i ] = ( rl [ i + 1 ] + Integer . MIN_VALUE * str . charAt ( i ) ) % b ;<br>    power10 = ( power10 * 10 ) % b ;<br>  }<br>  for ( int i = 0 ;<br>  i <= lenn - 1 ;<br>  i ++ ) {<br>    if ( ( lr [ i ] != 0 ) && ( rl [ i ] == 0 ) ) continue ;<br>    if ( ( rl [ i + 1 ] == 0 ) && ( i + 1 < lenn ) ) {<br>      System . out . print ( " YES " ) ;<br>      for ( int k = 0 ;<br>      k <= i + 1 ;<br>      k ++ ) {<br>        System . out . print ( str . charAt ( k ) + " SPACETOKEN " ) ;<br>      }<br>      System . out . print ( " , " ) ;<br>      for ( int i = i + 1 ;<br>      i < lenn ;<br>      i ++ ) {<br>        System . out . print ( str . charAt ( k ) + " SPACETOKEN " ) ;<br>        return ;<br>      }<br>    }<br>  }<br>  System . out . println ( " NO " ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < allocation . length ;<br>  i ++ ) allocation [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int bestIdx = - 1 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        if ( bestIdx == - 1 ) bestIdx = j ;<br>        else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ;<br>      }<br>    }<br>    if ( bestIdx != - 1 ) {<br>      allocation [ i ] = bestIdx ;<br>      blockSize [ bestIdx ] -= processSize [ i ] ;<br>    }<br>  }<br>  System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( "   " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ;<br>    else System . out . print ( "Not Allocated" ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bestFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>  int [ ] allocation = new int [ n ] ;<br>  allocation [ 0 ] = - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int bestIdx = - 1 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        if ( bestIdx == - 1 ) {<br>          bestIdx = j ;<br>        }<br>        else if ( blockSize [ bestIdx ] > blockSize [ j ] ) {<br>          bestIdx = j ;<br>        }<br>      }<br>    }<br>    if ( bestIdx != - 1 ) {<br>      allocation [ i ] = bestIdx ;<br>      blockSize [ bestIdx ] -= processSize [ i ] ;<br>    }<br>  }<br>  System . out . println ( "Process No.Process Size     Block no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . println ( i + "         " + processSize [ i ] + "         " ) ;<br>    if ( allocation [ i ] != - 1 ) {<br>      System . out . println ( allocation [ i ] + 1 ) ;<br>    }<br>    else {<br>      System . out . println ( "Not Allocated" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largestKSubmatrix ( int [ ] [ ] a ) {<br>  int [ ] [ ] dp = new int [ Row ] [ Col ] ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < Row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < Col ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;<br>      else {<br>        if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) {<br>          dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ;<br>        }<br>        else dp [ i ] [ j ] = 1 ;<br>      }<br>      result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int largestKSubmatrix ( int [ ] [ ] a ) {<br>  int [ ] [ ] dp = new int [ Row ] [ Col ] ;<br>  for ( int y = 0 ;<br>  y < Row ;<br>  y ++ ) dp [ y ] [ y ] = 0 ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < Row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < Col ;<br>    j ++ ) {<br>      if ( ( i == 0 || j == 0 ) && ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) ) {<br>        dp [ i ] [ j ] = Math . min ( Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = 1 ;<br>      }<br>    }<br>    result = Math . max ( result , dp [ i ] [ j ] ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  if ( dp [ n ] != - 1 ) return dp [ n ] ;<br>  if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ;<br>  else return dp [ n ] = n ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>  int [ ] dp = new int [ 100 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] = - 1 ;<br>  }<br>  if ( ( dp [ n ] != - 1 ) && ( n > 2 ) ) {<br>    dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) ;<br>    return dp [ n ] ;<br>  }<br>  else {<br>    dp [ n ] = n ;<br>    return dp [ n ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstElement ( int arr [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > count_map = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int a = 0 ;<br>    if ( count_map . get ( arr [ i ] ) != null ) {<br>      a = count_map . get ( arr [ i ] ) ;<br>    }<br>    count_map . put ( arr [ i ] , a + 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count_map . get ( arr [ i ] ) == k ) {<br>      return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstElement ( int [ ] arr , int n , int k ) {<br>  int [ ] countMap = new int [ n ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] < countMap . length ) || ( arr [ i ] > countMap [ n - 1 ] ) ) {<br>      countMap [ arr [ i ] ] ++ ;<br>    }<br>    else {<br>      countMap [ arr [ i ] ] = 1 ;<br>    }<br>    i ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( countMap [ arr [ i ] ] == k ) || ( countMap [ arr [ i ] ] > countMap [ n - 1 ] ) ) {<br>      return arr [ i ] ;<br>    }<br>    i ++ ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumOfSeries ( int n ) {<br>  return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double sumOfSeries ( int n ) {<br>  return ( ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_WORDS_IN_A_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWords ( String str ) {<br>  int state = OUT ;<br>  int wc = 0 ;<br>  int i = 0 ;<br>  while ( i < str . length ( ) ) {<br>    if ( str . charAt ( i ) == ' ' || str . charAt ( i ) == '\n' || str . charAt ( i ) == '\t' ) state = OUT ;<br>    else if ( state == OUT ) {<br>      state = IN ;<br>      ++ wc ;<br>    }<br>    ++ i ;<br>  }<br>  return wc ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWords ( String string ) {<br>  int state = OUT ;<br>  int wc = 0 ;<br>  for ( int i = 0 ;<br>  i < string . length ( ) ;<br>  i ++ ) {<br>    if ( ( string . charAt ( i ) == ' ' || string . charAt ( i ) == '\n' || string . charAt ( i ) == '\t' ) && state == OUT ) {<br>      state = IN ;<br>    }<br>    else if ( state == OUT ) {<br>      state = IN ;<br>      wc ++ ;<br>    }<br>  }<br>  return wc ;<br>}<br></td>
  </tr><tr>
    <th>PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDifference ( int arr [ ] , int N , int k ) {<br>  int M , S = 0 , S1 = 0 , max_difference = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) S += arr [ i ] ;<br>  int temp ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( arr [ i ] < arr [ j ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ j ] ;<br>        arr [ j ] = temp ;<br>      }<br>    }<br>  }<br>  M = Math . max ( k , N - k ) ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) S1 += arr [ i ] ;<br>  max_difference = S1 - ( S - S1 ) ;<br>  return max_difference ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDifference ( int [ ] arr , int N , int k ) {<br>  int S = 0 ;<br>  int S1 = 0 ;<br>  int maxDifference ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    S += arr [ i ] ;<br>  }<br>  Arrays . sort ( arr , 0 , N - k ) ;<br>  int M = Math . max ( k , N - k ) ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) {<br>    S1 += arr [ i ] ;<br>  }<br>  maxDifference = S1 - ( S - S1 ) ;<br>  return maxDifference ;<br>}<br></td>
  </tr><tr>
    <th>HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printNos ( int n ) {<br>  if ( n > 0 ) {<br>    printNos ( n - 1 ) ;<br>    System . out . print ( n + " " ) ;<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> static void printNos ( int n ) {<br>  if ( n > 0 ) {<br>    printNos ( n - 1 ) ;<br>    System . out . print ( n + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pairsInSortedRotated ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  int cnt = 0 ;<br>  while ( l != r ) {<br>    if ( arr [ l ] + arr [ r ] == x ) {<br>      cnt ++ ;<br>      if ( l == ( r - 1 + n ) % n ) {<br>        return cnt ;<br>      }<br>      l = ( l + 1 ) % n ;<br>      r = ( r - 1 + n ) % n ;<br>    }<br>    else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;<br>    else r = ( n + r - 1 ) % n ;<br>  }<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int pairsInSortedRotated ( int [ ] arr , int n , int x ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > arr [ i + 1 ] ) {<br>      break ;<br>    }<br>  }<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  int cnt = 0 ;<br>  while ( ( l != r ) && ( cnt < 0 ) ) {<br>    if ( arr [ l ] + arr [ r ] == x ) {<br>      cnt ++ ;<br>      if ( l == ( r - 1 + n ) % n ) {<br>        return cnt ;<br>      }<br>      l = ( l + 1 ) % n ;<br>      r = ( r - 1 + n ) % n ;<br>    }<br>    else if ( arr [ l ] + arr [ r ] < x ) {<br>      l = ( l + 1 ) % n ;<br>    }<br>    else {<br>      r = ( n + r - 1 ) % n ;<br>    }<br>  }<br>  return cnt ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSingle ( int arr [ ] , int n ) {<br>  int ones = 0 , twos = 0 ;<br>  int common_bit_mask ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    twos = twos | ( ones & arr [ i ] ) ;<br>    ones = ones ^ arr [ i ] ;<br>    common_bit_mask = ~ ( ones & twos ) ;<br>    ones &= common_bit_mask ;<br>    twos &= common_bit_mask ;<br>  }<br>  return ones ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSingle ( int [ ] arr , int n ) {<br>  int ones = 0 ;<br>  int twos = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    twos = twos | ( ones & arr [ i ] ) ;<br>    ones = ones ^ arr [ i ] ;<br>    int commonBitMask = ~ ( ones & twos ) ;<br>    ones &= commonBitMask ;<br>    twos &= commonBitMask ;<br>  }<br>  return ones ;<br>}<br></td>
  </tr><tr>
    <th>CASSINIS_IDENTITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int cassini ( int n ) {<br>  return ( n & 1 ) != 0 ? - 1 : 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int cassini ( int n ) {<br>  return n == 0 ? 1 : - 1 ;<br>}<br></td>
  </tr><tr>
    <th>DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean distributingBalls ( long k , long n , String str ) {<br>  int [ ] a = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( a [ i ] > k ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean distributingBalls ( int k , int n , String string ) {<br>  int [ ] a = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) a [ ( char ) string . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( ( a [ i ] > k ) && ( a [ i ] < n ) ) return false ;<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkCount ( int [ ] arr , int n , int k ) {<br>  int count ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] == arr [ i ] ) count ++ ;<br>      if ( count > 2 * k ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkCount ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] == arr [ i ] ) {<br>        count ++ ;<br>      }<br>      if ( count > 2 * k ) {<br>        return false ;<br>      }<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int [ ] arr , int n ) {<br>  if ( n < 4 ) {<br>    System . out . println ( "The array should have" + " atleast 4 elements" ) ;<br>  }<br>  int table1 [ ] = new int [ n + 1 ] ;<br>  int table2 [ ] = new int [ n ] ;<br>  int table3 [ ] = new int [ n - 1 ] ;<br>  int table4 [ ] = new int [ n - 2 ] ;<br>  Arrays . fill ( table1 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table2 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table3 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table4 , Integer . MIN_VALUE ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;<br>  }<br>  for ( int i = n - 3 ;<br>  i >= 0 ;<br>  i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;<br>  for ( int i = n - 4 ;<br>  i >= 0 ;<br>  i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;<br>  return table4 [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] arr , int n ) {<br>  if ( n < 4 ) {<br>    System . out . println ( "The array should have atlest 4 elements" ) ;<br>    return MIN ;<br>  }<br>  int [ ] table1 = new int [ n + 1 ] , table2 = new int [ n ] ;<br>  int [ ] table3 = new int [ n - 1 ] , table4 = new int [ n - 2 ] ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;<br>  }<br>  for ( int i = n - 3 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;<br>  }<br>  for ( int i = n - 4 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;<br>  }<br>  return table4 [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNegative ( int M [ ] [ ] , int n , int m ) {<br>  int count = 0 ;<br>  int i = 0 ;<br>  int j = m - 1 ;<br>  while ( j >= 0 && i < n ) {<br>    if ( M [ i ] [ j ] < 0 ) {<br>      count += j + 1 ;<br>      i += 1 ;<br>    }<br>    else j -= 1 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNegative ( int [ ] [ ] M , int n , int m ) {<br>  int count = 0 ;<br>  int i = 0 ;<br>  int j = m - 1 ;<br>  while ( j >= 0 && i < n ) {<br>    if ( M [ i ] [ j ] < 0 ) {<br>      count += ( j + 1 ) ;<br>      i ++ ;<br>    }<br>    else {<br>      j -- ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>SORT_AN_ARRAY_OF_0S_1S_AND_2S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sort012 ( int a [ ] , int arr_size ) {<br>  int lo = 0 ;<br>  int hi = arr_size - 1 ;<br>  int mid = 0 , temp = 0 ;<br>  while ( mid <= hi ) {<br>    switch ( a [ mid ] ) {<br>      case 0 : {<br>        temp = a [ lo ] ;<br>        a [ lo ] = a [ mid ] ;<br>        a [ mid ] = temp ;<br>        lo ++ ;<br>        mid ++ ;<br>        break ;<br>      }<br>      case 1 : mid ++ ;<br>      break ;<br>      case 2 : {<br>        temp = a [ mid ] ;<br>        a [ mid ] = a [ hi ] ;<br>        a [ hi ] = temp ;<br>        hi -- ;<br>        break ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sort012 ( int [ ] a , int arrSize ) {<br>  int lo = 0 ;<br>  int hi = arrSize - 1 ;<br>  int mid = 0 ;<br>  while ( mid <= hi ) {<br>    if ( a [ mid ] == 0 ) {<br>      a [ lo ] = a [ mid ] ;<br>      lo = lo + 1 ;<br>      mid = mid + 1 ;<br>    }<br>    else if ( a [ mid ] == 1 ) {<br>      mid = mid + 1 ;<br>    }<br>    else {<br>      a [ mid ] = a [ hi ] ;<br>      hi = hi - 1 ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>NTH_EVEN_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long evenFib ( int n ) {<br>  if ( n < 1 ) return n ;<br>  if ( n == 1 ) return 2 ;<br>  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int evenFib ( int n ) {<br>  if ( ( n < 1 ) || ( n == 1 ) ) return n ;<br>  if ( ( n == 1 ) || ( n == 2 ) ) return 2 ;<br>  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>NEXT_GREATER_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printNGE ( int arr [ ] , int n ) {<br>  int next , i , j ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    next = - 1 ;<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ i ] < arr [ j ] ) {<br>        next = arr [ j ] ;<br>        break ;<br>      }<br>    }<br>    System . out . println ( arr [ i ] + " -- " + next ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printNGE ( int [ ] arr ) {<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i += 1 ) {<br>    int next = - 1 ;<br>    for ( int j = i + 1 ;<br>    j < arr . length ;<br>    j += 1 ) {<br>      if ( arr [ i ] < arr [ j ] ) {<br>        next = arr [ j ] ;<br>        break ;<br>      }<br>    }<br>    System . out . println ( String . valueOf ( arr [ i ] ) + " -- " + next ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_CIRCLE_INNER_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void fitOrNotFit ( int R , int r , int x , int y , int rad ) {<br>  double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ;<br>  if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ;<br>  else System . out . println ( "Doesn't Fit" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void fitOrNotFit ( double R , double r , double x , double y , double rad ) {<br>  double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ;<br>  if ( ( val + rad <= R && val - rad >= R - r ) || ( val - rad >= R && val - r <= R - r ) ) System . out . println ( "Fits\n" ) ;<br>  else System . out . println ( "Doesn't Fit" ) ;<br>}<br></td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int gcdExtended ( int a , int b , int x , int y ) {<br>  if ( a == 0 ) {<br>    x = 0 ;<br>    y = 1 ;<br>    return b ;<br>  }<br>  int x1 = 1 , y1 = 1 ;<br>  int gcd = gcdExtended ( b % a , a , x1 , y1 ) ;<br>  x = y1 - ( b / a ) * x1 ;<br>  y = x1 ;<br>  return gcd ;<br>}<br></td>
    <td>translated code: <br><br> public static int gcdExtended ( int a , int b , int x , int y ) {<br>  if ( a == 0 ) {<br>    x = 0 ;<br>    y = 1 ;<br>    return b ;<br>  }<br>  int x1 = 1 ;<br>  int y1 = 1 ;<br>  int gcd = gcdExtended ( b % a , a , x1 , y1 ) ;<br>  x = y1 - ( b / a ) * x1 ;<br>  y = x1 ;<br>  return gcd ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) {<br>  int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ;<br>  for ( i = 0 ;<br>  i <= k ;<br>  i ++ ) {<br>    ptr [ i ] = 0 ;<br>  }<br>  minrange = Integer . MAX_VALUE ;<br>  while ( true ) {<br>    minind = - 1 ;<br>    minval = Integer . MAX_VALUE ;<br>    maxval = Integer . MIN_VALUE ;<br>    flag = 0 ;<br>    for ( i = 0 ;<br>    i < k ;<br>    i ++ ) {<br>      if ( ptr [ i ] == n ) {<br>        flag = 1 ;<br>        break ;<br>      }<br>      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) {<br>        minind = i ;<br>        minval = arr [ i ] [ ptr [ i ] ] ;<br>      }<br>      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) {<br>        maxval = arr [ i ] [ ptr [ i ] ] ;<br>      }<br>    }<br>    if ( flag == 1 ) {<br>      break ;<br>    }<br>    ptr [ minind ] ++ ;<br>    if ( ( maxval - minval ) < minrange ) {<br>      minel = minval ;<br>      maxel = maxval ;<br>      minrange = maxel - minel ;<br>    }<br>  }<br>  System . out . printf ( "The smallest range is [%d , %d]\n" , minel , maxel ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findSmallestRange ( int [ ] arr , int n , int k ) {<br>  int i , minval , maxval , minrange , minel , maxel , flag , minind ;<br>  for ( i = 0 ;<br>  i < k + 1 ;<br>  i ++ ) ptr [ i ] = 0 ;<br>  minrange = 10 * 9 ;<br>  while ( ( 1 ) ) {<br>    minind = - 1 ;<br>    minval = 10 * 9 ;<br>    maxval = - 10 * 9 ;<br>    flag = 0 ;<br>    for ( i = 0 ;<br>    i < k ;<br>    i ++ ) {<br>      if ( ( ptr [ i ] == n ) && ( arr [ i ] [ ptr [ i ] ] < minval ) ) {<br>        flag = 1 ;<br>        break ;<br>      }<br>      if ( ( ptr [ i ] < n ) && ( arr [ i ] [ ptr [ i ] ] > maxval ) ) {<br>        maxval = arr [ i ] [ ptr [ i ] ] ;<br>      }<br>    }<br>    if ( ( flag ) && ( arr [ minind ] == n ) && ( arr [ minind ] == 0 ) ) break ;<br>    ptr [ minind ] ++ ;<br>    if ( ( ( maxval - minval ) < minrange ) && ( arr [ minind ] == n ) && ( arr [ minind ] == 0 ) ) {<br>      minel = minval ;<br>      maxel = maxval ;<br>      minrange = maxel - minel ;<br>    }<br>  }<br>  System . out . println ( "The smallest range is [" + minel + "," + maxel + "]" ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STATION_IS_CONNECTED_IN_ONE_DIRECTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCost ( int cost [ ] [ ] ) {<br>  int dist [ ] = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dist [ i ] = INF ;<br>  dist [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < N ;<br>  j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ;<br>  return dist [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] [ ] cost ) {<br>  int [ ] dist = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dist [ i ] = INF ;<br>  dist [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < N ;<br>  j ++ ) if ( ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) && ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ;<br>  return dist [ N - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( a > b ) {<br>    if ( b > c ) return b ;<br>    else if ( a > c ) return c ;<br>    else return a ;<br>  }<br>  else {<br>    if ( a > c ) return a ;<br>    else if ( b > c ) return c ;<br>    else return b ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( a > b ) {<br>    if ( ( b > c ) && ( a > c ) ) {<br>      return b ;<br>    }<br>    else if ( ( a > c ) && ( b > c ) ) {<br>      return c ;<br>    }<br>    else {<br>      return a ;<br>    }<br>  }<br>  else {<br>    if ( ( a > c ) && ( b > c ) ) {<br>      return a ;<br>    }<br>    else if ( ( b > c ) && ( a > c ) ) {<br>      return c ;<br>    }<br>    else {<br>      return b ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int oddDigSum = 0 , evenDigSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ;<br>    else evenDigSum += ( str . charAt ( i ) - '0' ) ;<br>  }<br>  return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>  int n = st . length ( ) ;<br>  int oddDigSum = 0 ;<br>  int evenDigSum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( i % 2 == 0 ) && ( st . charAt ( i ) == ' ' ) ) oddDigSum = oddDigSum + ( ( Integer ) st . charAt ( i ) ) . intValue ( ) ;<br>    else evenDigSum = evenDigSum + ( ( Integer ) st . charAt ( i ) ) . intValue ( ) ;<br>  }<br>  return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getModulo ( int n , int d ) {<br>  return ( n & ( d - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int getModulo ( int n , int d ) {<br>  return ( n & ( d - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n , int k ) {<br>  int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;<br>  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;<br>  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i && j < k + 1 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;<br>      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;<br>      if ( j - 1 >= 0 ) {<br>        dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrings ( int n , int k ) {<br>  int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ;<br>  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;<br>  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < k + 1 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ;<br>      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;<br>      if ( j >= 1 ) {<br>        dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>FINDING_K_MODULUS_ARRAY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printEqualModNumbers ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int d = arr [ n - 1 ] - arr [ 0 ] ;<br>  Vector < Integer > v = new Vector < > ( ) ;<br>  for ( int i = 1 ;<br>  i * i <= d ;<br>  i ++ ) {<br>    if ( d % i == 0 ) {<br>      v . add ( i ) ;<br>      if ( i != d / i ) v . add ( d / i ) ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < v . size ( ) ;<br>  i ++ ) {<br>    int temp = arr [ 0 ] % v . get ( i ) ;<br>    int j ;<br>    for ( j = 1 ;<br>    j < n ;<br>    j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ;<br>    if ( j == n ) System . out . print ( v . get ( i ) + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printEqualModNumbers ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  ;<br>  int d = arr [ n - 1 ] - arr [ 0 ] ;<br>  ;<br>  int [ ] v = new int [ n ] ;<br>  ;<br>  int i = 1 ;<br>  ;<br>  while ( ( i * i <= d ) && ( i != d / i ) ) {<br>    if ( ( d % i == 0 ) && ( i != d / i ) ) {<br>      v [ i ] = i ;<br>      ;<br>      if ( ( i != d / i ) && ( i != d / i ) ) v [ i ] = d / i ;<br>      ;<br>    }<br>    i ++ ;<br>  };<br>  for ( i = 0 ;<br>  i < v . length ;<br>  i ++ ) {<br>    int temp = arr [ 0 ] % v [ i ] ;<br>    ;<br>    int j = 1 ;<br>    ;<br>    while ( ( j < n ) && ( arr [ j ] % v [ i ] != temp ) ) {<br>      if ( ( arr [ j ] % v [ i ] != temp ) && ( j != n ) ) break ;<br>      j ++ ;<br>    };<br>    if ( ( j == n ) && ( i != 0 ) && ( i != d / i ) ) {<br>      System . out . print ( v [ i ] + " " ) ;<br>    };<br>  }<br>}<br></td>
  </tr><tr>
    <th>CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void spiralFill ( int m , int n , int a [ ] [ ] ) {<br>  int val = 1 ;<br>  int k = 0 , l = 0 ;<br>  while ( k < m && l < n ) {<br>    for ( int i = l ;<br>    i < n ;<br>    ++ i ) {<br>      a [ k ] [ i ] = val ++ ;<br>    }<br>    k ++ ;<br>    for ( int i = k ;<br>    i < m ;<br>    ++ i ) {<br>      a [ i ] [ n - 1 ] = val ++ ;<br>    }<br>    n -- ;<br>    if ( k < m ) {<br>      for ( int i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        a [ m - 1 ] [ i ] = val ++ ;<br>      }<br>      m -- ;<br>    }<br>    if ( l < n ) {<br>      for ( int i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        a [ i ] [ l ] = val ++ ;<br>      }<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void spiralFill ( int m , int n , int [ ] [ ] a ) {<br>  int val = 1 ;<br>  int k = 0 , l = 0 ;<br>  while ( ( k < m && l < n ) || ( k > m && l > n ) ) {<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) {<br>      a [ k ] [ i ] = val ;<br>      val ++ ;<br>    }<br>    k ++ ;<br>    for ( int i = k ;<br>    i < m ;<br>    i ++ ) {<br>      a [ i ] [ n - 1 ] = val ;<br>      val ++ ;<br>    }<br>    n -- ;<br>    if ( ( k < m ) || ( k > n ) ) {<br>      for ( int i = n - 1 ;<br>      i >= l ;<br>      i -- ) {<br>        a [ m - 1 ] [ i ] = val ;<br>        val ++ ;<br>      }<br>      m -- ;<br>    }<br>    if ( ( l < n ) || ( l > m ) ) {<br>      for ( int i = m - 1 ;<br>      i >= k ;<br>      i -- ) {<br>        a [ i ] [ l ] = val ;<br>        val ++ ;<br>      }<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int xor = arr [ 0 ] ;<br>  int set_bit_no ;<br>  int i ;<br>  int n = size - 2 ;<br>  int x = 0 , y = 0 ;<br>  for ( i = 1 ;<br>  i < size ;<br>  i ++ ) xor ^= arr [ i ] ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) xor ^= i ;<br>  set_bit_no = ( xor & ~ ( xor - 1 ) ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int a = arr [ i ] & set_bit_no ;<br>    if ( a != 0 ) x = x ^ arr [ i ] ;<br>    else y = y ^ arr [ i ] ;<br>  }<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    int a = i & set_bit_no ;<br>    if ( a != 0 ) x = x ^ i ;<br>    else y = y ^ i ;<br>  }<br>  System . out . println ( "The two reppeated elements are :" ) ;<br>  System . out . println ( x + " " + y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>  int xor = arr [ 0 ] ;<br>  int n = size - 2 ;<br>  int x = 0 ;<br>  int y = 0 ;<br>  for ( int i = 1 ;<br>  i < size ;<br>  i ++ ) xor ^= arr [ i ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) xor ^= i ;<br>  int setBitNo = xor & ~ ( xor - 1 ) ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( ( arr [ i ] & setBitNo ) != 0 ) x = x ^ arr [ i ] ;<br>    else y = y ^ arr [ i ] ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] & setBitNo ) != 0 ) x = x ^ i ;<br>    else y = y ^ i ;<br>  }<br>  System . out . println ( "The two repeating" + "elements are" + y + " and" + x ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int N ) {<br>  if ( N == 1 ) return 4 ;<br>  int countB = 1 , countS = 1 , prev_countB , prev_countS ;<br>  for ( int i = 2 ;<br>  i <= N ;<br>  i ++ ) {<br>    prev_countB = countB ;<br>    prev_countS = countS ;<br>    countS = prev_countB + prev_countS ;<br>    countB = prev_countS ;<br>  }<br>  int result = countS + countB ;<br>  return ( result * result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int N ) {<br>  if ( ( N == 1 ) || ( N == 2 ) ) {<br>    return 4 ;<br>  }<br>  int countB = 1 ;<br>  int countS = 1 ;<br>  for ( int i = 2 ;<br>  i <= N ;<br>  i ++ ) {<br>    int prevCountB = countB ;<br>    int prevCountS = countS ;<br>    countS = prevCountB + prevCountS ;<br>    countB = prevCountS ;<br>  }<br>  int result = countS + countB ;<br>  return ( result * result ) ;<br>}<br></td>
  </tr><tr>
    <th>ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int factorial ( int n ) {<br>  return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int factorial ( int n ) {<br>  return 1 == ( n == 1 || n == 0 ) ? n * factorial ( n - 1 ) : n ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_SPARSE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSparse ( int array [ ] [ ] , int m , int n ) {<br>  int counter = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  ++ i ) for ( int j = 0 ;<br>  j < n ;<br>  ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ;<br>  return ( counter > ( ( m * n ) / 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSparse ( int [ ] [ ] array , int m , int n ) {<br>  int counter = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( array [ i ] [ j ] == 0 ) && ( array [ i ] [ j ] != 0 ) ) {<br>        counter = counter + 1 ;<br>      }<br>    }<br>  }<br>  return ( counter > ( ( m * n ) / 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , double [ ] wt , double [ ] val , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( ( wt [ n - 1 ] > W ) && ( wt [ n - 1 ] > 0 ) ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_LEAST_AVERAGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMinAvgSubarray ( int n , int k ) {<br>  if ( n < k ) return ;<br>  int res_index = 0 ;<br>  int curr_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) curr_sum += arr [ i ] ;<br>  int min_sum = curr_sum ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    curr_sum += arr [ i ] - arr [ i - k ] ;<br>    if ( curr_sum < min_sum ) {<br>      min_sum = curr_sum ;<br>      res_index = ( i - k + 1 ) ;<br>    }<br>  }<br>  System . out . println ( "Subarray between [" + res_index + ", " + ( res_index + k - 1 ) + "] has minimum average" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMinAvgSubarray ( int [ ] arr , int n , int k ) {<br>  if ( ( n < k ) || ( n > k ) ) return ;<br>  int resIndex = 0 ;<br>  int currSum = 0 ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) currSum += arr [ i ] ;<br>  int minSum = currSum ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    currSum += arr [ i ] - arr [ i - k ] ;<br>    if ( ( currSum < minSum ) && ( i > k ) ) {<br>      minSum = currSum ;<br>      resIndex = ( i - k + 1 ) ;<br>    }<br>  }<br>  System . out . println ( "Subarray between [" + resIndex + ", " + ( resIndex + k - 1 ) + "] has minimum average" ) ;<br>}<br></td>
  </tr><tr>
    <th>QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void query ( String s , int i , int j ) {<br>  int n = s . length ( ) ;<br>  i %= n ;<br>  j %= n ;<br>  if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( "Yes" ) ;<br>  else System . out . println ( "No" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void query ( String s , int i , int j ) {<br>  int n = s . length ( ) ;<br>  i %= n ;<br>  j %= n ;<br>  System . out . println ( "Yes" ) ;<br>  if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( "Yes" ) ;<br>  else System . out . println ( "No" ) ;<br>}<br></td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void productArray ( int arr [ ] , int n ) {<br>  if ( n == 1 ) {<br>    System . out . print ( "0" ) ;<br>    return ;<br>  }<br>  int i , temp = 1 ;<br>  int prod [ ] = new int [ n ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) prod [ j ] = 1 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    prod [ i ] = temp ;<br>    temp *= arr [ i ] ;<br>  }<br>  temp = 1 ;<br>  for ( i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    prod [ i ] *= temp ;<br>    temp *= arr [ i ] ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( prod [ i ] + " " ) ;<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void productArray ( int [ ] arr , int n ) {<br>  if ( n == 1 ) {<br>    System . out . println ( 0 ) ;<br>    return ;<br>  }<br>  int i , temp ;<br>  int [ ] prod = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    prod [ i ] = 1 ;<br>    temp *= arr [ i ] ;<br>  }<br>  temp = 1 ;<br>  for ( i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    prod [ i ] *= temp ;<br>    temp *= arr [ i ] ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( prod [ i ] + " " ) ;<br>  }<br>  return ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pairSum ( int mat [ ] [ ] , int n , int sum ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) Arrays . sort ( mat [ i ] ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int left = 0 , right = n - 1 ;<br>      while ( left < n && right >= 0 ) {<br>        if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) {<br>          System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ;<br>          left ++ ;<br>          right -- ;<br>        }<br>        else {<br>          if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ;<br>          else right -- ;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void pairSum ( int [ ] [ ] mat , int n , int sum ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mat [ i ] . sort ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int left = 0 ;<br>      int right = n - 1 ;<br>      while ( ( left < n && right >= 0 ) || ( j < n && left >= 0 ) ) {<br>        if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) && ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) ) {<br>          System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ;<br>          left ++ ;<br>          right -- ;<br>        }<br>        else {<br>          if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) && ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) ) {<br>            left ++ ;<br>          }<br>          else {<br>            right -- ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRotated ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) != str2 . length ( ) ) return false ;<br>  String clock_rot = "" ;<br>  String anticlock_rot = "" ;<br>  int len = str2 . length ( ) ;<br>  anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ;<br>  clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ;<br>  return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRotated ( String str1 , String str2 ) {<br>  if ( ( str1 . length ( ) != str2 . length ( ) ) || ( str1 . length ( ) == 0 ) ) return false ;<br>  String clock_rot = "" ;<br>  String anticlock_rot = "" ;<br>  int l = str2 . length ( ) ;<br>  anticlock_rot = ( anticlock_rot + str2 . substring ( l - 2 ) + str2 . substring ( 0 , l - 2 ) ) ;<br>  clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ;<br>  return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ;<br>}<br></td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  for ( int curr = 1 ;<br>  ;<br>  curr ++ ) {<br>    int sum = 0 ;<br>    for ( int x = curr ;<br>    x > 0 ;<br>    x = x / 10 ) sum = sum + x % 10 ;<br>    if ( sum == 10 ) count ++ ;<br>    if ( count == n ) return curr ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  for ( int curr = 0 ;<br>  curr < Integer . MAX_VALUE ;<br>  curr ++ ) {<br>    int sum = 0 ;<br>    int x = curr ;<br>    while ( ( x = curr ) != 0 ) {<br>      sum = sum + x % 10 ;<br>      x = x / 10 ;<br>    }<br>    if ( ( sum == 10 ) && ( count == 10 ) ) {<br>      count = count + 1 ;<br>    }<br>    if ( ( count == n ) && ( curr == 0 ) ) {<br>      return curr ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_SLOPE_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float slope ( float x1 , float y1 , float x2 , float y2 ) {<br>  return ( y2 - y1 ) / ( x2 - x1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static float slope ( float x1 , float y1 , float x2 , float y2 ) {<br>  return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ;<br>}<br></td>
  </tr><tr>
    <th>GCD_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int rangeGCD ( int n , int m ) {<br>  return ( n == m ) ? n : 1 ;<br>}<br></td>
    <td>translated code: <br><br> static int rangeGCD ( int n , int m ) {<br>  return n == m ? 1 : ( n == m ? 0 : 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSubarray ( boolean arr [ ] , int n ) {<br>  int count = 1 ;<br>  boolean prev = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( ( arr [ i ] ^ prev ) == false ) {<br>      while ( count > 0 ) {<br>        System . out . print ( count -- + " " ) ;<br>      }<br>    }<br>    ++ count ;<br>    prev = arr [ i ] ;<br>  }<br>  while ( count != 0 ) {<br>    System . out . print ( count -- + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSubarray ( int [ ] arr , int n ) {<br>  int count = 1 ;<br>  int prev = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( ( arr [ i ] ^ prev ) == 0 ) && ( ( arr [ i ] ^ prev ) == 0 ) ) {<br>      while ( ( count ) > 0 ) {<br>        System . out . print ( count + " " ) ;<br>        count -- ;<br>      }<br>    }<br>    count ++ ;<br>    prev = arr [ i ] ;<br>  }<br>  while ( ( count ) > 0 ) {<br>    System . out . print ( count + " " ) ;<br>    count -- ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int unitDigitXRaisedY ( int x , int y ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < y ;<br>  i ++ ) res = ( res * x ) % 10 ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int unitDigitXRaisedY ( int x , int y ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < y ;<br>  i ++ ) {<br>    res = ( res * x ) % 10 ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long moduloMultiplication ( long a , long b , long mod ) {<br>  long res = 0 ;<br>  a %= mod ;<br>  while ( b > 0 ) {<br>    if ( ( b & 1 ) > 0 ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( 2 * a ) % mod ;<br>    b >>= 1 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int moduloMultiplication ( int a , int b , int mod ) {<br>  int res = 0 ;<br>  ;<br>  a = a % mod ;<br>  ;<br>  while ( ( b ) > 0 ) {<br>    if ( ( b & 1 ) != 0 ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( 2 * a ) % mod ;<br>    b >>= 1 ;<br>    ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findSmallest ( int m , int s ) {<br>  if ( s == 0 ) {<br>    System . out . print ( m == 1 ? "Smallest number is 0" : "Not possible" ) ;<br>    return ;<br>  }<br>  if ( s > 9 * m ) {<br>    System . out . println ( "Not possible" ) ;<br>    return ;<br>  }<br>  int [ ] res = new int [ m ] ;<br>  s -= 1 ;<br>  for ( int i = m - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( s > 9 ) {<br>      res [ i ] = 9 ;<br>      s -= 9 ;<br>    }<br>    else {<br>      res [ i ] = s ;<br>      s = 0 ;<br>    }<br>  }<br>  res [ 0 ] = s + 1 ;<br>  System . out . print ( "Smallest number is " ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) System . out . print ( res [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findSmallest ( int m , int s ) {<br>  if ( ( s == 0 ) && ( m == 1 ) ) {<br>    System . out . println ( "Smallest number is 0" ) ;<br>  }<br>  else {<br>    System . out . println ( "Not possible" ) ;<br>  }<br>  return ;<br>}<br>if ( ( s > 9 * m ) && ( m > 1 ) ) {<br>  System . out . println ( "Not possible" ) ;<br>  return ;<br>}<br>int [ ] res = new int [ m + 1 ] ;<br>s -- ;<br>for ( int i = m - 1 ;<br>i > 0 ;<br>i -- ) {<br>  if ( ( s > 9 ) && ( s > 9 ) ) {<br>    res [ i ] = 9 ;<br>    s -= 9 ;<br>  }<br>  else {<br>    res [ i ] = s ;<br>    s = 0 ;<br>  }<br>}<br>res [ 0 ] = s + 1 ;<br>System . out . print ( "Smallest number is " ) ;<br>for ( int i = 0 ;<br>i < m ;<br>i ++ ) {<br>  System . out . print ( res [ i ] + " " ) ;<br>}<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largest ( ) {<br>  int i ;<br>  int max = arr [ 0 ] ;<br>  for ( i = 1 ;<br>  i < arr . length ;<br>  i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int largest ( int [ ] arr , int n ) {<br>  int max = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > max ) {<br>      max = arr [ i ] ;<br>    }<br>  }<br>  return max ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNums ( int n , int x , int y ) {<br>  boolean [ ] arr = new boolean [ n + 1 ] ;<br>  if ( x <= n ) arr [ x ] = true ;<br>  if ( y <= n ) arr [ y ] = true ;<br>  int result = 0 ;<br>  for ( int i = Math . min ( x , y ) ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( arr [ i ] ) {<br>      if ( i + x <= n ) arr [ i + x ] = true ;<br>      if ( i + y <= n ) arr [ i + y ] = true ;<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNums ( int n , int x , int y ) {<br>  boolean [ ] arr = new boolean [ n + 2 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = false ;<br>  if ( ( x <= n ) && ( x < n ) ) arr [ x ] = true ;<br>  if ( ( y <= n ) && ( y < n ) ) arr [ y ] = true ;<br>  int result = 0 ;<br>  for ( int i = Math . min ( x , y ) ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] ) ) {<br>      if ( ( i + x <= n ) && ( i + x <= n ) ) arr [ i + x ] = true ;<br>      if ( ( i + y <= n ) && ( i + y <= n ) ) arr [ i + y ] = true ;<br>      result = result + 1 ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>BUBBLE_SORT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bubbleSort ( int arr [ ] , int n ) {<br>  int i , j , temp ;<br>  boolean swapped ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    swapped = false ;<br>    for ( j = 0 ;<br>    j < n - i - 1 ;<br>    j ++ ) {<br>      if ( arr [ j ] > arr [ j + 1 ] ) {<br>        temp = arr [ j ] ;<br>        arr [ j ] = arr [ j + 1 ] ;<br>        arr [ j + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( swapped == false ) break ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bubbleSort ( int [ ] arr ) {<br>  int n = arr . length ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    boolean swapped = false ;<br>    for ( int j = 0 ;<br>    j <= n - i - 1 ;<br>    j ++ ) {<br>      if ( arr [ j ] > arr [ j + 1 ] ) {<br>        arr [ j ] = arr [ j + 1 ] ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( swapped == false ) break ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int maxSum ( int grid [ ] [ ] , int n ) {<br>  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;<br>  int excl = 0 , excl_new ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    excl_new = Math . max ( excl , incl ) ;<br>    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;<br>    excl = excl_new ;<br>  }<br>  return Math . max ( excl , incl ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] [ ] grid , int n ) {<br>  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;<br>  int excl = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int exclNew = Math . max ( excl , incl ) ;<br>    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;<br>    excl = exclNew ;<br>  }<br>  return Math . max ( excl , incl ) ;<br>}<br></td>
  </tr><tr>
    <th>GCD_FACTORIALS_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int gcdOfFactorial ( int m , int n ) {<br>  int min = m < n ? m : n ;<br>  return factorial ( min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double gcdOfFactorial ( int m , int n ) {<br>  return Math . factorial ( Math . min ( m , n ) ) ;<br>}<br></td>
  </tr><tr>
    <th>AREA_OF_A_SECTOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void SectorArea ( double radius , double angle ) {<br>  if ( angle >= 360 ) System . out . println ( "Angle not possible" ) ;<br>  else {<br>    double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ;<br>    System . out . println ( sector ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void SectorArea ( int radius , int angle ) {<br>  int pi = 22 / 7 ;<br>  if ( angle >= 360 ) {<br>    System . out . println ( "Angle not possible" ) ;<br>    return ;<br>  }<br>  else {<br>    int sector = ( pi * radius * radius ) * ( angle / 360 ) ;<br>    System . out . println ( sector ) ;<br>    return ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSeq ( int n ) {<br>  int nCr = 1 , res = 1 ;<br>  for ( int r = 1 ;<br>  r <= n ;<br>  r ++ ) {<br>    nCr = ( nCr * ( n + 1 - r ) ) / r ;<br>    res += nCr * nCr ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSeq ( int n ) {<br>  int nCr = 1 ;<br>  int res = 1 ;<br>  for ( int r = 1 ;<br>  r <= n ;<br>  r ++ ) {<br>    nCr = ( nCr * ( n + 1 - r ) ) / r ;<br>    ;<br>    res += nCr * nCr ;<br>  };<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str ) {<br>  int n = str . length ( ) ;<br>  int maxlen = 0 ;<br>  int sum [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ;<br>  for ( int len = 2 ;<br>  len <= n ;<br>  len ++ ) {<br>    for ( int i = 0 ;<br>    i < n - len + 1 ;<br>    i ++ ) {<br>      int j = i + len - 1 ;<br>      int k = len / 2 ;<br>      sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ;<br>      if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ;<br>    }<br>  }<br>  return maxlen ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string ) {<br>  int n = string . length ( ) ;<br>  int maxlen = 0 ;<br>  int [ ] [ ] Sum = new int [ n ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) {<br>    Sum [ y ] [ y ] = new int [ n ] ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    Sum [ i ] [ i ] = Integer . parseInt ( string . substring ( i ) ) ;<br>  }<br>  for ( int length = 2 ;<br>  length <= n ;<br>  length ++ ) {<br>    for ( int i = 0 ;<br>    i <= n - length + 1 ;<br>    i ++ ) {<br>      int j = i + length - 1 ;<br>      int k = length / 2 ;<br>      Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) ;<br>      if ( ( length % 2 == 0 && Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] && length > maxlen ) ) {<br>        maxlen = length ;<br>      }<br>    }<br>  }<br>  return maxlen ;<br>}<br></td>
  </tr><tr>
    <th>SWAP_ALL_ODD_AND_EVEN_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int swapBits ( int x ) {<br>  int even_bits = x & 0xAAAAAAAA ;<br>  int odd_bits = x & 0x55555555 ;<br>  even_bits >>= 1 ;<br>  odd_bits <<= 1 ;<br>  return ( even_bits | odd_bits ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int swapBits ( int x ) {<br>  int evenBits = x & 0xAAAAAAAA ;<br>  int oddBits = x & 0x55555555 ;<br>  evenBits >>>= 1 ;<br>  oddBits <<= 1 ;<br>  return ( evenBits | oddBits ) ;<br>}<br></td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void sortInWave ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i += 2 ) swap ( arr , i , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void sortInWave ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i += 2 ) {<br>    arr [ i ] = arr [ i + 1 ] ;<br>    arr [ i + 1 ] = arr [ i ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double compute ( int a , int b ) {<br>  double AM , GM , HM ;<br>  AM = ( a + b ) / 2 ;<br>  GM = Math . sqrt ( a * b ) ;<br>  HM = ( GM * GM ) / AM ;<br>  return HM ;<br>}<br></td>
    <td>translated code: <br><br> public static double compute ( double a , double b ) {<br>  double AM = ( a + b ) / 2 ;<br>  double GM = Math . sqrt ( a * b ) ;<br>  double HM = ( GM * GM ) / AM ;<br>  return HM ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_BALANCED_BINARY_TREES_HEIGHT_H</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long countBT ( int h ) {<br>  long [ ] dp = new long [ h + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= h ;<br>  ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ;<br>  return dp [ h ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countBT ( int h ) {<br>  final int MOD = 1000000007 ;<br>  int [ ] dp = new int [ h + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= h ;<br>  i ++ ) {<br>    dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ;<br>  }<br>  return dp [ h ] ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInsertion ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = 0 ;<br>  int [ ] count = new int [ 26 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < 26 ;<br>  i ++ ) {<br>    if ( count [ i ] % 2 == 1 ) res ++ ;<br>  }<br>  return ( res == 0 ) ? 0 : res - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInsertion ( String tr1 ) {<br>  int n = str1 . length ( ) ;<br>  int res = 0 ;<br>  int [ ] count = new int [ 26 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    count [ ( char ) str1 . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < 26 ;<br>  i ++ ) {<br>    if ( ( count [ i ] % 2 == 1 ) && ( count [ i ] % 3 == 1 ) ) {<br>      res ++ ;<br>    }<br>  }<br>  if ( ( res == 0 ) || ( res == 1 ) ) {<br>    return 0 ;<br>  }<br>  else {<br>    return res - 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SHUFFLE_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void randomize ( int arr [ ] , int n ) {<br>  Random r = new Random ( ) ;<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    int j = r . nextInt ( i + 1 ) ;<br>    int temp = arr [ i ] ;<br>    arr [ i ] = arr [ j ] ;<br>    arr [ j ] = temp ;<br>  }<br>  System . out . println ( Arrays . toString ( arr ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] randomize ( int [ ] arr , int n ) {<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    int j = ThreadLocalRandom . current ( ) . nextInt ( i + 1 ) ;<br>    arr [ i ] = arr [ j ] ;<br>    arr [ j ] = arr [ i ] ;<br>  }<br>  return arr ;<br>}<br></td>
  </tr><tr>
    <th>UGLY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getNthUglyNo ( int n ) {<br>  int ugly [ ] = new int [ n ] ;<br>  int i2 = 0 , i3 = 0 , i5 = 0 ;<br>  int next_multiple_of_2 = 2 ;<br>  int next_multiple_of_3 = 3 ;<br>  int next_multiple_of_5 = 5 ;<br>  int next_ugly_no = 1 ;<br>  ugly [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ;<br>    ugly [ i ] = next_ugly_no ;<br>    if ( next_ugly_no == next_multiple_of_2 ) {<br>      i2 = i2 + 1 ;<br>      next_multiple_of_2 = ugly [ i2 ] * 2 ;<br>    }<br>    if ( next_ugly_no == next_multiple_of_3 ) {<br>      i3 = i3 + 1 ;<br>      next_multiple_of_3 = ugly [ i3 ] * 3 ;<br>    }<br>    if ( next_ugly_no == next_multiple_of_5 ) {<br>      i5 = i5 + 1 ;<br>      next_multiple_of_5 = ugly [ i5 ] * 5 ;<br>    }<br>  }<br>  return next_ugly_no ;<br>}<br></td>
    <td>translated code: <br><br> public static int getNthUglyNo ( int n ) {<br>  int [ ] ugly = new int [ n ] ;<br>  ugly [ 0 ] = 1 ;<br>  int i2 = i3 = i5 = 0 ;<br>  int nextMultipleOf2 = 2 ;<br>  int nextMultipleOf3 = 3 ;<br>  int nextMultipleOf5 = 5 ;<br>  for ( int l = 1 ;<br>  l < n ;<br>  l ++ ) {<br>    ugly [ l ] = Math . min ( nextMultipleOf2 , nextMultipleOf3 , nextMultipleOf5 ) ;<br>    if ( ugly [ l ] == nextMultipleOf2 ) {<br>      i2 ++ ;<br>      nextMultipleOf2 = ugly [ i2 ] * 2 ;<br>    }<br>    if ( ugly [ l ] == nextMultipleOf3 ) {<br>      i3 ++ ;<br>      nextMultipleOf3 = ugly [ i3 ] * 3 ;<br>    }<br>    if ( ugly [ l ] == nextMultipleOf5 ) {<br>      i5 ++ ;<br>      nextMultipleOf5 = ugly [ i5 ] * 5 ;<br>    }<br>  }<br>  return ugly [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_COST_CUT_BOARD_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) {<br>  int res = 0 ;<br>  Arrays . sort ( X , Collections . reverseOrder ( ) ) ;<br>  Arrays . sort ( Y , Collections . reverseOrder ( ) ) ;<br>  int hzntl = 1 , vert = 1 ;<br>  int i = 0 , j = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( X [ i ] > Y [ j ] ) {<br>      res += X [ i ] * vert ;<br>      hzntl ++ ;<br>      i ++ ;<br>    }<br>    else {<br>      res += Y [ j ] * hzntl ;<br>      vert ++ ;<br>      j ++ ;<br>    }<br>  }<br>  int total = 0 ;<br>  while ( i < m ) total += X [ i ++ ] ;<br>  res += total * vert ;<br>  total = 0 ;<br>  while ( j < n ) total += Y [ j ++ ] ;<br>  res += total * hzntl ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double minimumCostOfBreaking ( double [ ] X , double [ ] Y , int m , int n ) {<br>  double res = 0 ;<br>  Arrays . sort ( X ) ;<br>  Arrays . sort ( Y ) ;<br>  double hzntl = 1 ;<br>  double vert = 1 ;<br>  int i = 0 ;<br>  int j = 0 ;<br>  while ( ( i < m && j < n ) || ( i < n && j < m ) ) {<br>    if ( ( X [ i ] > Y [ j ] ) || ( X [ i ] > Y [ j ] ) ) {<br>      res += X [ i ] * vert ;<br>      hzntl ++ ;<br>      i ++ ;<br>    }<br>    else {<br>      res += Y [ j ] * hzntl ;<br>      vert ++ ;<br>      j ++ ;<br>    }<br>  }<br>  double total = 0 ;<br>  while ( ( i < m ) || ( i < n ) ) {<br>    total += X [ i ] ;<br>    i ++ ;<br>  }<br>  res += total * vert ;<br>  total = 0 ;<br>  while ( ( j < n ) || ( j < m ) ) {<br>    total += Y [ j ] ;<br>    j ++ ;<br>  }<br>  res += total * hzntl ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>  int [ ] [ ] K = new int [ W + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int w = 0 ;<br>    w < W + 1 ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) {<br>        K [ i ] [ w ] = 0 ;<br>      }<br>      else if ( wt [ i - 1 ] <= w ) {<br>        K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      }<br>      else {<br>        K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>      }<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
  </tr><tr>
    <th>STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) {<br>  Queue < Integer > input = new LinkedList < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    input . add ( ip [ i ] ) ;<br>  }<br>  Queue < Integer > output = new LinkedList < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    output . add ( op [ i ] ) ;<br>  }<br>  Stack < Integer > tempStack = new Stack < > ( ) ;<br>  while ( ! input . isEmpty ( ) ) {<br>    int ele = input . poll ( ) ;<br>    if ( ele == output . peek ( ) ) {<br>      output . poll ( ) ;<br>      while ( ! tempStack . isEmpty ( ) ) {<br>        if ( tempStack . peek ( ) == output . peek ( ) ) {<br>          tempStack . pop ( ) ;<br>          output . poll ( ) ;<br>        }<br>        else break ;<br>      }<br>    }<br>    else {<br>      tempStack . push ( ele ) ;<br>    }<br>  }<br>  return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) {<br>  Queue < Integer > Input = new Queue < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) Input . offer ( ip [ i ] ) ;<br>  Queue < Integer > Output = new Queue < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) Output . offer ( op [ i ] ) ;<br>  Stack < Integer > tempStack = new Stack < Integer > ( ) ;<br>  while ( ( ! Input . isEmpty ( ) ) && ( ! Output . isEmpty ( ) ) ) {<br>    Integer ele = Input . peek ( ) ;<br>    Input . pop ( ) ;<br>    if ( ( ele == Output . peek ( ) ) && ( tempStack . size ( ) != 0 ) ) {<br>      Output . pop ( ) ;<br>      while ( ( tempStack . size ( ) != 0 ) && ( tempStack . size ( ) == 0 ) ) {<br>        if ( ( tempStack . peek ( ) == Output . peek ( ) ) && ( tempStack . size ( ) == 1 ) ) {<br>          tempStack . pop ( ) ;<br>          Output . pop ( ) ;<br>        }<br>        else break ;<br>      }<br>    }<br>    else tempStack . push ( ele ) ;<br>  }<br>  return ( Input . isEmpty ( ) && tempStack . size ( ) == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double procal ( int n ) {<br>  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double procal ( double n ) {<br>  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String simplify ( String str ) {<br>  int len = str . length ( ) ;<br>  char res [ ] = new char [ len ] ;<br>  int index = 0 , i = 0 ;<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  s . push ( 0 ) ;<br>  while ( i < len ) {<br>    if ( str . charAt ( i ) == '+' ) {<br>      if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ;<br>      if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ;<br>    }<br>    else if ( str . charAt ( i ) == '-' ) {<br>      if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ;<br>      else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ;<br>    }<br>    else if ( str . charAt ( i ) == '(' && i > 0 ) {<br>      if ( str . charAt ( i - 1 ) == '-' ) {<br>        int x = ( s . peek ( ) == 1 ) ? 0 : 1 ;<br>        s . push ( x ) ;<br>      }<br>      else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s . peek ( ) ) ;<br>    }<br>    else if ( str . charAt ( i ) == ')' ) s . pop ( ) ;<br>    else res [ index ++ ] = str . charAt ( i ) ;<br>    i ++ ;<br>  }<br>  return new String ( res ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String simplify ( String Str ) {<br>  int Len = Str . length ( ) ;<br>  String res = new String ( null ) ;<br>  int index = 0 ;<br>  int i = 0 ;<br>  Stack s = new Stack ( ) ;<br>  s . push ( 0 ) ;<br>  while ( ( i < Len ) && ( i < Str . length ( ) ) ) {<br>    if ( ( Str . charAt ( i ) == '+' ) ) {<br>      if ( ( s . pop ( ) == 1 ) ) {<br>        res . charAt ( index ) = '-' ;<br>        index ++ ;<br>      }<br>      if ( ( s . pop ( ) == 0 ) ) {<br>        res . charAt ( index ) = '+' ;<br>        index ++ ;<br>      }<br>    }<br>    else if ( ( Str . charAt ( i ) == '-' ) ) {<br>      if ( ( s . pop ( ) == 1 ) ) {<br>        res . charAt ( index ) = '+' ;<br>        index ++ ;<br>      }<br>      else if ( ( s . pop ( ) == 0 ) ) {<br>        res . charAt ( index ) = '-' ;<br>        index ++ ;<br>      }<br>    }<br>    else if ( ( Str . charAt ( i ) == '(' ) && i > 0 ) ) {<br>      if ( ( Str . charAt ( i - 1 ) == '-' ) ) {<br>        int x = 0 == ( s . pop ( ) == 1 ) ? 1 : 0 ;<br>        s . push ( x ) ;<br>      }<br>      else if ( ( Str . charAt ( i - 1 ) == '+' ) ) {<br>        s . push ( s . pop ( ) ) ;<br>      }<br>    }<br>    else if ( ( Str . charAt ( i ) == ')' ) ) {<br>      s . pop ( ) ;<br>    }<br>    else {<br>      res . charAt ( index ) = Str . charAt ( i ) ;<br>      index ++ ;<br>    }<br>    i ++ ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSquares ( int a , int b ) {<br>  int cnt = 0 ;<br>  for ( int i = a ;<br>  i <= b ;<br>  i ++ ) for ( int j = 1 ;<br>  j * j <= i ;<br>  j ++ ) if ( j * j == i ) cnt ++ ;<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountSquares ( int a , int b ) {<br>  int cnt = 0 ;<br>  for ( int i = a ;<br>  i <= b ;<br>  i ++ ) {<br>    int j = 1 ;<br>    ;<br>    while ( j * j <= i ) {<br>      if ( j * j == i ) cnt = cnt + 1 ;<br>      j = j + 1 ;<br>    }<br>    i = i + 1 ;<br>  }<br>  return cnt ;<br>}<br></td>
  </tr><tr>
    <th>K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minDiff ( int arr [ ] , int n , int k ) {<br>  int result = Integer . MAX_VALUE ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i <= n - k ;<br>  i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDiff ( int [ ] arr , int n , int k ) {<br>  int result = + 2147483647 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    result = ( int ) Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkDivisibility ( String num ) {<br>  int length = num . length ( ) ;<br>  if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( length % 3 == 1 ) {<br>    num += "00" ;<br>    length += 2 ;<br>  }<br>  else if ( length % 3 == 2 ) {<br>    num += "0" ;<br>    length += 1 ;<br>  }<br>  int sum = 0 , p = 1 ;<br>  for ( int i = length - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int group = 0 ;<br>    group += num . charAt ( i -- ) - '0' ;<br>    group += ( num . charAt ( i -- ) - '0' ) * 10 ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    sum = sum + group * p ;<br>    p *= ( - 1 ) ;<br>  }<br>  sum = Math . abs ( sum ) ;<br>  return ( sum % 13 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkDivisibility ( String num ) {<br>  int length = num . length ( ) ;<br>  if ( ( length == 1 && num . charAt ( 0 ) == '0' ) || ( length == 2 && num . charAt ( 0 ) == '1' ) ) {<br>    return true ;<br>  }<br>  if ( ( length % 3 == 1 ) || ( length % 3 == 2 ) ) {<br>    num = String . valueOf ( num ) + "00" ;<br>    length += 2 ;<br>  }<br>  else if ( ( length % 3 == 2 ) || ( length % 3 == 3 ) ) {<br>    num = String . valueOf ( num ) + "0" ;<br>    length += 1 ;<br>  }<br>  long sum = 0 ;<br>  long p = 1 ;<br>  for ( int i = length - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    long group = 0 ;<br>    group += ( num . charAt ( i ) - '0' ) ;<br>    i -- ;<br>    group += ( num . charAt ( i ) - '0' ) * 10 ;<br>    i -- ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    sum = sum + group * p ;<br>    p *= ( - 1 ) ;<br>  }<br>  sum = Math . abs ( sum ) ;<br>  return ( sum % 13 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSumSimple ( int mat [ ] [ ] , int k ) {<br>  if ( k > n ) return ;<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      int sum = 0 ;<br>      for ( int p = i ;<br>      p < k + i ;<br>      p ++ ) for ( int q = j ;<br>      q < k + j ;<br>      q ++ ) sum += mat [ p ] [ q ] ;<br>      System . out . print ( sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSumSimple ( int [ ] [ ] mat , int k ) {<br>  if ( ( k > n ) || ( k < 0 ) ) return ;<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      int sum = 0 ;<br>      for ( int p = i ;<br>      p < k + i ;<br>      p ++ ) {<br>        for ( int q = j ;<br>        q < k + j ;<br>        q ++ ) {<br>          sum += mat [ p ] [ q ] ;<br>        }<br>      }<br>      System . out . print ( sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void maxOverlap ( int [ ] start , int [ ] end , int n ) {<br>  int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ;<br>  int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ;<br>  int maxc = Math . max ( maxa , maxb ) ;<br>  int [ ] x = new int [ maxc + 2 ] ;<br>  Arrays . fill ( x , 0 ) ;<br>  int cur = 0 , idx = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    ++ x [ start [ i ] ] ;<br>    -- x [ end [ i ] + 1 ] ;<br>  }<br>  int maxy = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i <= maxc ;<br>  i ++ ) {<br>    cur += x [ i ] ;<br>    if ( maxy < cur ) {<br>      maxy = cur ;<br>      idx = i ;<br>    }<br>  }<br>  System . out . println ( "Maximum value is:" + maxy + " at position: " + idx + "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maxOverlap ( int [ ] start , int [ ] end ) {<br>  int n = start . length ;<br>  int maxa = Math . max ( start , end ) ;<br>  int maxb = Math . max ( end , start ) ;<br>  int maxc = Math . max ( maxa , maxb ) ;<br>  int [ ] x = ( maxc + 2 ) * new int [ n ] ;<br>  int cur = 0 ;<br>  int idx = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    x [ start [ i ] ] ++ ;<br>    x [ end [ i ] + 1 ] -- ;<br>  }<br>  int maxy = - 1 ;<br>  for ( int i = 0 ;<br>  i <= maxc ;<br>  i ++ ) {<br>    cur += x [ i ] ;<br>    if ( maxy < cur ) {<br>      maxy = cur ;<br>      idx = i ;<br>    }<br>  }<br>  System . out . println ( "Maximum value is: {<br>0:d}" + " at position: {<br>0:d}" + idx ) ;<br>    }<br>    </td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumWO3Consec ( int n ) {<br>  if ( sum [ n ] != - 1 ) return sum [ n ] ;<br>  if ( n == 0 ) return sum [ n ] = 0 ;<br>  if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;<br>  if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;<br>  return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumWO3Consec ( int n ) {<br>  if ( ( sum [ n ] != - 1 ) && ( n > 0 ) ) return sum [ n ] ;<br>  if ( ( n == 0 ) || ( n == 1 ) ) {<br>    sum [ n ] = 0 ;<br>    return sum [ n ] ;<br>  }<br>  if ( ( n == 2 ) || ( n == 3 ) ) {<br>    sum [ n ] = arr [ 0 ] ;<br>    return sum [ n ] ;<br>  }<br>  if ( ( n == 4 ) || ( n == 5 ) ) {<br>    sum [ n ] = arr [ 1 ] + arr [ 0 ] ;<br>    return sum [ n ] ;<br>  }<br>  sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ;<br>  return sum [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_ADDITION_TWO_MATRICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < N ;<br>  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void add ( int [ ] [ ] A , int [ ] [ ] B , int [ ] [ ] C ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxAverage ( int arr [ ] , int n , int k ) {<br>  if ( k > n ) return - 1 ;<br>  int sum = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < k ;<br>  i ++ ) sum += arr [ i ] ;<br>  int max_sum = sum , max_end = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    sum = sum + arr [ i ] - arr [ i - k ] ;<br>    if ( sum > max_sum ) {<br>      max_sum = sum ;<br>      max_end = i ;<br>    }<br>  }<br>  return max_end - k + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>  if ( ( k > n ) && ( k < 0 ) ) return - 1 ;<br>  int sum = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < k ;<br>  i ++ ) sum += arr [ i ] ;<br>  int maxSum = sum ;<br>  int maxEnd = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    sum = sum + arr [ i ] - arr [ i - k ] ;<br>    if ( ( sum > maxSum ) && ( sum < maxEnd ) ) {<br>      maxSum = sum ;<br>      maxEnd = i ;<br>    }<br>  }<br>  return maxEnd - k + 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void center ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void center ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( Integer . toString ( ( x1 + x2 ) / 2 ) + "," ) ;<br>  System . out . print ( "," + Integer . toString ( ( y1 + y2 ) / 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNonDecreasing ( int n ) {<br>  int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) dp [ i ] [ 1 ] = 1 ;<br>  for ( int digit = 0 ;<br>  digit <= 9 ;<br>  digit ++ ) {<br>    for ( int len = 2 ;<br>    len <= n ;<br>    len ++ ) {<br>      for ( int x = 0 ;<br>      x <= digit ;<br>      x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ;<br>    }<br>  }<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) count += dp [ i ] [ n ] ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonDecreasing ( int n ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] [ 1 ] = i ;<br>  }<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) {<br>    dp [ i ] [ 1 ] = 1 ;<br>  }<br>  for ( int digit = 0 ;<br>  digit < 10 ;<br>  digit ++ ) {<br>    for ( int len = 2 ;<br>    len <= n ;<br>    len ++ ) {<br>      for ( int x = 0 ;<br>      x < digit + 1 ;<br>      x ++ ) {<br>        dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ;<br>      }<br>    }<br>  }<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) {<br>    count += dp [ i ] [ n ] ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_REVERSE_STRING_REMOVING_VOWELS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void replaceOriginal ( String s , int n ) {<br>  char r [ ] = new char [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    r [ i ] = s . charAt ( n - 1 - i ) ;<br>    if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) {<br>      System . out . print ( r [ i ] ) ;<br>    }<br>  }<br>  System . out . println ( "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void replaceOriginal ( String s , int n ) {<br>  char [ ] r = new char [ n ] ;<br>  r [ 0 ] = ' ' ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    r [ i ] = s . charAt ( n - 1 - i ) ;<br>    if ( ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) || ( s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) ) {<br>      System . out . print ( r [ i ] + " " ) ;<br>    }<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMissing ( int a [ ] , int b [ ] , int n , int m ) {<br>  HashSet < Integer > s = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) s . add ( b [ i ] ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMissing ( int [ ] a , int [ ] b , int n , int m ) {<br>  Map < Integer , Integer > s = Maps . newHashMap ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    s . put ( b [ i ] , 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] != 0 ) {<br>      System . out . print ( a [ i ] + " " ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStr ( int n , int bCount , int cCount ) {<br>  if ( bCount < 0 || cCount < 0 ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  if ( bCount == 0 && cCount == 0 ) return 1 ;<br>  int res = countStr ( n - 1 , bCount , cCount ) ;<br>  res += countStr ( n - 1 , bCount - 1 , cCount ) ;<br>  res += countStr ( n - 1 , bCount , cCount - 1 ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStr ( int n , int bCount , int cCount ) {<br>  if ( ( bCount < 0 || cCount < 0 ) && ( n == 0 ) ) return 0 ;<br>  if ( ( bCount == 0 && cCount == 0 ) || ( bCount == 0 && cCount == 0 ) ) return 1 ;<br>  int res = countStr ( n - 1 , bCount , cCount ) ;<br>  res += countStr ( n - 1 , bCount - 1 , cCount ) ;<br>  res += countStr ( n - 1 , bCount , cCount - 1 ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>GOLD_MINE_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMaxGold ( int gold [ ] [ ] , int m , int n ) {<br>  int goldTable [ ] [ ] = new int [ m ] [ n ] ;<br>  for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ;<br>  for ( int col = n - 1 ;<br>  col >= 0 ;<br>  col -- ) {<br>    for ( int row = 0 ;<br>    row < m ;<br>    row ++ ) {<br>      int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ;<br>      int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ;<br>      int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ;<br>      goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ;<br>      ;<br>    }<br>  }<br>  int res = goldTable [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMaxGold ( int [ ] [ ] gold , int m , int n ) {<br>  int [ ] [ ] goldTable = new int [ n ] [ m ] ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) {<br>    for ( int col = n - 1 ;<br>    col >= 0 ;<br>    col -- ) {<br>      for ( int row = 0 ;<br>      row < m ;<br>      row ++ ) {<br>        if ( ( col == n - 1 ) || ( col == n - 2 ) ) {<br>          int right = 0 ;<br>          if ( goldTable [ row ] [ col + 1 ] != null ) {<br>            right = goldTable [ row ] [ col + 1 ] ;<br>          }<br>          if ( ( row == 0 || col == n - 1 ) || ( row == 0 ) ) {<br>            int rightUp = 0 ;<br>            if ( goldTable [ row - 1 ] [ col + 1 ] != null ) {<br>              rightUp = goldTable [ row - 1 ] [ col + 1 ] ;<br>            }<br>            if ( ( row == m - 1 || col == n - 1 ) || ( row == m - 2 ) ) {<br>              int rightDown = 0 ;<br>              if ( goldTable [ row + 1 ] [ col + 1 ] != null ) {<br>                rightDown = goldTable [ row + 1 ] [ col + 1 ] ;<br>              }<br>              goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , rightUp , rightDown ) ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>    int res = goldTable [ 0 ] [ 0 ] ;<br>    for ( int i = 1 ;<br>    i < m ;<br>    i ++ ) {<br>      res = Math . max ( res , goldTable [ i ] [ 0 ] ) ;<br>    }<br>    return res ;<br>  }<br>  </td>
  </tr><tr>
    <th>COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countWays ( int n ) {<br>  long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ;<br>  dp [ 0 ] [ 1 ] = 1 ;<br>  dp [ 1 ] [ 1 ] = 2 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;<br>    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ;<br>  }<br>  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>  int [ ] [ ] dp = new int [ 2 ] [ n + 1 ] ;<br>  dp [ 0 ] [ 1 ] = 1 ;<br>  dp [ 1 ] [ 1 ] = 2 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;<br>    dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ;<br>  }<br>  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maxProduct ( int arr [ ] , int n ) {<br>  if ( n < 2 ) {<br>    System . out . println ( "No pairs exists" ) ;<br>    return ;<br>  }<br>  if ( n == 2 ) {<br>    System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ;<br>    return ;<br>  }<br>  int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE ;<br>  int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > posa ) {<br>      posb = posa ;<br>      posa = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > posb ) posb = arr [ i ] ;<br>    if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) {<br>      negb = nega ;<br>      nega = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) negb = arr [ i ] ;<br>  }<br>  if ( nega * negb > posa * posb ) System . out . println ( "Max product pair is {<br>" + nega + ", " + negb + "}" ) ;<br>    else System . out . println ( "Max product pair is {<br>" + posa + ", " + posb + "}" ) ;<br>    }<br>    </td>
    <td>translated code: <br><br> public static void maxProduct ( int [ ] arr , int n ) {<br>  if ( ( n < 2 ) || ( n == 2 ) ) {<br>    System . out . println ( "No pairs exists" ) ;<br>    return ;<br>  }<br>  if ( ( n == 2 ) || ( n == 3 ) ) {<br>    System . out . print ( arr [ 0 ] + " " + arr [ 1 ] ) ;<br>    return ;<br>  }<br>  int posa = 0 ;<br>  int posb = 0 ;<br>  int nega = 0 ;<br>  int negb = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > posa ) && ( arr [ i ] < posb ) ) {<br>      posb = posa ;<br>      posa = arr [ i ] ;<br>    }<br>    else if ( ( arr [ i ] > posb ) && ( arr [ i ] < posa ) ) {<br>      posb = arr [ i ] ;<br>    }<br>    if ( ( arr [ i ] < 0 ) && ( Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) ) {<br>      negb = nega ;<br>      nega = arr [ i ] ;<br>    }<br>    else if ( ( arr [ i ] < 0 ) && ( Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) ) {<br>      negb = arr [ i ] ;<br>    }<br>  }<br>  if ( ( nega * negb > posa * posb ) && ( negb * posb > posa * posb ) ) {<br>    System . out . println ( "Max product pair is {<br>" + nega + ", " + negb + "}" ) ;<br>    }<br>    else {<br>      System . out . println ( "Max product pair is {<br>" + posa + ", " + posb + "}" ) ;<br>      }<br>    }<br>    </td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int getFirstSetBitPos ( int n ) {<br>  return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getFirstSetBitPos ( int n ) {<br>  return MathUtils . log2 ( n & - n ) + 1 ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longestSubseqWithK ( String str , int k ) {<br>  int n = str . length ( ) ;<br>  int freq [ ] = new int [ MAX_CHARS ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    freq [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( freq [ str . charAt ( i ) - 'a' ] >= k ) {<br>      System . out . print ( str . charAt ( i ) ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void longestSubseqWithK ( String str , int k ) {<br>  int n = str . length ( ) ;<br>  int [ ] freq = new int [ MAX_CHARS ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) freq [ ( char ) str . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( ( freq [ ( char ) str . charAt ( i ) - 'a' ] ) >= k ) System . out . print ( str . charAt ( i ) + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) {<br>  int remainder = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ;<br>  return ( remainder == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossibleToMakeDivisible ( int [ ] arr , int n ) {<br>  int remainder = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    remainder = ( remainder + arr [ i ] ) % 3 ;<br>  }<br>  return ( remainder == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>AREA_SQUARE_CIRCUMSCRIBED_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_Area ( int r ) {<br>  return ( 2 * r * r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findArea ( int r ) {<br>  return ( 2 * r * r ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = i ;<br>  j <= m ;<br>  j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ;<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static double MaxDotProduct ( double [ ] A , double [ ] B , int m , int n ) {<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = 0 ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < m ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ n ] [ m ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistSum ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = true ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i - 1 ] ] = true ;<br>    for ( int j = 1 ;<br>    j <= sum ;<br>    j ++ ) {<br>      if ( dp [ i - 1 ] [ j ] == true ) {<br>        dp [ i ] [ j ] = true ;<br>        dp [ i ] [ j + arr [ i - 1 ] ] = true ;<br>      }<br>    }<br>  }<br>  for ( int j = 0 ;<br>  j <= sum ;<br>  j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDistSum ( int [ ] arr , int n ) {<br>  int Sum = Arrays . stream ( arr ) . mapToInt ( Integer :: intValue ) . sum ( ) ;<br>  boolean [ ] [ ] dp = new boolean [ Sum + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = true ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i - 1 ] ] = true ;<br>    for ( int j = 1 ;<br>    j <= Sum ;<br>    j ++ ) {<br>      if ( ( dp [ i - 1 ] [ j ] == true ) && ( dp [ i ] [ j + arr [ i - 1 ] ] == true ) ) {<br>        dp [ i ] [ j ] = true ;<br>        dp [ i ] [ j + arr [ i - 1 ] ] = true ;<br>      }<br>    }<br>  }<br>  for ( int j = 0 ;<br>  j < Sum + 1 ;<br>  j ++ ) {<br>    if ( ( dp [ n ] [ j ] == true ) && ( dp [ n ] [ j + arr [ i - 1 ] ] == true ) ) {<br>      System . out . print ( j + " " ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void splitString ( String str ) {<br>  StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ;<br>    else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ;<br>    else special . append ( str . charAt ( i ) ) ;<br>  }<br>  System . out . println ( alpha ) ;<br>  System . out . println ( num ) ;<br>  System . out . println ( special ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void splitString ( String str ) {<br>  String alpha = "" ;<br>  String num = "" ;<br>  String special = "" ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) num = num + str . charAt ( i ) ;<br>    else if ( ( ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) || ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) ) alpha += str . charAt ( i ) ;<br>    else special += str . charAt ( i ) ;<br>  }<br>  System . out . println ( alpha ) ;<br>  System . out . println ( num ) ;<br>  System . out . println ( special ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxAlternateSum ( int arr [ ] , int n ) {<br>  if ( n == 1 ) return arr [ 0 ] ;<br>  int dec [ ] = new int [ n ] ;<br>  int inc [ ] = new int [ n ] ;<br>  dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;<br>  int flag = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( arr [ j ] > arr [ i ] ) {<br>        dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ;<br>        flag = 1 ;<br>      }<br>      else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ;<br>    }<br>  }<br>  int result = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( result < inc [ i ] ) result = inc [ i ] ;<br>    if ( result < dec [ i ] ) result = dec [ i ] ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxAlternateSum ( int [ ] arr , int n ) {<br>  if ( ( n == 1 ) || ( n == 0 ) ) return arr [ 0 ] ;<br>  int [ ] dec = new int [ n + 1 ] ;<br>  int [ ] inc = new int [ n + 1 ] ;<br>  dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;<br>  int flag = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ j ] > arr [ i ] ) && ( arr [ j ] < arr [ i ] ) ) {<br>        dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ;<br>        flag = 1 ;<br>      }<br>      else if ( ( arr [ j ] < arr [ i ] ) && flag == 1 ) {<br>        inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ;<br>      }<br>    }<br>  }<br>  int result = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( result < inc [ i ] ) && ( result < dec [ i ] ) ) result = inc [ i ] ;<br>    if ( ( result < dec [ i ] ) && ( result < inc [ i ] ) ) result = dec [ i ] ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIR_MAXIMUM_GCD_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findMaxGCD ( int arr [ ] , int n ) {<br>  int high = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) high = Math . max ( high , arr [ i ] ) ;<br>  int divisors [ ] = new int [ high + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= Math . sqrt ( arr [ i ] ) ;<br>    j ++ ) {<br>      if ( arr [ i ] % j == 0 ) {<br>        divisors [ j ] ++ ;<br>        if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ;<br>      }<br>    }<br>  }<br>  for ( int i = high ;<br>  i >= 1 ;<br>  i -- ) if ( divisors [ i ] > 1 ) return i ;<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxGCD ( int [ ] arr , int n ) {<br>  int high = 0 ;<br>  int i = 0 ;<br>  while ( i < n ) {<br>    high = Math . max ( high , arr [ i ] ) ;<br>    i = i + 1 ;<br>  }<br>  int [ ] divisors = new int [ high + 1 ] ;<br>  divisors [ 0 ] = 0 ;<br>  i = 0 ;<br>  while ( i < n ) {<br>    int j = 1 ;<br>    while ( j <= Math . sqrt ( arr [ i ] ) ) {<br>      if ( ( arr [ i ] % j == 0 ) && ( j != arr [ i ] / j ) ) {<br>        divisors [ j ] = divisors [ j ] + 1 ;<br>        if ( ( j != arr [ i ] / j ) && ( j != arr [ i ] / j ) ) {<br>          divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] ;<br>          + 1 ;<br>        }<br>      }<br>      j = j + 1 ;<br>    }<br>    i = i + 1 ;<br>  }<br>  i = high ;<br>  while ( i >= 1 ) {<br>    if ( ( divisors [ i ] > 1 ) && ( divisors [ i ] > 0 ) ) return i ;<br>    i = i - 1 ;<br>  }<br>  return 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCoins ( int coins [ ] , int m , int V ) {<br>  int table [ ] = new int [ V + 1 ] ;<br>  table [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) table [ i ] = Integer . MAX_VALUE ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) if ( coins [ j ] <= i ) {<br>      int sub_res = table [ i - coins [ j ] ] ;<br>      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ;<br>    }<br>  }<br>  return table [ V ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCoins ( int [ ] coins , int m , int V ) {<br>  int [ ] table = new int [ V + 1 ] ;<br>  table [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) table [ i ] = Integer . MAX_VALUE ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( coins [ j ] <= i ) && ( coins [ j ] >= coins [ i ] ) ) {<br>        int subRes = table [ i - coins [ j ] ] ;<br>        if ( ( subRes != Integer . MAX_VALUE && subRes + 1 < table [ i ] ) && ( subRes + 1 < table [ i ] ) ) {<br>          table [ i ] = subRes + 1 ;<br>        }<br>      }<br>    }<br>  }<br>  return table [ V ] ;<br>}<br></td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int sum = 0 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( tree . charAt ( i ) == '(' ) level ++ ;<br>    else if ( tree . charAt ( i ) == ')' ) level -- ;<br>    else {<br>      if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int sum = 0 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( tree . charAt ( i ) == '(' ) && ( tree . charAt ( i + 1 ) == ')' ) ) level ++ ;<br>    else if ( ( tree . charAt ( i ) == ')' ) && ( tree . charAt ( i + 1 ) == '(' ) ) level -- ;<br>    else {<br>      if ( ( level == k ) && ( tree . charAt ( i + 1 ) == '(' ) ) sum += ( Character . digit ( tree . charAt ( i + 1 ) , 16 ) - '0' ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int lcs ( char [ ] X , char [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  ;<br>  else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  ;<br>  else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkSentence ( char [ ] str ) {<br>  int len = str . length ;<br>  if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ;<br>  if ( str [ len - 1 ] != '.' ) return false ;<br>  int prev_state = 0 , curr_state = 0 ;<br>  int index = 1 ;<br>  while ( index <= str . length ) {<br>    if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ;<br>    else if ( str [ index ] == ' ' ) curr_state = 1 ;<br>    else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ;<br>    else if ( str [ index ] == '.' ) curr_state = 3 ;<br>    if ( prev_state == curr_state && curr_state != 2 ) return false ;<br>    if ( prev_state == 2 && curr_state == 0 ) return false ;<br>    if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ;<br>    index ++ ;<br>    prev_state = curr_state ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkSentence ( String string ) {<br>  int length = string . length ( ) ;<br>  if ( string . charAt ( 0 ) < 'A' || string . charAt ( 0 ) > 'Z' ) return false ;<br>  if ( string . charAt ( length - 1 ) != '.' ) return false ;<br>  int prev_state = 0 ;<br>  int curr_state = 0 ;<br>  int index = 1 ;<br>  while ( ( string . charAt ( index ) ) != ' ' ) {<br>    if ( string . charAt ( index ) >= 'A' && string . charAt ( index ) <= 'Z' ) curr_state = 0 ;<br>    else if ( string . charAt ( index ) == ' ' ) curr_state = 1 ;<br>    else if ( string . charAt ( index ) >= 'a' && string . charAt ( index ) <= 'z' ) curr_state = 2 ;<br>    else if ( string . charAt ( index ) == '.' ) curr_state = 3 ;<br>    if ( prev_state == curr_state && curr_state != 2 ) return false ;<br>    if ( prev_state == 2 && curr_state == 0 ) return false ;<br>    if ( curr_state == 3 && prev_state != 1 ) return true ;<br>    index ++ ;<br>    prev_state = curr_state ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_DIVISIBILITY_LARGE_NUMBER_999</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisible999 ( String num ) {<br>  int n = num . length ( ) ;<br>  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( n % 3 == 1 ) num = "00" + num ;<br>  if ( n % 3 == 2 ) num = "0" + num ;<br>  int gSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int group = 0 ;<br>    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;<br>    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;<br>    group += num . charAt ( i ) - '0' ;<br>    gSum += group ;<br>  }<br>  if ( gSum > 1000 ) {<br>    num = Integer . toString ( gSum ) ;<br>    n = num . length ( ) ;<br>    gSum = isDivisible999 ( num ) ? 1 : 0 ;<br>  }<br>  return ( gSum == 999 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisible999 ( String num ) {<br>  int n = num . length ( ) ;<br>  ;<br>  if ( ( n == 0 || num . charAt ( 0 ) == '0' ) && ( num . charAt ( 1 ) == ' ' ) ) return true ;<br>  if ( ( ( n % 3 ) == 1 ) && ( num . charAt ( 2 ) == ' ' ) ) num = "00" + num ;<br>  if ( ( ( n % 3 ) == 2 ) && ( num . charAt ( 3 ) == ' ' ) ) num = "0" + num ;<br>  int gSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 3 ) {<br>    int group = 0 ;<br>    group += ( ( char ) num . charAt ( i ) - 48 ) * 100 ;<br>    group += ( ( char ) num . charAt ( i + 1 ) - 48 ) * 10 ;<br>    group += ( ( char ) num . charAt ( i + 2 ) - 48 ) ;<br>    gSum += group ;<br>  }<br>  if ( ( gSum > 1000 ) && ( num . charAt ( 0 ) == ' ' ) ) {<br>    num = Integer . toString ( gSum ) ;<br>    n = num . length ( ) ;<br>    gSum = isDivisible999 ( num ) ;<br>  }<br>  return ( gSum == 999 ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int digitSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;<br>  return ( digitSum % 9 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>  int n = st . length ( ) ;<br>  int digitSum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    digitSum = digitSum + ( int ) ( st . charAt ( i ) ) ;<br>  }<br>  return ( digitSum % 9 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countTrees ( int n ) {<br>  int BT [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) BT [ i ] = 0 ;<br>  BT [ 0 ] = BT [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  ++ i ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ;<br>  return BT [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countTrees ( int n ) {<br>  int [ ] BT = new int [ n + 1 ] ;<br>  BT [ 0 ] = BT [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ;<br>    }<br>  }<br>  return BT [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swapUpperToLower ( int arr [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int temp = arr [ i ] [ j ] ;<br>      arr [ i ] [ j ] = arr [ j ] [ i ] ;<br>      arr [ j ] [ i ] = temp ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void swapUpperToLower ( int [ ] [ ] arr ) {<br>  int n = 4 ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      int temp = arr [ i ] [ j ] ;<br>      ;<br>      arr [ i ] [ j ] = arr [ j ] [ i ] ;<br>      ;<br>      arr [ j ] [ i ] = temp ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      System . out . print ( arr [ i ] [ j ] + " " ) ;<br>      ;<br>    }<br>    System . out . println ( " " ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int N , int K ) {<br>  int ans = 0 ;<br>  int y = N / K ;<br>  int x = N % K ;<br>  ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int N , int K ) {<br>  double ans ;<br>  ;<br>  double y = N / K ;<br>  ;<br>  double x = N % K ;<br>  ;<br>  ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ;<br>  ;<br>  return ( int ) ans ;<br>}<br></td>
  </tr><tr>
    <th>WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int xorZero ( String s ) {<br>  int one_count = 0 , zero_count = 0 ;<br>  char [ ] str = s . toCharArray ( ) ;<br>  int n = str . length ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( str [ i ] == '1' ) one_count ++ ;<br>  else zero_count ++ ;<br>  if ( one_count % 2 == 0 ) return zero_count ;<br>  return one_count ;<br>}<br></td>
    <td>translated code: <br><br> public static int xorZero ( String str ) {<br>  int oneCount = 0 ;<br>  int zeroCount = 0 ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 1 ) {<br>    if ( ( str . charAt ( i ) == '1' ) && ( str . charAt ( i + 1 ) == '0' ) ) {<br>      oneCount ++ ;<br>    }<br>    else {<br>      zeroCount ++ ;<br>    }<br>  }<br>  if ( ( oneCount % 2 == 0 ) && ( zeroCount == 0 ) ) {<br>    return zeroCount ;<br>  }<br>  return oneCount ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int S [ ] , int m , int n ) {<br>  if ( n == 0 ) return 1 ;<br>  if ( n < 0 ) return 0 ;<br>  if ( m <= 0 && n >= 1 ) return 0 ;<br>  return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int [ ] S , int m , int n ) {<br>  if ( ( n == 0 ) && ( m > 0 ) ) return 1 ;<br>  if ( ( n < 0 ) && ( m > 0 ) ) return 0 ;<br>  ;<br>  if ( ( m <= 0 && n >= 1 ) && ( n >= 0 ) ) return 0 ;<br>  return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int [ ] arr , int n ) {<br>  int [ ] dp = new int [ n ] ;<br>  if ( n == 1 ) return arr [ 0 ] ;<br>  if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ;<br>  if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ;<br>  if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ;<br>  dp [ 0 ] = arr [ 0 ] ;<br>  dp [ 1 ] = arr [ 1 ] ;<br>  dp [ 2 ] = arr [ 2 ] ;<br>  dp [ 3 ] = arr [ 3 ] ;<br>  for ( int i = 4 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ;<br>  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSum ( int [ ] arr , int n ) {<br>  int [ ] dp = new int [ n ] ;<br>  if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) return arr [ 0 ] ;<br>  if ( ( n == 2 ) && ( arr [ 0 ] == 1 ) ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ;<br>  if ( ( n == 3 ) && ( arr [ 0 ] == 2 ) ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ;<br>  if ( ( n == 4 ) && ( arr [ 0 ] == 3 ) ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ;<br>  dp [ 0 ] = arr [ 0 ] ;<br>  dp [ 1 ] = arr [ 1 ] ;<br>  dp [ 2 ] = arr [ 2 ] ;<br>  dp [ 3 ] = arr [ 3 ] ;<br>  for ( int i = 4 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ;<br>  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxPathSum ( int tri [ ] [ ] , int m , int n ) {<br>  for ( int i = m - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ;<br>      else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;<br>    }<br>  }<br>  return tri [ 0 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxPathSum ( int [ ] [ ] tri , int m , int n ) {<br>  for ( int i = m - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < i + 1 ;<br>    j ++ ) {<br>      if ( ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) && ( tri [ i ] [ j ] < tri [ i + 1 ] [ j + 1 ] ) ) {<br>        tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ;<br>      }<br>      else {<br>        tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;<br>      }<br>    }<br>  }<br>  return tri [ 0 ] [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) {<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n2 ;<br>  j ++ ) for ( int k = 0 ;<br>  k < n3 ;<br>  k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) {<br>  for ( int i = 0 ;<br>  i <= n1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n2 ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k <= n3 ;<br>      k ++ ) {<br>        if ( ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) && ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) ) {<br>          return true ;<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>TAIL_RECURSION_FIBONACCI</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int fib ( int n , int a , int b ) {<br>  if ( n == 0 ) return a ;<br>  if ( n == 1 ) return b ;<br>  return fib ( n - 1 , b , a + b ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fib ( int n , int a , int b ) {<br>  if ( n == 0 ) return a ;<br>  if ( n == 1 ) return b ;<br>  return fib ( n - 1 , b , a + b ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isLucky ( int n ) {<br>  boolean arr [ ] = new boolean [ 10 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) arr [ i ] = false ;<br>  while ( n > 0 ) {<br>    int digit = n % 10 ;<br>    if ( arr [ digit ] ) return false ;<br>    arr [ digit ] = true ;<br>    n = n / 10 ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static int isLucky ( int n ) {<br>  int [ ] ar = new int [ 10 ] ;<br>  while ( ( n > 0 ) && ( ar [ n ] != 0 ) ) {<br>    int digit = Math . floor ( n % 10 ) ;<br>    if ( ( ar [ digit ] != 0 ) && ( ar [ digit ] != 1 ) ) {<br>      return 0 ;<br>    }<br>    ar [ digit ] = 1 ;<br>    n = n / 10 ;<br>  }<br>  return 1 ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSumTricky ( int mat [ ] [ ] , int k ) {<br>  if ( k > n ) return ;<br>  int stripSum [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    int sum = 0 ;<br>    for ( int i = 0 ;<br>    i < k ;<br>    i ++ ) sum += mat [ i ] [ j ] ;<br>    stripSum [ 0 ] [ j ] = sum ;<br>    for ( int i = 1 ;<br>    i < n - k + 1 ;<br>    i ++ ) {<br>      sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ;<br>      stripSum [ i ] [ j ] = sum ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    int sum = 0 ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) sum += stripSum [ i ] [ j ] ;<br>    System . out . print ( sum + " " ) ;<br>    for ( int j = 1 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ;<br>      System . out . print ( sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSumTricky ( int [ ] [ ] mat , int k ) {<br>  n = mat . length ;<br>  if ( k > n ) return ;<br>  stripSum = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j = 0 ;<br>    for ( int i = 0 ;<br>    i < k ;<br>    i ++ ) {<br>      Sum += mat [ i ] [ j ] ;<br>    }<br>    stripSum [ 0 ] [ j ] = Sum ;<br>    for ( int i = 1 ;<br>    i < n - k ;<br>    i ++ ) {<br>      Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ;<br>      stripSum [ i ] [ j ] = Sum ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    Sum = 0 ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      Sum += stripSum [ i ] [ j ] ;<br>    }<br>    System . out . print ( Sum + " " ) ;<br>    for ( int j = 1 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ;<br>      System . out . print ( Sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minTime ( int n , int k , int a [ ] ) {<br>  int temp ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( a [ i ] < a [ j ] ) {<br>        temp = a [ i ] ;<br>        a [ i ] = a [ j ] ;<br>        a [ j ] = temp ;<br>      }<br>    }<br>  }<br>  int minTime = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += k ) minTime += ( 2 * a [ i ] ) ;<br>  return minTime ;<br>}<br></td>
    <td>translated code: <br><br> public static int minTime ( int n , int k , int [ ] a ) {<br>  Arrays . sort ( a , 0 , n ) ;<br>  ;<br>  int minTime = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += k ) {<br>    minTime += ( 2 * a [ i ] ) ;<br>  };<br>  return minTime ;<br>}<br></td>
  </tr><tr>
    <th>ODD_EVEN_SORT_BRICK_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void oddEvenSort ( int arr [ ] , int n ) {<br>  boolean isSorted = false ;<br>  while ( ! isSorted ) {<br>    isSorted = true ;<br>    int temp = 0 ;<br>    for ( int i = 1 ;<br>    i <= n - 2 ;<br>    i = i + 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ i + 1 ] ;<br>        arr [ i + 1 ] = temp ;<br>        isSorted = false ;<br>      }<br>    }<br>    for ( int i = 0 ;<br>    i <= n - 2 ;<br>    i = i + 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ i + 1 ] ;<br>        arr [ i + 1 ] = temp ;<br>        isSorted = false ;<br>      }<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void oddEvenSort ( int [ ] arr , int n ) {<br>  int isSorted = 0 ;<br>  while ( isSorted == 0 ) {<br>    isSorted = 1 ;<br>    int temp = 0 ;<br>    for ( int i = 1 ;<br>    i < n - 1 ;<br>    i += 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        arr [ i ] = arr [ i + 1 ] ;<br>        isSorted = 0 ;<br>      }<br>    }<br>    for ( int i = 0 ;<br>    i < n - 1 ;<br>    i += 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        arr [ i ] = arr [ i + 1 ] ;<br>        isSorted = 0 ;<br>      }<br>    }<br>  }<br>  return ;<br>}<br></td>
  </tr><tr>
    <th>RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char getMaxOccuringChar ( String str ) {<br>  int count [ ] = new int [ ASCII_SIZE ] ;<br>  int len = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) count [ str . charAt ( i ) ] ++ ;<br>  int max = - 1 ;<br>  char result = ' ' ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) {<br>    if ( max < count [ str . charAt ( i ) ] ) {<br>      max = count [ str . charAt ( i ) ] ;<br>      result = str . charAt ( i ) ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static char getMaxOccuringChar ( String str ) {<br>  int [ ] count = new int [ ASCII_SIZE ] ;<br>  int max = - 1 ;<br>  char c = '\0' ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    count [ ( int ) str . charAt ( i ) ] ++ ;<br>    ;<br>  }<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( max < count [ ( int ) str . charAt ( i ) ] ) {<br>      max = count [ ( int ) str . charAt ( i ) ] ;<br>      c = str . charAt ( i ) ;<br>    }<br>  }<br>  return c ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int CountPairs ( int n ) {<br>  int k = n ;<br>  int imin = 1 ;<br>  int ans = 0 ;<br>  while ( imin <= n ) {<br>    int imax = n / k ;<br>    ans += k * ( imax - imin + 1 ) ;<br>    imin = imax + 1 ;<br>    k = n / imin ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountPairs ( int n ) {<br>  int k = n ;<br>  int imin = 1 ;<br>  int ans = 0 ;<br>  while ( ( imin <= n ) && ( k > 0 ) ) {<br>    int imax = n / k ;<br>    ans += k * ( imax - imin + 1 ) ;<br>    imin = imax + 1 ;<br>    k = n / imin ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printKDistinct ( int arr [ ] , int n , int k ) {<br>  Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ;<br>    else h . put ( arr [ i ] , 1 ) ;<br>  }<br>  if ( h . size ( ) < k ) return - 1 ;<br>  int dist_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ;<br>    if ( dist_count == k ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int printKDistinct ( int arr [ ] , int size , int KthIndex ) {<br>  HashMap < Integer , Integer > dict = new HashMap < Integer , Integer > ( ) ;<br>  ArrayList < Integer > vect = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( ( arr [ i ] < dict . size ( ) ) && ( arr [ i ] > 0 ) ) dict . put ( arr [ i ] , dict . get ( arr [ i ] ) + 1 ) ;<br>    else dict . put ( arr [ i ] , 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( ( dict . get ( arr [ i ] ) > 1 ) && ( arr [ i ] > 0 ) ) continue ;<br>    else KthIndex = KthIndex - 1 ;<br>    if ( ( KthIndex == 0 ) || ( KthIndex == 1 ) ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void generate ( int ones , int zeroes , String str , int len ) {<br>  if ( len == str . length ( ) ) {<br>    System . out . print ( str + " " ) ;<br>    return ;<br>  }<br>  generate ( ones + 1 , zeroes , str + "1" , len ) ;<br>  if ( ones > zeroes ) {<br>    generate ( ones , zeroes + 1 , str + "0" , len ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void generate ( int ones , int zeroes , String str , int len1 ) {<br>  if ( ( len1 == str . length ( ) ) && ( ones > zeroes ) ) {<br>    System . out . print ( str + " " ) ;<br>    return ;<br>  }<br>  generate ( ones + 1 , zeroes , str + "1" , len1 ) ;<br>  if ( ( ones > zeroes ) && ( zeroes > ones ) ) {<br>    generate ( ones , zeroes + 1 , str + "0" , len1 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findElement ( int arr [ ] , int n , int key ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] == key ) return i ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findElement ( int [ ] arr , int n , int key ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == key ) && ( arr [ i + 1 ] == key ) ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) {<br>  int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k <= o ;<br>      k ++ ) {<br>        if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ;<br>        else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ;<br>        else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return L [ m ] [ n ] [ o ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcsOf3 ( int [ ] X , int [ ] Y , int [ ] Z , int m , int n , int o ) {<br>  int [ ] [ ] L = new int [ o + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k < o + 1 ;<br>      k ++ ) {<br>        if ( ( i == 0 || j == 0 || k == 0 ) && ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) ) {<br>          L [ i ] [ j ] [ k ] = 0 ;<br>        }<br>        else if ( ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) && ( X [ i ] == Z [ k - 1 ] ) ) {<br>          L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ;<br>        }<br>        else {<br>          L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ;<br>        }<br>      }<br>    }<br>  }<br>  return L [ m ] [ n ] [ o ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) {<br>  int fw [ ] = new int [ n ] ;<br>  int bw [ ] = new int [ n ] ;<br>  int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;<br>  fw [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , cur_max ) ;<br>    fw [ i ] = cur_max ;<br>  }<br>  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , cur_max ) ;<br>    bw [ i ] = cur_max ;<br>  }<br>  int fans = max_so_far ;<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;<br>  return fans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumSubarrayRemovingOneEle ( int [ ] arr , int n ) {<br>  int [ ] fw = new int [ n ] ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    fw [ k ] = 0 ;<br>  }<br>  int [ ] bw = new int [ n ] ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    int curMax = arr [ 0 ] , maxSoFar = arr [ 0 ] ;<br>    for ( int i = 1 ;<br>    i < n ;<br>    i ++ ) {<br>      curMax = Math . max ( arr [ i ] , curMax + arr [ i ] ) ;<br>      maxSoFar = Math . max ( maxSoFar , curMax ) ;<br>      fw [ i ] = curMax ;<br>    }<br>    curMax = maxSoFar = bw [ n - 1 ] = arr [ n - 1 ] ;<br>    int i = n - 2 ;<br>    while ( i >= 0 ) {<br>      curMax = Math . max ( arr [ i ] , curMax + arr [ i ] ) ;<br>      maxSoFar = Math . max ( maxSoFar , curMax ) ;<br>      bw [ i ] = curMax ;<br>      i -- ;<br>    }<br>    int fans = maxSoFar ;<br>    for ( int i = 1 ;<br>    i < n - 1 ;<br>    i ++ ) {<br>      fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;<br>    }<br>    return fans ;<br>  }<br>  </td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n , int m ) {<br>  int count [ ] = new int [ n + 1 ] ;<br>  count [ 0 ] = 0 ;<br>  int i ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ;<br>    else if ( i < m ) count [ i ] = 1 ;<br>    else count [ i ] = 2 ;<br>  }<br>  return count [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n , int m ) {<br>  int [ ] count = new int [ n + 2 ] ;<br>  for ( int i = 0 ;<br>  i < n + 2 ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>  }<br>  count [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( i > m ) && ( i < m ) ) {<br>      count [ i ] = count [ i - 1 ] + count [ i - m ] ;<br>    }<br>    else if ( ( i < m ) && ( i > m ) ) {<br>      count [ i ] = 1 ;<br>    }<br>    else {<br>      count [ i ] = 2 ;<br>    }<br>  }<br>  return count [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;<br>  else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ;<br>  else return c ;<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( ( ( a < b && b < c ) || ( c < b && b < a ) ) && ( ( b < a && a < c ) || ( c < a && a < b ) ) && ( ( c < a && c < b ) || ( c < a && a < c ) ) ) return b ;<br>  ;<br>  if ( ( ( b < a && a < c ) || ( c < a && a < b ) || ( b < a && b < c ) ) && ( ( c < a && c < b ) || ( c < a && b < c ) ) && ( ( a < b && a < c ) || ( a < b && c < b ) ) && ( ( b < a && b < c ) || ( b < a && c < c ) ) && ( ( c < a && c < b ) || ( c < a && c < b ) ) && ( ( a < b && a < c ) || ( a < c && c < b ) ) && ( ( b < a && b < c ) || ( b < a && c < b ) ) && ( ( c < a && c <</td>
  </tr><tr>
    <th>LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {<br>  int table [ ] = new int [ m ] ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) table [ j ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int current = 0 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ;<br>      if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ;<br>    }<br>  }<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) if ( table [ i ] > result ) result = table [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) {<br>  int [ ] table = new int [ m ] ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) table [ j ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int current = 0 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( arr1 [ i ] == arr2 [ j ] ) && ( current + 1 > table [ j ] ) ) {<br>        table [ j ] = current + 1 ;<br>      }<br>    }<br>    if ( ( arr1 [ i ] > arr2 [ j ] ) && ( current + 1 > table [ j ] ) ) {<br>      if ( ( table [ j ] > current ) && ( current + 1 > table [ j ] ) ) {<br>        current = table [ j ] ;<br>      }<br>    }<br>  }<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( ( table [ i ] > result ) && ( current + 1 > table [ j ] ) ) {<br>      result = table [ i ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumWO3Consec ( int arr [ ] , int n ) {<br>  int sum [ ] = new int [ n ] ;<br>  if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;<br>  if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;<br>  if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ;<br>  for ( int i = 3 ;<br>  i < n ;<br>  i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ;<br>  return sum [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumWO3Consec ( int [ ] arr , int n ) {<br>  int [ ] sum = new int [ n ] ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    sum [ k ] = 0 ;<br>  }<br>  if ( n >= 1 ) {<br>    sum [ 0 ] = arr [ 0 ] ;<br>  }<br>  if ( n >= 2 ) {<br>    sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;<br>  }<br>  if ( n > 2 ) {<br>    sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ;<br>  }<br>  for ( int i = 3 ;<br>  i < n ;<br>  i ++ ) {<br>    sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ;<br>  }<br>  return sum [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>EULERIAN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int eulerian ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      if ( i > j ) {<br>        if ( j == 0 ) dp [ i ] [ j ] = 1 ;<br>        else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int eulerian ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) {<br>    dp [ y ] [ y ] = 0 ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      if ( ( i > j ) && ( j == 0 ) ) {<br>        if ( ( j == 0 ) || ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) {<br>          dp [ i ] [ j ] = 1 ;<br>        }<br>        else {<br>          dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) ;<br>        }<br>      }<br>    }<br>  }<br>  return dp [ n ] [ m ] ;<br>}<br></td>
  </tr><tr>
    <th>DOUBLE_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long doublefactorial ( long n ) {<br>  if ( n == 0 || n == 1 ) return 1 ;<br>  return n * doublefactorial ( n - 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int doublefactorial ( int n ) {<br>  if ( ( n == 0 || n == 1 ) && ( n > 2 ) ) return 1 ;<br>  ;<br>  return n * doublefactorial ( n - 2 ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int arr [ ] , int n ) {<br>  int i = - 1 , temp = 0 ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    if ( arr [ j ] < 0 ) {<br>      i ++ ;<br>      temp = arr [ i ] ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = temp ;<br>    }<br>  }<br>  int pos = i + 1 , neg = 0 ;<br>  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {<br>    temp = arr [ neg ] ;<br>    arr [ neg ] = arr [ pos ] ;<br>    arr [ pos ] = temp ;<br>    pos ++ ;<br>    neg += 2 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] arr , int n ) {<br>  int i = - 1 ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    if ( ( arr [ j ] < 0 ) && ( arr [ j ] > 0 ) ) {<br>      i ++ ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = arr [ i ] ;<br>    }<br>  }<br>  int pos = i + 1 , neg = 0 ;<br>  while ( ( pos < n && neg < pos && arr [ neg ] < 0 ) || ( neg < n && arr [ pos ] > 0 ) ) {<br>    arr [ neg ] = arr [ pos ] ;<br>    pos ++ ;<br>    neg += 2 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSum ( int arr [ ] , int n , int k ) {<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int min = + 2147483647 ;<br>    int index = - 1 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] < min ) {<br>        min = arr [ j ] ;<br>        index = j ;<br>      }<br>    }<br>    if ( min == 0 ) break ;<br>    arr [ index ] = - arr [ index ] ;<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSum ( int [ ] arr , int n , int k ) {<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int min = + 2147483647 ;<br>    int index = - 1 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ j ] < min ) && ( arr [ j ] > max ) ) {<br>        min = arr [ j ] ;<br>        index = j ;<br>      }<br>    }<br>    if ( ( min == 0 ) || ( arr [ index ] == 0 ) ) break ;<br>    arr [ index ] = - arr [ index ] ;<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ELEMENT_AFTER_PREFIX_IS_MUST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pre_compute ( int a [ ] , int n , int index , int k ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ;<br>    else dp [ 0 ] [ i ] = a [ i ] ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( a [ j ] > a [ i ] && j > i ) {<br>        if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ;<br>        else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>      }<br>      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return dp [ index ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int preCompute ( int [ ] a , int n , int index , int k ) {<br>  int [ ] [ ] dp = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > a [ 0 ] ) {<br>      dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ;<br>    }<br>    else {<br>      dp [ 0 ] [ i ] = a [ i ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( a [ j ] > a [ i ] && j > i ) {<br>        if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) {<br>          dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ;<br>        }<br>        else {<br>          dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>        }<br>      }<br>      else {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>      }<br>    }<br>  }<br>  return dp [ index ] [ k ] ;<br>}<br></td>
  </tr><tr>
    <th>FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void myCopy ( char s1 [ ] , char s2 [ ] ) {<br>  int i = 0 ;<br>  for ( i = 0 ;<br>  i < s1 . length ;<br>  i ++ ) s2 [ i ] = s1 [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void myCopy ( String s1 , String s2 ) {<br>  for ( int i = 0 ;<br>  i < s1 . length ( ) ;<br>  i ++ ) {<br>    s2 . charAt ( i ) = s1 . charAt ( i ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubSequence ( String str1 , String str2 , int m , int n ) {<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n && j < m ;<br>  i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ;<br>  return ( j == m ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubSequence ( String str1 , String str2 , int m , int n ) {<br>  int j = 0 ;<br>  int i = 0 ;<br>  while ( j < m && i < n ) {<br>    if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j = j + 1 ;<br>    i = i + 1 ;<br>  }<br>  return j == m ;<br>}<br></td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int unitnumber ( int x , int y ) {<br>  x = x % 10 ;<br>  if ( y != 0 ) y = y % 4 + 4 ;<br>  return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int unitNumber ( int x , int y ) {<br>  x = x % 10 ;<br>  if ( y != 0 ) y = y % 4 + 4 ;<br>  return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] , j = 0 ;<br>  Arrays . fill ( allocation , - 1 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( j < m ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>      j = ( j + 1 ) % m ;<br>    }<br>  }<br>  System . out . print ( "\nProcess No.\tProcess Size\tBlock no.\n" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( i + 1 + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) {<br>      System . out . print ( allocation [ i ] + 1 ) ;<br>    }<br>    else {<br>      System . out . print ( "Not Allocated" ) ;<br>    }<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void NextFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>  int [ ] allocation = new int [ n ] ;<br>  allocation [ 0 ] = - 1 ;<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( j < m ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>      j = ( j + 1 ) % m ;<br>    }<br>  }<br>  System . out . println ( "Process No.Process Size Block no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . println ( i + "          " + processSize [ i ] + "     " ) ;<br>    if ( allocation [ i ] != - 1 ) {<br>      System . out . println ( allocation [ i ] + " " ) ;<br>    }<br>    else {<br>      System . out . println ( "Not Allocated" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int nobleInteger ( int arr [ ] ) {<br>  int size = arr . length ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < size ;<br>    j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ;<br>    if ( count == arr [ i ] ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int nobleInteger ( int [ ] arr , int size ) {<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j <= size ;<br>    j ++ ) {<br>      if ( ( arr [ i ] < arr [ j ] ) && ( arr [ i ] > arr [ j ] ) ) {<br>        count ++ ;<br>      }<br>    }<br>    if ( ( count == arr [ i ] ) && ( count > 0 ) ) {<br>      return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumflip ( int mat [ ] [ ] , int n ) {<br>  int transpose [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ;<br>  int flip = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ;<br>  return flip / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minimumFlip ( int [ ] [ ] mat , int n ) {<br>  int [ ] [ ] transpose = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      transpose [ i ] [ j ] = mat [ j ] [ i ] ;<br>    }<br>  }<br>  int flip = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) {<br>        flip ++ ;<br>      }<br>    }<br>  }<br>  return ( int ) ( flip / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>SEGREGATE_EVEN_ODD_NUMBERS_SET_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void arrayEvenAndOdd ( int arr [ ] , int n ) {<br>  int i = - 1 , j = 0 ;<br>  while ( j != n ) {<br>    if ( arr [ j ] % 2 == 0 ) {<br>      i ++ ;<br>      int temp = arr [ i ] ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = temp ;<br>    }<br>    j ++ ;<br>  }<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) System . out . print ( arr [ k ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void arrayEvenAndOdd ( int [ ] arr , int n ) {<br>  int i = - 1 ;<br>  int j = 0 ;<br>  while ( ( j != n ) && ( arr [ j ] % 2 == 0 ) ) {<br>    if ( ( arr [ j ] % 2 == 0 ) && ( arr [ i ] == 0 ) ) {<br>      i = i + 1 ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = arr [ i ] ;<br>    }<br>    j = j + 1 ;<br>  }<br>  for ( i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    System . out . print ( Integer . toString ( arr [ i ] ) + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) {<br>  System . out . println ( node ) ;<br>  for ( int i = 0 ;<br>  i < list [ node ] . size ( ) ;<br>  i ++ ) {<br>    if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void dfs ( int [ ] [ ] List , int node , int arrival ) {<br>  System . out . println ( node ) ;<br>  for ( int i = 0 ;<br>  i < List [ node ] . length ;<br>  i ++ ) {<br>    if ( ( List [ node ] [ i ] != arrival ) && ( List [ node ] [ i ] != arrival ) ) {<br>      dfs ( List , List [ node ] [ i ] , node ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int turnOffK ( int n , int k ) {<br>  if ( k <= 0 ) return n ;<br>  return ( n & ~ ( 1 << ( k - 1 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int turnOffK ( int n , int k ) {<br>  if ( ( k <= 0 ) || ( k > 1 ) ) return n ;<br>  return ( n & ~ ( 1 << ( k - 1 ) ) ) ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( String s , int len ) {<br>  int MAX = 1000 ;<br>  int cur = 0 , dig = 0 ;<br>  int [ ] sum = new int [ MAX ] ;<br>  int [ ] [ ] dp = new int [ MAX ] [ 3 ] ;<br>  dp [ 0 ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= len ;<br>  i ++ ) {<br>    dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ;<br>    cur += dig ;<br>    cur %= 3 ;<br>    sum [ i ] = cur ;<br>    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ;<br>    dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ;<br>    dp [ i ] [ sum [ i ] ] ++ ;<br>  }<br>  int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ;<br>  for ( int i = 1 ;<br>  i <= len ;<br>  i ++ ) {<br>    dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ;<br>    if ( dig == 8 ) ans ++ ;<br>    if ( i - 2 >= 0 ) {<br>      dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = dprev * 10 + dig ;<br>      if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ;<br>    }<br>    if ( i - 3 >= 0 ) {<br>      dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ;<br>      dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = dprev2 * 100 + dprev * 10 + dig ;<br>      if ( value % 8 != 0 ) continue ;<br>      ans += ( i - 2 ) ;<br>      ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( String s , int Len ) {<br>  MAX = Integer . MAX_VALUE ;<br>  int cur = 0 ;<br>  int dig ;<br>  int [ ] Sum = new int [ MAX ] ;<br>  int [ ] [ ] dp = new int [ MAX ] [ 2 ] ;<br>  dp [ 0 ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= Len ;<br>  i ++ ) {<br>    dig = Integer . parseInt ( s . charAt ( i - 1 ) ) - 48 ;<br>    cur += dig ;<br>    cur %= 3 ;<br>    Sum [ i ] = cur ;<br>    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ;<br>    dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ;<br>    dp [ i ] [ Sum [ i ] ] ++ ;<br>  }<br>  int ans = 0 ;<br>  int dprev = 0 ;<br>  int value ;<br>  int dprev2 = 0 ;<br>  for ( int i = 1 ;<br>  i <= Len ;<br>  i ++ ) {<br>    dig = Integer . parseInt ( s . charAt ( i - 1 ) ) - 48 ;<br>    if ( dig == 8 ) ans ++ ;<br>    if ( i - 2 >= 0 ) {<br>      dprev = Integer . parseInt ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = dprev * 10 + dig ;<br>      if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ;<br>    }<br>    if ( i - 3 >= 0 ) {<br>      dprev2 = Integer . parseInt ( s . charAt ( i - 3 ) ) - 48 ;<br>      dprev = Integer . parseInt ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = ( dprev2 * 100 + dprev * 10 + dig ) ;<br>      if ( value % 8 != 0 ) continue ;<br>      ans += ( i - 2 ) ;<br>      ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>ADD_1_TO_A_GIVEN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int addOne ( int x ) {<br>  return ( - ( ~ x ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int addOne ( int x ) {<br>  return ( - ( ~ x ) ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isAnBn ( String s ) {<br>  int l = s . length ( ) ;<br>  if ( l % 2 == 1 ) {<br>    return false ;<br>  }<br>  int i = 0 ;<br>  int j = l - 1 ;<br>  while ( i < j ) {<br>    if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) {<br>      return false ;<br>    }<br>    i ++ ;<br>    j -- ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isAnBn ( String str ) {<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) != 'a' ) && ( str . charAt ( i ) != 'b' ) ) {<br>      break ;<br>    }<br>  }<br>  if ( ( i * 2 != n ) && ( i * 2 != n ) ) {<br>    return false ;<br>  }<br>  for ( int j = i ;<br>  j < n ;<br>  j ++ ) {<br>    if ( ( str . charAt ( j ) != 'b' ) && ( str . charAt ( j ) != 'a' ) ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFirstRepeating ( int arr [ ] ) {<br>  int min = - 1 ;<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i = arr . length - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( set . contains ( arr [ i ] ) ) min = i ;<br>    else set . add ( arr [ i ] ) ;<br>  }<br>  if ( min != - 1 ) System . out . println ( "The first repeating element is " + arr [ min ] ) ;<br>  else System . out . println ( "There are no repeating elements" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printFirstRepeating ( int [ ] arr , int n ) {<br>  int Min = - 1 ;<br>  Map < Integer , Integer > myset = Collections . emptyMap ( ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( arr [ i ] < myset . keySet ( ) . size ( ) ) {<br>      Min = i ;<br>    }<br>    else {<br>      myset . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  if ( ( Min != - 1 ) && ( arr [ Min ] > 0 ) ) {<br>    System . out . println ( "The first repeating element is" + arr [ Min ] ) ;<br>  }<br>  else {<br>    System . out . println ( "There are no repeating elements" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COST_BALANCE_PARANTHESES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int costToBalance ( String s ) {<br>  if ( s . length ( ) == 0 ) System . out . println ( 0 ) ;<br>  int ans = 0 ;<br>  int o = 0 , c = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == '(' ) o ++ ;<br>    if ( s . charAt ( i ) == ')' ) c ++ ;<br>  }<br>  if ( o != c ) return - 1 ;<br>  int [ ] a = new int [ s . length ( ) ] ;<br>  if ( s . charAt ( 0 ) == '(' ) a [ 0 ] = 1 ;<br>  else a [ 0 ] = - 1 ;<br>  if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ;<br>  for ( int i = 1 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == '(' ) a [ i ] = a [ i - 1 ] + 1 ;<br>    else a [ i ] = a [ i - 1 ] - 1 ;<br>    if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int costToBalance ( String s ) {<br>  if ( ( s . length ( ) == 0 ) || ( s . length ( ) > 1 ) ) System . out . println ( 0 ) ;<br>  int ans = 0 ;<br>  int o = 0 ;<br>  int c = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == '(' ) ) o ++ ;<br>    if ( ( s . charAt ( i ) == ')' ) ) c ++ ;<br>  }<br>  if ( ( o != c ) && ( o != 0 ) ) return - 1 ;<br>  int [ ] a = new int [ s . length ( ) ] ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == '(' ) ) a [ 0 ] = 1 ;<br>    else a [ 0 ] = - 1 ;<br>    if ( ( a [ 0 ] < 0 ) && ( a [ 0 ] > 0 ) ) ans += Math . abs ( a [ 0 ] ) ;<br>    for ( int i = 1 ;<br>    i < s . length ( ) ;<br>    i ++ ) {<br>      if ( ( s . charAt ( i ) == '(' ) ) a [ i ] = a [ i - 1 ] + 1 ;<br>      else a [ i ] = a [ i - 1 ] - 1 ;<br>      if ( ( a [ i ] < 0 ) && ( a [ i ] > 0 ) ) ans += Math . abs ( a [ i ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findWinner ( int x , int y , int n ) {<br>  boolean [ ] dp = new boolean [ n + 1 ] ;<br>  Arrays . fill ( dp , false ) ;<br>  dp [ 0 ] = false ;<br>  dp [ 1 ] = true ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ;<br>    else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ;<br>    else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ;<br>    else dp [ i ] = false ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findWinner ( int x , int y , int n ) {<br>  boolean [ ] dp = new boolean [ n + 1 ] ;<br>  dp [ 0 ] = false ;<br>  dp [ 1 ] = true ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( i - 1 >= 0 && ! dp [ i - 1 ] ) || ( i - x >= 0 && ! dp [ i - x ] ) ) {<br>      dp [ i ] = true ;<br>    }<br>    else if ( ( i - y >= 0 && ! dp [ i - y ] ) || ( i - x >= 0 && ! dp [ i - x ] ) ) {<br>      dp [ i ] = true ;<br>    }<br>    else if ( ( i - z >= 0 && ! dp [ i - z ] ) || ( i - y >= 0 && ! dp [ i - y ] ) ) {<br>      dp [ i ] = true ;<br>    }<br>    else {<br>      dp [ i ] = false ;<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getTotalNumberOfSequences ( int m , int n ) {<br>  if ( m < n ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getTotalNumberOfSequences ( int m , int n ) {<br>  if ( m < n ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  int res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void printDuplicates ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > map = new HashMap < > ( ) ;<br>  int count = 0 ;<br>  boolean dup = false ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( map . containsKey ( arr [ i ] ) ) {<br>      count = map . get ( arr [ i ] ) ;<br>      map . put ( arr [ i ] , count + 1 ) ;<br>    }<br>    else {<br>      map . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) {<br>    if ( entry . getValue ( ) > 1 ) {<br>      System . out . print ( entry . getKey ( ) + " " ) ;<br>      dup = true ;<br>    }<br>  }<br>  if ( ! dup ) {<br>    System . out . println ( "-1" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printDuplicates ( String [ ] arr ) {<br>  HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ;<br>  for ( String ele : arr ) {<br>    try {<br>      map . put ( ele , 1 ) ;<br>    }<br>    catch ( Exception e ) {<br>      map . put ( ele , 1 ) ;<br>    }<br>  }<br>  for ( String item : map . keySet ( ) ) {<br>    if ( ( map . get ( item ) > 1 ) && ( map . get ( item ) < ( arr . length - 1 ) ) ) {<br>      System . out . print ( item + " " ) ;<br>    }<br>  }<br>  System . out . println ( "\n" ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestRepeatingSubSeq ( char X [ ] , int m , int n ) {<br>  if ( dp [ m ] [ n ] != - 1 ) {<br>    return dp [ m ] [ n ] ;<br>  }<br>  if ( m == 0 || n == 0 ) {<br>    return dp [ m ] [ n ] = 0 ;<br>  }<br>  if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) {<br>    return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ;<br>  }<br>  return dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestRepeatingSubSeq ( int [ ] X , int m , int n ) {<br>  if ( ( dp [ m ] [ n ] != - 1 ) && ( dp [ m ] [ n ] != - 1 ) ) return dp [ m ] [ n ] ;<br>  if ( ( m == 0 || n == 0 ) && ( X [ m - 1 ] == X [ n - 1 ] && m != n ) ) {<br>    dp [ m ] [ n ] = 0 ;<br>    return dp [ m ] [ n ] ;<br>  }<br>  if ( ( X [ m - 1 ] == X [ n - 1 ] && m != n ) && ( X [ m ] == X [ n - 1 ] && m != n ) ) {<br>    dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ;<br>    return dp [ m ] [ n ] ;<br>  }<br>  dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ;<br>  return dp [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void findCount ( int n , int sum ) {<br>  int start = ( int ) Math . pow ( 10 , n - 1 ) ;<br>  int end = ( int ) Math . pow ( 10 , n ) - 1 ;<br>  int count = 0 ;<br>  int i = start ;<br>  while ( i < end ) {<br>    int cur = 0 ;<br>    int temp = i ;<br>    while ( temp != 0 ) {<br>      cur += temp % 10 ;<br>      temp = temp / 10 ;<br>    }<br>    if ( cur == sum ) {<br>      count ++ ;<br>      i += 9 ;<br>    }<br>    else i ++ ;<br>  }<br>  System . out . println ( count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findCount ( int n , int sum ) {<br>  int start = Math . pow ( 10 , n - 1 ) ;<br>  ;<br>  int end = Math . pow ( 10 , n ) - 1 ;<br>  int count = 0 ;<br>  int i = start ;<br>  while ( ( i <= end ) && ( i != 0 ) ) {<br>    int cur = 0 ;<br>    int temp = i ;<br>    while ( ( temp != 0 ) && ( temp != sum ) ) {<br>      cur += temp % 10 ;<br>      temp = temp / 10 ;<br>    }<br>    if ( ( cur == sum ) && ( i == 9 ) ) {<br>      count = count + 1 ;<br>      i += 9 ;<br>    }<br>    else {<br>      i = i + 1 ;<br>    }<br>  }<br>  System . out . println ( count ) ;<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimum_cost ( int a [ ] , int n ) {<br>  int mn = Integer . MAX_VALUE ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mn = Math . min ( a [ i ] , mn ) ;<br>    sum += a [ i ] ;<br>  }<br>  return mn * ( sum - mn ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long minimumCost ( long [ ] a , int n ) {<br>  long mn = Long . MAX_VALUE ;<br>  long sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mn = Math . min ( a [ i ] , mn ) ;<br>    sum += a [ i ] ;<br>  }<br>  return mn * ( sum - mn ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDivisors ( int n ) {<br>  Vector < Integer > v = new Vector < > ( ) ;<br>  for ( int i = 1 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    if ( n % i == 0 ) {<br>      if ( n / i == i ) System . out . printf ( "%d " , i ) ;<br>      else {<br>        System . out . printf ( "%d " , i ) ;<br>        v . add ( n / i ) ;<br>      }<br>    }<br>  }<br>  for ( int i = v . size ( ) - 1 ;<br>  i >= 0 ;<br>  i -- ) System . out . printf ( "%d " , v . get ( i ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDivisors ( int n ) {<br>  List < Integer > list = new ArrayList < Integer > ( ) ;<br>  for ( int i = 1 ;<br>  i <= Integer . MAX_VALUE ;<br>  i ++ ) {<br>    if ( ( n % i == 0 ) && ( n / i == i ) ) {<br>      if ( ( n / i == i ) && ( n % i == 0 ) ) {<br>        System . out . print ( i + " " ) ;<br>      }<br>      else {<br>        System . out . print ( i + " " ) ;<br>        list . add ( Integer . valueOf ( n / i ) ) ;<br>      }<br>    }<br>  }<br>  for ( int i : list . subList ( 0 , list . size ( ) - 1 ) ) {<br>    System . out . print ( i + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) {<br>  System . out . print ( " Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) ;<br>  }<br>  System . out . println ( ) ;<br>  System . out . print ( " Diagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void diagonalSquare ( int [ ] [ ] mat , int row , int column ) {<br>  System . out . print ( "Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i <= row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] ) ;<br>  }<br>  System . out . print ( "\n\nDiagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i <= row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double polygonArea ( double X [ ] , double Y [ ] , int n ) {<br>  double area = 0.0 ;<br>  int j = n - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;<br>    j = i ;<br>  }<br>  return Math . abs ( area / 2.0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double polygonArea ( double [ ] X , double [ ] Y , int n ) {<br>  double area = 0.0 ;<br>  int j = n - 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;<br>    j = i ;<br>  }<br>  return Math . abs ( area / 2.0 ) ;<br>}<br></td>
  </tr><tr>
    <th>RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) {<br>  int count = 0 ;<br>  for ( int i = left - 1 ;<br>  i < right ;<br>  ++ i ) if ( arr [ i ] == element ) ++ count ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFrequency ( int [ ] arr , int n , int left , int right , int element ) {<br>  int count = 0 ;<br>  for ( int i = left - 1 ;<br>  i < right ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == element ) && ( arr [ i + 1 ] == element ) ) {<br>      count ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>SERIES_LARGEST_GCD_SUM_EQUALS_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void print_sequence ( int n , int k ) {<br>  int b = n / ( k * ( k + 1 ) / 2 ) ;<br>  if ( b == 0 ) {<br>    System . out . println ( "-1" ) ;<br>  }<br>  else {<br>    int r = 1 ;<br>    for ( int x = 1 ;<br>    x * x <= n ;<br>    x ++ ) {<br>      if ( n % x != 0 ) continue ;<br>      if ( x <= b && x > r ) r = x ;<br>      if ( n / x <= b && n / x > r ) r = n / x ;<br>    }<br>    for ( int i = 1 ;<br>    i < k ;<br>    i ++ ) System . out . print ( r * i + " " ) ;<br>    int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;<br>    System . out . println ( res ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSequence ( int n , int k ) {<br>  int b = ( int ) ( n / ( k * ( k + 1 ) / 2 ) ) ;<br>  ;<br>  if ( b == 0 ) System . out . println ( "-1" ) ;<br>  else {<br>    int r = 1 ;<br>    ;<br>    int x = 1 ;<br>    while ( x * x <= n ) {<br>      if ( n % x != 0 ) continue ;<br>      ;<br>      else if ( x <= b && x > r ) r = x ;<br>      else if ( n / x <= b && n / x > r ) r = n / x ;<br>      x = x + 1 ;<br>    }<br>    int i = 1 ;<br>    while ( i < k ) {<br>      System . out . print ( r * i + " " ) ;<br>      i = i + 1 ;<br>    }<br>    int lastTerm = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;<br>    System . out . println ( lastTerm ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    s . add ( a1 [ i ] ) ;<br>  }<br>  ArrayList < Integer > al = new ArrayList < > ( s ) ;<br>  for ( int i = 0 ;<br>  i < n2 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n3 ;<br>    j ++ ) {<br>      if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) {<br>        return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    s . add ( a1 [ i ] ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n2 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n3 ;<br>    j ++ ) {<br>      if ( sum - a2 [ i ] - a3 [ j ] == s . size ( ) ) {<br>        return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaximum ( int arr [ ] , int low , int high ) {<br>  if ( low == high ) return arr [ low ] ;<br>  if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ;<br>  if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;<br>  else return findMaximum ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaximum ( int [ ] arr , int low , int high ) {<br>  if ( low == high ) return arr [ low ] ;<br>  if ( high == low + 1 && arr [ low ] >= arr [ high ] ) return arr [ low ] ;<br>  ;<br>  if ( high == low + 1 && arr [ low ] < arr [ high ] ) return arr [ high ] ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;<br>  else return findMaximum ( arr , mid + 1 , high ) ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int fib ( int n ) {<br>  if ( lookup [ n ] == NIL ) {<br>    if ( n <= 1 ) lookup [ n ] = n ;<br>    else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;<br>  }<br>  return lookup [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> static int fib ( int n , int [ ] lookup ) {<br>  if ( n == 0 || n == 1 ) lookup [ n ] = n ;<br>  if ( lookup [ n ] == 0 ) lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ;<br>  return lookup [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int power ( int x , int y , int p ) {<br>  int res = 1 ;<br>  x = x % p ;<br>  while ( y > 0 ) {<br>    if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;<br>    y = y >> 1 ;<br>    x = ( x * x ) % p ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int power ( int x , int y , int p ) {<br>  int res = 1 ;<br>  x = x % p ;<br>  while ( ( y > 0 ) && ( ( y & 1 ) == 1 ) ) {<br>    if ( ( ( y & 1 ) == 0 ) || ( ( y & 1 ) == 1 ) ) {<br>      res = ( res * x ) % p ;<br>    }<br>    y = y >> 1 ;<br>    x = ( x * x ) % p ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPowerOfTwo ( int x ) {<br>  return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfTwo ( int x ) {<br>  return ( x > 0 && ( ! ( x & ( x - 1 ) ) ) ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longestString ( String str1 , String str2 ) {<br>  int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ;<br>  for ( int i = 0 ;<br>  i < str1 . length ( ) ;<br>  i ++ ) {<br>    count1 [ str1 . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < str2 . length ( ) ;<br>  i ++ ) {<br>    count2 [ str2 . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  String result = "" ;<br>  for ( int i = 0 ;<br>  i < 26 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= Math . min ( count1 [ i ] , count2 [ i ] ) ;<br>    j ++ ) {<br>      result += ( char ) ( 'a' + i ) ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longestString ( String str1 , String str2 ) {<br>  int count1 [ 26 ] = {<br>    0 };<br>    int count2 [ 26 ] = {<br>      0 };<br>      for ( int i = 0 ;<br>      i < str1 . length ( ) ;<br>      i ++ ) count1 [ ( char ) str1 . charAt ( i ) - 'a' ] ++ ;<br>      for ( int i = 0 ;<br>      i < str2 . length ( ) ;<br>      i ++ ) count2 [ ( char ) str2 . charAt ( i ) - 'a' ] ++ ;<br>      String result = "" ;<br>      for ( int i = 0 ;<br>      i < 26 ;<br>      i ++ ) {<br>        for ( int j = 1 ;<br>        j <= Math . min ( count1 [ i ] , count2 [ i ] ) + 1 ;<br>        j ++ ) result = result + ( char ) ( 'a' + i ) ;<br>      }<br>      System . out . println ( result ) ;<br>    }<br>    </td>
  </tr><tr>
    <th>DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_difference ( int arr [ ] , int n , int m ) {<br>  int max = 0 , min = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 , j = n - 1 ;<br>  i < m ;<br>  i ++ , j -- ) {<br>    min += arr [ i ] ;<br>    max += arr [ j ] ;<br>  }<br>  return ( max - min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findDifference ( int [ ] arr , int n , int m ) {<br>  int max = 0 ;<br>  int min = 0 ;<br>  Arrays . sort ( arr ) ;<br>  ;<br>  int j = n - 1 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    min += arr [ i ] ;<br>    max += arr [ j ] ;<br>    j = j - 1 ;<br>  }<br>  return ( max - min ) ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static String printNumbers ( int [ ] numbers ) {<br>  ArrayList < Integer > array = new ArrayList < > ( ) ;<br>  for ( int number : numbers ) {<br>    if ( findContainsOneTwoThree ( number ) ) array . add ( number ) ;<br>  }<br>  Collections . sort ( array ) ;<br>  StringBuffer strbuf = new StringBuffer ( ) ;<br>  Iterator it = array . iterator ( ) ;<br>  while ( it . hasNext ( ) ) {<br>    int value = ( int ) it . next ( ) ;<br>    if ( strbuf . length ( ) > 0 ) strbuf . append ( ", " ) ;<br>    strbuf . append ( Integer . toString ( value ) ) ;<br>  }<br>  return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1" ;<br>}<br></td>
    <td>translated code: <br><br> public static List < String > printNumbers ( List < String > numbers ) {<br>  numbers = CollectionUtils . toCollection ( numbers ) ;<br>  List < String > result = new ArrayList < String > ( ) ;<br>  for ( String num : numbers ) {<br>    if ( ( "1" . equals ( num ) && "2" . equals ( num ) && "3" . equals ( num ) ) || ( "0" . equals ( num ) && "1" . equals ( num ) && "2" . equals ( num ) ) || ( "0" . equals ( num ) && "0" . equals ( num ) && "1" . equals ( num ) ) ) {<br>      result . add ( num ) ;<br>    }<br>  }<br>  if ( result . isEmpty ( ) ) {<br>    result . add ( "-1" ) ;<br>  }<br>  return Collections . unmodifiableList ( result ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  max_ref = 1 ;<br>  _lis ( arr , n ) ;<br>  return max_ref ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>  maximum = 0 ;<br>  int n = arr . length ;<br>  maximum = 1 ;<br>  _lis ( arr , n ) ;<br>  return maximum ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) {<br>  double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ;<br>  return Math . ceil ( d / ( 2 * r ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double minRevolutions ( double r , double x1 , double y1 , double x2 , double y2 ) {<br>  double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ;<br>  return Math . ceil ( d / ( 2 * r ) ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) {<br>  for ( int i = 0 ;<br>  i < set1 . length ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < set2 . length ;<br>    j ++ ) {<br>      if ( set1 [ i ] == set2 [ j ] ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) {<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( set1 [ i ] == set2 [ j ] ) && ( set1 [ i ] != set2 [ j ] ) ) {<br>        return false ;<br>      }<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_SUM_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinSum ( int num ) {<br>  int sum = 0 ;<br>  for ( int i = 2 ;<br>  i * i <= num ;<br>  i ++ ) {<br>    while ( num % i == 0 ) {<br>      sum += i ;<br>      num /= i ;<br>    }<br>  }<br>  sum += num ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinSum ( int num ) {<br>  int sum = 0 ;<br>  int i = 2 ;<br>  while ( ( i * i <= num ) && ( num % i == 0 ) ) {<br>    while ( ( num % i == 0 ) && ( num % i == 0 ) ) {<br>      sum += i ;<br>      num /= i ;<br>    }<br>    i ++ ;<br>  }<br>  sum += num ;<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int mostFrequent ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int max_count = 1 , res = arr [ 0 ] ;<br>  int curr_count = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ;<br>    else {<br>      if ( curr_count > max_count ) {<br>        max_count = curr_count ;<br>        res = arr [ i - 1 ] ;<br>      }<br>      curr_count = 1 ;<br>    }<br>  }<br>  if ( curr_count > max_count ) {<br>    max_count = curr_count ;<br>    res = arr [ n - 1 ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int mostFrequent ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int maxCount = 1 ;<br>  int res = arr [ 0 ] ;<br>  int currCount = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == arr [ i - 1 ] ) && ( arr [ i ] > 0 ) ) {<br>      currCount ++ ;<br>    }<br>    else {<br>      if ( ( currCount > maxCount ) && ( currCount < maxCount ) ) {<br>        maxCount = currCount ;<br>        res = arr [ i - 1 ] ;<br>      }<br>      currCount = 1 ;<br>    }<br>  }<br>  if ( ( currCount > maxCount ) && ( currCount < maxCount ) ) {<br>    maxCount = currCount ;<br>    res = arr [ n - 1 ] ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minXOR ( int arr [ ] , int n ) {<br>  Arrays . parallelSort ( arr ) ;<br>  int minXor = Integer . MAX_VALUE ;<br>  int val = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    val = arr [ i ] ^ arr [ i + 1 ] ;<br>    minXor = Math . min ( minXor , val ) ;<br>  }<br>  return minXor ;<br>}<br></td>
    <td>translated code: <br><br> public static int minXOR ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int minXor = Integer . MAX_VALUE ;<br>  int val ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    val = arr [ i ] ^ arr [ i + 1 ] ;<br>    ;<br>    minXor = Math . min ( minXor , val ) ;<br>    ;<br>  }<br>  return minXor ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_PRODUCT_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minproduct ( int a [ ] , int b [ ] , int n , int k ) {<br>  int diff = 0 , res = 0 ;<br>  int temp = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int pro = a [ i ] * b [ i ] ;<br>    res = res + pro ;<br>    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>    int d = Math . abs ( pro - temp ) ;<br>    if ( d > diff ) diff = d ;<br>  }<br>  return res - diff ;<br>}<br></td>
    <td>translated code: <br><br> public static double minproduct ( double [ ] a , double [ ] b , int n , double k ) {<br>  double diff = 0 ;<br>  double res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    double pro = a [ i ] * b [ i ] ;<br>    res = res + pro ;<br>    if ( ( pro < 0 && b [ i ] < 0 ) || ( pro > 0 && a [ i ] < 0 ) ) {<br>      double temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>      if ( ( pro < 0 && b [ i ] < 0 ) || ( pro > 0 && a [ i ] < 0 ) ) {<br>        temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>      }<br>      else if ( ( pro > 0 && a [ i ] < 0 ) || ( pro > 0 && b [ i ] > 0 ) ) {<br>        temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>      }<br>      else if ( ( pro > 0 && a [ i ] > 0 ) || ( pro < 0 && b [ i ] > 0 ) ) {<br>        temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>      }<br>      double d = Math . abs ( pro - temp ) ;<br>      if ( ( d > diff ) || ( d < 0 ) ) {<br>        diff = d ;<br>      }<br>    }<br>  }<br>  return res - diff ;<br>}<br></td>
  </tr><tr>
    <th>FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int russianPeasant ( int a , int b ) {<br>  int res = 0 ;<br>  while ( b > 0 ) {<br>    if ( ( b & 1 ) != 0 ) res = res + a ;<br>    a = a << 1 ;<br>    b = b >> 1 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int russianPeasant ( int a , int b ) {<br>  int res = 0 ;<br>  while ( ( b > 0 ) && ( b < 1 ) ) {<br>    if ( ( b & 1 ) != 0 ) {<br>      res = res + a ;<br>    }<br>    a = a << 1 ;<br>    b = b >> 1 ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>DIVISIBILITY_9_USING_BITWISE_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivBy9 ( int n ) {<br>  if ( n == 0 || n == 9 ) return true ;<br>  if ( n < 9 ) return false ;<br>  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivBy9 ( int n ) {<br>  if ( ( n == 0 || n == 9 ) && ( n % 9 == 0 ) ) return true ;<br>  if ( ( n < 9 ) && ( n % 9 == 0 ) ) return false ;<br>  return isDivBy9 ( ( int ) ( n >>> 3 ) - ( int ) ( n & 7 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isInorder ( int [ ] arr , int n ) {<br>  if ( n == 0 || n == 1 ) {<br>    return true ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i - 1 ] > arr [ i ] ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isInorder ( int [ ] arr , int n ) {<br>  if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] > arr [ 1 ] ) ) return true ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i += 1 ) {<br>    if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] > arr [ i + 1 ] ) ) return false ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      if ( ( arr1 [ i ] + arr2 [ j ] == x ) && ( arr1 [ i ] + arr2 [ j ] == x ) ) {<br>        System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>BINARY_REPRESENTATION_OF_NEXT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String nextGreater ( String num ) {<br>  int l = num . length ( ) ;<br>  int i ;<br>  for ( i = l - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( num . charAt ( i ) == '0' ) {<br>      num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ;<br>      break ;<br>    }<br>    else {<br>      num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ;<br>    }<br>  }<br>  if ( i < 0 ) {<br>    num = "1" + num ;<br>  }<br>  return num ;<br>}<br></td>
    <td>translated code: <br><br> public static String nextGreater ( String num1 ) {<br>  int l = num1 . length ( ) ;<br>  ;<br>  StringBuilder num = new StringBuilder ( num1 ) ;<br>  ;<br>  int i = l - 1 ;<br>  ;<br>  while ( ( i >= 0 ) && ( num . charAt ( i ) == '0' ) ) {<br>    if ( ( num . charAt ( i ) == '1' ) || ( num . charAt ( i ) == '2' ) ) {<br>      num . setCharAt ( i , '1' ) ;<br>      break ;<br>    }<br>    else {<br>      num . setCharAt ( i , '0' ) ;<br>    }<br>    i -- ;<br>  }<br>  num1 = num . toString ( ) ;<br>  ;<br>  if ( ( i < 0 ) && ( num1 . charAt ( i ) == '1' ) ) {<br>    num1 = "1" + num1 ;<br>  }<br>  return num1 ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findSubArray ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  int maxsize = - 1 , startindex = 0 ;<br>  int endindex = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] == 0 ) sum += - 1 ;<br>      else sum += 1 ;<br>      if ( sum == 0 && maxsize < j - i + 1 ) {<br>        maxsize = j - i + 1 ;<br>        startindex = i ;<br>      }<br>    }<br>  }<br>  endindex = startindex + maxsize - 1 ;<br>  if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ;<br>  else System . out . println ( startindex + " to " + endindex ) ;<br>  return maxsize ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubArray ( int [ ] arr , int n ) {<br>  int sum = 0 ;<br>  int maxsize = - 1 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    sum = - 1 == ( arr [ i ] == 0 ) ? 1 : 0 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      sum = sum + ( - 1 == ( arr [ j ] == 0 ) ? 1 : 0 ) + 1 ;<br>      if ( ( sum == 0 ) && ( maxsize < j - i + 1 ) ) {<br>        maxsize = j - i + 1 ;<br>        startindex = i ;<br>      }<br>    }<br>  }<br>  if ( ( maxsize == - 1 ) || ( ( ( ( int ) arr [ startindex ] ) & 0xff ) == 0 ) ) {<br>    System . out . println ( "No such subarray" ) ;<br>    ;<br>  }<br>  else {<br>    System . out . println ( startindex + " to" + startindex + maxsize - 1 ) ;<br>    ;<br>  }<br>  return maxsize ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  HashSet < Integer > Hash = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    Hash . add ( arr [ i ] ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      if ( Hash . contains ( product ) ) {<br>        result ++ ;<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  HashSet < Integer > Hash = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) Hash . add ( arr [ i ] ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      if ( product == ( Hash . size ( ) - 1 ) ) result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lps ( String seq ) {<br>  int n = seq . length ( ) ;<br>  int i , j , cl ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ i ] = 1 ;<br>  for ( cl = 2 ;<br>  cl <= n ;<br>  cl ++ ) {<br>    for ( i = 0 ;<br>    i < n - cl + 1 ;<br>    i ++ ) {<br>      j = i + cl - 1 ;<br>      if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ;<br>      else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ;<br>      else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;<br>    }<br>  }<br>  return L [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lps ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] L = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    L [ i ] [ i ] = 0 ;<br>  }<br>  for ( int cl = 2 ;<br>  cl <= n ;<br>  cl ++ ) {<br>    for ( int i = 0 ;<br>    i < n - cl + 1 ;<br>    i ++ ) {<br>      int j = i + cl - 1 ;<br>      if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) {<br>        L [ i ] [ j ] = 2 ;<br>      }<br>      else if ( str . charAt ( i ) == str . charAt ( j ) ) {<br>        L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ;<br>      }<br>      else {<br>        L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;<br>        ;<br>      }<br>    }<br>  }<br>  return L [ 0 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getInvCount ( int arr [ ] , int n ) {<br>  int invcount = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int small = 0 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;<br>    int great = 0 ;<br>    for ( int j = i - 1 ;<br>    j >= 0 ;<br>    j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;<br>    invcount += great * small ;<br>  }<br>  return invcount ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr , int n ) {<br>  int invcount = 0 ;<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int small = 0 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ i ] > arr [ j ] ) && ( arr [ j ] < arr [ i ] ) ) small ++ ;<br>    }<br>    int great = 0 ;<br>    ;<br>    for ( int j = i - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( ( arr [ i ] < arr [ j ] ) && ( arr [ j ] < arr [ i ] ) ) great ++ ;<br>    }<br>    invcount += great * small ;<br>  }<br>  return invcount ;<br>}<br></td>
  </tr><tr>
    <th>DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisibleBy10 ( String bin ) {<br>  int n = bin . length ( ) ;<br>  if ( bin . charAt ( n - 1 ) == '1' ) return false ;<br>  int sum = 0 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( bin . charAt ( i ) == '1' ) {<br>      int posFromRight = n - i - 1 ;<br>      if ( posFromRight % 4 == 1 ) sum = sum + 2 ;<br>      else if ( posFromRight % 4 == 2 ) sum = sum + 4 ;<br>      else if ( posFromRight % 4 == 3 ) sum = sum + 8 ;<br>      else if ( posFromRight % 4 == 0 ) sum = sum + 6 ;<br>    }<br>  }<br>  if ( sum % 10 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisibleBy10 ( String bin ) {<br>  int n = bin . length ( ) ;<br>  if ( ( bin . charAt ( n - 1 ) == '1' ) || ( bin . charAt ( n - 2 ) == '1' ) || ( bin . charAt ( n - 3 ) == '1' ) ) {<br>    return false ;<br>  }<br>  int sum = 0 ;<br>  int i = n - 2 ;<br>  while ( i >= 0 ) {<br>    if ( ( bin . charAt ( i ) == '1' ) || ( bin . charAt ( i ) == '2' ) ) {<br>      int posFromRight = n - i - 1 ;<br>      if ( ( posFromRight % 4 == 1 ) && ( ( posFromRight % 4 == 2 ) || ( posFromRight % 4 == 3 ) ) ) {<br>        sum = sum + 2 ;<br>      }<br>      else if ( ( posFromRight % 4 == 2 ) && ( ( posFromRight % 4 == 3 ) || ( posFromRight % 4 == 0 ) ) ) {<br>        sum = sum + 4 ;<br>      }<br>      else if ( ( posFromRight % 4 == 3 ) && ( ( posFromRight % 4 == 0 ) || ( posFromRight % 4 == 1 ) ) ) {<br>        sum = sum + 8 ;<br>      }<br>      else if ( ( posFromRight % 4 == 0 ) && ( ( posFromRight % 4 == 1 ) || ( posFromRight % 4 == 2 ) ) ) {<br>        sum = sum + 6 ;<br>      }<br>    }<br>    i = i - 1 ;<br>  }<br>  if ( ( sum % 10 == 0 ) && ( sum % 10 == 1 ) ) {<br>    return true ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 , j = 0 ;<br>  if ( m < n ) return false ;<br>  Arrays . sort ( arr1 ) ;<br>  Arrays . sort ( arr2 ) ;<br>  while ( i < n && j < m ) {<br>    if ( arr1 [ j ] < arr2 [ i ] ) j ++ ;<br>    else if ( arr1 [ j ] == arr2 [ i ] ) {<br>      j ++ ;<br>      i ++ ;<br>    }<br>    else if ( arr1 [ j ] > arr2 [ i ] ) return false ;<br>  }<br>  if ( i < n ) return false ;<br>  else return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubset ( int [ ] arr1 , int [ ] arr2 , int m , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  if ( m < n ) return 0 ;<br>  Arrays . sort ( arr1 ) ;<br>  Arrays . sort ( arr2 ) ;<br>  while ( i < n && j < m ) {<br>    if ( arr1 [ j ] < arr2 [ i ] ) j ++ ;<br>    else if ( arr1 [ j ] == arr2 [ i ] ) {<br>      j ++ ;<br>      i ++ ;<br>    }<br>    else if ( arr1 [ j ] > arr2 [ i ] ) return 0 ;<br>  }<br>  return false ? i < n : true ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubsetSum ( int set [ ] , int n , int sum ) {<br>  boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) subset [ 0 ] [ i ] = true ;<br>  for ( int i = 1 ;<br>  i <= sum ;<br>  i ++ ) subset [ i ] [ 0 ] = false ;<br>  for ( int i = 1 ;<br>  i <= sum ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ;<br>      if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ;<br>    }<br>  }<br>  return subset [ sum ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubsetSum ( int [ ] set , int n , int sum ) {<br>  boolean [ ] [ ] subset = ( new boolean [ sum + 1 ] [ n + 1 ] ) ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    subset [ i ] [ 0 ] = true ;<br>    for ( int i = 1 ;<br>    i < sum ;<br>    i ++ ) {<br>      subset [ 0 ] [ i ] = false ;<br>    }<br>    for ( int i = 1 ;<br>    i < n ;<br>    i ++ ) {<br>      for ( int j = 1 ;<br>      j < sum ;<br>      j ++ ) {<br>        if ( j < set [ i - 1 ] ) {<br>          subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ;<br>        }<br>        if ( j >= set [ i - 1 ] ) {<br>          subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ) ;<br>        }<br>      }<br>    }<br>  }<br>  return subset [ n ] [ sum ] ;<br>}<br></td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int kthgroupsum ( int k ) {<br>  return k * k * k ;<br>}<br></td>
    <td>translated code: <br><br> public static double kthGroupSum ( double k ) {<br>  return k * k * k ;<br>}<br></td>
  </tr><tr>
    <th>THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void thirdLargest ( int arr [ ] , int arr_size ) {<br>  if ( arr_size < 3 ) {<br>    System . out . printf ( " Invalid Input " ) ;<br>    return ;<br>  }<br>  int first = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;<br>  int second = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ;<br>  int third = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ;<br>  System . out . printf ( "The third Largest " + "element is %d\n" , third ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void thirdLargest ( int arr [ ] , int arrSize ) {<br>  if ( ( arrSize < 3 ) || ( arr [ 0 ] > arr [ 1 ] ) || ( arr [ 1 ] > arr [ 2 ] ) ) {<br>    System . out . println ( " Invalid Input " ) ;<br>    return ;<br>  }<br>  int first = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < arrSize ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > first ) && ( arr [ i ] < first ) ) {<br>      first = arr [ i ] ;<br>    }<br>  }<br>  int second = - Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < arrSize ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > second && arr [ i ] < first ) && ( arr [ i ] > second ) ) {<br>      second = arr [ i ] ;<br>    }<br>  }<br>  int third = - Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < arrSize ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > third && arr [ i ] < second ) && ( arr [ i ] > third ) && ( arr [ i ] > third ) ) {<br>      third = arr [ i ] ;<br>    }<br>  }<br>  System . out . println ( "The Third Largest" + "element is" + third ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumNodes ( int l ) {<br>  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>  double sumLastLevel = 0 ;<br>  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;<br>  double sum = sumLastLevel * l ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumNodes ( int l ) {<br>  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>  ;<br>  double sumLastLevel ;<br>  sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ;<br>  double sum = sumLastLevel * l ;<br>  return ( int ) sum ;<br>}<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  int x = a - b ;<br>  int y = b - c ;<br>  int z = a - c ;<br>  if ( x * y > 0 ) return b ;<br>  else if ( x * z > 0 ) return c ;<br>  else return a ;<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  int x = a - b ;<br>  int y = b - c ;<br>  int z = a - c ;<br>  if ( x * y > 0 ) {<br>    return b ;<br>  }<br>  else if ( ( x * z > 0 ) && ( y * z > 0 ) ) {<br>    return a ;<br>  }<br>  else {<br>    return a ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  int maxA = - 100000000 , maxB = - 100000000 ;<br>  int maxC = - 100000000 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > maxA ) {<br>      maxC = maxB ;<br>      maxB = maxA ;<br>      maxA = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > maxB ) {<br>      maxC = maxB ;<br>      maxB = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > maxC ) maxC = arr [ i ] ;<br>  }<br>  return ( maxA + maxB + maxC ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>  int maxA = - 100000000 ;<br>  int maxB = - 100000000 ;<br>  int maxC = - 100000000 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > maxA ) && ( arr [ i ] < maxB ) ) {<br>      maxC = maxB ;<br>      maxB = maxA ;<br>      maxA = arr [ i ] ;<br>    }<br>    else if ( ( arr [ i ] > maxB ) && ( arr [ i ] < maxC ) ) {<br>      maxC = maxB ;<br>      maxB = arr [ i ] ;<br>    }<br>    else if ( ( arr [ i ] > maxC ) && ( arr [ i ] < maxC ) ) {<br>      maxC = arr [ i ] ;<br>    }<br>  }<br>  return ( maxA + maxB + maxC ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 ;<br>  HashSet < Integer > us = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) us . add ( arr1 [ i ] ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 ;<br>  HashSet < Integer > us = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) us . add ( arr1 [ i ] ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( x - arr2 [ j ] == us . size ( ) ) count ++ ;<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinStepToReachEnd ( int arr [ ] , int N ) {<br>  boolean [ ] visit = new boolean [ N ] ;<br>  int [ ] distance = new int [ N ] ;<br>  Vector < Integer > [ ] digit = new Vector [ 10 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) digit [ i ] = new Vector < > ( ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) visit [ i ] = false ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) digit [ arr [ i ] ] . add ( i ) ;<br>  distance [ 0 ] = 0 ;<br>  visit [ 0 ] = true ;<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  q . add ( 0 ) ;<br>  while ( ! q . isEmpty ( ) ) {<br>    int idx = q . peek ( ) ;<br>    q . remove ( ) ;<br>    if ( idx == N - 1 ) break ;<br>    int d = arr [ idx ] ;<br>    for ( int i = 0 ;<br>    i < digit [ d ] . size ( ) ;<br>    i ++ ) {<br>      int nextidx = digit [ d ] . get ( i ) ;<br>      if ( ! visit [ nextidx ] ) {<br>        visit [ nextidx ] = true ;<br>        q . add ( nextidx ) ;<br>        distance [ nextidx ] = distance [ idx ] + 1 ;<br>      }<br>    }<br>    digit [ d ] . clear ( ) ;<br>    if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) {<br>      visit [ idx - 1 ] = true ;<br>      q . add ( idx - 1 ) ;<br>      distance [ idx - 1 ] = distance [ idx ] + 1 ;<br>    }<br>    if ( idx + 1 < N && ! visit [ idx + 1 ] ) {<br>      visit [ idx + 1 ] = true ;<br>      q . add ( idx + 1 ) ;<br>      distance [ idx + 1 ] = distance [ idx ] + 1 ;<br>    }<br>  }<br>  return distance [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinStepToReachEnd ( int [ ] arr , int N ) {<br>  boolean [ ] visit = new boolean [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) visit [ i ] = false ;<br>  int [ ] distance = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) digit [ arr [ i ] ] . add ( i ) ;<br>  distance [ 0 ] = 0 ;<br>  visit [ 0 ] = true ;<br>  LinkedList < Integer > q = new LinkedList < Integer > ( ) ;<br>  q . add ( 0 ) ;<br>  while ( ( q . size ( ) > 0 ) && ( visit [ 0 ] == false ) ) {<br>    int idx = q . getFirst ( ) ;<br>    q . remove ( q . getFirst ( ) ) ;<br>    if ( ( idx == N - 1 ) || ( idx == N - 2 ) ) break ;<br>    int d = arr [ idx ] ;<br>    for ( int i = 0 ;<br>    i < digit [ d ] . length ;<br>    i ++ ) {<br>      int nextidx = digit [ d ] [ i ] ;<br>      if ( ( visit [ nextidx ] == false ) && ( visit [ idx - 1 ] == false ) ) {<br>        visit [ idx - 1 ] = true ;<br>        q . add ( nextidx ) ;<br>        distance [ nextidx ] = distance [ idx ] + 1 ;<br>      }<br>    }<br>    if ( ( idx - 1 >= 0 ) && ( visit [ idx - 1 ] == false ) ) {<br>      visit [ idx - 1 ] = true ;<br>      q . add ( idx - 1 ) ;<br>      distance [ idx - 1 ] = distance [ idx ] + 1 ;<br>    }<br>    if ( ( idx + 1 < N ) && ( visit [ idx + 1 ] == false ) ) {<br>      visit [ idx + 1 ] = true ;<br>      q . add ( idx + 1 ) ;<br>      distance [ idx + 1 ] = distance [ idx ] + 1 ;<br>    }<br>  }<br>  return distance [ N - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n - 1 && k > 0 ;<br>  ++ i ) {<br>    int pos = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( j - i > k ) break ;<br>      if ( arr [ j ] < arr [ pos ] ) pos = j ;<br>    }<br>    int temp ;<br>    for ( int j = pos ;<br>    j > i ;<br>    -- j ) {<br>      temp = arr [ j ] ;<br>      arr [ j ] = arr [ j - 1 ] ;<br>      arr [ j - 1 ] = temp ;<br>    }<br>    k -= pos - i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void minimizeWithKSwaps ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int pos = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( j - i > k ) && ( arr [ j ] < arr [ pos ] ) ) {<br>        pos = j ;<br>      }<br>    }<br>    for ( int j = pos ;<br>    j > i ;<br>    j -- ) {<br>      arr [ j ] = arr [ j - 1 ] ;<br>      arr [ j - 1 ] = arr [ j ] ;<br>    }<br>    k -= pos - i ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String printSequence ( String arr [ ] , String input ) {<br>  String output = "" ;<br>  int n = input . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( input . charAt ( i ) == ' ' ) output = output + "0" ;<br>    else {<br>      int position = input . charAt ( i ) - 'A' ;<br>      output = output + arr [ position ] ;<br>    }<br>  }<br>  return output ;<br>}<br></td>
    <td>translated code: <br><br> public static String printSequence ( char [ ] arr , String input ) {<br>  int n = input . length ( ) ;<br>  String output = "" ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( input . charAt ( i ) == ' ' ) || ( input . charAt ( i ) == '\t' ) ) {<br>      output = output + "0" ;<br>    }<br>    else {<br>      int position = Character . digit ( input . charAt ( i ) , 16 ) - Character . digit ( input . charAt ( i ) , 16 ) ;<br>      output = output + arr [ position ] ;<br>    }<br>  }<br>  return output ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int arraySortedOrNot ( int arr [ ] , int n ) {<br>  if ( n == 1 || n == 0 ) return 1 ;<br>  if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ;<br>  return arraySortedOrNot ( arr , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arraySortedOrNot ( int [ ] arr ) {<br>  int n = arr . length ;<br>  if ( n == 1 || n == 0 ) return true ;<br>  return arr [ 0 ] <= arr [ 1 ] && arraySortedOrNot ( arr , 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) {<br>  int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;<br>  int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;<br>  if ( distSq == radSumSq ) return 1 ;<br>  else if ( distSq > radSumSq ) return - 1 ;<br>  else return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int circle ( float x1 , float y1 , float x2 , float y2 , float r1 , float r2 ) {<br>  float distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;<br>  ;<br>  float radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;<br>  ;<br>  if ( ( distSq == radSumSq ) && ( distSq > radSumSq ) ) return 1 ;<br>  else if ( ( distSq > radSumSq ) && ( distSq < radSumSq ) ) return - 1 ;<br>  else return 0 ;<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
  </tr><tr>
    <th>PADOVAN_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pad ( int n ) {<br>  int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    pNext = pPrevPrev + pPrev ;<br>    pPrevPrev = pPrev ;<br>    pPrev = pCurr ;<br>    pCurr = pNext ;<br>  }<br>  return pNext ;<br>}<br></td>
    <td>translated code: <br><br> public static int pad ( int n ) {<br>  int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    pNext = pPrevPrev + pPrev ;<br>    pPrevPrev = pPrev ;<br>    pPrev = pCurr ;<br>    pCurr = pNext ;<br>  };<br>  return pNext ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean check ( String s ) {<br>  if ( s . length ( ) >= 10 ) return true ;<br>  for ( int i = 1 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < s . length ( ) ;<br>      k ++ ) {<br>        String s1 = "" , s2 = "" , s3 = "" , s4 = "" ;<br>        try {<br>          s1 = s . substring ( 0 , i ) ;<br>          s2 = s . substring ( i , j - i ) ;<br>          s3 = s . substring ( j , k - j ) ;<br>          s4 = s . substring ( k , s . length ( ) - k ) ;<br>        }<br>        catch ( StringIndexOutOfBoundsException e ) {<br>        }<br>        if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String s ) {<br>  if ( ( s . length ( ) >= 10 ) && ( s . charAt ( 0 ) == 'a' ) && ( s . charAt ( 1 ) == 'b' ) && ( s . charAt ( 2 ) == 'c' ) && ( s . charAt ( 3 ) == 'd' ) ) {<br>    return true ;<br>  }<br>  for ( int i = 1 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < s . length ( ) ;<br>      k ++ ) {<br>        String s1 = s . substring ( 0 , i ) ;<br>        String s2 = s . substring ( i , j - i ) ;<br>        String s3 = s . substring ( j , k - j ) ;<br>        String s4 = s . substring ( k , s . length ( ) - k ) ;<br>        if ( ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) || ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) ) {<br>          return true ;<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) {<br>  Arrays . sort ( a , Collections . reverseOrder ( ) ) ;<br>  Arrays . sort ( b ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( int [ ] a , int [ ] b , int n , int k ) {<br>  Arrays . sort ( a , 0 , n ) ;<br>  Arrays . sort ( b , 0 , n ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( a [ i ] + b [ i ] ) < k ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int winner ( int a [ ] , int n , int k ) {<br>  if ( k >= n - 1 ) return n ;<br>  int best = 0 , times = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > best ) {<br>      best = a [ i ] ;<br>      if ( i == 1 ) times = 1 ;<br>    }<br>    else times += 1 ;<br>    if ( times >= k ) return best ;<br>  }<br>  return best ;<br>}<br></td>
    <td>translated code: <br><br> public static int winner ( int [ ] a , int n , int k ) {<br>  if ( k >= n - 1 ) return n ;<br>  int best = 0 ;<br>  int times = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > best ) {<br>      best = a [ i ] ;<br>      if ( i == true ) times = 1 ;<br>    }<br>    else times ++ ;<br>    if ( times >= k ) return best ;<br>  }<br>  return best ;<br>}<br></td>
  </tr><tr>
    <th>DIRECTION_LAST_SQUARE_BLOCK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void direction ( int R , int C ) {<br>  if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( R == C && R % 2 != 0 && C % 2 != 0 ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void direction ( int R , int C ) {<br>  if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) || ( R == C && R % 2 != 0 && C % 2 != 0 ) ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) || ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) || ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIntegralSolutions ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n - i ;<br>  j ++ ) for ( int k = 0 ;<br>  k <= ( n - i - j ) ;<br>  k ++ ) if ( i + j + k == n ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIntegralSolutions ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k < n + 1 ;<br>      k ++ ) {<br>        if ( i + j + k == n ) {<br>          result ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swapDiagonal ( int matrix [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int temp = matrix [ i ] [ i ] ;<br>    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;<br>    matrix [ i ] [ N - i - 1 ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void swapDiagonal ( int [ ] [ ] matrix ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;<br>    matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ i ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MinOperation ( int a [ ] , int n , int k ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( a [ i ] != 1 && a [ i ] > k ) {<br>      result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ;<br>    }<br>    else {<br>      result = result + k - a [ i ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int MinOperation ( int [ ] a , int n , int k ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( a [ i ] != 1 && a [ i ] > k ) || ( a [ i ] == 1 && a [ i ] == k ) ) {<br>      result = ( result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ) ;<br>    }<br>    else {<br>      result = result + k - a [ i ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) {<br>  if ( i >= N || j >= N ) {<br>    return 0 ;<br>  }<br>  int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ;<br>  if ( mat [ i ] [ j ] == 1 ) {<br>    return ( int ) ( Math . pow ( 2 , p ) + result ) ;<br>  }<br>  else {<br>    return result ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static double maxDecimalValue ( double [ ] [ ] mat , int i , int j , double p ) {<br>  if ( i >= N || j >= N ) return 0 ;<br>  double result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ;<br>  if ( mat [ i ] [ j ] == 1 ) return Math . pow ( 2 , p ) + result ;<br>  else return result ;<br>}<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long squareRoot ( int n ) {<br>  int x = n ;<br>  int y = 1 ;<br>  while ( x > y ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  }<br>  return ( long ) x ;<br>}<br></td>
    <td>translated code: <br><br> public static int squareRoot ( int n ) {<br>  int x = n ;<br>  ;<br>  int y = 1 ;<br>  ;<br>  while ( ( x > y ) && ( x < y ) ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  };<br>  return x ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KMP ( int m , int n , String str2 , String str1 ) {<br>  int pos = 0 , len = 0 ;<br>  int [ ] p = new int [ m + 1 ] ;<br>  int k = 0 ;<br>  char [ ] ch1 = str1 . toCharArray ( ) ;<br>  char [ ] ch2 = str2 . toCharArray ( ) ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ;<br>    if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ;<br>    p [ i ] = k ;<br>  }<br>  for ( int j = 0 , i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ;<br>    if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ;<br>    if ( j > len ) {<br>      len = j ;<br>      pos = i - j + 1 ;<br>    }<br>  }<br>  System . out . println ( "Shift = " + pos ) ;<br>  System . out . println ( "Prefix = " + str1 . substring ( 0 , len ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void KMP ( int m , int n , String str2 , String str1 ) {<br>  int pos = 0 ;<br>  int Len = 0 ;<br>  int [ ] p = new int [ m + 1 ] ;<br>  int k = 0 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( ( k > 0 && str1 . charAt ( k ) != str1 . charAt ( i - 1 ) ) || ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) ) {<br>      k = p [ k ] ;<br>    }<br>    if ( ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) || ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) ) {<br>      k ++ ;<br>    }<br>    p [ i ] = k ;<br>  }<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    while ( ( j > 0 && j < n && str1 . charAt ( j ) != str2 . charAt ( i ) ) || ( j < n && str1 . charAt ( j ) == str2 . charAt ( i ) ) ) {<br>      j ++ ;<br>    }<br>    if ( ( j > Len ) && ( str1 . charAt ( j ) == str2 . charAt ( i ) ) ) {<br>      j ++ ;<br>    }<br>    if ( ( j > Len ) && ( str1 . charAt ( j ) == str2 . charAt ( i ) ) ) {<br>      Len = j ;<br>      pos = i - j + 1 ;<br>    }<br>  }<br>  System . out . println ( "Shift = " + pos ) ;<br>  System . out . println ( "Prefix = " + str1 . substring ( 0 , Len ) ) ;<br>}<br></td>
  </tr><tr>
    <th>SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void printSorted ( int [ ] arr , int start , int end ) {<br>  if ( start > end ) return ;<br>  printSorted ( arr , start * 2 + 1 , end ) ;<br>  System . out . print ( arr [ start ] + " " ) ;<br>  printSorted ( arr , start * 2 + 2 , end ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSorted ( int [ ] arr , int start , int end ) {<br>  if ( start > end ) return ;<br>  printSorted ( arr , start * 2 + 1 , end ) ;<br>  System . out . print ( arr [ start ] + " " ) ;<br>  printSorted ( arr , start * 2 + 2 , end ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( int degree [ ] , int n ) {<br>  int deg_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    deg_sum += degree [ i ] ;<br>  }<br>  return ( 2 * ( n - 1 ) == deg_sum ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int [ ] degree , int n ) {<br>  int degSum = sum ( degree ) ;<br>  if ( ( 2 * ( n - 1 ) == degSum ) && ( 2 * ( n - 2 ) == degSum ) ) {<br>    return true ;<br>  }<br>  else {<br>    return false ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MOVE_ZEROES_END_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pushZerosToEnd ( int arr [ ] , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ;<br>  while ( count < n ) arr [ count ++ ] = 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void pushZerosToEnd ( int [ ] arr , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] != 0 ) {<br>      arr [ count ] = arr [ i ] ;<br>      count ++ ;<br>    }<br>  }<br>  while ( count < n ) {<br>    arr [ count ] = 0 ;<br>    count ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int answerQuery ( int a [ ] , int n , int l , int r ) {<br>  int count = 0 ;<br>  l = l - 1 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i ++ ) {<br>    int element = a [ i ] ;<br>    int divisors = 0 ;<br>    for ( int j = l ;<br>    j < r ;<br>    j ++ ) {<br>      if ( a [ j ] % a [ i ] == 0 ) divisors ++ ;<br>      else break ;<br>    }<br>    if ( divisors == ( r - l ) ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int answerQuery ( int [ ] a , int n , int l , int r ) {<br>  int count = 0 ;<br>  l = l - 1 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i += 1 ) {<br>    int element = a [ i ] ;<br>    int divisors = 0 ;<br>    for ( int j = l ;<br>    j < r ;<br>    j += 1 ) {<br>      if ( ( a [ j ] % a [ i ] == 0 ) && ( element % a [ i ] == 0 ) ) {<br>        divisors ++ ;<br>      }<br>      else {<br>        break ;<br>      }<br>    }<br>    if ( ( divisors == ( r - l ) ) && ( element % a [ i ] == 0 ) ) {<br>      count ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumOfLargePrimeFactor ( int n ) {<br>  int prime [ ] = new int [ n + 1 ] , sum = 0 ;<br>  Arrays . fill ( prime , 0 ) ;<br>  int max = n / 2 ;<br>  for ( int p = 2 ;<br>  p <= max ;<br>  p ++ ) {<br>    if ( prime [ p ] == 0 ) {<br>      for ( int i = p * 2 ;<br>      i <= n ;<br>      i += p ) prime [ i ] = p ;<br>    }<br>  }<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( prime [ p ] != 0 ) sum += prime [ p ] ;<br>    else sum += p ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumOfLargePrimeFactor ( int n ) {<br>  int [ ] prime = new int [ n + 1 ] ;<br>  prime [ 0 ] = 0 ;<br>  int sum = 0 ;<br>  int max = ( int ) ( n / 2 ) ;<br>  for ( int p = 2 ;<br>  p <= max ;<br>  p ++ ) {<br>    if ( prime [ p ] == 0 ) {<br>      for ( int i = p * 2 ;<br>      i <= n ;<br>      i += p ) {<br>        prime [ i ] = p ;<br>      }<br>    }<br>  }<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( prime [ p ] > 0 ) {<br>      sum += prime [ p ] ;<br>    }<br>    else {<br>      sum += p ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String arrangeString ( String str ) {<br>  int char_count [ ] = new int [ MAX_CHAR ] ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) char_count [ str . charAt ( i ) - 'A' ] ++ ;<br>    else sum = sum + ( str . charAt ( i ) - '0' ) ;<br>  }<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    char ch = ( char ) ( 'A' + i ) ;<br>    while ( char_count [ i ] -- != 0 ) res = res + ch ;<br>  }<br>  if ( sum > 0 ) res = res + sum ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String arrangeString ( String string ) {<br>  int [ ] charCount = new int [ MAX_CHAR ] ;<br>  int s = 0 ;<br>  for ( int i = 0 ;<br>  i < string . length ( ) ;<br>  i ++ ) {<br>    if ( string . charAt ( i ) >= 'A' && string . charAt ( i ) <= 'Z' ) {<br>      charCount [ Character . digit ( string . charAt ( i ) - 'A' , 16 ) ] ++ ;<br>    }<br>    else {<br>      s += Character . digit ( string . charAt ( i ) - '0' , 16 ) ;<br>    }<br>  }<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    char ch = ( char ) ( Character . digit ( 'A' + i , 16 ) + '0' ) ;<br>    while ( charCount [ i ] > 0 ) {<br>      res += ch ;<br>      charCount [ i ] -- ;<br>    }<br>  }<br>  if ( s > 0 ) {<br>    res += String . valueOf ( s ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  int count [ ] [ ] = new int [ m ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) count [ i ] [ 0 ] = 1 ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) count [ 0 ] [ j ] = 1 ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ;<br>  }<br>  return count [ m - 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>  int [ ] [ ] count = new int [ m ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) {<br>    count [ y ] [ 0 ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    count [ i ] [ 0 ] = 1 ;<br>  };<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    count [ 0 ] [ j ] = 1 ;<br>  };<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ;<br>    }<br>  }<br>  return count [ m - 1 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int editDistDP ( String str1 , String str2 , int m , int n ) {<br>  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int editDistDP ( String str1 , String str2 , int m , int n ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      if ( i == 0 ) {<br>        dp [ i ] [ j ] = j ;<br>      }<br>      else if ( j == 0 ) {<br>        dp [ i ] [ j ] = i ;<br>      }<br>      else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = 1 + Math . min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSol ( int coeff [ ] , int start , int end , int rhs ) {<br>  if ( rhs == 0 ) return 1 ;<br>  int result = 0 ;<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSol ( int [ ] coeff , int start , int end , int rhs ) {<br>  if ( ( rhs == 0 ) || ( rhs == 1 ) ) {<br>    return 1 ;<br>  }<br>  int result = 0 ;<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) {<br>    if ( ( coeff [ i ] <= rhs ) && ( coeff [ i ] > rhs ) ) {<br>      result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minheapify ( int [ ] a , int index ) {<br>  int small = index ;<br>  int l = 2 * index + 1 ;<br>  int r = 2 * index + 2 ;<br>  if ( l < n && a [ l ] < a [ small ] ) small = l ;<br>  if ( r < n && a [ r ] < a [ small ] ) small = r ;<br>  if ( small != index ) {<br>    int t = a [ small ] ;<br>    a [ small ] = a [ index ] ;<br>    a [ index ] = t ;<br>    minheapify ( a , small ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void minheapify ( int [ ] a , int index ) {<br>  int small = index ;<br>  int l = 2 * index + 1 ;<br>  int r = 2 * index + 2 ;<br>  if ( ( l < n && a [ l ] < a [ small ] ) || ( r < n && a [ r ] < a [ small ] ) ) small = l ;<br>  if ( ( small != index ) && ( a [ small ] < a [ index ] ) ) small = r ;<br>  if ( ( small != index ) && ( a [ index ] < a [ small ] ) ) {<br>    ( ( int [ ] ) a [ small ] ) [ 0 ] = a [ index ] ;<br>    minheapify ( a , small ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void computeLPSArray ( String pat , int M , int lps [ ] ) {<br>  int len = 0 ;<br>  int i = 1 ;<br>  lps [ 0 ] = 0 ;<br>  while ( i < M ) {<br>    if ( pat . charAt ( i ) == pat . charAt ( len ) ) {<br>      len ++ ;<br>      lps [ i ] = len ;<br>      i ++ ;<br>    }<br>    else {<br>      if ( len != 0 ) {<br>        len = lps [ len - 1 ] ;<br>      }<br>      else {<br>        lps [ i ] = len ;<br>        i ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> static void computeLPSArray ( int [ ] pat , int M , int [ ] lps ) {<br>  int len = 0 ;<br>  lps [ 0 ] = 0 ;<br>  int i = 1 ;<br>  while ( i < M ) {<br>    if ( pat [ i ] == pat [ len ] ) {<br>      len ++ ;<br>      lps [ i ] = len ;<br>      i ++ ;<br>    }<br>    else {<br>      if ( len != 0 ) len = lps [ len - 1 ] ;<br>      else {<br>        lps [ i ] = 0 ;<br>        i ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_DIFFERENCE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinDiff ( int [ ] arr , int n ) {<br>  int diff = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ;<br>  return diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinDiff ( int [ ] arr , int n ) {<br>  int diff = 10 * 20 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ) {<br>        diff = Math . abs ( arr [ i ] - arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  return diff ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void print ( int n , int k ) {<br>  int rem = 1 ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    System . out . print ( ( 10 * rem ) / n ) ;<br>    rem = ( 10 * rem ) % n ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void Print ( int n , int k ) {<br>  int rem = 1 ;<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) {<br>    System . out . print ( Math . floor ( ( ( 10 * rem ) / n ) ) + " " ) ;<br>    rem = ( 10 * rem ) % n ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void groupElements ( int arr [ ] , int n ) {<br>  boolean visited [ ] = new boolean [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    visited [ i ] = false ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! visited [ i ] ) {<br>      System . out . print ( arr [ i ] + " " ) ;<br>      for ( int j = i + 1 ;<br>      j < n ;<br>      j ++ ) {<br>        if ( arr [ i ] == arr [ j ] ) {<br>          System . out . print ( arr [ i ] + " " ) ;<br>          visited [ j ] = true ;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void groupElements ( int [ ] arr , int n ) {<br>  boolean [ ] visited = new boolean [ n ] ;<br>  visited [ 0 ] = false ;<br>  visited [ 1 ] = false ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) visited [ i ] = false ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( visited [ i ] == false ) && ( arr [ i ] == arr [ j ] ) ) {<br>      System . out . print ( arr [ i ] + " " ) ;<br>      for ( int j = i + 1 ;<br>      j < n ;<br>      j ++ ) {<br>        if ( ( arr [ i ] == arr [ j ] ) && ( arr [ j ] == arr [ i ] ) ) {<br>          System . out . print ( arr [ i ] + " " ) ;<br>          visited [ j ] = true ;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkIsAP ( int arr [ ] , int n ) {<br>  if ( n == 1 ) return true ;<br>  Arrays . sort ( arr ) ;<br>  int d = arr [ 1 ] - arr [ 0 ] ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkIsAP ( int [ ] arr , int n ) {<br>  if ( ( n == 1 ) && ( arr [ 0 ] == 0 ) ) return true ;<br>  Arrays . sort ( arr ) ;<br>  int d = arr [ 1 ] - arr [ 0 ] ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] - arr [ i - 1 ] != d ) && ( arr [ i ] - arr [ i - 2 ] != d ) ) return false ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findPosition ( int k , int n ) {<br>  long f1 = 0 , f2 = 1 , f3 ;<br>  int i = 2 ;<br>  while ( i != 0 ) {<br>    f3 = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    if ( f2 % k == 0 ) {<br>      return n * i ;<br>    }<br>    i ++ ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findPosition ( int k , int n ) {<br>  int f1 = 0 ;<br>  int f2 = 1 ;<br>  int i = 2 ;<br>  ;<br>  while ( i != 0 ) {<br>    int f3 = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    if ( f2 % k == 0 ) return n * i ;<br>    i ++ ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_DIFFERENCE_EQUAL_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairsWithDiffK ( int arr [ ] , int n , int k ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  int l = 0 ;<br>  int r = 0 ;<br>  while ( r < n ) {<br>    if ( arr [ r ] - arr [ l ] == k ) {<br>      count ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( arr [ r ] - arr [ l ] > k ) l ++ ;<br>    else r ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairsWithDiffK ( int [ ] arr , int n , int k ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  int l = 0 ;<br>  int r = 0 ;<br>  while ( r < n ) {<br>    if ( arr [ r ] - arr [ l ] == k ) {<br>      count ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( arr [ r ] - arr [ l ] > k ) {<br>      l ++ ;<br>    }<br>    else {<br>      r ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNum ( int [ ] arr , int n ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNum ( int [ ] arr , int n ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) || ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) ) {<br>      count += arr [ i + 1 ] - arr [ i ] - 1 ;<br>      ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String maximumPalinUsingKChanges ( String str , int k ) {<br>  char palin [ ] = str . toCharArray ( ) ;<br>  String ans = "" ;<br>  int l = 0 ;<br>  int r = str . length ( ) - 1 ;<br>  while ( l < r ) {<br>    if ( str . charAt ( l ) != str . charAt ( r ) ) {<br>      palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ;<br>      k -- ;<br>    }<br>    l ++ ;<br>    r -- ;<br>  }<br>  if ( k < 0 ) {<br>    return "Not possible" ;<br>  }<br>  l = 0 ;<br>  r = str . length ( ) - 1 ;<br>  while ( l <= r ) {<br>    if ( l == r ) {<br>      if ( k > 0 ) {<br>        palin [ l ] = '9' ;<br>      }<br>    }<br>    if ( palin [ l ] < '9' ) {<br>      if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) {<br>        k -= 2 ;<br>        palin [ l ] = palin [ r ] = '9' ;<br>      }<br>      else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) {<br>        k -- ;<br>        palin [ l ] = palin [ r ] = '9' ;<br>      }<br>    }<br>    l ++ ;<br>    r -- ;<br>  }<br>  for ( int i = 0 ;<br>  i < palin . length ;<br>  i ++ ) ans += palin [ i ] ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static String maximumPalinUsingKChanges ( String strr , int k ) {<br>  String palin = strr ;<br>  int l = 0 ;<br>  int r = strr . length ( ) - 1 ;<br>  while ( ( l <= r ) && ( palin . charAt ( l ) != '-' ) ) {<br>    if ( ( strr . charAt ( l ) != '-' ) && ( palin . charAt ( l ) != '+' ) ) {<br>      palin . charAt ( l ) = palin . charAt ( r ) = Math . max ( strr . charAt ( l ) , strr . charAt ( r ) ) ;<br>      k -- ;<br>    }<br>    l ++ ;<br>    r -- ;<br>  }<br>  if ( ( k < 0 ) || ( k > 0 ) ) return "Not possible" ;<br>  l = 0 ;<br>  r = strr . length ( ) - 1 ;<br>  while ( ( l <= r ) && ( palin . charAt ( l ) != '-' ) && ( palin . charAt ( l ) != '+' ) ) {<br>    if ( ( l == r ) || ( k > 0 ) ) palin . charAt ( l ) = '9' ;<br>    if ( ( palin . charAt ( l ) < '9' ) || ( k >= 2 && palin . charAt ( l ) == strr . charAt ( l ) && palin . charAt ( r ) == strr . charAt ( r ) ) ) {<br>      k -- ;<br>      palin . charAt ( l ) = palin . charAt ( r ) = '9' ;<br>    }<br>    else if ( ( k >= 1 && ( palin . charAt ( l ) != strr . charAt ( l ) || palin . charAt ( r ) != '-' ) ) || ( k == 1 && ( palin . charAt ( l ) != strr . charAt ( l ) || palin . charAt ( r ) != '+' ) ) ) ) {<br>      k -- ;<br>      palin . charAt ( l ) = palin . charAt ( r ) = '9' ;<br>    }<br>  }<br>  l ++ ;<br>  r -- ;<br>}<br>return palin ;<br>}<br></td>
  </tr><tr>
    <th>SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void subArray ( int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      for ( int k = i ;<br>      k <= j ;<br>      k ++ ) System . out . print ( arr [ k ] + " " ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void subArray ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j <= n ;<br>    j ++ ) {<br>      for ( int k = i ;<br>      k <= j ;<br>      k ++ ) {<br>        System . out . print ( arr [ k ] + " " ) ;<br>      }<br>      System . out . print ( "\n" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSum ( int a [ ] [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sort ( a , i , n ) ;<br>  int sum = a [ n - 1 ] [ M - 1 ] ;<br>  int prev = a [ n - 1 ] [ M - 1 ] ;<br>  int i , j ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( a [ i ] [ j ] < prev ) {<br>        prev = a [ i ] [ j ] ;<br>        sum += prev ;<br>        break ;<br>      }<br>    }<br>    if ( j == - 1 ) return 0 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSum ( int [ ] [ ] a , int n ) {<br>  M ++ ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) a [ i ] . sort ( ) ;<br>  ;<br>  int sum = a [ n - 1 ] [ M - 1 ] ;<br>  ;<br>  int prev = a [ n - 1 ] [ M - 1 ] ;<br>  ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( ( a [ i ] [ j ] < prev ) && ( a [ i ] [ j ] > sum ) ) {<br>        prev = a [ i ] [ j ] ;<br>        sum += prev ;<br>        break ;<br>      }<br>    }<br>    if ( ( j == - 1 ) || ( j == M - 1 ) ) return 0 ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int factorial ( int n ) {<br>  if ( n == 0 ) return 1 ;<br>  return n * factorial ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int factorial ( int n ) {<br>  return 1 == ( n == 1 || n == 0 ) ? n * factorial ( n - 1 ) : n ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSquares ( int n ) {<br>  int square = 0 , prev_x = 0 ;<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) {<br>    square = ( square + x + prev_x ) ;<br>    System . out . print ( square + " " ) ;<br>    prev_x = x ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSquares ( int n ) {<br>  int square = 0 ;<br>  int prevX = 0 ;<br>  ;<br>  for ( int x = 0 ;<br>  x <= n ;<br>  x ++ ) {<br>    square = ( square + x + prevX ) ;<br>    System . out . print ( square + " " ) ;<br>    prevX = x ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    c [ i ] = a [ i ] ;<br>  }<br>  for ( int j = 0 ;<br>  j < n2 ;<br>  j ++ ) {<br>    c [ i ++ ] = b [ j ] ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void concatenate ( double [ ] a , double [ ] b , double [ ] c , int n1 , int n2 ) {<br>  int i = - 1 ;<br>  for ( i = 0 ;<br>  i < n1 ;<br>  i ++ ) c [ i ] = a [ i ] ;<br>  for ( int j = 0 ;<br>  j < n2 ;<br>  j ++ ) {<br>    c [ i ] = b [ j ] ;<br>    i ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) {<br>  int diff = Integer . MAX_VALUE ;<br>  int res_l = 0 , res_r = 0 ;<br>  int l = 0 , r = n - 1 ;<br>  while ( l < m && r >= 0 ) {<br>    if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {<br>      res_l = l ;<br>      res_r = r ;<br>      diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;<br>    }<br>    if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;<br>    else l ++ ;<br>  }<br>  System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) {<br>  int diff = Integer . MAX_VALUE ;<br>  int l = 0 ;<br>  int r = n - 1 ;<br>  while ( ( l < m && r >= 0 ) || ( l < m && r < n ) ) {<br>    if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {<br>      int resL = l ;<br>      int resR = r ;<br>      diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;<br>    }<br>    if ( ar1 [ l ] + ar2 [ r ] > x ) {<br>      r = r - 1 ;<br>    }<br>    else {<br>      l = l + 1 ;<br>    }<br>  }<br>  System . out . println ( "The closest pair is [" + ar1 [ resL ] + "," + ar2 [ resR ] + "]" ) ;<br>}<br></td>
  </tr><tr>
    <th>CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minRemove ( int arr [ ] , int n ) {<br>  int LIS [ ] = new int [ n ] ;<br>  int len = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) LIS [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ;<br>    }<br>    len = Math . max ( len , LIS [ i ] ) ;<br>  }<br>  return n - len ;<br>}<br></td>
    <td>translated code: <br><br> public static int minRemove ( int [ ] arr , int n ) {<br>  int [ ] LIS = new int [ n ] ;<br>  int len = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) LIS [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) || ( arr [ i ] > arr [ j ] && ( arr [ i ] - arr [ j ] ) <= ( arr [ j ] - arr [ i ] ) ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ;<br>    }<br>    len = Math . max ( len , LIS [ i ] ) ;<br>  }<br>  return ( n - len ) ;<br>}<br></td>
  </tr><tr>
    <th>TAIL_RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int fact ( int n ) {<br>  if ( n == 0 ) return 1 ;<br>  return n * fact ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long fact ( long n ) {<br>  if ( ( n == 0 ) || ( n == 1 ) ) return 1 ;<br>  return n * fact ( n - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>RECURSIVE_FUNCTIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) {<br>  if ( 0 == n ) return ;<br>  tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ;<br>  System . out . printf ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) ;<br>  tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) {<br>  if ( ( 0 == n ) && ( sourcePole > 0 ) && ( auxiliaryPole > 0 ) ) {<br>    tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ;<br>    System . out . println ( "Move the disk" + sourcePole + " from" + sourcePole + " to" + destinationPole ) ;<br>    tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_X_Y_SATISFYING_AX_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solution ( int a , int b , int n ) {<br>  for ( int i = 0 ;<br>  i * a <= n ;<br>  i ++ ) {<br>    if ( ( n - ( i * a ) ) % b == 0 ) {<br>      System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ;<br>      return ;<br>    }<br>  }<br>  System . out . println ( "No solution" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int solution ( int a , int b , int n ) {<br>  int i = 0 ;<br>  while ( i * a <= n ) {<br>    if ( ( n - ( i * a ) ) % b == 0 ) {<br>      System . out . println ( "x = " + i + ", y = " + ( int ) ( ( n - ( i * a ) ) / b ) ) ;<br>      return 0 ;<br>    }<br>    i = i + 1 ;<br>  }<br>  System . out . println ( "No solution" ) ;<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long exponentiation ( long base , long exp ) {<br>  long t = 1L ;<br>  while ( exp > 0 ) {<br>    if ( exp % 2 != 0 ) t = ( t * base ) % N ;<br>    base = ( base * base ) % N ;<br>    exp /= 2 ;<br>  }<br>  return t % N ;<br>}<br></td>
    <td>translated code: <br><br> public static int exponentiation ( int bas , int exp ) {<br>  int t = 1 ;<br>  ;<br>  while ( ( exp > 0 ) && ( exp % 2 != 0 ) ) {<br>    if ( ( exp % 2 != 0 ) ) t = ( t * bas ) % N ;<br>    ;<br>    bas = ( bas * bas ) % N ;<br>    exp = ( int ) ( exp / 2 ) ;<br>  }<br>  return t % N ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkIfAllTogether ( String s , char c ) {<br>  boolean oneSeen = false ;<br>  int i = 0 , n = s . length ( ) ;<br>  while ( i < n ) {<br>    if ( s . charAt ( i ) == c ) {<br>      if ( oneSeen == true ) return false ;<br>      while ( i < n && s . charAt ( i ) == c ) i ++ ;<br>      oneSeen = true ;<br>    }<br>    else i ++ ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkIfAllTogether ( String s , char c ) {<br>  boolean oneSeen = false ;<br>  int i = 0 ;<br>  int n = s . length ( ) ;<br>  while ( ( i < n ) && ( s . charAt ( i ) == c ) ) {<br>    if ( ( i < n ) && ( s . charAt ( i ) == c ) ) {<br>      if ( ( oneSeen == true ) && ( s . charAt ( i ) == c ) ) {<br>        return false ;<br>      }<br>      while ( ( i < n ) && ( s . charAt ( i ) == c ) ) {<br>        i = i + 1 ;<br>      }<br>      oneSeen = true ;<br>    }<br>    else {<br>      i = i + 1 ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findArea ( Integer arr [ ] , int n ) {<br>  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;<br>  int [ ] dimension = {<br>    0 , 0 };<br>    for ( int i = 0 , j = 0 ;<br>    i < n - 1 && j < 2 ;<br>    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;<br>    return ( dimension [ 0 ] * dimension [ 1 ] ) ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int findArea ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr , 0 , n ) ;<br>  int [ ] dimension = {<br>    0 , 0 };<br>    int i = 0 ;<br>    int j = 0 ;<br>    while ( ( i < n - 1 && j < 2 ) || ( i < n - 1 && j < 2 ) ) {<br>      if ( ( arr [ i ] == arr [ i + 1 ] ) && ( arr [ j ] == arr [ i ] ) ) {<br>        dimension [ j ] = arr [ i ] ;<br>        j ++ ;<br>        i ++ ;<br>      }<br>      i ++ ;<br>    }<br>    return ( dimension [ 0 ] * dimension [ 1 ] ) ;<br>  }<br>  </td>
  </tr><tr>
    <th>PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int Circumference ( int a ) {<br>  return 4 * a ;<br>}<br></td>
    <td>translated code: <br><br> public static Circumference a ( int a ) {<br>  return ( 4 * a ) ;<br>}<br></td>
  </tr><tr>
    <th>CYCLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void cycleSort ( int arr [ ] , int n ) {<br>  int writes = 0 ;<br>  for ( int cycle_start = 0 ;<br>  cycle_start <= n - 2 ;<br>  cycle_start ++ ) {<br>    int item = arr [ cycle_start ] ;<br>    int pos = cycle_start ;<br>    for ( int i = cycle_start + 1 ;<br>    i < n ;<br>    i ++ ) if ( arr [ i ] < item ) pos ++ ;<br>    if ( pos == cycle_start ) continue ;<br>    while ( item == arr [ pos ] ) pos += 1 ;<br>    if ( pos != cycle_start ) {<br>      int temp = item ;<br>      item = arr [ pos ] ;<br>      arr [ pos ] = temp ;<br>      writes ++ ;<br>    }<br>    while ( pos != cycle_start ) {<br>      pos = cycle_start ;<br>      for ( int i = cycle_start + 1 ;<br>      i < n ;<br>      i ++ ) if ( arr [ i ] < item ) pos += 1 ;<br>      while ( item == arr [ pos ] ) pos += 1 ;<br>      if ( item != arr [ pos ] ) {<br>        int temp = item ;<br>        item = arr [ pos ] ;<br>        arr [ pos ] = temp ;<br>        writes ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int cycleSort ( int [ ] array ) {<br>  int writes = 0 ;<br>  for ( int cycleStart = 0 ;<br>  cycleStart <= array . length - 1 ;<br>  cycleStart ++ ) {<br>    int item = array [ cycleStart ] ;<br>    int pos = cycleStart ;<br>    for ( int i = cycleStart + 1 ;<br>    i < array . length ;<br>    i ++ ) {<br>      if ( array [ i ] < item ) {<br>        pos ++ ;<br>      }<br>    }<br>    if ( pos == cycleStart ) {<br>      continue ;<br>    }<br>    while ( item == array [ pos ] ) {<br>      pos ++ ;<br>    }<br>    array [ pos ] = item ;<br>    writes ++ ;<br>    while ( pos != cycleStart ) {<br>      pos = cycleStart ;<br>      for ( int i = cycleStart + 1 ;<br>      i < array . length ;<br>      i ++ ) {<br>        if ( array [ i ] < item ) {<br>          pos ++ ;<br>        }<br>      }<br>      while ( item == array [ pos ] ) {<br>        pos ++ ;<br>      }<br>      array [ pos ] = item ;<br>      writes ++ ;<br>    }<br>  }<br>  return writes ;<br>}<br></td>
  </tr><tr>
    <th>SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int selectRandom ( int x ) {<br>  count ++ ;<br>  if ( count == 1 ) res = x ;<br>  else {<br>    Random r = new Random ( ) ;<br>    int i = r . nextInt ( count ) ;<br>    if ( i == count - 1 ) res = x ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int selectRandom ( int x ) {<br>  int res = 0 ;<br>  ;<br>  int count = 0 ;<br>  ;<br>  count ++ ;<br>  if ( ( count == 1 ) && ( x == 0 ) ) {<br>    res = x ;<br>  }<br>  else {<br>    int i = random . nextInt ( count ) ;<br>    if ( ( i == count - 1 ) && ( x == 0 ) ) {<br>      res = x ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>HOSOYAS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printHosoya ( int n ) {<br>  int dp [ ] [ ] = new int [ N ] [ N ] ;<br>  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ;<br>  dp [ 1 ] [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ;<br>      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) System . out . print ( dp [ i ] [ j ] + "" ) ;<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printHosoya ( int n ) {<br>  int [ ] [ ] dp = new int [ N ] [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = dp [ i + 1 ] [ i ] = dp [ i + 2 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( i > j ) && ( i < n ) ) {<br>        dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i + 1 ;<br>    j ++ ) {<br>      System . out . print ( dp [ i ] [ j ] + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lastPosition ( int n , int m , int k ) {<br>  if ( m <= n - k + 1 ) return m + k - 1 ;<br>  m = m - ( n - k + 1 ) ;<br>  return ( m % n == 0 ) ? n : ( m % n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lastPosition ( int n , int m , int k ) {<br>  if ( ( m <= n - k + 1 ) && ( m > n - k ) ) return m + k - 1 ;<br>  m = m - ( n - k + 1 ) ;<br>  if ( ( m % n == 0 ) && ( m > n - k ) ) return n ;<br>  else return m % n ;<br>}<br></td>
  </tr><tr>
    <th>PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void longestSubsequence ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;<br>  int [ ] dp = new int [ n ] ;<br>  int maximum = Integer . MIN_VALUE ;<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mp . get ( a [ i ] - 1 ) != null ) {<br>      int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ;<br>      dp [ i ] = 1 + dp [ lastIndex ] ;<br>    }<br>    else dp [ i ] = 1 ;<br>    mp . put ( a [ i ] , i + 1 ) ;<br>    if ( maximum < dp [ i ] ) {<br>      maximum = dp [ i ] ;<br>      index = i ;<br>    }<br>  }<br>  for ( int curr = a [ index ] - maximum + 1 ;<br>  curr <= a [ index ] ;<br>  curr ++ ) System . out . print ( curr + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longestSubsequence ( int [ ] a , int n ) {<br>  int mp [ ] = new int [ 13 ] ;<br>  for ( int i = 0 ;<br>  i < 13 ;<br>  i ++ ) {<br>    mp [ i ] = 0 ;<br>  }<br>  int dp [ ] = new int [ n ] ;<br>  int maximum = - Integer . MAX_VALUE - 1 ;<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( ( a [ i ] - 1 ) < mp [ i ] ) && ( mp [ i ] > 0 ) ) {<br>      int lastIndex = mp [ a [ i ] - 1 ] - 1 ;<br>      dp [ i ] = 1 + dp [ lastIndex ] ;<br>    }<br>    else {<br>      dp [ i ] = 1 ;<br>    }<br>    mp [ a [ i ] ] = i + 1 ;<br>    if ( ( maximum < dp [ i ] ) && ( mp [ i ] > 0 ) ) {<br>      maximum = dp [ i ] ;<br>      index = i ;<br>    }<br>  }<br>  for ( int curr = a [ index ] - maximum + 1 ;<br>  curr < a [ index ] + 1 ;<br>  curr += 1 ) {<br>    System . out . print ( curr + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countTriangle ( int graph [ ] [ ] , boolean isDirected ) {<br>  int count_Triangle = 0 ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < V ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k < V ;<br>      k ++ ) {<br>        if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_Triangle ++ ;<br>      }<br>    }<br>  }<br>  if ( isDirected == true ) {<br>    count_Triangle /= 3 ;<br>  }<br>  else {<br>    count_Triangle /= 6 ;<br>  }<br>  return count_Triangle ;<br>}<br></td>
    <td>translated code: <br><br> public static int countTriangle ( int [ ] [ ] g , boolean isDirected ) {<br>  int nodes = g . length ;<br>  int count_Triangle = 0 ;<br>  for ( int i = 0 ;<br>  i < nodes ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < nodes ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k < nodes ;<br>      k ++ ) {<br>        if ( ( i != j && i != k && j != k && g [ i ] [ j ] != null && g [ j ] [ k ] != null && g [ k ] [ i ] != null ) ) {<br>          count_Triangle ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return count_Triangle / 3 == 0 ? count_Triangle / 6 : count_Triangle / 3 ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) {<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( set . contains ( arr [ i ] ) ) return true ;<br>    set . add ( arr [ i ] ) ;<br>    if ( i >= k ) set . remove ( arr [ i - k ] ) ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkDuplicatesWithinK ( int [ ] arr , int n , int k ) {<br>  ArrayList < Integer > myset = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == myset . get ( i ) ) return true ;<br>    myset . add ( arr [ i ] ) ;<br>    if ( ( i >= k ) && ( i < n ) ) myset . remove ( arr [ i - k ] ) ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_SORT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInsertionStepToSortArray ( int arr [ ] , int N ) {<br>  int [ ] lis = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  int max = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;<br>  return ( N - max ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInsertionStepToSortArray ( int [ ] arr , int N ) {<br>  int [ ] lis = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) || ( arr [ i ] < arr [ j ] && lis [ i ] > lis [ j ] + 1 ) ) lis [ i ] = lis [ j ] + 1 ;<br>  int max = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) if ( ( max < lis [ i ] ) && ( max > lis [ i ] ) ) max = lis [ i ] ;<br>  return ( N - max ) ;<br>}<br></td>
  </tr><tr>
    <th>GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDuo ( String str ) {<br>  int countChar [ ] = new int [ MAX_CHAR ] ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    countChar [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  String str1 = "" , str2 = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( countChar [ i ] > 1 ) {<br>      str2 = str2 + ( char ) ( i + 'a' ) ;<br>    }<br>    else if ( countChar [ i ] == 1 ) {<br>      str1 = str1 + ( char ) ( i + 'a' ) ;<br>    }<br>  }<br>  System . out . print ( "String with characters occurring " + "once:\n" ) ;<br>  System . out . print ( str1 + "\n" ) ;<br>  System . out . print ( "String with characters occurring " + "multiple times:\n" ) ;<br>  System . out . print ( str2 + "\n" ) ;<br>  System . out . print ( "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDuo ( String string ) {<br>  int [ ] countChar = new int [ MAX_CHAR ] ;<br>  int n = string . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    countChar [ ( int ) string . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  String str1 = "" ;<br>  String str2 = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( ( countChar [ i ] > 1 ) && ( countChar [ i ] == 1 ) ) {<br>      str2 = str2 + ( char ) ( i + 'a' ) ;<br>    }<br>    else if ( ( countChar [ i ] == 1 ) && ( countChar [ i ] == 0 ) ) {<br>      str1 = str1 + ( char ) ( i + 'a' ) ;<br>    }<br>  }<br>  System . out . println ( "String with characters occurring once:" + "\n" + str1 ) ;<br>  System . out . println ( "String with characters occurring" + "multiple times:" + "\n" + str2 ) ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countDigits ( int a , int b ) {<br>  if ( a == 0 || b == 0 ) return 1 ;<br>  return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDigits ( int a , int b ) {<br>  if ( ( a == 0 || b == 0 ) && ( a > b ) ) return 1 ;<br>  return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;<br>}<br></td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countNonDecreasing ( int n ) {<br>  int N = 10 ;<br>  long count = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    count *= ( N + i - 1 ) ;<br>    count /= i ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonDecreasing ( int n ) {<br>  int N = 10 ;<br>  int count = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    count = ( int ) ( count * ( N + i - 1 ) ) ;<br>    count = ( int ) ( count / i ) ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countStrs ( int n ) {<br>  long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < 27 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= 25 ;<br>  i ++ ) {<br>    dp [ 1 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= 25 ;<br>    j ++ ) {<br>      if ( j == 0 ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;<br>      }<br>    }<br>  }<br>  long sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= 25 ;<br>  i ++ ) {<br>    sum = ( sum + dp [ n ] [ i ] ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrs ( int n ) {<br>  int [ ] [ ] dp = new int [ 27 ] [ n + 1 ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    dp [ j ] [ j ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= 26 ;<br>  i ++ ) {<br>    dp [ 1 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= 26 ;<br>    j ++ ) {<br>      if ( ( j == 0 ) || ( j == 1 ) ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>        ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;<br>        ;<br>      }<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= 26 ;<br>  i ++ ) {<br>    sum = sum + dp [ n ] [ i ] ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_EFFICIENTLY_CALCULATE_EX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float exponential ( int n , float x ) {<br>  float sum = 1 ;<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  -- i ) sum = 1 + x * sum / i ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static void exponential ( int n , double x ) {<br>  double sum = 1.0 ;<br>  for ( int i = n ;<br>  i > 0 ;<br>  i -- ) {<br>    sum = 1 + x * sum / i ;<br>  }<br>  System . out . println ( "e^x =" + sum ) ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 , secondary = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    principal += mat [ i ] [ i ] ;<br>    secondary += mat [ i ] [ n - i - 1 ] ;<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 ;<br>  int secondary = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    principal += mat [ i ] [ i ] ;<br>    secondary += mat [ i ] [ n - i - 1 ] ;<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_WAYS_BREAK_STRING_BRACKET_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findCombinations ( String str , int index , String out ) {<br>  if ( index == str . length ( ) ) System . out . println ( out ) ;<br>  for ( int i = index ;<br>  i < str . length ( ) ;<br>  i ++ ) findCombinations ( str , i + 1 , out + "(" + str . substring ( index , i + 1 ) + ")" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findCombinations ( String string , int index , String out ) {<br>  if ( index == string . length ( ) ) System . out . println ( out ) ;<br>  for ( int i = index ;<br>  i < string . length ( ) ;<br>  i += 1 ) findCombinations ( string , i + 1 , out + "(" + string . substring ( index , i + 1 ) + ")" ) ;<br>}<br></td>
  </tr><tr>
    <th>LINEAR_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int search ( int arr [ ] , int x ) {<br>  int n = arr . length ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) return i ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int arr [ ] , int n , int x ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == x ) ) return i ;<br>  };<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int singleNumber ( int a [ ] , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i : a ) {<br>    s . add ( i ) ;<br>  }<br>  int arr_sum = 0 ;<br>  for ( int i : a ) {<br>    arr_sum += i ;<br>  }<br>  int set_sum = 0 ;<br>  for ( int i : s ) {<br>    set_sum += i ;<br>  }<br>  return ( 3 * set_sum - arr_sum ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int singleNumber ( List < Integer > nums ) {<br>  return ( 3 * sum ( Sets . newHashSet ( nums ) ) . size ( ) - sum ( nums ) ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>SEARCH_ALMOST_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int binarySearch ( int arr [ ] , int l , int r , int x ) {<br>  if ( r >= l ) {<br>    int mid = l + ( r - l ) / 2 ;<br>    if ( arr [ mid ] == x ) return mid ;<br>    if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ;<br>    if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ;<br>    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ;<br>    return binarySearch ( arr , mid + 2 , r , x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int l , int r , int x ) {<br>  if ( ( r >= l ) && ( r <= r ) ) {<br>    int mid = ( int ) ( l + ( r - l ) / 2 ) ;<br>    if ( ( arr [ mid ] == x ) && ( arr [ mid + 1 ] == x ) ) return mid ;<br>    if ( ( mid > l && arr [ mid - 1 ] == x ) && ( arr [ mid + 1 ] == x ) ) return ( mid - 1 ) ;<br>    if ( ( mid < r && arr [ mid + 1 ] == x ) && ( arr [ mid + 1 ] == x ) ) return ( mid + 1 ) ;<br>    if ( ( arr [ mid ] > x ) && ( arr [ mid ] == x ) ) return binarySearch ( arr , l , mid - 2 , x ) ;<br>    return binarySearch ( arr , mid + 2 , r , x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void computeTotient ( int n ) {<br>  long phi [ ] = new long [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) phi [ i ] = i ;<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( phi [ p ] == p ) {<br>      phi [ p ] = p - 1 ;<br>      for ( int i = 2 * p ;<br>      i <= n ;<br>      i += p ) {<br>        phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void computeTotient ( int n ) {<br>  int [ ] phi = new int [ n + 2 ] ;<br>  for ( int i = 0 ;<br>  i < phi . length ;<br>  i ++ ) {<br>    phi [ i ] = 0 ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    phi [ i ] = i ;<br>  }<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( ( phi [ p ] == p ) && ( phi [ p ] > 0 ) ) {<br>      phi [ p ] = p - 1 ;<br>      for ( int i = 2 * p ;<br>      i <= n ;<br>      i += p ) {<br>        phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinNumber ( int n ) {<br>  int count = 0 , ans = 1 ;<br>  while ( n % 2 == 0 ) {<br>    count ++ ;<br>    n /= 2 ;<br>  }<br>  if ( count % 2 == 1 ) ans *= 2 ;<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i += 2 ) {<br>    count = 0 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n /= i ;<br>    }<br>    if ( count % 2 == 1 ) ans *= i ;<br>  }<br>  if ( n > 2 ) ans *= n ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinNumber ( int n ) {<br>  int count = 0 ;<br>  int ans = 1 ;<br>  while ( n % 2 == 0 ) {<br>    count ++ ;<br>    n /= 2 ;<br>  }<br>  if ( count % 2 != 0 ) ans *= 2 ;<br>  for ( int i = 3 ;<br>  i < ( int ) ( Math . sqrt ( n ) ) + 1 ;<br>  i += 2 ) {<br>    count = 0 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n /= i ;<br>    }<br>    if ( count % 2 != 0 ) ans *= i ;<br>  }<br>  if ( n > 2 ) ans *= n ;<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_JUMP_REACH_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countWaysToJump ( int arr [ ] , int n ) {<br>  int count_jump [ ] = new int [ n ] ;<br>  Arrays . fill ( count_jump , 0 ) ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;<br>    for ( int j = i + 1 ;<br>    j < n - 1 && j <= arr [ i ] + i ;<br>    j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ;<br>    if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( count_jump [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void countWaysToJump ( int [ ] arr , int n ) {<br>  int [ ] countJump = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    countJump [ i ] = 0 ;<br>  }<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( arr [ i ] >= n - i - 1 ) && ( arr [ i ] <= arr [ i ] + i ) ) {<br>      countJump [ i ] ++ ;<br>    }<br>    int j = i + 1 ;<br>    while ( ( j < n - 1 ) && ( j <= arr [ i ] + i ) ) {<br>      if ( ( countJump [ j ] != - 1 ) && ( countJump [ i ] != - 1 ) ) {<br>        countJump [ i ] += countJump [ j ] ;<br>      }<br>      j ++ ;<br>    }<br>    if ( ( countJump [ i ] == 0 ) && ( countJump [ j ] == 0 ) ) {<br>      countJump [ i ] = - 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( countJump [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void substringConversions ( String str , int k , int b ) {<br>  int i = 0 , sum = 0 , counter = k - 1 ;<br>  for ( i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ;<br>    counter -- ;<br>  }<br>  System . out . print ( sum + " " ) ;<br>  int prev = sum ;<br>  sum = 0 ;<br>  counter = 0 ;<br>  for ( ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ;<br>    sum = sum * b ;<br>    sum = sum + ( str . charAt ( i ) - '0' ) ;<br>    System . out . print ( sum + " " ) ;<br>    prev = sum ;<br>    counter ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void substringConversions ( String str1 , int k , int b ) {<br>  for ( int i = 0 ;<br>  i <= str1 . length ( ) - k + 1 ;<br>  i ++ ) {<br>    String sub = str1 . substring ( i , k + i ) ;<br>    int Sum = 0 ;<br>    int counter = 0 ;<br>    for ( int i = sub . length ( ) - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      Sum = ( Sum + ( ( Character . digit ( sub . charAt ( i ) , 16 ) - '0' ) * Math . pow ( b , counter ) ) ) ;<br>      counter ++ ;<br>    }<br>    System . out . print ( Sum + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minAbsSumPair ( int arr [ ] , int arr_size ) {<br>  int inv_count = 0 ;<br>  int l , r , min_sum , sum , min_l , min_r ;<br>  if ( arr_size < 2 ) {<br>    System . out . println ( "Invalid Input" ) ;<br>    return ;<br>  }<br>  min_l = 0 ;<br>  min_r = 1 ;<br>  min_sum = arr [ 0 ] + arr [ 1 ] ;<br>  for ( l = 0 ;<br>  l < arr_size - 1 ;<br>  l ++ ) {<br>    for ( r = l + 1 ;<br>    r < arr_size ;<br>    r ++ ) {<br>      sum = arr [ l ] + arr [ r ] ;<br>      if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) {<br>        min_sum = sum ;<br>        min_l = l ;<br>        min_r = r ;<br>      }<br>    }<br>  }<br>  System . out . println ( " The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void minAbsSumPair ( int [ ] arr , int arrSize ) {<br>  int invCount = 0 ;<br>  if ( arrSize < 2 ) {<br>    System . out . println ( "Invalid Input" ) ;<br>    return ;<br>  }<br>  int minL = 0 ;<br>  int minR = 1 ;<br>  int minSum = arr [ 0 ] + arr [ 1 ] ;<br>  for ( int l = 0 ;<br>  l <= arrSize - 1 ;<br>  l ++ ) {<br>    for ( int r = l + 1 ;<br>    r <= arrSize ;<br>    r ++ ) {<br>      int sum = arr [ l ] + arr [ r ] ;<br>      if ( Math . abs ( minSum ) > Math . abs ( sum ) ) {<br>        minSum = sum ;<br>        minL = l ;<br>        minR = r ;<br>      }<br>    }<br>  }<br>  System . out . println ( "The two elements whose sum is minimum are" + arr [ minL ] + " and " + arr [ minR ] ) ;<br>}<br></td>
  </tr><tr>
    <th>HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findoptimal ( int N ) {<br>  if ( N <= 6 ) return N ;<br>  int [ ] screen = new int [ N ] ;<br>  int b ;<br>  int n ;<br>  for ( n = 1 ;<br>  n <= 6 ;<br>  n ++ ) screen [ n - 1 ] = n ;<br>  for ( n = 7 ;<br>  n <= N ;<br>  n ++ ) {<br>    screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ;<br>  }<br>  return screen [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findoptimal ( int N ) {<br>  if ( ( N <= 6 ) && ( N > 0 ) ) return N ;<br>  int [ ] screen = new int [ N ] ;<br>  screen [ 0 ] = 0 ;<br>  for ( int n = 1 ;<br>  n < 7 ;<br>  n ++ ) screen [ n - 1 ] = n ;<br>  for ( int n = 7 ;<br>  n <= N ;<br>  n ++ ) screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ;<br>  ;<br>  return screen [ N - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_BINARY_CONVERSION_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int decimalToBinary ( int N ) {<br>  int B_Number = 0 ;<br>  int cnt = 0 ;<br>  while ( N != 0 ) {<br>    int rem = N % 2 ;<br>    double c = Math . pow ( 10 , cnt ) ;<br>    B_Number += rem * c ;<br>    N /= 2 ;<br>    cnt ++ ;<br>  }<br>  return B_Number ;<br>}<br></td>
    <td>translated code: <br><br> public static int decimalToBinary ( int N ) {<br>  int B_Number = 0 ;<br>  int cnt = 0 ;<br>  while ( ( N != 0 ) && ( N % 2 == 0 ) ) {<br>    int rem = N % 2 ;<br>    int c = Math . pow ( 10 , cnt ) ;<br>    B_Number += rem * c ;<br>    N /= 2 ;<br>    cnt ++ ;<br>  }<br>  return B_Number ;<br>}<br></td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPaths ( int n , int m ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) dp [ 0 ] [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= m ;<br>  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ;<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPaths ( int n , int m ) {<br>  if ( ( n == 0 || m == 0 ) && ( n > m ) ) return 1 ;<br>  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) {<br>  Arrays . sort ( arr ) ;<br>  int result = 0 ;<br>  for ( int i = k1 ;<br>  i < k2 - 1 ;<br>  i ++ ) result += arr [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumBetweenTwoKth ( int [ ] arr , int n , int k1 , int k2 ) {<br>  Arrays . sort ( arr ) ;<br>  int result = 0 ;<br>  for ( int i = k1 ;<br>  i <= k2 - 1 ;<br>  i ++ ) {<br>    result += arr [ i ] ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minRange ( int arr [ ] , int n , int k ) {<br>  int l = 0 , r = n ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    int j ;<br>    for ( j = i ;<br>    j < n ;<br>    j ++ ) {<br>      s . add ( arr [ j ] ) ;<br>      if ( s . size ( ) == k ) {<br>        if ( ( j - i ) < ( r - l ) ) {<br>          r = j ;<br>          l = i ;<br>        }<br>        break ;<br>      }<br>    }<br>    if ( j == n ) break ;<br>  }<br>  if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ;<br>  else System . out . println ( l + " " + r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void minRange ( int [ ] arr , int n , int k ) {<br>  int l = 0 ;<br>  int r = n ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    String [ ] s = new String [ n ] ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      s [ j ] = arr [ j ] ;<br>      if ( ( s [ j ] . length ( ) == k ) && ( ( s [ j ] . length ( ) - l ) < ( r - l ) ) ) {<br>        r = j ;<br>        l = i ;<br>      }<br>      break ;<br>    }<br>    if ( ( j == n ) && ( l == 0 ) ) break ;<br>  }<br>  if ( ( l == 0 ) && ( r == n ) ) System . out . println ( "Invalid k" ) ;<br>  else System . out . println ( l + " " + r ) ;<br>}<br></td>
  </tr><tr>
    <th>AREA_OF_A_HEXAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static double hexagonArea ( double s ) {<br>  return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double hexagonArea ( double s ) {<br>  return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOfSubstringWithKOnes ( String s , int K ) {<br>  int N = s . length ( ) ;<br>  int res = 0 ;<br>  int countOfOne = 0 ;<br>  int [ ] freq = new int [ N + 1 ] ;<br>  freq [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    countOfOne += ( s . charAt ( i ) - '0' ) ;<br>    if ( countOfOne >= K ) {<br>      res += freq [ countOfOne - K ] ;<br>    }<br>    freq [ countOfOne ] ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfSubstringWithKOnes ( String s , int K ) {<br>  int N = s . length ( ) ;<br>  int res = 0 ;<br>  int countOfOne = 0 ;<br>  int [ ] freq = new int [ N + 1 ] ;<br>  freq [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i += 1 ) {<br>    countOfOne += Character . digit ( s . charAt ( i ) , 10 ) - '0' ;<br>    if ( ( countOfOne >= K ) && ( countOfOne < N ) ) {<br>      res += freq [ countOfOne - K ] ;<br>    }<br>    freq [ countOfOne ] ++ ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int answer_query ( int a [ ] , int n , int l , int r ) {<br>  int count = 0 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int answerQuery ( int [ ] a , int n , int l , int r ) {<br>  int count = 0 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i ++ ) {<br>    if ( ( a [ i ] == a [ i + 1 ] ) && ( n == a [ i ] ) ) {<br>      count ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int check_duck ( String num ) {<br>  int len = num . length ( ) ;<br>  int count_zero = 0 ;<br>  char ch ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    ch = num . charAt ( i ) ;<br>    if ( ch == '0' ) count_zero ++ ;<br>  }<br>  return count_zero ;<br>}<br></td>
    <td>translated code: <br><br> public static int checkDuck ( String num ) {<br>  int l = num . length ( ) ;<br>  int countZero = 0 ;<br>  int i = 1 ;<br>  while ( i < l ) {<br>    char ch = num . charAt ( i ) ;<br>    if ( ( ch == '0' ) || ( ch == '1' ) || ( ch == '2' ) || ( ch == '3' ) || ( ch == '4' ) || ( ch == '5' ) || ( ch == '6' ) || ( ch == '7' ) || ( ch == '8' ) || ( ch == '9' ) ) {<br>      countZero = countZero + 1 ;<br>    }<br>    i = i + 1 ;<br>  }<br>  return countZero ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIntegralSolutions ( int n ) {<br>  return ( ( n + 1 ) * ( n + 2 ) ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIntegralSolutions ( int n ) {<br>  return ( int ) ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProfit ( int price [ ] , int n , int k ) {<br>  int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) profit [ i ] [ 0 ] = 0 ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) profit [ 0 ] [ j ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int prevDiff = Integer . MIN_VALUE ;<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ;<br>      profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ;<br>    }<br>  }<br>  return profit [ k ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProfit ( int [ ] price , int n , int k ) {<br>  int [ ] [ ] profit = new int [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    profit [ i - 1 ] = new int [ n + 1 ] ;<br>  }<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int prevDiff = Integer . MAX_VALUE ;<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ;<br>      profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ;<br>    }<br>  }<br>  return profit [ k ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findCount ( String str ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) {<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int findCount ( String str ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( ( ( i == Character . MAX_VALUE ) || ( i == Character . MIN_VALUE ) ) && ( str . charAt ( i ) == 'a' ) ) {<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_GFG_SUBSEQUENCES_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countSubsequence ( String s , int n ) {<br>  int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    switch ( s . charAt ( i ) ) {<br>      case 'G' : cntG ++ ;<br>      result += C ;<br>      break ;<br>      case 'F' : cntF ++ ;<br>      C += cntG ;<br>      break ;<br>      default : continue ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void countSubsequence ( String s , int n ) {<br>  int cntG = 0 ;<br>  int cntF = 0 ;<br>  int result = 0 ;<br>  int C = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == 'G' ) && ( s . charAt ( i ) == 'F' ) ) {<br>      cntG ++ ;<br>      result += C ;<br>      continue ;<br>    }<br>    if ( ( s . charAt ( i ) == 'F' ) && ( s . charAt ( i ) == 'G' ) ) {<br>      cntF ++ ;<br>      C += cntG ;<br>      continue ;<br>    }<br>    else continue ;<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findSmallest ( int arr [ ] , int n ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < n && arr [ i ] <= res ;<br>  i ++ ) res = res + arr [ i ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSmallest ( int [ ] arr , int n ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( arr [ i ] <= res ) {<br>      res = res + arr [ i ] ;<br>    }<br>    else {<br>      break ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_POINTS_COLLECTED_BY_TWO_PERSONS_ALLOWED_TO_MEET_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxPoints ( int A [ ] [ ] ) {<br>  int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= M ;<br>  j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) for ( int j = M ;<br>  j >= 1 ;<br>  j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) for ( int j = 1 ;<br>  j <= M ;<br>  j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = M ;<br>  j >= 1 ;<br>  j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  int ans = 0 ;<br>  for ( int i = 2 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 2 ;<br>    j < M ;<br>    j ++ ) {<br>      int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ;<br>      int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ;<br>      ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxPoints ( int [ ] A ) {<br>  P1S = new int [ N + 2 ] ;<br>  P1E = new int [ M + 2 ] ;<br>  P2S = new int [ N + 2 ] ;<br>  P2E = new int [ M + 2 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( int i = N ;<br>  i <= M ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= N ;<br>    j ++ ) {<br>      P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( int i = N ;<br>  i <= M ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( int i = N ;<br>  i <= M ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = M ;<br>    j <= N ;<br>    j ++ ) {<br>      P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 2 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 2 ;<br>    j <= M ;<br>    j ++ ) {<br>      op1 = P1S [ i ] [ j - 1 ] + P1E [ i ]</td>
  </tr><tr>
    <th>PROGRAM_FIND_CIRCUMFERENCE_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double circumference ( double r ) {<br>  double PI = 3.1415 ;<br>  double cir = 2 * PI * r ;<br>  return cir ;<br>}<br></td>
    <td>translated code: <br><br> public static double circumference ( double r ) {<br>  return ( 2 * PI * r ) ;<br>}<br></td>
  </tr><tr>
    <th>QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void leftRotate ( int arr [ ] , int n , int k ) {<br>  for ( int i = k ;<br>  i < k + n ;<br>  i ++ ) System . out . print ( arr [ i % n ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void leftRotate ( int [ ] arr , int n , int k ) {<br>  for ( int i = k ;<br>  i < k + n ;<br>  i ++ ) {<br>    System . out . print ( Integer . toString ( arr [ i % n ] ) + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int [ ] A , int n ) {<br>  int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ;<br>  return ( min_val * ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int minSum ( int [ ] A ) {<br>  int minVal = Math . min ( A ) ;<br>  ;<br>  return minVal * ( A . length - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>RECURSIVE_PROGRAM_PRIME_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n , int i ) {<br>  if ( n <= 2 ) return ( n == 2 ) ? true : false ;<br>  if ( n % i == 0 ) return false ;<br>  if ( i * i > n ) return true ;<br>  return isPrime ( n , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n , int i ) {<br>  if ( ( n <= 2 ) && ( n == 2 ) ) return true ? ( n == 2 ) : false ;<br>  if ( ( n % i == 0 ) && ( i * i > n ) ) return false ;<br>  return isPrime ( n , i + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>SPARSE_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sparseSearch ( String arr [ ] , String x , int n ) {<br>  return binarySearch ( arr , 0 , n - 1 , x ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int sparseSearch ( String arr , int key , int low , int high ) {<br>  int left = 0 ;<br>  int right = 0 ;<br>  while ( low <= high ) {<br>    int mid = ( low + high ) / 2 ;<br>    if ( arr . charAt ( mid ) == '\0' ) {<br>      left = mid - 1 ;<br>      right = mid + 1 ;<br>      if ( left < low && right > high ) {<br>        return - 1 ;<br>      }<br>      else if ( right <= high && arr . charAt ( right ) != '\0' ) {<br>        mid = right ;<br>      }<br>      else if ( left >= low && arr . charAt ( left ) != '\0' ) {<br>        mid = left ;<br>      }<br>    }<br>    if ( arr . charAt ( mid ) == key ) {<br>      System . out . println ( "Found string {<br>}<br> at index {<br>}" . format ( arr . charAt ( mid ) , mid ) ) ;<br>      return 0 ;<br>    }<br>    else if ( arr . charAt ( mid ) > key ) {<br>      high = mid - 1 ;<br>    }<br>    else if ( arr . charAt ( mid ) < key ) {<br>      low = mid + 1 ;<br>    }<br>    left -- ;<br>    right ++ ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( String a , String b , int m , int n ) {<br>  if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;<br>  if ( m == 0 ) return 0 ;<br>  if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ;<br>  else return count ( a , b , m - 1 , n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int [ ] a , int [ ] b , int m , int n ) {<br>  if ( ( ( m == 0 && n == 0 ) || n == 0 ) || ( m == 0 ) ) return 1 ;<br>  if ( ( m == 0 ) || ( n == 0 ) ) return 0 ;<br>  if ( ( a [ m - 1 ] == b [ n - 1 ] ) && ( a [ m - 1 ] == b [ n - 1 ] ) ) return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) ;<br>  else return count ( a , b , m - 1 , n ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean arraySortedOrNot ( int arr [ ] , int n ) {<br>  if ( n == 0 || n == 1 ) return true ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arraySortedOrNot ( int [ ] arr , int n ) {<br>  if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] > arr [ 1 ] ) ) return true ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] > arr [ i + 1 ] ) ) return false ;<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxOnesIndex ( int arr [ ] , int n ) {<br>  int max_count = 0 ;<br>  int max_index = 0 ;<br>  int prev_zero = - 1 ;<br>  int prev_prev_zero = - 1 ;<br>  for ( int curr = 0 ;<br>  curr < n ;<br>  ++ curr ) {<br>    if ( arr [ curr ] == 0 ) {<br>      if ( curr - prev_prev_zero > max_count ) {<br>        max_count = curr - prev_prev_zero ;<br>        max_index = prev_zero ;<br>      }<br>      prev_prev_zero = prev_zero ;<br>      prev_zero = curr ;<br>    }<br>  }<br>  if ( n - prev_prev_zero > max_count ) max_index = prev_zero ;<br>  return max_index ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxOnesIndex ( int [ ] arr , int n ) {<br>  int maxCount = 0 ;<br>  int maxIndex = 0 ;<br>  int prevZero = - 1 ;<br>  int prevPrevZero = - 1 ;<br>  for ( int curr = 0 ;<br>  curr < n ;<br>  curr ++ ) {<br>    if ( ( arr [ curr ] == 0 ) && ( arr [ curr ] > prevZero ) ) {<br>      if ( ( curr - prevPrevZero > maxCount ) && ( arr [ curr ] > prevZero ) ) {<br>        maxCount = curr - prevPrevZero ;<br>        maxIndex = prevZero ;<br>      }<br>      prevPrevZero = prevZero ;<br>      prevZero = curr ;<br>    }<br>  }<br>  if ( ( n - prevPrevZero > maxCount ) && ( arr [ n - prevZero ] > prevZero ) ) {<br>    maxIndex = prevZero ;<br>  }<br>  return maxIndex ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProduct ( int arr [ ] , int n ) {<br>  if ( n < 3 ) {<br>    return - 1 ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProduct ( int [ ] arr , int n ) {<br>  if ( n < 3 ) return - 1 ;<br>  Arrays . sort ( arr ) ;<br>  return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ;<br>}<br></td>
  </tr><tr>
    <th>COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) {<br>  int Xmax = Collections . max ( Arrays . asList ( X ) ) ;<br>  int Xmin = Collections . min ( Arrays . asList ( X ) ) ;<br>  int Ymax = Collections . max ( Arrays . asList ( Y ) ) ;<br>  int Ymin = Collections . min ( Arrays . asList ( Y ) ) ;<br>  System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ;<br>  System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ;<br>  System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ;<br>  System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printRect ( int X , int Y , int n ) {<br>  int Xmax = Math . max ( X ) ;<br>  int Xmin = Math . min ( X ) ;<br>  int Ymax = Math . max ( Y ) ;<br>  int Ymin = Math . min ( Y ) ;<br>  System . out . print ( "{" + Xmin + ", " + Ymin + "}" + "\n" ) ;<br>  System . out . print ( "{" + Xmin + ", " + Ymax + "}" + "\n" ) ;<br>  System . out . print ( "{" + Xmax + ", " + Ymax + "}" + "\n" ) ;<br>  System . out . print ( "{" + Xmax + ", " + Ymin + "}" + "\n" ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOfBinaryNumberLessThanN ( int N ) {<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  q . add ( 1 ) ;<br>  int cnt = 0 ;<br>  int t ;<br>  while ( q . size ( ) > 0 ) {<br>    t = q . peek ( ) ;<br>    q . remove ( ) ;<br>    if ( t <= N ) {<br>      cnt ++ ;<br>      q . add ( t * 10 ) ;<br>      q . add ( t * 10 + 1 ) ;<br>    }<br>  }<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfBinaryNumberLessThanN ( int N ) {<br>  Deque < Integer > q = new LinkedList < Integer > ( ) ;<br>  q . add ( 1 ) ;<br>  int cnt = 0 ;<br>  while ( ( q . size ( ) > 0 ) && ( cnt < N ) ) {<br>    int t = q . poll ( ) ;<br>    if ( ( t <= N ) && ( t > 0 ) ) {<br>      cnt = cnt + 1 ;<br>      q . add ( t * 10 ) ;<br>      q . add ( t * 10 + 1 ) ;<br>    }<br>  }<br>  return cnt ;<br>}<br></td>
  </tr><tr>
    <th>CONVERT_DECIMAL_FRACTION_BINARY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String decimalToBinary ( double num , int k_prec ) {<br>  String binary = "" ;<br>  int Integral = ( int ) num ;<br>  double fractional = num - Integral ;<br>  while ( Integral > 0 ) {<br>    int rem = Integral % 2 ;<br>    binary += ( ( char ) ( rem + '0' ) ) ;<br>    Integral /= 2 ;<br>  }<br>  binary = reverse ( binary ) ;<br>  binary += ( '.' ) ;<br>  while ( k_prec -- > 0 ) {<br>    fractional *= 2 ;<br>    int fract_bit = ( int ) fractional ;<br>    if ( fract_bit == 1 ) {<br>      fractional -= fract_bit ;<br>      binary += ( char ) ( 1 + '0' ) ;<br>    }<br>    else {<br>      binary += ( char ) ( 0 + '0' ) ;<br>    }<br>  }<br>  return binary ;<br>}<br></td>
    <td>translated code: <br><br> public static String decimalToBinary ( int num , int k_prec ) {<br>  String binary = "" ;<br>  int Integral = Integer . MIN_VALUE ;<br>  int fractional = num - Integral ;<br>  while ( ( Integral ) > 0 ) {<br>    int rem = Integral % 2 ;<br>    binary += Integer . toString ( rem ) ;<br>    ;<br>    Integral /= 2 ;<br>  }<br>  binary = binary . substring ( 0 , binary . length ( ) - 1 ) ;<br>  binary += '.' ;<br>  while ( ( k_prec ) > 0 ) {<br>    fractional *= 2 ;<br>    int fractBit = Integer . MIN_VALUE ;<br>    if ( ( fractBit == 1 ) && ( fractional >= 0 ) ) {<br>      fractional -= fractBit ;<br>      binary += '1' ;<br>    }<br>    else {<br>      binary += '0' ;<br>    }<br>    k_prec -- ;<br>  }<br>  return binary ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSETS_OF_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumZeros ( int arr [ ] , int n , int k ) {<br>  int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ;<br>  for ( int [ ] row : subset ) {<br>    Arrays . fill ( row , - 1 ) ;<br>  }<br>  subset [ 0 ] [ 0 ] = 0 ;<br>  for ( int p = 0 ;<br>  p < n ;<br>  p ++ ) {<br>    int pw2 = 0 , pw5 = 0 ;<br>    while ( arr [ p ] % 2 == 0 ) {<br>      pw2 ++ ;<br>      arr [ p ] /= 2 ;<br>    }<br>    while ( arr [ p ] % 5 == 0 ) {<br>      pw5 ++ ;<br>      arr [ p ] /= 5 ;<br>    }<br>    for ( int i = k - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      for ( int j = 0 ;<br>      j < MAX5 ;<br>      j ++ ) {<br>        if ( subset [ i ] [ j ] != - 1 ) {<br>          subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ;<br>        }<br>      }<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < MAX5 ;<br>  i ++ ) {<br>    ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumZeros ( int [ ] arr , int n , int k ) {<br>  MAX5 = n ;<br>  int [ ] [ ] subset = new int [ k + 1 ] [ n ] ;<br>  subset [ 0 ] [ 0 ] = 0 ;<br>  for ( int p = 0 ;<br>  p < arr . length ;<br>  p ++ ) {<br>    int pw2 = 0 , pw5 = 0 ;<br>    while ( ! p % 2 ) {<br>      pw2 ++ ;<br>      p /= 2 ;<br>    }<br>    while ( ! p % 5 ) {<br>      pw5 ++ ;<br>      p /= 5 ;<br>    }<br>    for ( int i = k - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      for ( int j = 0 ;<br>      j < MAX5 ;<br>      j ++ ) {<br>        if ( subset [ i ] [ j ] != - 1 ) {<br>          subset [ i + 1 ] [ j + pw5 ] = ( int ) Math . max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ;<br>        }<br>      }<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < MAX5 ;<br>  i ++ ) {<br>    ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int l , int h , int key ) {<br>  if ( l > h ) return - 1 ;<br>  int mid = ( l + h ) / 2 ;<br>  if ( arr [ mid ] == key ) return mid ;<br>  if ( arr [ l ] <= arr [ mid ] ) {<br>    if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;<br>    return search ( arr , mid + 1 , h , key ) ;<br>  }<br>  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ;<br>  return search ( arr , l , mid - 1 , key ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int l , int h , int key ) {<br>  if ( l > h ) return - 1 ;<br>  int mid = ( l + h ) / 2 ;<br>  if ( arr [ mid ] == key ) return mid ;<br>  if ( arr [ l ] <= arr [ mid ] ) {<br>    if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;<br>    return search ( arr , mid + 1 , h , key ) ;<br>  }<br>  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( a , mid + 1 , h , key ) ;<br>  return search ( arr , l , mid - 1 , key ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_AREA_CIRCULAR_SEGMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float area_of_segment ( float radius , float angle ) {<br>  float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ;<br>  float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ;<br>  return area_of_sector - area_of_triangle ;<br>}<br></td>
    <td>translated code: <br><br> public static double areaOfSegment ( double radius , double angle ) {<br>  double areaOfSector = Math . PI * ( radius * radius ) ;<br>  * ( angle / 360 ) = 0 ;<br>  double areaOfTriangle = 1 / 2 * ( radius * radius ) ;<br>  * Math . sin ( ( angle * Math . PI ) / 180 ) = 0 ;<br>  return areaOfSector - areaOfTriangle ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void printSmall ( int arr [ ] , int n , int k ) {<br>  for ( int i = k ;<br>  i < n ;<br>  ++ i ) {<br>    int max_var = arr [ k - 1 ] ;<br>    int pos = k - 1 ;<br>    for ( int j = k - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( arr [ j ] > max_var ) {<br>        max_var = arr [ j ] ;<br>        pos = j ;<br>      }<br>    }<br>    if ( max_var > arr [ i ] ) {<br>      int j = pos ;<br>      while ( j < k - 1 ) {<br>        arr [ j ] = arr [ j + 1 ] ;<br>        j ++ ;<br>      }<br>      arr [ k - 1 ] = arr [ i ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) System . out . print ( arr [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSmall ( int [ ] arr , int n , int k ) {<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    int maxVar = arr [ k - 1 ] ;<br>    int pos = k - 1 ;<br>    for ( int j = k - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( ( arr [ j ] > maxVar ) && ( arr [ j ] < maxVar ) ) {<br>        maxVar = arr [ j ] ;<br>        pos = j ;<br>      }<br>    }<br>    if ( ( maxVar > arr [ i ] ) && ( arr [ i ] < maxVar ) ) {<br>      int j = pos ;<br>      while ( ( j < k - 1 ) && ( arr [ j ] > maxVar ) && ( arr [ j ] < maxVar ) ) {<br>        arr [ j ] = arr [ j + 1 ] ;<br>        j ++ ;<br>      }<br>      arr [ k - 1 ] = arr [ i ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) {<br>    System . out . print ( arr [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NTH_NON_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nonFibonacci ( int n ) {<br>  int prevPrev = 1 , prev = 2 , curr = 3 ;<br>  while ( n > 0 ) {<br>    prevPrev = prev ;<br>    prev = curr ;<br>    curr = prevPrev + prev ;<br>    n = n - ( curr - prev - 1 ) ;<br>  }<br>  n = n + ( curr - prev - 1 ) ;<br>  return prev + n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nonFibonacci ( int n ) {<br>  int prevPrev = 1 ;<br>  int prev = 2 ;<br>  int curr = 3 ;<br>  while ( n > 0 ) {<br>    prevPrev = prev ;<br>    prev = curr ;<br>    curr = prevPrev + prev ;<br>    n = n - ( curr - prev - 1 ) ;<br>  }<br>  n = n + ( curr - prev - 1 ) ;<br>  return prev + n ;<br>}<br></td>
  </tr><tr>
    <th>ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == x ) ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int nearestSmallerEqFib ( int n ) {<br>  if ( n == 0 || n == 1 ) return n ;<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  while ( f3 <= n ) {<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return f2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int nearestSmallerEqFib ( int n ) {<br>  if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) return n ;<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  while ( ( f3 = f1 + f2 ) <= n ) {<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return f2 ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_MAXIMUM_SHORTEST_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_maximum ( int a [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    int d = Math . min ( 1 + i , n - i ) ;<br>    if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;<br>    else {<br>      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;<br>    }<br>  }<br>  int ans = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaximum ( int [ ] a , int n , int k ) {<br>  Map < Integer , Integer > b = Maps . newHashMap ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    int d = Math . min ( 1 + i , n - i ) ;<br>    if ( x != 0 ) {<br>      b . put ( x , d ) ;<br>    }<br>    else {<br>      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;<br>    }<br>  }<br>  int ans = 10 * 9 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    if ( ( x != ( k - x ) && ( k - x ) < b . keySet ( ) . size ( ) ) || ( x != ( k - x ) && ( k - x ) < b . keySet ( ) . size ( ) ) ) {<br>      ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOGRAPHIC_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void generate ( Set < String > st , String s ) {<br>  if ( s . length ( ) == 0 ) {<br>    return ;<br>  }<br>  if ( ! st . contains ( s ) ) {<br>    st . add ( s ) ;<br>    for ( int i = 0 ;<br>    i < s . length ( ) ;<br>    i ++ ) {<br>      String t = s ;<br>      t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ;<br>      generate ( st , t ) ;<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void generate ( Set < String > st , String s ) {<br>  if ( s . length ( ) == 0 ) return ;<br>  if ( s != null ) {<br>    st . add ( s ) ;<br>    for ( int i = 0 ;<br>    i < s . length ( ) ;<br>    i ++ ) {<br>      String t = Arrays . copyOfRange ( s , i , i + 1 ) . trim ( ) ;<br>      t = t . replaceAll ( "\\s+" , "" ) ;<br>      generate ( st , t ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pow ( int a , int b ) {<br>  if ( b == 0 ) return 1 ;<br>  int answer = a ;<br>  int increment = a ;<br>  int i , j ;<br>  for ( i = 1 ;<br>  i < b ;<br>  i ++ ) {<br>    for ( j = 1 ;<br>    j < a ;<br>    j ++ ) {<br>      answer += increment ;<br>    }<br>    increment = answer ;<br>  }<br>  return answer ;<br>}<br></td>
    <td>translated code: <br><br> public static double pow ( double a , int b ) {<br>  if ( ( b == 0 ) || ( b == 1 ) ) return 1 ;<br>  double answer = a ;<br>  double increment = a ;<br>  for ( int i = 1 ;<br>  i <= b ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= a ;<br>    j ++ ) {<br>      answer += increment ;<br>    }<br>    increment = answer ;<br>  }<br>  return answer ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxvolume ( int s ) {<br>  int length = s / 3 ;<br>  s -= length ;<br>  int breadth = s / 2 ;<br>  int height = s - breadth ;<br>  return length * breadth * height ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxvolume ( int s ) {<br>  int length = ( int ) ( s / 3 ) ;<br>  s -= length ;<br>  int breadth = s / 2 ;<br>  int height = s - breadth ;<br>  return ( int ) ( length * breadth * height ) ;<br>}<br></td>
  </tr><tr>
    <th>HORNERS_METHOD_POLYNOMIAL_EVALUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int horner ( int poly [ ] , int n , int x ) {<br>  int result = poly [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) result = result * x + poly [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static double horner ( double [ ] poly , int n , double x ) {<br>  double result = poly [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    result = result * x + poly [ i ] ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minTime ( int [ ] arr , int n , int m ) {<br>  int t = 0 ;<br>  while ( true ) {<br>    int items = 0 ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) items += ( t / arr [ i ] ) ;<br>    if ( items >= m ) return t ;<br>    t ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int minTime ( int [ ] arr , int n , int m ) {<br>  int t = 0 ;<br>  while ( ( 1 ) ) {<br>    int items = 0 ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      items += ( t / arr [ i ] ) ;<br>    }<br>    if ( ( items >= m ) && ( items < n ) ) {<br>      return t ;<br>    }<br>    t ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int difference ( int arr [ ] [ ] , int n ) {<br>  int d1 = 0 , d2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) d1 += arr [ i ] [ j ] ;<br>      if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ;<br>    }<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int difference ( int [ ] [ ] arr , int n ) {<br>  int d1 = 0 ;<br>  int d2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( i == j ) && ( i != n - j - 1 ) ) {<br>        d1 += arr [ i ] [ j ] ;<br>      }<br>      if ( ( i == n - j - 1 ) && ( i != n - j - 1 ) ) {<br>        d2 += arr [ i ] [ j ] ;<br>      }<br>    }<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_UNCOMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int shortestSeq ( char [ ] S , char [ ] T ) {<br>  int m = S . length , n = T . length ;<br>  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = MAX ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      char ch = S [ i - 1 ] ;<br>      int k ;<br>      for ( k = j - 1 ;<br>      k >= 0 ;<br>      k -- ) {<br>        if ( T [ k ] == ch ) {<br>          break ;<br>        }<br>      }<br>      if ( k == - 1 ) {<br>        dp [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ;<br>      }<br>    }<br>  }<br>  int ans = dp [ m ] [ n ] ;<br>  if ( ans >= MAX ) {<br>    ans = - 1 ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestSeq ( String S , String T ) {<br>  int m = S . length ( ) ;<br>  int n = T . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int j = 0 ;<br>  j < m + 1 ;<br>  j ++ ) dp [ j ] [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) dp [ i ] [ 0 ] = MAX ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      char ch = S . charAt ( i - 1 ) ;<br>      int k = j - 1 ;<br>      while ( k >= 0 ) {<br>        if ( T . charAt ( k ) == ch ) break ;<br>        k -- ;<br>      }<br>      if ( k == - 1 ) dp [ i ] [ j ] = 1 ;<br>      else dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ;<br>    }<br>  }<br>  int ans = dp [ m ] [ n ] ;<br>  if ( ans >= MAX ) ans = - 1 ;<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findFlips ( String str , int n ) {<br>  char last = ' ' ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( last != str . charAt ( i ) ) res ++ ;<br>    last = str . charAt ( i ) ;<br>  }<br>  return res / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFlips ( String str , int n ) {<br>  char last = ' ' ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( last != str . charAt ( i ) ) && ( last != ' ' ) ) {<br>      res ++ ;<br>    }<br>    last = str . charAt ( i ) ;<br>  }<br>  return res / 2 ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinInsertions ( char str [ ] , int l , int h ) {<br>  if ( l > h ) return Integer . MAX_VALUE ;<br>  if ( l == h ) return 0 ;<br>  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;<br>  return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinInsertions ( String str , int l , int h ) {<br>  if ( ( l > h ) || ( l == h ) ) return Integer . MAX_VALUE ;<br>  if ( ( l == h ) || ( l == h - 1 ) ) return 0 ;<br>  if ( ( str . charAt ( l ) == str . charAt ( h ) ) && ( str . charAt ( l ) == str . charAt ( h ) ) ) return findMinInsertions ( str , l + 1 , h - 1 ) ;<br>  else return ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( String str ) {<br>  int result = 0 ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( String str1 ) {<br>  int result = 0 ;<br>  ;<br>  int n = str1 . length ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( Math . abs ( ( char ) str1 . charAt ( i ) - ( char ) str1 . charAt ( j ) ) ) == Math . abs ( i - j ) ) {<br>        result ++ ;<br>      };<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MULTISTAGE_GRAPH_SHORTEST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int shortestDist ( int [ ] [ ] graph ) {<br>  int [ ] dist = new int [ N ] ;<br>  dist [ N - 1 ] = 0 ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    dist [ i ] = INF ;<br>    for ( int j = i ;<br>    j < N ;<br>    j ++ ) {<br>      if ( graph [ i ] [ j ] == INF ) {<br>        continue ;<br>      }<br>      dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ;<br>    }<br>  }<br>  return dist [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestDist ( int [ ] [ ] graph ) {<br>  static final int INF = - 1 ;<br>  int [ ] dist = new int [ N ] ;<br>  dist [ N - 1 ] = 0 ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    dist [ i ] = INF ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( graph [ i ] [ j ] == INF ) continue ;<br>      dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ;<br>    }<br>  }<br>  return dist [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMaxSubSquare ( int M [ ] [ ] ) {<br>  int i , j ;<br>  int R = M . length ;<br>  int C = M [ 0 ] . length ;<br>  int S [ ] [ ] = new int [ R ] [ C ] ;<br>  int max_of_s , max_i , max_j ;<br>  for ( i = 0 ;<br>  i < R ;<br>  i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ;<br>  for ( j = 0 ;<br>  j < C ;<br>  j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ;<br>  for ( i = 1 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( j = 1 ;<br>    j < C ;<br>    j ++ ) {<br>      if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ;<br>      else S [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  max_of_s = S [ 0 ] [ 0 ] ;<br>  max_i = 0 ;<br>  max_j = 0 ;<br>  for ( i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      if ( max_of_s < S [ i ] [ j ] ) {<br>        max_of_s = S [ i ] [ j ] ;<br>        max_i = i ;<br>        max_j = j ;<br>      }<br>    }<br>  }<br>  System . out . println ( "Maximum size sub-matrix is: " ) ;<br>  for ( i = max_i ;<br>  i > max_i - max_of_s ;<br>  i -- ) {<br>    for ( j = max_j ;<br>    j > max_j - max_of_s ;<br>    j -- ) {<br>      System . out . print ( M [ i ] [ j ] + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printMaxSubSquare ( int [ ] [ ] M ) {<br>  int R = M . length ;<br>  int C = M [ 0 ] . length ;<br>  int [ ] [ ] S = new int [ C ] [ R ] ;<br>  for ( int l = 0 ;<br>  l < R ;<br>  l ++ ) {<br>    for ( int i = 1 ;<br>    i < R ;<br>    i ++ ) {<br>      for ( int j = 1 ;<br>      j < C ;<br>      j ++ ) {<br>        if ( ( M [ i ] [ j ] == 1 ) && ( M [ i ] [ j ] == 1 ) ) {<br>          S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] ) + 1 ;<br>        }<br>        else {<br>          S [ i ] [ j ] = 0 ;<br>        }<br>      }<br>    }<br>  }<br>  int maxOfS = S [ 0 ] [ 0 ] ;<br>  int maxI = 0 ;<br>  int maxJ = 0 ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      if ( ( maxOfS < S [ i ] [ j ] ) && ( M [ i ] [ j ] == 1 ) ) {<br>        maxOfS = S [ i ] [ j ] ;<br>        maxI = i ;<br>        maxJ = j ;<br>      }<br>    }<br>  }<br>  System . out . print ( "Maximum size sub-matrix is: " ) ;<br>  for ( int i = maxI ;<br>  i < maxI - maxOfS ;<br>  i ++ ) {<br>    for ( int j = maxJ ;<br>    j < maxJ - maxOfS ;<br>    j ++ ) {<br>      System . out . print ( M [ i ] [ j ] + "" ) ;<br>    }<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printClosest ( int arr [ ] , int n , int x ) {<br>  int res_l = 0 , res_r = 0 ;<br>  int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ;<br>  while ( r > l ) {<br>    if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) {<br>      res_l = l ;<br>      res_r = r ;<br>      diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;<br>    }<br>    if ( arr [ l ] + arr [ r ] > x ) r -- ;<br>    else l ++ ;<br>  }<br>  System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printClosest ( int [ ] arr , int n , int x ) {<br>  int resL = 0 , resR = 0 ;<br>  int l = 0 , r = n - 1 , diff = MAX_VAL ;<br>  while ( r > l ) {<br>    if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) {<br>      resL = l ;<br>      resR = r ;<br>      diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;<br>    }<br>    if ( arr [ l ] + arr [ r ] > x ) {<br>      r -- ;<br>    }<br>    else {<br>      l ++ ;<br>    }<br>  }<br>  System . out . println ( "The closest pair is {<br>}<br> and {<br>}" . format ( arr [ resL ] , arr [ resR ] ) ) ;<br>}<br></td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>  int t = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( B [ i ] != 0 ) {<br>      if ( A [ i ] != i + 1 ) t = A [ i ] ;<br>      A [ i ] = A [ i + 1 ] ;<br>      A [ i + 1 ] = t ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( A [ i ] != i + 1 ) return 0 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( B [ i ] ) {<br>      if ( A [ i ] != i + 1 ) {<br>        A [ i ] = A [ i + 1 ] ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( A [ i ] != i + 1 ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>TILE_STACKING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int possibleWays ( int n , int m , int k ) {<br>  int [ ] [ ] dp = new int [ N ] [ N ] ;<br>  int [ ] [ ] presum = new int [ N ] [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>      presum [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 0 ;<br>    presum [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ;<br>      if ( j > k ) {<br>        dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ;<br>      }<br>    }<br>    for ( int j = 1 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int possibleWays ( int n , int m , int k ) {<br>  int [ ] [ ] dp = new int [ 10 ] [ 10 ] ;<br>  int [ ] [ ] presum = new int [ 10 ] [ 10 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 0 ;<br>    presum [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    presum [ i ] [ 0 ] = 1 ;<br>    dp [ i ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ;<br>      if ( j > k ) {<br>        dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ;<br>      }<br>    }<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumEqualProduct ( int a [ ] , int n ) {<br>  int zero = 0 , two = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] == 0 ) {<br>      zero ++ ;<br>    }<br>    if ( a [ i ] == 2 ) {<br>      two ++ ;<br>    }<br>  }<br>  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ;<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumEqualProduct ( int [ ] a , int n ) {<br>  int zero = 0 ;<br>  int two = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] == 0 ) zero ++ ;<br>    if ( a [ i ] == 2 ) two ++ ;<br>  }<br>  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ;<br>  return cnt ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minPalPartion ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] C = new int [ n ] [ n ] ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  int i , j , k , L ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    P [ i ] [ i ] = true ;<br>    C [ i ] [ i ] = 0 ;<br>  }<br>  for ( L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>      else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ;<br>      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;<br>      else {<br>        C [ i ] [ j ] = Integer . MAX_VALUE ;<br>        for ( k = i ;<br>        k <= j - 1 ;<br>        k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ;<br>      }<br>    }<br>  }<br>  return C [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minPalPartion ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] C = new int [ n ] [ n ] ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  int j ;<br>  int k ;<br>  int L ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    P [ i ] [ i ] = true ;<br>    ;<br>    C [ i ] [ i ] = 0 ;<br>  };<br>  for ( L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( int i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>      else P [ i ] [ j ] = ( ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ) ;<br>      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;<br>      else {<br>        C [ i ] [ j ] = 100000000 ;<br>        for ( k = i ;<br>        k < j ;<br>        k ++ ) C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ;<br>      }<br>    }<br>  }<br>  return C [ 0 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeatingNumber ( int [ ] arr , int n ) {<br>  int sq = ( int ) Math . sqrt ( n ) ;<br>  int range = ( n / sq ) + 1 ;<br>  int [ ] count = new int [ range ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    count [ ( arr [ i ] - 1 ) / sq ] ++ ;<br>  }<br>  int selected_block = range - 1 ;<br>  for ( int i = 0 ;<br>  i < range - 1 ;<br>  i ++ ) {<br>    if ( count [ i ] > sq ) {<br>      selected_block = i ;<br>      break ;<br>    }<br>  }<br>  HashMap < Integer , Integer > m = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) {<br>      m . put ( arr [ i ] , 1 ) ;<br>      if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeatingNumber ( int [ ] arr , int n ) {<br>  double sq = Math . sqrt ( n ) ;<br>  int range__ = ( int ) ( ( n / sq ) + 1 ) ;<br>  int [ ] count = new int [ range__ ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 1 ) {<br>    count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ;<br>  }<br>  int selectedBlock = range__ - 1 ;<br>  for ( int i = 0 ;<br>  i < range__ - 1 ;<br>  i += 1 ) {<br>    if ( ( count [ i ] > sq ) && ( count [ i ] <= ( ( selectedBlock + 1 ) * sq ) ) ) {<br>      selectedBlock = i ;<br>      break ;<br>    }<br>  }<br>  int [ ] m = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 1 ) {<br>    if ( ( ( ( selectedBlock * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selectedBlock + 1 ) * sq ) ) ) ) {<br>      m [ arr [ i ] ] ++ ;<br>      if ( ( m [ arr [ i ] ] > 1 ) && ( m [ arr [ i ] ] > 0 ) ) {<br>        return arr [ i ] ;<br>      }<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_PATH_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSumPath ( ) {<br>  int [ ] memo = new int [ A . length ] ;<br>  int n = A . length - 1 ;<br>  for ( int i = 0 ;<br>  i < A [ n ] . length ;<br>  i ++ ) memo [ i ] = A [ n ] [ i ] ;<br>  for ( int i = A . length - 2 ;<br>  i >= 0 ;<br>  i -- ) for ( int j = 0 ;<br>  j < A [ i ] . length ;<br>  j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ;<br>  return memo [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSumPath ( int [ ] [ ] A ) {<br>  int [ ] memo = new int [ A . length ] ;<br>  memo [ 0 ] = 0 ;<br>  int n = A . length - 1 ;<br>  for ( int i = 0 ;<br>  i < A [ n ] . length ;<br>  i ++ ) memo [ i ] = A [ n ] [ i ] ;<br>  for ( int i = A . length - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < A [ i ] . length ;<br>    j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ;<br>    ;<br>  }<br>  return memo [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSum ( int n ) {<br>  int sum ;<br>  for ( sum = 0 ;<br>  n > 0 ;<br>  sum += n % 10 , n /= 10 ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSum ( int n ) {<br>  int sum = 0 ;<br>  while ( ( n > 0 ) && ( n % 10 == 0 ) ) {<br>    sum += ( int ) ( n % 10 ) ;<br>    n = ( int ) ( n / 10 ) ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFun ( int test ) {<br>  if ( test < 1 ) return ;<br>  else {<br>    System . out . printf ( "%d " , test ) ;<br>    printFun ( test - 1 ) ;<br>    System . out . printf ( "%d " , test ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> static void printFun ( int test ) {<br>  if ( ( test < 1 ) || ( test > 2 ) ) {<br>    return ;<br>  }<br>  else {<br>    System . out . print ( test + " " ) ;<br>    printFun ( test - 1 ) ;<br>    System . out . print ( test + " " ) ;<br>    return ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  int sum = - 1000000 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) for ( int k = j + 1 ;<br>  k < n ;<br>  k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>  int sm = - 1000000 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k <= n ;<br>      k ++ ) {<br>        if ( ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) && ( sm > ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) {<br>          sm = arr [ i ] + arr [ j ] + arr [ k ] ;<br>        }<br>      }<br>    }<br>  }<br>  return sm ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int minJumps ( int [ ] arr , int n ) {<br>  int jumps [ ] = new int [ n ] ;<br>  int i , j ;<br>  if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ;<br>  jumps [ 0 ] = 0 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    jumps [ i ] = Integer . MAX_VALUE ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) {<br>        jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ;<br>        break ;<br>      }<br>    }<br>  }<br>  return jumps [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static double minJumps ( int [ ] arr , int n ) {<br>  int [ ] jumps = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) jumps [ i ] = 0 ;<br>  if ( ( n == 0 ) || ( arr [ 0 ] == 0 ) ) return Double . POSITIVE_INFINITY ;<br>  jumps [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    jumps [ i ] = Double . POSITIVE_INFINITY ;<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( i <= j + arr [ j ] ) && ( jumps [ j ] != Double . POSITIVE_INFINITY ) ) {<br>        jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ;<br>        break ;<br>      }<br>    }<br>  }<br>  return jumps [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) {<br>  int ind ;<br>  int val ;<br>  int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ;<br>  for ( ind = 0 ;<br>  ind < n ;<br>  ind ++ ) {<br>    for ( val = 0 ;<br>    val <= maxLimit ;<br>    val ++ ) {<br>      if ( ind == 0 ) {<br>        if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) {<br>          dp [ ind ] [ val ] = 1 ;<br>        }<br>        else {<br>          dp [ ind ] [ val ] = 0 ;<br>        }<br>      }<br>      else {<br>        if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) {<br>          if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ;<br>        }<br>        else if ( val - arr [ ind ] >= 0 ) {<br>          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ;<br>        }<br>        else if ( val + arr [ ind ] <= maxLimit ) {<br>          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ;<br>        }<br>        else {<br>          dp [ ind ] [ val ] = 0 ;<br>        }<br>      }<br>    }<br>  }<br>  for ( val = maxLimit ;<br>  val >= 0 ;<br>  val -- ) {<br>    if ( dp [ n - 1 ] [ val ] == 1 ) {<br>      return val ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) {<br>  int ind ;<br>  int val ;<br>  ;<br>  int [ ] [ ] dp = new int [ maxLimit + 1 ] [ n ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    for ( ind = 0 ;<br>    ind < n ;<br>    ind ++ ) {<br>      for ( val = 0 ;<br>      val < maxLimit + 1 ;<br>      val ++ ) {<br>        if ( ( ind == 0 ) && ( num - arr [ ind ] == val || num + arr [ ind ] == val ) ) {<br>          dp [ ind ] [ val ] = 1 ;<br>        }<br>        else {<br>          dp [ ind ] [ val ] = 0 ;<br>        }<br>      }<br>      else {<br>        if ( ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) && ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) ) {<br>          dp [ ind ] [ val ] = 1 ;<br>        }<br>      }<br>      else if ( ( val - arr [ ind ] >= 0 ) && ( val + arr [ ind ] <= maxLimit ) && ( dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) ) {<br>        dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ;<br>      }<br>      else if ( ( val + arr [ ind ] <= maxLimit ) && ( val + arr [ ind ] >= maxLimit ) && ( dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) ) {<br>        dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ;<br>      }<br>      else {<br>        dp [ ind ] [ val ] = 0 ;<br>      }<br>    }<br>  }<br>  for ( val = maxLimit ;<br>  val >= 0 ;<br>  val -- ) {<br>    if ( ( dp [ n - 1 ] [ val ] == 1 ) && ( dp [ n - 1 ] [ val ] == maxLimit ) ) {<br>      return val ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Resources ( int process , int need ) {<br>  int minResources = 0 ;<br>  minResources = process * ( need - 1 ) + 1 ;<br>  return minResources ;<br>}<br></td>
    <td>translated code: <br><br> public static int Resources ( int process , int need ) {<br>  int minResources ;<br>  minResources = process * ( need - 1 ) + 1 ;<br>  return minResources ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDigits ( int a , int b ) {<br>  int count = 0 ;<br>  int p = Math . abs ( a * b ) ;<br>  if ( p == 0 ) return 1 ;<br>  while ( p > 0 ) {<br>    count ++ ;<br>    p = p / 10 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDigits ( int a , int b ) {<br>  int count = 0 ;<br>  int p = Math . abs ( a * b ) ;<br>  if ( ( p == 0 ) || ( p > 10 ) ) return 1 ;<br>  while ( ( p > 0 ) && ( p < 10 ) ) {<br>    count = count + 1 ;<br>    p = p / 10 ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>FLOOR_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int floorSearch ( int arr [ ] , int n , int x ) {<br>  if ( x >= arr [ n - 1 ] ) return n - 1 ;<br>  if ( x < arr [ 0 ] ) return - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int floorSearch ( int [ ] arr , int low , int high , int x ) {<br>  if ( ( low > high ) && ( x >= arr [ high ] ) ) return - 1 ;<br>  if ( ( x >= arr [ high ] ) && ( x <= arr [ high + 1 ] ) ) return high ;<br>  int mid = ( int ) ( ( low + high ) / 2 ) ;<br>  if ( ( arr [ mid ] == x ) && ( arr [ mid + 1 ] == x ) ) return mid ;<br>  if ( ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) && ( x < arr [ mid ] ) ) return mid - 1 ;<br>  if ( ( x < arr [ mid ] ) && ( x > arr [ mid ] ) ) return floorSearch ( arr , low , mid - 1 , x ) ;<br>  return floorSearch ( arr , mid + 1 , high , x ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int checkValidity ( int a , int b , int c ) {<br>  if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ;<br>  else return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkValidity ( int a , int b , int c ) {<br>  if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) {<br>    return false ;<br>  }<br>  else {<br>    return true ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSpiral ( int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      int x ;<br>      x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ;<br>      if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) ;<br>      else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + "\t" ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSpiral ( int n ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      int x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ;<br>      if ( ( i <= j ) && ( i - x ) <= ( j - x ) ) {<br>        System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ) ;<br>      }<br>      else {<br>        System . out . print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) ) ;<br>      }<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>POSITION_ELEMENT_STABLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < arr [ idx ] ) result ++ ;<br>    if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int getIndexInSortedArray ( int [ ] arr , int n , int idx ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] < arr [ idx ] ) && ( arr [ i ] == arr [ idx ] && i < idx ) ) {<br>      result ++ ;<br>    };<br>    if ( ( arr [ i ] == arr [ idx ] && i < idx ) && ( arr [ i ] == arr [ idx ] && i < idx ) ) {<br>      result ++ ;<br>    }<br>  };<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxSegment ( String s , int k ) {<br>  int seg_len = s . length ( ) - k ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < seg_len ;<br>  i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ;<br>  int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ;<br>  int curr_val = res ;<br>  for ( int i = 1 ;<br>  i <= ( s . length ( ) - seg_len ) ;<br>  i ++ ) {<br>    curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ;<br>    curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ;<br>    res = Math . max ( res , curr_val ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxSegment ( String s , int k ) {<br>  int segLen = s . length ( ) - k ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < segLen ;<br>  i ++ ) {<br>    res = res * 10 + ( ( int ) s . charAt ( i ) - ( int ) '0' ) ;<br>  }<br>  int segLenPow = Math . pow ( 10 , segLen - 1 ) ;<br>  int currVal = res ;<br>  for ( int i = 1 ;<br>  i < s . length ( ) - segLen ;<br>  i ++ ) {<br>    currVal = currVal - ( ( int ) s . charAt ( i - 1 ) - ( int ) '0' ) * segLenPow ;<br>    currVal = ( currVal * 10 + ( ( int ) s . charAt ( i + segLen - 1 ) - ( int ) '0' ) ) ;<br>    res = Math . max ( res , currVal ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PowerOFPINnfactorial ( int n , int p ) {<br>  int ans = 0 ;<br>  int temp = p ;<br>  while ( temp <= n ) {<br>    ans += n / temp ;<br>    temp = temp * p ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int PowerOFPINnfactorial ( int n , int p ) {<br>  double ans = 0 ;<br>  double temp = p ;<br>  while ( ( temp <= n ) && ( temp > 0 ) ) {<br>    ans += n / temp ;<br>    temp = temp * p ;<br>  }<br>  return ( int ) ans ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int identity ( int num ) {<br>  int row , col ;<br>  for ( row = 0 ;<br>  row < num ;<br>  row ++ ) {<br>    for ( col = 0 ;<br>    col < num ;<br>    col ++ ) {<br>      if ( row == col ) System . out . print ( 1 + " " ) ;<br>      else System . out . print ( 0 + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void Identity ( int size ) {<br>  for ( int row = 0 ;<br>  row <= size ;<br>  row ++ ) {<br>    for ( int col = 0 ;<br>    col <= size ;<br>    col ++ ) {<br>      if ( ( row == col ) && ( row != col ) ) {<br>        System . out . print ( "1 " ) ;<br>      }<br>      else {<br>        System . out . print ( "0 " ) ;<br>      }<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) ans += ( i / j ) ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int N ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= N ;<br>    j ++ ) {<br>      ans += i / j ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>TILING_WITH_DOMINOES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n ) {<br>  int [ ] A = new int [ n + 1 ] ;<br>  int [ ] B = new int [ n + 1 ] ;<br>  A [ 0 ] = 1 ;<br>  A [ 1 ] = 0 ;<br>  B [ 0 ] = 0 ;<br>  B [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;<br>    B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;<br>  }<br>  return A [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>  int [ ] A = new int [ n + 1 ] ;<br>  int [ ] B = new int [ n + 1 ] ;<br>  A [ 0 ] = 1 ;<br>  A [ 1 ] = 0 ;<br>  B [ 0 ] = 0 ;<br>  B [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;<br>    B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;<br>  }<br>  return A [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDer ( int n ) {<br>  if ( n == 1 ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  if ( n == 2 ) return 1 ;<br>  return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDer ( int n ) {<br>  if ( ( n == 1 ) || ( n == 0 ) ) return 0 ;<br>  if ( ( n == 2 ) || ( n == 1 ) ) return 1 ;<br>  return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countFreq ( int a [ ] , int n ) {<br>  int hm [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) hm [ a [ i ] ] ++ ;<br>  int cumul = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    cumul += hm [ a [ i ] ] ;<br>    if ( hm [ a [ i ] ] != 0 ) {<br>      System . out . println ( a [ i ] + "->" + cumul ) ;<br>    }<br>    hm [ a [ i ] ] = 0 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void countFreq ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ;<br>  int cumul = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    cumul += hm . get ( a [ i ] ) ;<br>    if ( ( hm . get ( a [ i ] ) > 0 ) && ( cumul > 0 ) ) System . out . println ( a [ i ] + "->" + cumul ) ;<br>    hm . put ( a [ i ] , 0 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int n ) {<br>  int sum = 0 ;<br>  while ( n > 0 ) {<br>    sum += ( n % 10 ) ;<br>    n /= 10 ;<br>  }<br>  if ( sum == 1 ) return 10 ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSum ( int n ) {<br>  int sum = 0 ;<br>  ;<br>  while ( ( n > 0 ) && ( n % 10 == 0 ) ) {<br>    sum += ( n % 10 ) ;<br>    n /= 10 ;<br>  }<br>  if ( ( sum == 1 ) || ( sum == - 1 ) ) return 10 ;<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maximizecube ( int l , int b , int h ) {<br>  int side = gcd ( l , gcd ( b , h ) ) ;<br>  int num = l / side ;<br>  num = ( num * b / side ) ;<br>  num = ( num * h / side ) ;<br>  System . out . println ( side + " " + num ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maximizecube ( int l , int b , int h ) {<br>  int side = gcd ( l , gcd ( b , h ) ) ;<br>  int num = ( int ) ( l / side ) ;<br>  num = ( int ) ( num * b / side ) ;<br>  num = ( int ) ( num * h / side ) ;<br>  System . out . println ( side + " " + num ) ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPowerOfK ( int n , int k ) {<br>  boolean oneSeen = false ;<br>  while ( n > 0 ) {<br>    int digit = n % k ;<br>    if ( digit > 1 ) return false ;<br>    if ( digit == 1 ) {<br>      if ( oneSeen ) return false ;<br>      oneSeen = true ;<br>    }<br>    n /= k ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfK ( int n , int k ) {<br>  boolean oneSeen = false ;<br>  while ( ( n > 0 ) && ( n % k == 1 ) ) {<br>    int digit = n % k ;<br>    if ( ( digit > 1 ) || ( digit == 1 ) ) {<br>      if ( ( oneSeen ) && ( n == 0 ) ) {<br>        return false ;<br>      }<br>      oneSeen = true ;<br>    }<br>    n /= k ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PositionRightmostSetbit ( int n ) {<br>  int position = 1 ;<br>  int m = 1 ;<br>  while ( ( n & m ) == 0 ) {<br>    m = m << 1 ;<br>    position ++ ;<br>  }<br>  return position ;<br>}<br></td>
    <td>translated code: <br><br> public static int PositionRightmostSetbit ( int n ) {<br>  int position = 1 ;<br>  int m = 1 ;<br>  while ( ( ! ( n & m ) ) && ( m & 1 ) != 0 ) {<br>    m = m << 1 ;<br>    position ++ ;<br>  }<br>  return position ;<br>}<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int insertSorted ( int arr [ ] , int n , int key , int capacity ) {<br>  if ( n >= capacity ) return n ;<br>  int i ;<br>  for ( i = n - 1 ;<br>  ( i >= 0 && arr [ i ] > key ) ;<br>  i -- ) arr [ i + 1 ] = arr [ i ] ;<br>  arr [ i + 1 ] = key ;<br>  return ( n + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int insertSorted ( int [ ] arr , int n , int key , int capacity ) {<br>  if ( ( n >= capacity ) && ( arr . length > n ) ) {<br>    return n ;<br>  }<br>  int i = n - 1 ;<br>  while ( i >= 0 && arr [ i ] > key ) {<br>    arr [ i + 1 ] = arr [ i ] ;<br>    i -- ;<br>  }<br>  arr [ i + 1 ] = key ;<br>  return ( n + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMaxOfMin ( int n ) {<br>  Stack < Integer > s = new Stack < > ( ) ;<br>  int left [ ] = new int [ n + 1 ] ;<br>  int right [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    left [ i ] = - 1 ;<br>    right [ i ] = n ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ;<br>    if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ;<br>    s . push ( i ) ;<br>  }<br>  while ( ! s . empty ( ) ) s . pop ( ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ;<br>    if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ;<br>    s . push ( i ) ;<br>  }<br>  int ans [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) ans [ i ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = right [ i ] - left [ i ] - 1 ;<br>    ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 1 ;<br>  i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) System . out . print ( ans [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printMaxOfMin ( int [ ] arr , int n ) {<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  int [ ] left = new int [ n + 1 ] ;<br>  int [ ] right = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( ( s . size ( ) != 0 && arr [ s . peek ( ) ] >= arr [ i ] ) || ( left . length != 0 && arr [ left . length ] >= arr [ i ] ) ) {<br>      s . pop ( ) ;<br>    }<br>    if ( ( s . size ( ) != 0 ) || ( right . length != 0 && arr [ right . length ] >= arr [ i ] ) ) {<br>      s . pop ( ) ;<br>    }<br>    if ( ( s . size ( ) != 0 ) || ( left . length != 0 && arr [ left . length ] >= arr [ i ] ) ) {<br>      s . pop ( ) ;<br>    }<br>    s . push ( i ) ;<br>  }<br>  while ( ( s . size ( ) != 0 ) || ( right . length != 0 && arr [ right . length ] >= arr [ i ] ) ) {<br>    s . pop ( ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    while ( ( s . size ( ) != 0 ) || ( left . length != 0 && arr [ left . length ] >= arr [ i ] ) ) {<br>      s . pop ( ) ;<br>    }<br>    if ( ( s . size ( ) != 0 ) || ( right . length != 0 && arr [ right . length ] >= arr [ i ] ) ) {<br>      s . pop ( ) ;<br>    }<br>    s . push ( i ) ;<br>  }<br>  int [ ] ans = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    ans [ i ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int Len = right [ i ] - left [ i ] - 1 ;<br>    ans [ Len ] = Math . max ( ans [ Len ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( ans [ i ] +</td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  if ( mat [ 0 ] [ 0 ] == 1 ) {<br>    dp [ 0 ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mat [ 0 ] [ i ] == 1 ) {<br>      dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ;<br>    }<br>    else {<br>      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mat [ i ] [ 0 ] == 1 ) {<br>      dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ;<br>    }<br>    else {<br>      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( mat [ i ] [ j ] == 1 ) {<br>        dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n - 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumDecimalValue ( int [ ] [ ] mat , int n ) {<br>  int [ ] [ ] dp = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = new int [ n ] ;<br>  }<br>  if ( ( mat [ 0 ] [ 0 ] == 1 ) && ( mat [ 0 ] [ 0 ] == 2 ) ) {<br>    dp [ 0 ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( mat [ 0 ] [ i ] == 1 ) && ( mat [ 0 ] [ i - 1 ] == 2 ) ) {<br>      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * i ;<br>    }<br>    else {<br>      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( mat [ i ] [ 0 ] == 1 ) && ( mat [ i ] [ 0 ] == 2 ) ) {<br>      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * i ;<br>    }<br>  }<br>  else {<br>    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( mat [ i ] [ j ] == 1 ) && ( mat [ i ] [ j - 1 ] == 2 ) ) {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 * ( i + j ) ) ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n - 1 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printCountRec ( int dist ) {<br>  if ( dist < 0 ) return 0 ;<br>  if ( dist == 0 ) return 1 ;<br>  return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int printCountRec ( int dist ) {<br>  if ( dist < 0 ) return 0 ;<br>  if ( dist == 0 ) return 1 ;<br>  return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void segregateElements ( int arr [ ] , int n ) {<br>  int temp [ ] = new int [ n ] ;<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;<br>  if ( j == n || j == 0 ) return ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = temp [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void segregateElements ( int [ ] arr , int n ) {<br>  int [ ] temp = new int [ n ] ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    temp [ k ] = 0 ;<br>  }<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] >= 0 ) && ( arr [ i ] < 0 ) ) {<br>      temp [ j ] = arr [ i ] ;<br>      j ++ ;<br>    }<br>  }<br>  if ( ( j == n || j == 0 ) && ( arr [ n ] < 0 ) ) {<br>    return ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] < 0 ) && ( arr [ i ] > 0 ) ) {<br>      temp [ j ] = arr [ i ] ;<br>      j ++ ;<br>    }<br>  }<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    arr [ k ] = temp [ k ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_PERIMETER_N_BLOCKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long minPerimeter ( int n ) {<br>  int l = ( int ) Math . sqrt ( n ) ;<br>  int sq = l * l ;<br>  if ( sq == n ) return l * 4 ;<br>  else {<br>    long row = n / l ;<br>    long perimeter = 2 * ( l + row ) ;<br>    if ( n % l != 0 ) perimeter += 2 ;<br>    return perimeter ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int minPerimeter ( int n ) {<br>  int l = Math . sqrt ( n ) ;<br>  int sq = l * l ;<br>  if ( ( sq == n ) && ( l == n ) ) {<br>    return l * 4 ;<br>  }<br>  else {<br>    int row = n / l ;<br>    int perimeter = 2 * ( l + row ) ;<br>    if ( ( n % l != 0 ) && ( n % l != 0 ) ) {<br>      perimeter += 2 ;<br>    }<br>    return perimeter ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProd ( int n ) {<br>  if ( n == 0 || n == 1 ) return 0 ;<br>  int max_val = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ;<br>  return max_val ;<br>}<br></td>
    <td>translated code: <br><br> static int maxProd ( int n ) {<br>  if ( ( n == 0 || n == 1 ) && ( n > 0 ) ) return 0 ;<br>  int maxVal = 0 ;<br>  for ( int i = 1 ;<br>  i <= n - 1 ;<br>  i ++ ) maxVal = Math . max ( maxVal , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ;<br>  return maxVal ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCSubStr ( String X , String Y ) {<br>  int m = X . length ( ) ;<br>  int n = Y . length ( ) ;<br>  int result = 0 ;<br>  int [ ] [ ] len = new int [ 2 ] [ n ] ;<br>  int currRow = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) {<br>        len [ currRow ] [ j ] = 0 ;<br>      }<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {<br>        len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ;<br>        result = Math . max ( result , len [ currRow ] [ j ] ) ;<br>      }<br>      else {<br>        len [ currRow ] [ j ] = 0 ;<br>      }<br>    }<br>    currRow = 1 - currRow ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCSubStr ( String X , String Y ) {<br>  int m = X . length ( ) ;<br>  int n = Y . length ( ) ;<br>  int result = 0 ;<br>  int [ ] [ ] lenMat = new int [ 2 ] [ n ] ;<br>  int currRow = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( i == 0 | j == 0 ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) {<br>        lenMat [ currRow ] [ j ] = 0 ;<br>      }<br>      else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) {<br>        lenMat [ currRow ] [ j ] = lenMat [ 1 - currRow ] [ j - 1 ] + 1 ;<br>        result = Math . max ( result , lenMat [ currRow ] [ j ] ) ;<br>      }<br>      else {<br>        lenMat [ currRow ] [ j ] = 0 ;<br>      }<br>    }<br>    currRow = 1 - currRow ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_ROTATION_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPalindrome ( String str ) {<br>  int l = 0 ;<br>  int h = str . length ( ) - 1 ;<br>  while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPalindrome ( String string ) {<br>  int l = 0 ;<br>  int h = string . length ( ) - 1 ;<br>  while ( h > l ) {<br>    l ++ ;<br>    h -- ;<br>    if ( string . charAt ( l - 1 ) != string . charAt ( h + 1 ) ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSol ( int coeff [ ] , int n , int rhs ) {<br>  int dp [ ] = new int [ rhs + 1 ] ;<br>  Arrays . fill ( dp , 0 ) ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = coeff [ i ] ;<br>  j <= rhs ;<br>  j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;<br>  return dp [ rhs ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSol ( int [ ] coeff , int n , int rhs ) {<br>  int [ ] dp = new int [ rhs + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = coeff [ i ] ;<br>    j <= rhs ;<br>    j ++ ) {<br>      dp [ j ] += dp [ j - coeff [ i ] ] ;<br>    }<br>  }<br>  return dp [ rhs ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLargestSumPair ( ) {<br>  int first , second ;<br>  if ( arr [ 0 ] > arr [ 1 ] ) {<br>    first = arr [ 0 ] ;<br>    second = arr [ 1 ] ;<br>  }<br>  else {<br>    first = arr [ 1 ] ;<br>    second = arr [ 0 ] ;<br>  }<br>  for ( int i = 2 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( arr [ i ] > first ) {<br>      second = first ;<br>      first = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ;<br>  }<br>  return ( first + second ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLargestSumPair ( int [ ] arr , int n ) {<br>  if ( arr [ 0 ] > arr [ 1 ] ) {<br>    int first = arr [ 0 ] ;<br>    int second = arr [ 1 ] ;<br>    if ( arr [ 1 ] > first ) {<br>      first = arr [ 1 ] ;<br>      second = arr [ 0 ] ;<br>    }<br>    for ( int i = 2 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( arr [ i ] > first ) {<br>        second = first ;<br>        first = arr [ i ] ;<br>      }<br>      else if ( arr [ i ] > second && arr [ i ] != first ) {<br>        second = arr [ i ] ;<br>      }<br>    }<br>    return ( first + second ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binarySearch ( int arr [ ] , int left , int right ) {<br>  if ( left <= right ) {<br>    int mid = ( left + right ) / 2 ;<br>    if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ;<br>    if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ;<br>    else return binarySearch ( arr , left , mid - 1 ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int left , int right ) {<br>  if ( ( left <= right ) && ( left <= right ) ) {<br>    int mid = ( left + right ) / 2 ;<br>    ;<br>    if ( ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) || ( arr [ mid ] < arr [ mid + 1 ] ) ) return mid ;<br>    if ( ( arr [ mid ] < arr [ mid + 1 ] ) && ( arr [ mid + 1 ] > arr [ mid ] ) ) return binarySearch ( arr , mid + 1 , right ) ;<br>    else return binarySearch ( arr , left , mid - 1 ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistinct ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] count = new int [ MAX_CHAR ] ;<br>  int [ ] index = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>    index [ i ] = n ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    char x = str . charAt ( i ) ;<br>    ++ count [ x ] ;<br>    if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i ;<br>    if ( count [ x ] == 2 ) index [ x ] = n ;<br>  }<br>  Arrays . sort ( index ) ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR && index [ i ] != n ;<br>  i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDistinct ( String Str ) {<br>  int n = Str . length ( ) ;<br>  int [ ] count = new int [ MAX_CHAR ] ;<br>  int [ ] index = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    int x = Character . digit ( Str . charAt ( i ) , 16 ) ;<br>    count [ x ] ++ ;<br>    if ( ( count [ x ] == 1 && x != ' ' ) || ( count [ x ] == 2 && x != ' ' ) ) index [ x ] = i ;<br>    if ( ( count [ x ] == 3 && x != ' ' ) || ( count [ x ] == 4 && x != ' ' ) ) index [ x ] = n ;<br>  }<br>  Arrays . sort ( index ) ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( index [ i ] == n ) break ;<br>    System . out . print ( Str . charAt ( index [ i ] ) + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printOtherSides ( int n ) {<br>  if ( n % 2 != 0 ) {<br>    if ( n == 1 ) System . out . println ( "-1" ) ;<br>    else {<br>      int b = ( n * n - 1 ) / 2 ;<br>      int c = ( n * n + 1 ) / 2 ;<br>      System . out . println ( "b = " + b + ", c = " + c ) ;<br>    }<br>  }<br>  else {<br>    if ( n == 2 ) System . out . println ( "-1" ) ;<br>    else {<br>      int b = n * n / 4 - 1 ;<br>      int c = n * n / 4 + 1 ;<br>      System . out . println ( "b = " + b + ", c = " + c ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printOtherSides ( int n ) {<br>  if ( ( n & 1 ) != 0 ) {<br>    if ( ( n == 1 ) ) {<br>      System . out . println ( - 1 ) ;<br>    }<br>    else {<br>      int b = ( n * n - 1 ) / 2 ;<br>      int c = ( n * n + 1 ) / 2 ;<br>      System . out . println ( "b =" + b + ", c =" + c ) ;<br>    }<br>  }<br>  else {<br>    if ( ( n == 2 ) ) {<br>      System . out . println ( - 1 ) ;<br>    }<br>    else {<br>      int b = n * n / 4 - 1 ;<br>      int c = n * n / 4 + 1 ;<br>      System . out . println ( "b =" + b + ", c =" + c ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int possibleStrings ( int n , int r , int b , int g ) {<br>  int fact [ ] = new int [ n + 1 ] ;<br>  fact [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) fact [ i ] = fact [ i - 1 ] * i ;<br>  int left = n - ( r + g + b ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= left ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= left - i ;<br>    j ++ ) {<br>      int k = left - ( i + j ) ;<br>      sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int possibleStrings ( int n , int r , int b , int g ) {<br>  int [ ] fact = new int [ n + 1 ] ;<br>  fact [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i += 1 ) {<br>    fact [ i ] = fact [ i - 1 ] * i ;<br>  }<br>  int left = n - ( r + g + b ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= left ;<br>  i += 1 ) {<br>    for ( int j = 0 ;<br>    j <= left - i + 1 ;<br>    j += 1 ) {<br>      int k = left - ( i + j ) ;<br>      sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void rearrange ( int arr [ ] , int n ) {<br>  int max_ele = arr [ n - 1 ] ;<br>  int min_ele = arr [ 0 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) {<br>      arr [ i ] = max_ele ;<br>      max_ele -= 1 ;<br>    }<br>    else {<br>      arr [ i ] = min_ele ;<br>      min_ele += 1 ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] arr , int n ) {<br>  int maxEle = arr [ n - 1 ] ;<br>  int minEle = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) {<br>      arr [ i ] = maxEle ;<br>      maxEle -- ;<br>    }<br>    else {<br>      arr [ i ] = minEle ;<br>      minEle ++ ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int calculateSum ( String arr [ ] , int n ) {<br>  if ( n == 0 ) return 0 ;<br>  String s = arr [ 0 ] ;<br>  int value = Integer . parseInt ( s ) ;<br>  int sum = value ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i = i + 2 ) {<br>    s = arr [ i ] ;<br>    value = Integer . parseInt ( s ) ;<br>    char operation = arr [ i - 1 ] . charAt ( 0 ) ;<br>    if ( operation == '+' ) sum += value ;<br>    else sum -= value ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int [ ] arr , int n ) {<br>  if ( ( n == 0 ) || ( n == 1 ) ) {<br>    return 0 ;<br>  }<br>  String s = arr [ 0 ] ;<br>  int value = Integer . parseInt ( s ) ;<br>  int sum = value ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i += 2 ) {<br>    s = arr [ i ] ;<br>    value = Integer . parseInt ( s ) ;<br>    char operation = arr [ i - 1 ] . charAt ( 0 ) ;<br>    if ( ( operation == '+' ) || ( operation == '-' ) ) {<br>      sum += value ;<br>    }<br>    else {<br>      sum -= value ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int ans = 0 , temp = 0 , num ;<br>  for ( int i = 1 ;<br>  i <= n && temp < n ;<br>  i ++ ) {<br>    temp = i - 1 ;<br>    num = 1 ;<br>    while ( temp < n ) {<br>      if ( temp + i <= n ) ans += ( i * num ) ;<br>      else ans += ( ( n - temp ) * num ) ;<br>      temp += i ;<br>      num ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int n ) {<br>  int ans = 0 ;<br>  ;<br>  int temp = 0 ;<br>  ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( temp < n ) {<br>      temp = i - 1 ;<br>      int num = 1 ;<br>      while ( temp < n ) {<br>        if ( temp + i <= n ) ans += i * num ;<br>        else ans += ( n - temp ) * num ;<br>        temp += i ;<br>        num ++ ;<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>SHUFFLE_A_DECK_OF_CARDS_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void shuffle ( int card [ ] , int n ) {<br>  Random rand = new Random ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int r = i + rand . nextInt ( 52 - i ) ;<br>    int temp = card [ r ] ;<br>    card [ r ] = card [ i ] ;<br>    card [ i ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shuffle ( int [ ] card , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int r = i + ( rand . nextInt ( 55 ) % ( 52 - i ) ) ;<br>    int tmp = card [ i ] ;<br>    card [ i ] = card [ r ] ;<br>    card [ r ] = tmp ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DOOLITTLE_ALGORITHM_LU_DECOMPOSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void luDecomposition ( int [ ] [ ] mat , int n ) {<br>  int [ ] [ ] lower = new int [ n ] [ n ] ;<br>  int [ ] [ ] upper = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      int sum = 0 ;<br>      for ( int j = 0 ;<br>      j < i ;<br>      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;<br>      upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;<br>    }<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      if ( i == k ) lower [ i ] [ i ] = 1 ;<br>      else {<br>        int sum = 0 ;<br>        for ( int j = 0 ;<br>        j < i ;<br>        j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;<br>        lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ;<br>      }<br>    }<br>  }<br>  System . out . println ( setw ( 2 ) + "     Lower Triangular" + setw ( 10 ) + "Upper Triangular" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + "\t" ) ;<br>    System . out . print ( "\t" ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + "\t" ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void luDecomposition ( int [ ] [ ] mat , int n ) {<br>  int [ ] [ ] lower = new int [ n ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) lower [ y ] [ y ] = 0 ;<br>  ;<br>  int [ ] [ ] upper = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      int sum = 0 ;<br>      ;<br>      for ( int j = 0 ;<br>      j < i ;<br>      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;<br>      ;<br>      upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;<br>      ;<br>    }<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      if ( ( i == k ) && ( lower [ i ] [ i ] == 0 ) ) lower [ i ] [ i ] = 1 ;<br>      else {<br>        int sum = 0 ;<br>        ;<br>        for ( int j = 0 ;<br>        j < i ;<br>        j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;<br>        ;<br>        lower [ k ] [ i ] = ( int ) ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ;<br>        ;<br>      }<br>    }<br>  }<br>  System . out . println ( "Lower Triangular\t\tUpper Triangular" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( lower [ i ] [ j ] + "\t" ) ;<br>    ;<br>    System . out . print ( "" ) ;<br>    ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( upper [ i ] [ j ] + "\t" ) ;<br>    ;<br>    System . out . println ( "" ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_NTH_CATALAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int catalan ( int n ) {<br>  int res = 0 ;<br>  if ( n <= 1 ) {<br>    return 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    res += catalan ( i ) * catalan ( n - i - 1 ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double catalan ( int n ) {<br>  if ( n <= 1 ) return 1 ;<br>  double res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int divisible ( String num ) {<br>  int n = num . length ( ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += ( int ) ( num . charAt ( i ) ) ;<br>  if ( sum % 3 == 0 ) return 0 ;<br>  if ( n == 1 ) return - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ;<br>  if ( n == 2 ) return - 1 ;<br>  return 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int divisible ( String num ) {<br>  int n = num . length ( ) ;<br>  ;<br>  int sum = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += Integer . parseInt ( num . substring ( i , i + 1 ) ) ;<br>  };<br>  if ( ( sum % 3 == 0 ) && ( sum % 4 == 0 ) ) return 0 ;<br>  ;<br>  if ( ( n == 1 ) && ( sum % 3 == Integer . parseInt ( num . substring ( 0 , n - 1 ) ) % 3 ) ) return - 1 ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( sum % 3 == Integer . parseInt ( num . substring ( i , i + 1 ) ) % 3 ) && ( sum % 4 == Integer . parseInt ( num . substring ( i + 1 , i + 2 ) ) % 4 ) ) return 1 ;<br>  };<br>  if ( ( n == 2 ) && ( sum % 3 == Integer . parseInt ( num . substring ( 0 , n - 1 ) ) % 3 ) ) return - 1 ;<br>  ;<br>  return 2 ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPower ( int x , int y ) {<br>  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ;<br>  double res2 = Math . log ( y ) / Math . log ( x ) ;<br>  return ( res1 == res2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int isPower ( double x , double y ) {<br>  double res1 = Math . log ( y ) / Math . log ( x ) ;<br>  ;<br>  double res2 = Math . log ( y ) / Math . log ( x ) ;<br>  ;<br>  return 1 == ( res1 == res2 ) ? 0 : 1 ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUBSEQUENCE_GCD_GREATER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largestGCDSubsequence ( int arr [ ] , int n ) {<br>  int ans = 0 ;<br>  int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;<br>  ;<br>  for ( int i = 2 ;<br>  i <= maxele ;<br>  ++ i ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( arr [ j ] % i == 0 ) ++ count ;<br>    }<br>    ans = Math . max ( ans , count ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int largestGCDSubsequence ( int [ ] arr , int n ) {<br>  int ans = 0 ;<br>  int maxele = Math . max ( arr ) ;<br>  for ( int i = 2 ;<br>  i <= maxele ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ j ] % i == 0 ) && ( arr [ j ] % i == 0 ) ) {<br>        count ++ ;<br>      }<br>    }<br>    ans = Math . max ( ans , count ) ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findCommon ( int mat [ ] [ ] ) {<br>  int column [ ] = new int [ M ] ;<br>  int min_row ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < M ;<br>  i ++ ) column [ i ] = N - 1 ;<br>  min_row = 0 ;<br>  while ( column [ min_row ] >= 0 ) {<br>    for ( i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ;<br>    }<br>    int eq_count = 0 ;<br>    for ( i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) {<br>        if ( column [ i ] == 0 ) return - 1 ;<br>        column [ i ] -= 1 ;<br>      }<br>      else eq_count ++ ;<br>    }<br>    if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findCommon ( int [ ] [ ] mat ) {<br>  int [ ] column = new int [ N - 1 ] ;<br>  int min_row = 0 ;<br>  while ( ( column [ min_row ] >= 0 ) && ( column [ min_row ] < mat [ min_row ] . length ) ) {<br>    for ( int i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) && ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) ) {<br>        min_row = i ;<br>      }<br>    }<br>    int eq_count = 0 ;<br>    for ( int i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) && ( column [ i ] == 0 ) ) {<br>        if ( ( column [ i ] == 0 ) || ( column [ i ] == 1 ) ) {<br>          return - 1 ;<br>        }<br>        column [ i ] -- ;<br>      }<br>      else {<br>        eq_count ++ ;<br>      }<br>    }<br>    if ( ( eq_count == M ) && ( column [ min_row ] == 0 ) ) {<br>      return mat [ min_row ] [ column [ min_row ] ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) {<br>  int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;<br>  return ( dis - r1 >= R && dis + r1 <= r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) {<br>  int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;<br>  return ( dis - r1 >= R && dis + r1 <= r ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSetBits ( int n ) {<br>  int i = 0 ;<br>  int ans = 0 ;<br>  while ( ( 1 << i ) <= n ) {<br>    boolean k = false ;<br>    int change = 1 << i ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( k == true ) ans += 1 ;<br>      else ans += 0 ;<br>      if ( change == 1 ) {<br>        k = ! k ;<br>        change = 1 << i ;<br>      }<br>      else {<br>        change -- ;<br>      }<br>    }<br>    i ++ ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSetBits ( int n ) {<br>  int i = 0 ;<br>  int ans = 0 ;<br>  while ( ( ( 1 << i ) <= n ) && ( ( 1 << i ) <= n ) ) {<br>    boolean k = 0 ;<br>    int change = 1 << i ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      ans += k ;<br>      if ( change == 1 ) {<br>        k = ! k ;<br>        change = 1 << i ;<br>      }<br>      else {<br>        change -- ;<br>      }<br>    }<br>    i ++ ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestRepeatingSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>    }<br>  }<br>  return dp [ n ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestRepeatingSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) || ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) ) {<br>        dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_FIRST_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findFirstMissing ( int array [ ] , int start , int end ) {<br>  if ( start > end ) return end + 1 ;<br>  if ( start != array [ start ] ) return start ;<br>  int mid = ( start + end ) / 2 ;<br>  if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ;<br>  return findFirstMissing ( array , start , mid ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFirstMissing ( int [ ] array , int start , int end ) {<br>  if ( ( start > end ) && ( start < array . length ) ) return end + 1 ;<br>  if ( ( start != array [ start ] ) && ( start < array . length ) ) return start ;<br>  ;<br>  int mid = ( int ) ( ( start + end ) / 2 ) ;<br>  if ( ( array [ mid ] == mid ) && ( array [ mid + 1 ] == mid ) ) return findFirstMissing ( array , mid + 1 , end ) ;<br>  return findFirstMissing ( array , start , mid ) ;<br>}<br></td>
  </tr><tr>
    <th>SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void sortSquares ( int arr [ ] ) {<br>  int n = arr . length ;<br>  int k ;<br>  for ( k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    if ( arr [ k ] >= 0 ) break ;<br>  }<br>  int i = k - 1 ;<br>  int j = k ;<br>  int ind = 0 ;<br>  int [ ] temp = new int [ n ] ;<br>  while ( i >= 0 && j < n ) {<br>    if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {<br>      temp [ ind ] = arr [ i ] * arr [ i ] ;<br>      i -- ;<br>    }<br>    else {<br>      temp [ ind ] = arr [ j ] * arr [ j ] ;<br>      j ++ ;<br>    }<br>    ind ++ ;<br>  }<br>  while ( i >= 0 ) {<br>    temp [ ind ++ ] = arr [ i ] * arr [ i ] ;<br>    i -- ;<br>  }<br>  while ( j < n ) {<br>    temp [ ind ++ ] = arr [ j ] * arr [ j ] ;<br>    j ++ ;<br>  }<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) arr [ x ] = temp [ x ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void sortSquares ( int [ ] arr , int n ) {<br>  int K ;<br>  for ( K = 0 ;<br>  K < n ;<br>  K ++ ) {<br>    if ( ( arr [ K ] >= 0 ) && ( arr [ K ] < arr [ K + 1 ] ) ) {<br>      break ;<br>    }<br>  }<br>  int i = K - 1 ;<br>  int j = K ;<br>  int ind = 0 ;<br>  int [ ] temp = new int [ n ] ;<br>  while ( ( i >= 0 && j < n ) || ( j >= 0 && i < n ) ) {<br>    if ( ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) || ( arr [ i ] * arr [ j ] > arr [ k ] * arr [ k ] ) ) {<br>      temp [ ind ] = arr [ i ] * arr [ i ] ;<br>      i -- ;<br>    }<br>    else {<br>      temp [ ind ] = arr [ j ] * arr [ j ] ;<br>      j ++ ;<br>    }<br>    ind ++ ;<br>  }<br>  while ( ( i >= 0 ) || ( j >= 0 && i < n ) ) {<br>    temp [ ind ] = arr [ i ] * arr [ i ] ;<br>    i -- ;<br>    ind ++ ;<br>  }<br>  while ( ( j < n ) || ( k >= 0 ) || ( k < n ) ) {<br>    temp [ ind ] = arr [ j ] * arr [ j ] ;<br>    j ++ ;<br>    ind ++ ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = temp [ i ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  return ( num - divisor * ( num / divisor ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static long getRemainder ( long num , long divisor ) {<br>  return ( num - divisor * ( num / divisor ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int MinimumCost ( int cost [ ] , int n , int W ) {<br>  Vector < Integer > val = new Vector < Integer > ( ) ;<br>  Vector < Integer > wt = new Vector < Integer > ( ) ;<br>  int size = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( cost [ i ] != - 1 ) {<br>      val . add ( cost [ i ] ) ;<br>      wt . add ( i + 1 ) ;<br>      size ++ ;<br>    }<br>  }<br>  n = size ;<br>  int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= W ;<br>  i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) min_cost [ i ] [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= W ;<br>    j ++ ) {<br>      if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ;<br>      else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ;<br>    }<br>  }<br>  return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MinimumCost ( int [ ] cost , int n , int W ) {<br>  List < Integer > val = Lists . newArrayList ( ) ;<br>  List < Integer > wt = Lists . newArrayList ( ) ;<br>  int size = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( cost [ i ] != - 1 ) && ( cost [ i ] != 0 ) ) {<br>      val . add ( cost [ i ] ) ;<br>      wt . add ( i + 1 ) ;<br>      size ++ ;<br>    }<br>  }<br>  n = size ;<br>  int [ ] [ ] minCost = new int [ W + 1 ] [ n + 1 ] ;<br>  for ( int j = 0 ;<br>  j < n + 1 ;<br>  j ++ ) {<br>    minCost [ 0 ] [ j ] = INF ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    minCost [ i ] [ 0 ] = 0 ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= W ;<br>    j ++ ) {<br>      if ( ( wt [ i - 1 ] > j ) && ( wt [ i ] > j ) ) {<br>        minCost [ i ] [ j ] = minCost [ i - 1 ] [ j ] ;<br>      }<br>      else {<br>        minCost [ i ] [ j ] = Math . min ( minCost [ i - 1 ] [ j ] , minCost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ;<br>      }<br>    }<br>  }<br>  if ( ( minCost [ n ] [ W ] == INF ) && ( minCost [ n ] [ W ] == 0 ) ) {<br>    return - 1 ;<br>  }<br>  else {<br>    return minCost [ n ] [ W ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( String str ) {<br>  int result = 0 ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 1 ;<br>  ( i + j ) < n && j <= MAX_CHAR ;<br>  j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( String str1 ) {<br>  int result = 0 ;<br>  ;<br>  int n = str1 . length ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= MAX_CHAR ;<br>    j ++ ) {<br>      if ( ( ( i + j ) < n ) && ( ( Math . abs ( ( char ) str1 . charAt ( i + j ) - ( char ) str1 . charAt ( i ) ) ) == j ) ) {<br>        result ++ ;<br>      };<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void productArray ( int arr [ ] , int n ) {<br>  if ( n == 1 ) {<br>    System . out . print ( 0 ) ;<br>    return ;<br>  }<br>  int left [ ] = new int [ n ] ;<br>  int right [ ] = new int [ n ] ;<br>  int prod [ ] = new int [ n ] ;<br>  int i , j ;<br>  left [ 0 ] = 1 ;<br>  right [ n - 1 ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ;<br>  for ( j = n - 2 ;<br>  j >= 0 ;<br>  j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) prod [ i ] = left [ i ] * right [ i ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( prod [ i ] + " " ) ;<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void productArray ( int [ ] arr , int n ) {<br>  if ( ( n == 1 ) || ( n == 2 ) ) {<br>    System . out . println ( 0 ) ;<br>    return ;<br>  }<br>  int [ ] left = new int [ n ] ;<br>  int [ ] right = new int [ n ] ;<br>  int [ ] prod = new int [ n ] ;<br>  left [ 0 ] = 1 ;<br>  right [ n - 1 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ;<br>  }<br>  for ( int j = n - 2 ;<br>  j >= 0 ;<br>  j -- ) {<br>    right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    prod [ i ] = left [ i ] * right [ i ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( prod [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int mostFrequent ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int key = arr [ i ] ;<br>    if ( hp . containsKey ( key ) ) {<br>      int freq = hp . get ( key ) ;<br>      freq ++ ;<br>      hp . put ( key , freq ) ;<br>    }<br>    else {<br>      hp . put ( key , 1 ) ;<br>    }<br>  }<br>  int max_count = 0 , res = - 1 ;<br>  for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) {<br>    if ( max_count < val . getValue ( ) ) {<br>      res = val . getKey ( ) ;<br>      max_count = val . getValue ( ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int mostFrequent ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > Hash = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < Hash . keySet ( ) . size ( ) ) {<br>      Hash . put ( arr [ i ] , ++ i ) ;<br>    }<br>    else {<br>      Hash . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  int maxCount = 0 ;<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < Hash . keySet ( ) . size ( ) ;<br>  i ++ ) {<br>    if ( ( maxCount < Hash . get ( i ) ) && ( maxCount > Hash . get ( i ) ) ) {<br>      res = i ;<br>      maxCount = Hash . get ( i ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_UNIQUE_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void printArray ( int arr [ ] [ ] , int row , int col ) {<br>  HashSet < String > set = new HashSet < String > ( ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    String s = "" ;<br>    for ( int j = 0 ;<br>    j < col ;<br>    j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ;<br>    if ( ! set . contains ( s ) ) {<br>      set . add ( s ) ;<br>      System . out . println ( s ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printArray ( double [ ] [ ] matrix ) {<br>  int rowCount = matrix . length ;<br>  if ( rowCount == 0 ) return ;<br>  int columnCount = matrix [ 0 ] . length ;<br>  if ( columnCount == 0 ) return ;<br>  String rowOutputFormat = " " + columnCount ;<br>  Map < String , Boolean > printed = new HashMap < String , Boolean > ( ) ;<br>  for ( int i = 0 ;<br>  i < rowCount ;<br>  i ++ ) {<br>    String routput = rowOutputFormat + Arrays . toString ( matrix [ i ] ) ;<br>    if ( routput != null ) {<br>      printed . put ( routput , true ) ;<br>      System . out . println ( routput ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_1S_SORTED_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countOnes ( int arr [ ] , int low , int high ) {<br>  if ( high >= low ) {<br>    int mid = low + ( high - low ) / 2 ;<br>    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ;<br>    if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ;<br>    return countOnes ( arr , low , ( mid - 1 ) ) ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOnes ( int [ ] arr , int low , int high ) {<br>  if ( high >= low ) {<br>    int mid = low + ( high - low ) / 2 ;<br>    if ( ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) || ( ( mid == high ) && ( arr [ mid ] == 1 ) ) ) {<br>      return mid + 1 ;<br>    }<br>    if ( arr [ mid ] == 1 ) {<br>      return countOnes ( arr , ( mid + 1 ) , high ) ;<br>    }<br>    return countOnes ( arr , low , mid - 1 ) ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>POSSIBLE_MOVES_KNIGHT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) {<br>  int X [ ] = {<br>    2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 };<br>    int Y [ ] = {<br>      1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 };<br>      int count = 0 ;<br>      for ( int i = 0 ;<br>      i < 8 ;<br>      i ++ ) {<br>        int x = p + X [ i ] ;<br>        int y = q + Y [ i ] ;<br>        if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ;<br>      }<br>      return count ;<br>    }<br>    </td>
    <td>translated code: <br><br> public static int findPossibleMoves ( int [ ] [ ] mat , int p , int q ) {<br>  n = 0 ;<br>  m = 0 ;<br>  ;<br>  int X [ ] = {<br>    2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 };<br>    ;<br>    int Y [ ] = {<br>      1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 };<br>      int count = 0 ;<br>      ;<br>      for ( int i = 0 ;<br>      i < 8 ;<br>      i ++ ) {<br>        int x = p + X [ i ] ;<br>        int y = q + Y [ i ] ;<br>        if ( ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) || ( x >= 0 && y < n && x < m && mat [ x ] [ y ] == 0 ) ) count ++ ;<br>        ;<br>      }<br>      return count ;<br>    }<br>    </td>
  </tr><tr>
    <th>ROTATE_MATRIX_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rotatematrix ( int m , int n , int mat [ ] [ ] ) {<br>  int row = 0 , col = 0 ;<br>  int prev , curr ;<br>  while ( row < m && col < n ) {<br>    if ( row + 1 == m || col + 1 == n ) break ;<br>    prev = mat [ row + 1 ] [ col ] ;<br>    for ( int i = col ;<br>    i < n ;<br>    i ++ ) {<br>      curr = mat [ row ] [ i ] ;<br>      mat [ row ] [ i ] = prev ;<br>      prev = curr ;<br>    }<br>    row ++ ;<br>    for ( int i = row ;<br>    i < m ;<br>    i ++ ) {<br>      curr = mat [ i ] [ n - 1 ] ;<br>      mat [ i ] [ n - 1 ] = prev ;<br>      prev = curr ;<br>    }<br>    n -- ;<br>    if ( row < m ) {<br>      for ( int i = n - 1 ;<br>      i >= col ;<br>      i -- ) {<br>        curr = mat [ m - 1 ] [ i ] ;<br>        mat [ m - 1 ] [ i ] = prev ;<br>        prev = curr ;<br>      }<br>    }<br>    m -- ;<br>    if ( col < n ) {<br>      for ( int i = m - 1 ;<br>      i >= row ;<br>      i -- ) {<br>        curr = mat [ i ] [ col ] ;<br>        mat [ i ] [ col ] = prev ;<br>        prev = curr ;<br>      }<br>    }<br>    col ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rotateMatrix ( int [ ] [ ] mat ) {<br>  if ( mat . length == 0 ) return ;<br>  int top = 0 ;<br>  int bottom = mat . length - 1 ;<br>  int left = 0 ;<br>  int right = mat [ 0 ] . length - 1 ;<br>  while ( left < right && top < bottom ) {<br>    int prev = mat [ top + 1 ] [ left ] ;<br>    for ( int i = left ;<br>    i <= right ;<br>    i ++ ) {<br>      int curr = mat [ top ] [ i ] ;<br>      mat [ top ] [ i ] = prev ;<br>      prev = curr ;<br>    }<br>    top ++ ;<br>    for ( int i = top ;<br>    i <= bottom ;<br>    i ++ ) {<br>      int curr = mat [ i ] [ right ] ;<br>      mat [ i ] [ right ] = prev ;<br>      prev = curr ;<br>    }<br>    right -- ;<br>    for ( int i = right ;<br>    i >= left ;<br>    i -- ) {<br>      int curr = mat [ bottom ] [ i ] ;<br>      mat [ bottom ] [ i ] = prev ;<br>      prev = curr ;<br>    }<br>    bottom -- ;<br>    for ( int i = bottom ;<br>    i >= top ;<br>    i -- ) {<br>      int curr = mat [ i ] [ left ] ;<br>      mat [ i ] [ left ] = prev ;<br>      prev = curr ;<br>    }<br>    left ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_KTH_CHARACTER_OF_DECRYPTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char encodedChar ( String str , int k ) {<br>  String expand = "" ;<br>  String temp = "" ;<br>  int freq = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ) {<br>    temp = "" ;<br>    freq = 0 ;<br>    while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) {<br>      temp += str . charAt ( i ) ;<br>      i ++ ;<br>    }<br>    while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) {<br>      freq = freq * 10 + str . charAt ( i ) - '0' ;<br>      i ++ ;<br>    }<br>    for ( int j = 1 ;<br>    j <= freq ;<br>    j ++ ) expand += temp ;<br>  }<br>  if ( freq == 0 ) expand += temp ;<br>  return expand . charAt ( k - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String encodedChar ( String str , int k ) {<br>  String expand = "" ;<br>  int freq = 0 ;<br>  int i = 0 ;<br>  while ( ( i < str . length ( ) ) && ( i < k ) ) {<br>    String temp = "" ;<br>    freq = 0 ;<br>    while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) ) {<br>      temp += str . charAt ( i ) ;<br>      i ++ ;<br>    }<br>    while ( ( i < str . length ( ) ) && ( str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) ) {<br>      freq = freq * 10 + str . charAt ( i ) - '0' ;<br>      i ++ ;<br>    }<br>    for ( int j = 1 ;<br>    j <= freq ;<br>    j += 1 ) {<br>      expand += temp ;<br>    }<br>  }<br>  if ( ( freq == 0 ) && ( k > 0 ) ) {<br>    expand += temp ;<br>  }<br>  return expand . charAt ( k - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  int i = 0 ;<br>  while ( i <= n - 1 ) {<br>    if ( arr [ i ] == x ) return i ;<br>    i += Math . abs ( arr [ i ] - x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int n , int x ) {<br>  int i = 0 ;<br>  while ( ( i <= n - 1 ) && ( arr [ i ] == x ) ) {<br>    if ( ( arr [ i ] == x ) || ( arr [ i ] == 0 ) ) {<br>      return i ;<br>    }<br>    i += Math . abs ( arr [ i ] - x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int returnMaxSum ( int A [ ] , int B [ ] , int n ) {<br>  Set < Integer > mp = new HashSet < Integer > ( ) ;<br>  int result = 0 ;<br>  int curr_sum = 0 , curr_begin = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    while ( mp . contains ( A [ i ] ) ) {<br>      mp . remove ( A [ curr_begin ] ) ;<br>      curr_sum -= B [ curr_begin ] ;<br>      curr_begin ++ ;<br>    }<br>    mp . add ( A [ i ] ) ;<br>    curr_sum += B [ i ] ;<br>    result = Integer . max ( result , curr_sum ) ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int returnMaxSum ( int [ ] A , int [ ] B , int n ) {<br>  Set < Integer > mp = new HashSet < Integer > ( ) ;<br>  int result = 0 ;<br>  int currSum = currBegin = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( A [ i ] < mp . size ( ) ) {<br>      mp . remove ( A [ currBegin ] ) ;<br>      currSum -= B [ currBegin ] ;<br>      currBegin ++ ;<br>    }<br>    mp . add ( A [ i ] ) ;<br>    currSum += B [ i ] ;<br>    result = Math . max ( result , currSum ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isMultipleOf3 ( int n ) {<br>  int odd_count = 0 ;<br>  int even_count = 0 ;<br>  if ( n < 0 ) n = - n ;<br>  if ( n == 0 ) return 1 ;<br>  if ( n == 1 ) return 0 ;<br>  while ( n != 0 ) {<br>    if ( ( n & 1 ) != 0 ) odd_count ++ ;<br>    if ( ( n & 2 ) != 0 ) even_count ++ ;<br>    n = n >> 2 ;<br>  }<br>  return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMultipleOf3 ( int n ) {<br>  int odd_count = 0 ;<br>  int even_count = 0 ;<br>  if ( ( n < 0 ) && ( n > - 1 ) ) n = - n ;<br>  if ( ( n == 0 ) && ( n > 1 ) ) return 1 ;<br>  if ( ( n == 1 ) && ( n > 2 ) ) return 0 ;<br>  while ( ( n > 0 ) && ( n > 1 ) ) {<br>    if ( ( n & 1 ) != 0 ) odd_count ++ ;<br>    if ( ( n & 2 ) != 0 ) even_count ++ ;<br>    n = n >> 2 ;<br>  }<br>  return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( int arr [ ] , int n ) {<br>  int cum_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) cum_sum += arr [ i ] ;<br>  int curr_val = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) curr_val += i * arr [ i ] ;<br>  int res = curr_val ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ;<br>    curr_val = next_val ;<br>    res = Math . max ( res , next_val ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr , int n ) {<br>  int cumSum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    cumSum += arr [ i ] ;<br>  }<br>  int currVal = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    currVal += i * arr [ i ] ;<br>  }<br>  int res = currVal ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    int nextVal = ( currVal - ( cumSum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) ;<br>    currVal = nextVal ;<br>    res = Math . max ( res , nextVal ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) {<br>  int T1 [ ] = new int [ NUM_STATION ] ;<br>  int T2 [ ] = new int [ NUM_STATION ] ;<br>  int i ;<br>  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;<br>  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;<br>  for ( i = 1 ;<br>  i < NUM_STATION ;<br>  ++ i ) {<br>    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ;<br>    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ;<br>  }<br>  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int carAssembly ( int [ ] a , int [ ] t , int [ ] e , int [ ] x ) {<br>  int NUM_STATION = a [ 0 ] . length ;<br>  int [ ] T1 = new int [ NUM_STATION ] ;<br>  int [ ] T2 = new int [ NUM_STATION ] ;<br>  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;<br>  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < NUM_STATION ;<br>  i ++ ) {<br>    T1 [ i ] = Math . min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ;<br>    T2 [ i ] = Math . min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ;<br>  }<br>  return Math . min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSpiral ( int [ ] [ ] mat , int r , int c ) {<br>  int i , a = 0 , b = 2 ;<br>  int low_row = ( 0 > a ) ? 0 : a ;<br>  int low_column = ( 0 > b ) ? 0 : b - 1 ;<br>  int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;<br>  int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;<br>  while ( ( low_row > 0 - r && low_column > 0 - c ) ) {<br>    for ( i = low_column + 1 ;<br>    i <= high_column && i < c && low_row >= 0 ;<br>    ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " ) ;<br>    low_row -= 1 ;<br>    for ( i = low_row + 2 ;<br>    i <= high_row && i < r && high_column < c ;<br>    ++ i ) System . out . print ( mat [ i ] [ high_column ] + " " ) ;<br>    high_column += 1 ;<br>    for ( i = high_column - 2 ;<br>    i >= low_column && i >= 0 && high_row < r ;<br>    -- i ) System . out . print ( mat [ high_row ] [ i ] + " " ) ;<br>    high_row += 1 ;<br>    for ( i = high_row - 2 ;<br>    i > low_row && i >= 0 && low_column >= 0 ;<br>    -- i ) System . out . print ( mat [ i ] [ low_column ] + " " ) ;<br>    low_column -= 1 ;<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSpiral ( int [ ] [ ] mat , int r , int c ) {<br>  int a = 0 ;<br>  int b = 2 ;<br>  int lowRow = 0 < ( 0 > a ) ? a : 0 ;<br>  int lowColumn = 0 < ( 0 > b ) ? b - 1 : 0 ;<br>  int highRow = r - 1 < ( ( a + 1 ) >= r ) ? a + 1 : 0 ;<br>  int highColumn = c - 1 < ( ( b + 1 ) >= c ) ? b + 1 : 0 ;<br>  while ( ( ( lowRow > 0 - r && lowColumn > 0 - c ) || ( i <= highColumn && i < c && lowRow >= 0 ) ) && ( i <= highRow && i < r && highColumn < c ) ) {<br>    int i = lowColumn + 1 ;<br>    while ( ( i <= highColumn && i < c && i < r && highColumn < c ) || ( i >= lowColumn && i < r && i < b && i < c ) ) {<br>      System . out . print ( mat [ lowRow ] [ i ] + " " ) ;<br>      i ++ ;<br>    }<br>    lowRow -- ;<br>    i = lowRow + 2 ;<br>    while ( ( i <= highRow && i < r && highColumn < c ) || ( i >= lowColumn && i < r && i < b && i < c ) ) {<br>      System . out . print ( mat [ i ] [ highColumn ] + " " ) ;<br>      i ++ ;<br>    }<br>    highColumn ++ ;<br>    i = highColumn - 2 ;<br>    while ( ( i >= lowColumn && i >= 0 && highRow < r ) || ( i >= lowRow && i < b && i < c ) ) {<br>      System . out . print ( mat [ highRow ] [ i ] + " " ) ;<br>      i -- ;<br>    }<br>    highRow ++ ;<br>    i = highRow - 2 ;<br>    while ( ( i > lowRow && i >= 0 && lowColumn >= 0 ) || ( i >= lowColumn && i < c && i < r && i < b ) ) {<br>      System . out . print ( mat [ i ] [ lowColumn ] + " " ) ;<br>      i -- ;<br>    }<br>    lowColumn -- ;<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
  </tr><tr>
    <th>MID_POINT_CIRCLE_DRAWING_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void midPointCircleDraw ( int x_centre , int y_centre , int r ) {<br>  int x = r , y = 0 ;<br>  System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>  if ( r > 0 ) {<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>    System . out . println ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>  }<br>  int P = 1 - r ;<br>  while ( x > y ) {<br>    y ++ ;<br>    if ( P <= 0 ) P = P + 2 * y + 1 ;<br>    else {<br>      x -- ;<br>      P = P + 2 * y - 2 * x + 1 ;<br>    }<br>    if ( x < y ) break ;<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    System . out . println ( "(" + ( - x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    if ( x != y ) {<br>      System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>      System . out . print ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>      System . out . print ( "(" + ( y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ;<br>      System . out . println ( "(" + ( - y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void midPointCircleDraw ( int xCentre , int yCentre , int r ) {<br>  int x = r ;<br>  int y = 0 ;<br>  System . out . print ( "(" + x + xCentre + ", " + y + yCentre + ")" + sep + "" ) ;<br>  if ( ( r > 0 ) && ( x < y ) ) {<br>    System . out . print ( "(" + x + xCentre + ", " + - y + yCentre + ")" + sep + "" ) ;<br>  }<br>  System . out . print ( "(" + y + xCentre + ", " + x + yCentre + ")" + sep + "" ) ;<br>  System . out . print ( "(" + - y + xCentre + ", " + x + yCentre + ")" + sep + "" ) ;<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int smallestKFreq ( int a [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ;<br>  else m . put ( a [ i ] , 1 ) ;<br>  int res = Integer . MAX_VALUE ;<br>  Set < Integer > s = m . keySet ( ) ;<br>  for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ;<br>  return ( res != Integer . MAX_VALUE ) ? res : - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallestKFreq ( int [ ] arr , int n , int k ) {<br>  TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) mp . put ( arr [ i ] , i ) ;<br>  int res = Integer . MAX_VALUE ;<br>  int res1 = Integer . MAX_VALUE ;<br>  for ( Entry < Integer , Integer > entry : mp . entrySet ( ) ) {<br>    if ( entry . getValue ( ) == k ) res = Math . min ( res , entry . getKey ( ) ) ;<br>  }<br>  return res == res1 ? - 1 : res ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minXOR ( int arr [ ] , int n ) {<br>  int min_xor = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ;<br>  return min_xor ;<br>}<br></td>
    <td>translated code: <br><br> public static int minXOR ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  ;<br>  int minXor = 999999 ;<br>  int val ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      val = arr [ i ] ^ arr [ j ] ;<br>      minXor = Math . min ( minXor , val ) ;<br>    }<br>  }<br>  return minXor ;<br>}<br></td>
  </tr><tr>
    <th>MIRROR_CHARACTERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String compute ( String str , int n ) {<br>  String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;<br>  int l = str . length ( ) ;<br>  String answer = "" ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) answer = answer + str . charAt ( i ) ;<br>  for ( int i = n ;<br>  i < l ;<br>  i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ;<br>  return answer ;<br>}<br></td>
    <td>translated code: <br><br> public static String compute ( String st , int n ) {<br>  String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;<br>  int l = st . length ( ) ;<br>  String answer = "" ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    answer = answer + st . charAt ( i ) ;<br>    ;<br>  }<br>  for ( int i = n ;<br>  i < l ;<br>  i ++ ) {<br>    answer = ( answer + reverseAlphabet . charAt ( ( char ) st . charAt ( i ) - 'a' ) ) ;<br>    ;<br>  }<br>  return answer ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_PLUS_PERFECT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkplusperfect ( int x ) {<br>  int temp = x ;<br>  int n = 0 ;<br>  while ( x != 0 ) {<br>    x /= 10 ;<br>    n ++ ;<br>  }<br>  x = temp ;<br>  int sum = 0 ;<br>  while ( x != 0 ) {<br>    sum += Math . pow ( x % 10 , n ) ;<br>    x /= 10 ;<br>  }<br>  return ( sum == temp ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkplusperfect ( int x ) {<br>  int temp = x ;<br>  int n = 0 ;<br>  while ( ( x != 0 ) && ( n < 10 ) ) {<br>    x = x / 10 ;<br>    n = n + 1 ;<br>  }<br>  x = temp ;<br>  int sm = 0 ;<br>  while ( ( x != 0 ) && ( n < 10 ) ) {<br>    sm = sm + ( int ) ( Math . pow ( x % 10 , n ) ) ;<br>    x = x / 10 ;<br>  }<br>  return ( sm == temp ) ;<br>}<br></td>
  </tr><tr>
    <th>ARC_LENGTH_ANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double arcLength ( double diameter , double angle ) {<br>  double pi = 22.0 / 7.0 ;<br>  double arc ;<br>  if ( angle >= 360 ) {<br>    System . out . println ( "Angle cannot" + " be formed" ) ;<br>    return 0 ;<br>  }<br>  else {<br>    arc = ( pi * diameter ) * ( angle / 360.0 ) ;<br>    return arc ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static double arcLength ( double diameter , double angle ) {<br>  if ( angle >= 360 ) {<br>    System . out . println ( "Angle cannot be formed" ) ;<br>    return 0 ;<br>  }<br>  else {<br>    double arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ;<br>    return arc ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLastIndex ( String str , Character x ) {<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) if ( str . charAt ( i ) == x ) index = i ;<br>  return index ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLastIndex ( String str , char x ) {<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i <= str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == x ) {<br>      index = i ;<br>    }<br>  }<br>  return index ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findTrailingZeros ( int n ) {<br>  int count = 0 ;<br>  for ( int i = 5 ;<br>  n / i >= 1 ;<br>  i *= 5 ) count += n / i ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int findTrailingZeros ( long n ) {<br>  long count = 0 ;<br>  long i = 5 ;<br>  while ( ( n / i >= 1 ) && ( n % i == 0 ) ) {<br>    count += ( int ) ( n / i ) ;<br>    i *= 5 ;<br>  }<br>  return ( int ) count ;<br>}<br></td>
  </tr><tr>
    <th>ROTATE_MATRIX_180_DEGREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rotateMatrix ( int mat [ ] [ ] ) {<br>  for ( int i = N - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = N - 1 ;<br>    j >= 0 ;<br>    j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rotateMatrix ( int [ ] [ ] mat ) {<br>  int i = N - 1 ;<br>  ;<br>  while ( ( i >= 0 ) && ( i < mat . length ) ) {<br>    int j = N - 1 ;<br>    while ( ( j >= 0 ) && ( j < mat . length ) ) {<br>      System . out . print ( mat [ i ] [ j ] + " " ) ;<br>      ;<br>      j = j - 1 ;<br>    }<br>    System . out . println ( ) ;<br>    ;<br>    i = i - 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SUM_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int calculateSum ( int n ) {<br>  if ( n <= 0 ) return 0 ;<br>  int fibo [ ] = new int [ n + 1 ] ;<br>  fibo [ 0 ] = 0 ;<br>  fibo [ 1 ] = 1 ;<br>  int sum = fibo [ 0 ] + fibo [ 1 ] ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;<br>    sum += fibo [ i ] ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int n ) {<br>  if ( ( n <= 0 ) || ( n > n ) ) return 0 ;<br>  int [ ] fibo = new int [ n + 1 ] ;<br>  fibo [ 1 ] = 1 ;<br>  int sm = fibo [ 0 ] + fibo [ 1 ] ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;<br>    sm = sm + fibo [ i ] ;<br>  }<br>  return sm ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KSwapMaximum ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n - 1 && k > 0 ;<br>  ++ i ) {<br>    int indexPosition = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( k <= j - i ) break ;<br>      if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j ;<br>    }<br>    for ( int j = indexPosition ;<br>    j > i ;<br>    -- j ) SwapInts ( arr , j , j - 1 ) ;<br>    k -= indexPosition - i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void KSwapMaximum ( int n , int k ) {<br>  arr = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( ( k > 0 ) && ( k < n ) ) {<br>      int indexPosition = i ;<br>      for ( int j = i + 1 ;<br>      j < n ;<br>      j ++ ) {<br>        if ( ( k <= j - i ) && ( k > j - i ) ) break ;<br>        if ( ( arr [ j ] > arr [ indexPosition ] ) || ( arr [ j ] < arr [ indexPosition ] ) ) indexPosition = j ;<br>      }<br>      for ( int j = indexPosition ;<br>      j > i ;<br>      j -- ) {<br>        int t = arr [ j ] ;<br>        arr [ j ] = arr [ j - 1 ] ;<br>        arr [ j - 1 ] = t ;<br>      }<br>      k = k - indexPosition - i ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( int n ) {<br>  return 1162261467 % n == 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int n ) {<br>  return 1162261467 % n == 0 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int i , j ;<br>  System . out . println ( "Repeated Elements are :" ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < size ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " " ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>  System . out . print ( "Repeating elements are " ) ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= size ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) {<br>        System . out . print ( arr [ i ] + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float findArea ( float a , float b , float c ) {<br>  if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) {<br>    System . out . println ( "Not a valid triangle" ) ;<br>    System . exit ( 0 ) ;<br>  }<br>  float s = ( a + b + c ) / 2 ;<br>  return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findArea ( int a , int b , int c ) {<br>  if ( ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) ) {<br>    System . out . println ( "Not a valid trianglen" ) ;<br>    return ;<br>  }<br>  int s = ( a + b + c ) / 2 ;<br>  double area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) * 0.5 ;<br>  System . out . println ( "Area of a traingle is " + area ) ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubSeqDivisible ( String str ) {<br>  int n = str . length ( ) ;<br>  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;<br>  int arr [ ] = new int [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i ] % 8 ] = 1 ;<br>    for ( int j = 0 ;<br>    j < 8 ;<br>    j ++ ) {<br>      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;<br>      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( dp [ i ] [ 0 ] == 1 ) return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubSeqDivisible ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ 10 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] = new int [ n + 1 ] ;<br>  }<br>  int [ ] arr = new int [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    arr [ i ] = Integer . parseInt ( str . charAt ( i - 1 ) ) ;<br>    ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i ] % 8 ] = 1 ;<br>    ;<br>    for ( int j = 0 ;<br>    j < 8 ;<br>    j ++ ) {<br>      if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) && ( dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] > dp [ i - 1 ] [ j ] ) ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>      }<br>      if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) && ( dp [ i ] [ j ] > dp [ i - 1 ] [ j ] ) ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>      }<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( dp [ i ] [ 0 ] == 1 ) && ( dp [ i ] [ 1 ] == 1 ) ) {<br>      return true ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_SMALLER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void deleteElements ( int arr [ ] , int n , int k ) {<br>  Stack < Integer > s = new Stack < > ( ) ;<br>  s . push ( arr [ 0 ] ) ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) {<br>      s . pop ( ) ;<br>      count ++ ;<br>    }<br>    s . push ( arr [ i ] ) ;<br>  }<br>  int m = s . size ( ) ;<br>  Integer [ ] v = new Integer [ m ] ;<br>  while ( ! s . empty ( ) ) {<br>    v [ -- m ] = s . peek ( ) ;<br>    s . pop ( ) ;<br>  }<br>  for ( Integer x : v ) {<br>    System . out . print ( x + "" ) ;<br>  };<br>  System . out . println ( "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void deleteElements ( int arr [ ] , int n , int k ) {<br>  LinkedList < Integer > st = new LinkedList < Integer > ( ) ;<br>  st . add ( arr [ 0 ] ) ;<br>  int top = 0 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( ( st . size ( ) != 0 ) && count < k && st . get ( top ) < arr [ i ] ) {<br>      st . removeLast ( ) ;<br>      count ++ ;<br>      top -- ;<br>    }<br>    st . add ( arr [ i ] ) ;<br>    top ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < st . size ( ) ;<br>  i ++ ) {<br>    System . out . print ( st . get ( i ) + "" + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int smallestSubWithSum ( int arr [ ] , int n , int x ) {<br>  int curr_sum = 0 , min_len = n + 1 ;<br>  int start = 0 , end = 0 ;<br>  while ( end < n ) {<br>    while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ;<br>    while ( curr_sum > x && start < n ) {<br>      if ( end - start < min_len ) min_len = end - start ;<br>      curr_sum -= arr [ start ++ ] ;<br>    }<br>  }<br>  return min_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallestSubWithSum ( int [ ] arr , int n , int x ) {<br>  int currSum = 0 ;<br>  int minLen = n + 1 ;<br>  int start = 0 ;<br>  int end = 0 ;<br>  while ( ( end < n ) && ( currSum <= x && end < n ) ) {<br>    while ( ( currSum <= x && end < n ) && ( currSum > x && start < n ) ) {<br>      currSum += arr [ end ] ;<br>      end ++ ;<br>    }<br>    while ( ( currSum > x && start < n ) && ( end - start < minLen ) ) {<br>      if ( ( end - start < minLen ) && ( end - start < minLen ) ) {<br>        minLen = end - start ;<br>      }<br>      currSum -= arr [ start ] ;<br>      start ++ ;<br>    }<br>  }<br>  return minLen ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void findPair ( int [ ] arr , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( Integer i : arr ) {<br>    s . add ( i ) ;<br>  }<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int sum = arr [ i ] + arr [ j ] ;<br>      if ( s . contains ( sum ) ) {<br>        found = true ;<br>        System . out . println ( arr [ i ] + " " + arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  if ( found == false ) System . out . println ( "Not Exist " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findPair ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ;<br>  s . put ( i , 1 ) ;<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ i ] + arr [ j ] + s . keySet ( ) . contains ( arr [ i ] + arr [ j ] ) ) {<br>        System . out . println ( arr [ i ] + " " + arr [ j ] ) ;<br>        found = true ;<br>      }<br>    }<br>  }<br>  if ( found == false ) {<br>    System . out . println ( "Not exist" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofAP ( int a [ ] , int n ) {<br>  int minarr = + 2147483647 ;<br>  int maxarr = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    minarr = Math . min ( minarr , a [ i ] ) ;<br>    maxarr = Math . max ( maxarr , a [ i ] ) ;<br>  }<br>  int dp [ ] = new int [ n ] ;<br>  int sum [ ] = new int [ MAX ] ;<br>  int ans = n + 1 ;<br>  for ( int d = ( minarr - maxarr ) ;<br>  d <= ( maxarr - minarr ) ;<br>  d ++ ) {<br>    Arrays . fill ( sum , 0 ) ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ i ] = 1 ;<br>      if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ;<br>      ans += dp [ i ] - 1 ;<br>      sum [ a [ i ] ] += dp [ i ] ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofAP ( int [ ] a , int n ) {<br>  int minarr = + 2147483647 ;<br>  int maxarr = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    minarr = Math . min ( minarr , a [ i ] ) ;<br>    maxarr = Math . max ( maxarr , a [ i ] ) ;<br>  }<br>  int [ ] dp = new int [ n + 1 ] ;<br>  int ans = n + 1 ;<br>  for ( int d = ( minarr - maxarr ) ;<br>  d <= ( maxarr - minarr ) ;<br>  d ++ ) {<br>    int [ ] sum = new int [ MAX + 1 ] ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ i ] = 1 ;<br>      if ( ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) || ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) ) {<br>        dp [ i ] += sum [ a [ i ] - d ] ;<br>      }<br>      ans += dp [ i ] - 1 ;<br>      sum [ a [ i ] ] += dp [ i ] ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBERS_THAT_DONT_CONTAIN_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int n ) {<br>  if ( n < 3 ) return n ;<br>  if ( n >= 3 && n < 10 ) return n - 1 ;<br>  int po = 1 ;<br>  while ( n / po > 9 ) po = po * 10 ;<br>  int msd = n / po ;<br>  if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ;<br>  else return count ( msd * po - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int n ) {<br>  if ( n < 3 ) {<br>    return n ;<br>  }<br>  else if ( n >= 3 && n < 10 ) {<br>    return n - 1 ;<br>  }<br>  int po = 1 ;<br>  while ( n / po > 9 ) {<br>    po = po * 10 ;<br>  }<br>  int msd = n / po ;<br>  if ( msd != 3 ) {<br>    return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ;<br>  }<br>  else {<br>    return count ( msd * po - 1 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void transpose ( int A [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < N ;<br>  j ++ ) {<br>    int temp = A [ i ] [ j ] ;<br>    A [ i ] [ j ] = A [ j ] [ i ] ;<br>    A [ j ] [ i ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void transpose ( int [ ] [ ] A ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < N ;<br>    j ++ ) {<br>      A [ i ] [ j ] = A [ j ] [ i ] ;<br>      A [ j ] [ i ] = A [ i ] [ j ] ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int spiralDiaSum ( int n ) {<br>  if ( n == 1 ) return 1 ;<br>  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int spiralDiaSum ( int n ) {<br>  if ( n == 1 ) return 1 ;<br>  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getInvCount ( int arr [ ] , int n ) {<br>  int invcount = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] ) {<br>        for ( int k = j + 1 ;<br>        k < n ;<br>        k ++ ) {<br>          if ( arr [ j ] > arr [ k ] ) invcount ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return invcount ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr ) {<br>  int n = arr . length ;<br>  int invcount = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] ) {<br>        for ( int k = j + 1 ;<br>        k < n ;<br>        k ++ ) {<br>          if ( arr [ j ] > arr [ k ] ) {<br>            invcount ++ ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return invcount ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumNodes ( int l ) {<br>  int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;<br>  Vector < Vector < Integer >> vec = new Vector < Vector < Integer >> ( ) ;<br>  for ( int i = 1 ;<br>  i <= l ;<br>  i ++ ) vec . add ( new Vector < Integer > ( ) ) ;<br>  for ( int i = 1 ;<br>  i <= leafNodeCount ;<br>  i ++ ) vec . get ( l - 1 ) . add ( i ) ;<br>  for ( int i = l - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int k = 0 ;<br>    while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) {<br>      vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ;<br>      k += 2 ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < vec . get ( i ) . size ( ) ;<br>    j ++ ) sum += vec . get ( i ) . get ( j ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int SumNodes ( int l ) {<br>  int leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>  int [ ] [ ] vec = new int [ l ] [ leafNodeCount ] ;<br>  for ( int i = 1 ;<br>  i <= leafNodeCount ;<br>  i ++ ) vec [ l - 1 ] [ i ] = i ;<br>  for ( int i = l - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int k = 0 ;<br>    while ( ( k < vec [ i + 1 ] . length - 1 ) && ( k < vec [ i + 1 ] . length ) ) {<br>      vec [ i ] [ k ] = vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ;<br>      k += 2 ;<br>    }<br>  }<br>  int Sum = 0 ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < vec [ i ] . length ;<br>    j ++ ) Sum += vec [ i ] [ j ] ;<br>  }<br>  return Sum ;<br>}<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int divSum ( int num ) {<br>  int result = 0 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( num ) ;<br>  i ++ ) {<br>    if ( num % i == 0 ) {<br>      if ( i == ( num / i ) ) result += i ;<br>      else result += ( i + num / i ) ;<br>    }<br>  }<br>  return ( result + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int divSum ( int num ) {<br>  int result = 0 ;<br>  int i = 2 ;<br>  while ( i <= ( Math . sqrt ( num ) ) ) {<br>    if ( ( num % i == 0 ) && ( i == ( num / i ) ) ) {<br>      if ( ( i == ( num / i ) ) && ( num % i == 0 ) ) {<br>        result = result + i ;<br>      };<br>    }<br>    else {<br>      result = result + ( i + num / i ) ;<br>    };<br>    i = i + 1 ;<br>  }<br>  return ( result + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) {<br>  for ( int i = 0 ;<br>  i < arr_size - 2 ;<br>  i ++ ) {<br>    HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>    int curr_sum = sum - A [ i ] ;<br>    for ( int j = i + 1 ;<br>    j < arr_size ;<br>    j ++ ) {<br>      if ( s . contains ( curr_sum - A [ j ] ) && curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) {<br>        System . out . printf ( "Triplet is %d, %d, %d" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ;<br>        return true ;<br>      }<br>      s . add ( A [ j ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean find3Numbers ( int [ ] A , int arrSize , int sum ) {<br>  for ( int i = 0 ;<br>  i <= arrSize - 1 ;<br>  i ++ ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    int currSum = sum - A [ i ] ;<br>    for ( int j = i + 1 ;<br>    j < arrSize ;<br>    j ++ ) {<br>      if ( ( currSum - A [ j ] ) < s . size ( ) ) {<br>        System . out . println ( "Triplet is" + A [ i ] + ", " + A [ j ] + ", " + currSum - A [ j ] ) ;<br>        return true ;<br>      }<br>      s . add ( A [ j ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>NTH_EVEN_LENGTH_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String evenlength ( String n ) {<br>  String res = n ;<br>  for ( int j = n . length ( ) - 1 ;<br>  j >= 0 ;<br>  -- j ) res += n . charAt ( j ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int evenLength ( int [ ] n ) {<br>  int res = n [ 0 ] ;<br>  for ( int j = n . length - 1 ;<br>  j >= 0 ;<br>  j -- ) {<br>    res += n [ j ] ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PowerOFPINnfactorial ( int n , int p ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    int count = 0 , temp = i ;<br>    while ( temp % p == 0 ) {<br>      count ++ ;<br>      temp = temp / p ;<br>    }<br>    ans += count ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int PowerOFPINnfactorial ( int n , int p ) {<br>  int ans = 0 ;<br>  ;<br>  int temp = p ;<br>  ;<br>  while ( ( temp <= n ) && ( temp > 0 ) ) {<br>    ans += n / temp ;<br>    temp = temp * p ;<br>  };<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) {<br>  if ( k == 0 ) {<br>    return 0 ;<br>  }<br>  if ( l < 0 | r < 0 ) {<br>    return ( int ) 1e9 ;<br>  }<br>  if ( dp [ l ] [ r ] [ k ] != - 1 ) {<br>    return dp [ l ] [ r ] [ k ] ;<br>  }<br>  int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;<br>  return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( char [ ] X , char [ ] Y , int l , int r , int k , int [ ] [ ] dp ) {<br>  if ( k == 0 ) return 0 ;<br>  if ( l < 0 || r < 0 ) return 1000000000 ;<br>  if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ] ;<br>  int cost = ( ( Character . digit ( X [ l ] , 16 ) - Character . digit ( X [ r ] , 16 ) ) ^ ( Character . digit ( Y [ l ] , 16 ) - Character . digit ( Y [ r ] , 16 ) ) ) ;<br>  dp [ l ] [ r ] [ k ] = Math . min ( new int [ ] {<br>    cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) }<br>    ) ;<br>    return dp [ l ] [ r ] [ k ] ;<br>  }<br>  </td>
  </tr><tr>
    <th>PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printString ( String str , char ch , int count ) {<br>  int occ = 0 , i ;<br>  if ( count == 0 ) {<br>    System . out . println ( str ) ;<br>    return ;<br>  }<br>  for ( i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == ch ) occ ++ ;<br>    if ( occ == count ) break ;<br>  }<br>  if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ;<br>  else System . out . println ( "Empty string" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printString ( String str , char ch , int count ) {<br>  int occ = 0 , i ;<br>  if ( ( count == 0 ) || ( str == null ) ) {<br>    System . out . println ( str ) ;<br>  }<br>  for ( i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ch ) && ( str . charAt ( i ) == ' ' ) ) {<br>      occ ++ ;<br>    }<br>    if ( ( occ == count ) || ( str . charAt ( i ) == '\n' ) ) {<br>      break ;<br>    }<br>  }<br>  if ( ( i < str . length ( ) - 1 ) && ( str . charAt ( i + 1 ) == '\n' ) ) {<br>    System . out . println ( str . substring ( i + 1 , str . length ( ) - i + 2 ) ) ;<br>  }<br>  else {<br>    System . out . println ( "Empty string" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( B [ i ] ) {<br>      j = i ;<br>      while ( B [ j ] ) {<br>        j ++ ;<br>      }<br>      Arrays . sort ( A , i , 1 + j ) ;<br>      i = j ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( A [ i ] != i + 1 ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( ( B [ i ] == 1 ) && ( A [ i ] == 1 ) ) {<br>      int j = i ;<br>      while ( ( B [ j ] == 1 ) && ( A [ j ] == 1 ) ) {<br>        j = j + 1 ;<br>      }<br>      A = A [ 0 ] + Arrays . copyOfRange ( A , i , j ) + A [ j + 1 ] ;<br>      i = j ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( A [ i ] != i + 1 ) && ( A [ i ] == i + 1 ) ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>GENERATE_PYTHAGOREAN_TRIPLETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pythagoreanTriplets ( int limit ) {<br>  int a , b , c = 0 ;<br>  int m = 2 ;<br>  while ( c < limit ) {<br>    for ( int n = 1 ;<br>    n < m ;<br>    ++ n ) {<br>      a = m * m - n * n ;<br>      b = 2 * m * n ;<br>      c = m * m + n * n ;<br>      if ( c > limit ) break ;<br>      System . out . println ( a + " " + b + " " + c ) ;<br>    }<br>    m ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void pythagoreanTriplets ( int limits ) {<br>  int c = 0 , m = 2 ;<br>  while ( c < limits ) {<br>    for ( int n = 1 ;<br>    n < m ;<br>    n ++ ) {<br>      int a = m * m - n * n ;<br>      int b = 2 * m * n ;<br>      c = m * m + n * n ;<br>      if ( c > limits ) break ;<br>      System . out . println ( a + " " + b + " " + c ) ;<br>    }<br>    m = m + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSeq ( int n , int diff ) {<br>  if ( Math . abs ( diff ) > n ) return 0 ;<br>  if ( n == 1 && diff == 0 ) return 2 ;<br>  if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ;<br>  int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSeq ( int n , int diff ) {<br>  if ( ( Math . abs ( diff ) > n ) && ( diff == 0 ) ) return 0 ;<br>  if ( ( n == 1 && diff == 0 ) || ( diff == 1 ) ) return 2 ;<br>  if ( ( n == 1 && Math . abs ( diff ) == 1 ) || ( diff == 1 ) ) return 1 ;<br>  int res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossibleTriangle ( int [ ] arr , int N ) {<br>  if ( N < 3 ) return false ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < N - 2 ;<br>  i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossibleTriangle ( int [ ] arr , int N ) {<br>  if ( N < 3 ) return false ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < N - 2 ;<br>  i ++ ) {<br>    if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printInSortedOrder ( String arr [ ] , int n ) {<br>  int index [ ] = new int [ n ] ;<br>  int i , j , min ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    index [ i ] = i ;<br>  }<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    min = i ;<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) {<br>        min = j ;<br>      }<br>    }<br>    if ( min != i ) {<br>      int temp = index [ min ] ;<br>      index [ min ] = index [ i ] ;<br>      index [ i ] = temp ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( arr [ index [ i ] ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printInSortedOrder ( int [ ] arr , int n ) {<br>  int [ ] index = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) index [ i ] = i ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int min = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ index [ min ] ] > arr [ index [ j ] ] ) && ( arr [ index [ min ] ] < arr [ index [ j ] ] ) ) min = j ;<br>    }<br>    if ( ( min != i ) || ( index [ min ] != i ) ) index [ min ] = index [ i ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( arr [ index [ i ] ] + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>GAME_REPLACING_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int playGame ( int arr [ ] ) {<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i : arr ) set . add ( i ) ;<br>  return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int playGame ( int [ ] arr , int n ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return 1 == s . size ( ) % 2 ? 2 : 1 ;<br>}<br></td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int gcd ( int a , int b ) {<br>  if ( a == 0 ) return b ;<br>  return gcd ( b % a , a ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long gcd ( long a , long b ) {<br>  if ( a == 0 ) return b ;<br>  return gcd ( b % a , a ) ;<br>}<br></td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void sortInWave ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 2 ) {<br>    if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ;<br>    if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortInWave ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 2 ) {<br>    if ( ( i > 0 && arr [ i ] < arr [ i - 1 ] ) || ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) ) {<br>      arr [ i ] = arr [ i - 1 ] ;<br>      arr [ i - 1 ] = arr [ i ] ;<br>    }<br>    if ( ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) || ( i < n - 2 && arr [ i ] < arr [ i + 1 ] ) ) {<br>      arr [ i ] = arr [ i + 1 ] ;<br>      arr [ i + 1 ] = arr [ i ] ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSumSubarray ( int arr [ ] , int n ) {<br>  int min_prefix_sum = 0 ;<br>  int res = Integer . MIN_VALUE ;<br>  int prefix_sum [ ] = new int [ n ] ;<br>  prefix_sum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ;<br>    min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSumSubarray ( int [ ] arr , int n ) {<br>  int min_prefix_sum = 0 ;<br>  int res = - Integer . MAX_VALUE ;<br>  int [ ] prefix_sum = new int [ n ] ;<br>  prefix_sum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ;<br>    min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String firstLetterWord ( String str ) {<br>  String result = "" ;<br>  boolean v = true ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == ' ' ) {<br>      v = true ;<br>    }<br>    else if ( str . charAt ( i ) != ' ' && v == true ) {<br>      result += ( str . charAt ( i ) ) ;<br>      v = false ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static String firstLetterWord ( String str ) {<br>  String result = "" ;<br>  boolean v = true ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) {<br>      v = true ;<br>    }<br>    else if ( ( str . charAt ( i ) != ' ' ) && v == true ) {<br>      result += ( str . charAt ( i ) ) ;<br>      v = false ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int multiTerms = n * ( n + 1 ) / 2 ;<br>  int sum = multiTerms ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    multiTerms = multiTerms - ( i - 1 ) ;<br>    sum = sum + multiTerms * i ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int n ) {<br>  int multiTerms = n * ( n + 1 ) / 2 ;<br>  int sm = multiTerms ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    multiTerms = multiTerms - ( i - 1 ) ;<br>    sm = sm + multiTerms * i ;<br>  }<br>  return sm ;<br>}<br></td>
  </tr><tr>
    <th>CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCost ( int a [ ] , int n , int k ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= k ;<br>  j ++ ) dp [ i ] [ j ] = inf ;<br>  dp [ 0 ] [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= k ;<br>  j ++ ) for ( int m = i - 1 ;<br>  m >= 0 ;<br>  m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ;<br>  return dp [ n ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] a , int n , int k ) {<br>  int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = inf ;<br>  };<br>  dp [ 0 ] [ 0 ] = 0 ;<br>  ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= k ;<br>    j ++ ) {<br>      for ( int m = i - 1 ;<br>      m >= 0 ;<br>      m -- ) {<br>        dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ;<br>        ;<br>      }<br>    }<br>  };<br>  return dp [ n ] [ k ] ;<br>}<br></td>
  </tr><tr>
    <th>LEIBNIZ_HARMONIC_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void LeibnizHarmonicTriangle ( int n ) {<br>  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= i ;<br>    j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j - 1 ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void LeibnizHarmonicTriangle ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( ( j == 0 || j == i ) && ( C [ i ] [ j ] == 0 ) ) {<br>        C [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= i ;<br>    j ++ ) {<br>      System . out . print ( "1/" ) ;<br>      ;<br>      System . out . print ( i * C [ i - 1 ] [ j - 1 ] + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COUNT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean canMakeStr2 ( String str1 , String str2 ) {<br>  int [ ] count = new int [ MAX ] ;<br>  char [ ] str3 = str1 . toCharArray ( ) ;<br>  for ( int i = 0 ;<br>  i < str3 . length ;<br>  i ++ ) count [ str3 [ i ] ] ++ ;<br>  char [ ] str4 = str2 . toCharArray ( ) ;<br>  for ( int i = 0 ;<br>  i < str4 . length ;<br>  i ++ ) {<br>    if ( count [ str4 [ i ] ] == 0 ) return false ;<br>    count [ str4 [ i ] ] -- ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canMakeStr2 ( String s1 , String s2 ) {<br>  int [ ] count = new int [ s1 . length ( ) ] ;<br>  for ( int i = 0 ;<br>  i < s1 . length ( ) ;<br>  i ++ ) {<br>    count [ s1 . charAt ( i ) ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < s2 . length ( ) ;<br>  i ++ ) {<br>    if ( count [ s2 . charAt ( i ) ] == 0 ) {<br>      return false ;<br>    }<br>    count [ s2 . charAt ( i ) ] -- ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int SumOfKsubArray ( int arr [ ] , int k ) {<br>  int sum = 0 ;<br>  Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ;<br>  int i = 0 ;<br>  for ( i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ;<br>    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ;<br>    G . addLast ( i ) ;<br>    S . addLast ( i ) ;<br>  }<br>  for ( ;<br>  i < arr . length ;<br>  i ++ ) {<br>    sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ;<br>    while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) S . removeFirst ( ) ;<br>    while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) G . removeFirst ( ) ;<br>    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ;<br>    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ;<br>    G . addLast ( i ) ;<br>    S . addLast ( i ) ;<br>  }<br>  sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int SumOfKsubArray ( int [ ] arr , int n , int k ) {<br>  int Sum = 0 ;<br>  Deque < Integer > S = new ArrayDeque < > ( ) ;<br>  Deque < Integer > G = new ArrayDeque < > ( ) ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    while ( ( S . size ( ) > 0 && arr [ S . size ( ) - 1 ] >= arr [ i ] ) || ( G . size ( ) > 0 && arr [ G . size ( ) - 1 ] <= arr [ i ] ) ) S . pop ( ) ;<br>    while ( ( G . size ( ) > 0 && arr [ G . size ( ) - 1 ] <= arr [ i ] ) || ( S . size ( ) > 0 && arr [ S . size ( ) - 1 ] <= arr [ i ] ) ) G . pop ( ) ;<br>    G . push ( i ) ;<br>    S . push ( i ) ;<br>  }<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    Sum += arr [ S . size ( ) ] + arr [ G . size ( ) ] ;<br>    while ( ( S . size ( ) > 0 && S . size ( ) <= i - k ) || ( G . size ( ) > 0 && G . size ( ) <= i - k ) ) S . pop ( ) ;<br>    while ( ( S . size ( ) > 0 && arr [ S . size ( ) - 1 ] >= arr [ i ] ) || ( G . size ( ) > 0 && arr [ G . size ( ) - 1 ] <= arr [ i ] ) ) G . pop ( ) ;<br>    G . push ( i ) ;<br>    S . push ( i ) ;<br>  }<br>  Sum += arr [ S . size ( ) ] + arr [ G . size ( ) ] ;<br>  return Sum ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int lcs ( char [ ] X , char [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  ;<br>  else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  ;<br>  else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long findMinSum ( long a [ ] , long b [ ] , long n ) {<br>  Arrays . sort ( a ) ;<br>  Arrays . sort ( b ) ;<br>  long sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinSum ( int [ ] a , int [ ] b , int n ) {<br>  Arrays . sort ( a ) ;<br>  Arrays . sort ( b ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSolutions ( int n ) {<br>  int res = 0 ;<br>  for ( int x = 0 ;<br>  x * x < n ;<br>  x ++ ) for ( int y = 0 ;<br>  x * x + y * y < n ;<br>  y ++ ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSolutions ( int n ) {<br>  int res = 0 ;<br>  int x = 0 ;<br>  while ( ( x * x < n ) && ( x * x + y * y < n ) ) {<br>    int y = 0 ;<br>    while ( ( x * x + y * y < n ) && ( x * x + y * y < n ) ) {<br>      res = res + 1 ;<br>      y = y + 1 ;<br>    }<br>    x = x + 1 ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 1 ;<br>  j < m ;<br>  j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;<br>  return ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOps ( int [ ] [ ] A , int [ ] [ ] B , int m , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      A [ i ] [ j ] -= B [ i ] [ j ] ;<br>    };<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) ) {<br>        return - 1 ;<br>      }<br>    };<br>  }<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    result += Math . abs ( A [ i ] [ 0 ] ) ;<br>  }<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) {<br>    result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;<br>  };<br>  return ( result ) ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int FirstRepeated ( String str ) {<br>  int checker = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    int val = ( str . charAt ( i ) - 'a' ) ;<br>    if ( ( checker & ( 1 << val ) ) > 0 ) return i ;<br>    checker |= ( 1 << val ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int FirstRepeated ( String string ) {<br>  int checker = 0 ;<br>  int pos = 0 ;<br>  for ( int i = 0 ;<br>  i < string . length ( ) ;<br>  i ++ ) {<br>    int val = ( int ) string . charAt ( i ) - 'a' ;<br>    ;<br>    if ( ( ( checker & ( 1 << val ) ) > 0 ) && ( ( checker & ( 1 << val ) ) > 0 ) ) return pos ;<br>    checker |= ( 1 << val ) ;<br>    pos ++ ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void find_max ( int [ ] A , int N , int K ) {<br>  HashMap < Integer , Integer > Count = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < K - 1 ;<br>  i ++ ) if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ;<br>  else Count . put ( A [ i ] , 1 ) ;<br>  TreeSet < Integer > Myset = new TreeSet < Integer > ( ) ;<br>  for ( Map . Entry x : Count . entrySet ( ) ) {<br>    if ( Integer . parseInt ( String . valueOf ( x . getValue ( ) ) ) == 1 ) Myset . add ( Integer . parseInt ( String . valueOf ( x . getKey ( ) ) ) ) ;<br>  }<br>  for ( int i = K - 1 ;<br>  i < N ;<br>  i ++ ) {<br>    if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ;<br>    else Count . put ( A [ i ] , 1 ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( A [ i ] ) ) ) == 1 ) Myset . add ( A [ i ] ) ;<br>    else Myset . remove ( A [ i ] ) ;<br>    if ( Myset . size ( ) == 0 ) System . out . println ( "Nothing" ) ;<br>    else System . out . println ( Myset . last ( ) ) ;<br>    int x = A [ i - K + 1 ] ;<br>    Count . put ( x , Count . get ( x ) - 1 ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 1 ) Myset . add ( x ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 0 ) Myset . remove ( x ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findMax ( int [ ] A , int N , int K ) {<br>  Map < Integer , Integer > Count = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < K - 1 ;<br>  i ++ ) {<br>    Count . put ( A [ i ] , Count . get ( A [ i ] ) + 1 ) ;<br>  }<br>  Map < Integer , Integer > Myset = new HashMap < Integer , Integer > ( ) ;<br>  for ( int x : Count . keySet ( ) ) {<br>    if ( ( Count . get ( x ) == 1 ) && ( Count . get ( x ) == 0 ) ) {<br>      Myset . put ( x , 1 ) ;<br>    }<br>  }<br>  for ( int i = K - 1 ;<br>  i < N ;<br>  i ++ ) {<br>    Count . put ( A [ i ] , Count . get ( A [ i ] ) + 1 ) ;<br>    if ( ( Count . get ( A [ i ] ) == 1 ) && ( Count . get ( A [ i ] ) == 0 ) ) {<br>      Myset . put ( A [ i ] , 1 ) ;<br>    }<br>    else {<br>      -- Myset . get ( A [ i ] ) ;<br>    }<br>    if ( ( Myset . size ( ) == 0 ) && ( Count . get ( A [ i ] ) == 0 ) ) {<br>      System . out . println ( "Nothing" ) ;<br>    }<br>    else {<br>      int maxm = - 10 * 9 ;<br>      for ( int i : Myset . keySet ( ) ) {<br>        maxm = Math . max ( i , maxm ) ;<br>      }<br>      System . out . println ( maxm ) ;<br>    }<br>    int x = A [ i - K + 1 ] ;<br>    if ( x < Count . keySet ( ) . size ( ) ) {<br>      Count . get ( x ) -- ;<br>      if ( ( Count . get ( x ) == 1 ) && ( Count . get ( A [ x ] ) == 0 ) ) {<br>        Myset . put ( x , 1 ) ;<br>      }<br>      if ( ( Count . get ( x ) == 0 ) && ( Count . get ( A [ x ] ) == 1 ) ) {<br>        -- Myset . get ( A [ x ] ) ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int calculateEnergy ( int mat [ ] [ ] , int n ) {<br>  int i_des , j_des , q ;<br>  int tot_energy = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      q = mat [ i ] [ j ] / n ;<br>      i_des = q ;<br>      j_des = mat [ i ] [ j ] - ( n * q ) ;<br>      tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ;<br>    }<br>  }<br>  return tot_energy ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateEnergy ( int [ ] [ ] mat , int n ) {<br>  int tot_energy = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      int q = mat [ i ] [ j ] / n ;<br>      int i_des = q ;<br>      int j_des = mat [ i ] [ j ] - ( n * q ) ;<br>      tot_energy += ( Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ) ;<br>    }<br>  }<br>  return tot_energy ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) {<br>  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;<br>      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {<br>        LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ;<br>        result = Integer . max ( result , LCStuff [ i ] [ j ] ) ;<br>      }<br>      else LCStuff [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCSubStr ( int [ ] X , int [ ] Y , int m , int n ) {<br>  int [ ] [ ] LCSuff = new int [ n + 1 ] [ m + 1 ] ;<br>  LCSuff [ 0 ] [ 0 ] = 0 ;<br>  LCSuff [ 0 ] [ 1 ] = 0 ;<br>  LCSuff [ 0 ] [ 2 ] = 0 ;<br>  LCSuff [ 0 ] [ 3 ] = 0 ;<br>  LCSuff [ 0 ] [ 4 ] = 0 ;<br>  LCSuff [ 0 ] [ 5 ] = 0 ;<br>  LCSuff [ 0 ] [ 6 ] = 0 ;<br>  LCSuff [ 0 ] [ 7 ] = 0 ;<br>  LCSuff [ 0 ] [ 8 ] = 0 ;<br>  LCSuff [ 0 ] [ 9 ] = 0 ;<br>  LCSuff [ 0 ] [ 10 ] = 0 ;<br>  LCSuff [ 0 ] [ 11 ] = 0 ;<br>  LCSuff [ 0 ] [ 12 ] = 0 ;<br>  LCSuff [ 0 ] [ 13 ] = 0 ;<br>  LCSuff [ 0 ] [ 14 ] = 0 ;<br>  LCSuff [ 0 ] [ 15 ] = 0 ;<br>  LCSuff [ 0 ] [ 16 ] = 0 ;<br>  LCSuff [ 0 ] [ 17 ] = 0 ;<br>  LCSuff [ 0 ] [ 18 ] = 0 ;<br>  LCSuff [ 0 ] [ 19 ] = 0 ;<br>  LCSuff [ 0 ] [ 20 ] = 0 ;<br>  LCSuff [ 0 ] [ 21 ] = 0 ;<br>  LCSuff [ 0 ] [ 22 ] = 0 ;<br>  LCSuff [ 0 ] [ 23 ] = 0 ;<br>  LCSuff [ 0 ] [ 24 ] = 0 ;<br>  LCSuff [ 0 ] [ 25 ] = 0 ;<br>  LCSuff [ 0 ] [ 26 ] = 0 ;<br>  LCSuff [ 0 ] [ 27 ] = 0 ;<br>  LCSuff [ 0 ] [ 28 ] = 0 ;<br>  LCSuff [ 0 ] [ 29 ] = 0 ;<br>  LCSuff [ 0 ] [ 30 ] = 0 ;<br>  LCSuff [ 0 ] [ 31 ] = 0 ;<br>  LCSuff [ 0 ] [ 32 ] = 0 ;<br>  LCSuff [ 0 ] [ 33 ] = 0 ;<br>  LCSuff [ 0 ] [ 34 ] = 0 ;<br>  LCSuff [ 0 ] [ 35 ] = 0 ;<br>  LCSuff [ 0 ] [ 36 ] = 0 ;<br>  LCSuff [ 0 ] [ 37 ] = 0 ;<br>  LCSuff [ 0 ] [ 38</td>
  </tr><tr>
    <th>MAXIMUM_SUM_BITONIC_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumBitonicSubArr ( int arr [ ] , int n ) {<br>  int [ ] msis = new int [ n ] ;<br>  int [ ] msds = new int [ n ] ;<br>  int max_sum = Integer . MIN_VALUE ;<br>  msis [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ;<br>  else msis [ i ] = arr [ i ] ;<br>  msds [ n - 1 ] = arr [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ;<br>  else msds [ i ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ;<br>  return max_sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumBitonicSubArr ( int [ ] arr , int n ) {<br>  int [ ] msis = new int [ n ] ;<br>  int [ ] msds = new int [ n ] ;<br>  int maxSum = 0 ;<br>  msis [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i ] < arr [ n - 1 ] ) ) {<br>      msis [ i ] = msis [ i - 1 ] + arr [ i ] ;<br>    }<br>    else {<br>      msis [ i ] = arr [ i ] ;<br>    }<br>  }<br>  msds [ n - 1 ] = arr [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( arr [ i ] > arr [ i + 1 ] ) && ( arr [ i ] < arr [ n - 1 ] ) ) {<br>      msds [ i ] = msds [ i + 1 ] + arr [ i ] ;<br>    }<br>    else {<br>      msds [ i ] = arr [ i ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( maxSum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) && ( maxSum > ( msis [ i ] + msds [ i ] - arr [ i ] ) ) ) {<br>      maxSum = ( msis [ i ] + msds [ i ] - arr [ i ] ) ;<br>    }<br>  }<br>  return maxSum ;<br>}<br></td>
  </tr><tr>
    <th>NEWMAN_CONWAY_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sequence ( int n ) {<br>  if ( n == 1 || n == 2 ) return 1 ;<br>  else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int sequence ( int n ) {<br>  if ( n == 1 || n == 2 ) return 1 ;<br>  else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printAllAPTriplets ( int [ ] arr , int n ) {<br>  ArrayList < Integer > s = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int diff = arr [ j ] - arr [ i ] ;<br>      boolean exists = s . contains ( arr [ i ] - diff ) ;<br>      if ( exists ) System . out . println ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) ;<br>    }<br>    s . add ( arr [ i ] ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printAllAPTriplets ( int [ ] arr , int n ) {<br>  int [ ] s = new int [ n ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      int diff = arr [ j ] - arr [ i ] ;<br>      ;<br>      if ( ( ( arr [ i ] - diff ) < arr [ j ] ) && ( ( arr [ i ] - diff ) > arr [ j ] ) ) {<br>        System . out . print ( "{}<br> {<br>}<br> {<br>}" . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) ) ;<br>        ;<br>      }<br>    }<br>  }<br>  s [ n - 1 ] = arr [ i ] ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countInRange ( int arr [ ] , int n , int x , int y ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countInRange ( int [ ] arr , int n , int x , int y ) {<br>  int count = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] >= x && arr [ i ] <= y ) || ( arr [ i ] >= x && arr [ i ] <= y ) ) {<br>      count ++ ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>HIGHWAY_BILLBOARD_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) {<br>  int [ ] maxRev = new int [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) maxRev [ i ] = 0 ;<br>  int nxtbb = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    if ( nxtbb < n ) {<br>      if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ;<br>      else {<br>        if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ;<br>        else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;<br>        nxtbb ++ ;<br>      }<br>    }<br>    else maxRev [ i ] = maxRev [ i - 1 ] ;<br>  }<br>  return maxRev [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) {<br>  int [ ] maxRev = new int [ m + 1 ] ;<br>  int nxtbb = 0 ;<br>  ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    if ( ( nxtbb < n ) && ( x [ nxtbb ] != i ) ) {<br>      if ( ( x [ nxtbb ] != i ) && ( x [ nxtbb ] != x [ nxtbb ] ) ) {<br>        maxRev [ i ] = maxRev [ i - 1 ] ;<br>      }<br>      else {<br>        if ( ( i <= t ) && ( x [ nxtbb ] != i ) ) {<br>          maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ;<br>        }<br>        else {<br>          maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;<br>        };<br>        nxtbb ++ ;<br>      }<br>    }<br>    else {<br>      maxRev [ i ] = maxRev [ i - 1 ] ;<br>    }<br>  }<br>  return maxRev [ m ] ;<br>}<br></td>
  </tr><tr>
    <th>CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMat ( int degseq [ ] , int n ) {<br>  int [ ] [ ] mat = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {<br>        degseq [ i ] -- ;<br>        degseq [ j ] -- ;<br>        mat [ i ] [ j ] = 1 ;<br>        mat [ j ] [ i ] = 1 ;<br>      }<br>    }<br>  }<br>  System . out . print ( "\n" + setw ( 3 ) + "     " ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" ) ;<br>  System . out . print ( "\n\n" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( setw ( 4 ) + "(" + i + ")" ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printMat ( int [ ] degseq , int n ) {<br>  int [ ] [ ] mat = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( degseq [ i ] > 0 && degseq [ j ] > 0 ) || ( degseq [ i ] > 0 && degseq [ j ] > 0 ) ) {<br>        degseq [ i ] -- ;<br>        degseq [ j ] -- ;<br>        mat [ i ] [ j ] = 1 ;<br>        mat [ j ] [ i ] = 1 ;<br>      }<br>    }<br>  }<br>  System . out . print ( "      " ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( "" + "(" + i + ")" + "" ) ;<br>  }<br>  System . out . println ( ) ;<br>  System . out . println ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( "" + "(" + i + ")" + "" ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      System . out . print ( "     " + mat [ i ] [ j ] + "" ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean oppositeSigns ( int x , int y ) {<br>  return ( ( x ^ y ) < 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean oppositeSigns ( int x , int y ) {<br>  return ( ( x ^ y ) < 0 ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>TRIANGULAR_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isTriangular ( int num ) {<br>  if ( num < 0 ) return false ;<br>  int c = ( - 2 * num ) ;<br>  int b = 1 , a = 1 ;<br>  int d = ( b * b ) - ( 4 * a * c ) ;<br>  if ( d < 0 ) return false ;<br>  float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ;<br>  if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isTriangular ( double num ) {<br>  if ( ( num < 0 ) || ( num > 1 ) ) return false ;<br>  double c = ( - 2 * num ) ;<br>  double b = 1 , a = 1 ;<br>  double d = ( b * b ) - ( 4 * a * c ) ;<br>  if ( ( d < 0 ) || ( d > 1 ) ) return false ;<br>  double root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  if ( ( root1 > 0 ) && Math . floor ( root1 ) == root1 ) return true ;<br>  if ( ( root2 > 0 ) && Math . floor ( root2 ) == root2 ) return true ;<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isPowerOfFour ( int n ) {<br>  if ( n == 0 ) return 0 ;<br>  while ( n != 1 ) {<br>    if ( n % 4 != 0 ) return 0 ;<br>    n = n / 4 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfFour ( int n ) {<br>  if ( ( n == 0 ) || ( n % 4 != 0 ) ) {<br>    return false ;<br>  }<br>  while ( ( n != 1 ) && ( n % 4 != 0 ) ) {<br>    if ( ( n % 4 != 0 ) || ( n % 4 != 1 ) ) {<br>      return false ;<br>    }<br>    n = n / 4 ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>LAST_NON_ZERO_DIGIT_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lastNon0Digit ( int n ) {<br>  if ( n < 10 ) return dig [ n ] ;<br>  if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>}<br></td>
    <td>translated code: <br><br> static int lastNon0Digit ( int n ) {<br>  if ( ( n < 10 ) && ( n > 0 ) ) return dig [ n ] ;<br>  if ( ( ( ( n / 10 ) % 10 ) % 2 == 0 ) && ( n > 0 ) ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>}<br></td>
  </tr><tr>
    <th>SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortByPattern ( char [ ] str , char [ ] pat ) {<br>  int count [ ] = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < str . length ;<br>  i ++ ) {<br>    count [ str [ i ] - 'a' ] ++ ;<br>  }<br>  int index = 0 ;<br>  for ( int i = 0 ;<br>  i < pat . length ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < count [ pat [ i ] - 'a' ] ;<br>    j ++ ) {<br>      str [ index ++ ] = pat [ i ] ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static String sortByPattern ( String str , String pat ) {<br>  MAX_CHAR = MAX_CHAR ;<br>  int [ ] count = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i <= str . length ( ) ;<br>  i ++ ) {<br>    count [ ( char ) str . charAt ( i ) - 97 ] ++ ;<br>  }<br>  int index = 0 ;<br>  ;<br>  str = "" ;<br>  for ( int i = 0 ;<br>  i <= pat . length ( ) ;<br>  i ++ ) {<br>    int j = 0 ;<br>    while ( ( j < count [ ( char ) pat . charAt ( i ) - ( char ) 'a' ] ) && ( j < count [ ( char ) pat . charAt ( i ) - ( char ) 'A' ] ) ) {<br>      str += pat . charAt ( i ) ;<br>      j = j + 1 ;<br>      index ++ ;<br>    }<br>  }<br>  return str ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumBox ( int [ ] arr , int n ) {<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  Arrays . sort ( arr ) ;<br>  q . add ( arr [ 0 ] ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int now = q . element ( ) ;<br>    if ( arr [ i ] >= 2 * now ) q . remove ( ) ;<br>    q . add ( arr [ i ] ) ;<br>  }<br>  return q . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minimumBox ( int [ ] arr , int n ) {<br>  Queue < Integer > q = new LinkedList < Integer > ( ) ;<br>  Arrays . sort ( arr ) ;<br>  q . add ( arr [ 0 ] ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int now = q . poll ( ) ;<br>    if ( ( arr [ i ] >= 2 * now ) && ( arr [ i ] <= 2 * now ) ) q . remove ( i ) ;<br>    q . add ( arr [ i ] ) ;<br>  }<br>  return q . size ( ) ;<br>}<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binarySearch ( int arr [ ] , int low , int high , int key ) {<br>  if ( high < low ) return - 1 ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( key == arr [ mid ] ) return mid ;<br>  if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ;<br>  return binarySearch ( arr , low , ( mid - 1 ) , key ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int low , int high , int key ) {<br>  if ( ( high < low ) || ( low > high ) ) return - 1 ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( ( key == arr [ ( int ) mid ] ) && ( key > arr [ ( int ) mid ] ) ) return mid ;<br>  if ( ( key > arr [ ( int ) mid ] ) && ( key < arr [ ( int ) mid ] ) ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ;<br>  return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int i ;<br>  System . out . println ( "The repeating elements are : " ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>    else System . out . print ( Math . abs ( arr [ i ] ) + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>  System . out . println ( " The repeating elements are" + size ) ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    if ( ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) && ( arr [ Math . abs ( arr [ i ] ) ] < 1 ) ) {<br>      arr [ Math . abs ( arr [ i ] ) ] = ( - 1 ) * arr [ Math . abs ( arr [ i ] ) ] ;<br>    }<br>    else {<br>      System . out . println ( Math . abs ( arr [ i ] ) + " " ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findgroups ( int arr [ ] , int n ) {<br>  int c [ ] = new int [ ] {<br>    0 , 0 , 0 };<br>    int i ;<br>    int res = 0 ;<br>    for ( i = 0 ;<br>    i < n ;<br>    i ++ ) c [ arr [ i ] % 3 ] ++ ;<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;<br>    res += c [ 1 ] * c [ 2 ] ;<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;<br>    return res ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int findgroups ( int [ ] arr , int n ) {<br>  int c [ ] = {<br>    0 , 0 , 0 };<br>    int res = 0 ;<br>    for ( int i = 0 ;<br>    i <= n ;<br>    i ++ ) {<br>      c [ arr [ i ] % 3 ] ++ ;<br>    }<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;<br>    res += c [ 1 ] * c [ 2 ] ;<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;<br>    return res ;<br>  }<br>  </td>
  </tr><tr>
    <th>PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printStringAlternate ( String str ) {<br>  int [ ] occ = new int [ 122 ] ;<br>  String s = str . toLowerCase ( ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    char temp = s . charAt ( i ) ;<br>    occ [ temp ] ++ ;<br>    if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ;<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printStringAlternate ( String string ) {<br>  HashMap < String , Integer > occ = new HashMap < String , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i <= string . length ( ) ;<br>  i ++ ) {<br>    String temp = string . substring ( i ) . toLowerCase ( ) ;<br>    occ . put ( temp , occ . get ( temp ) + 1 ) ;<br>    if ( occ . get ( temp ) & 1 ) {<br>      System . out . print ( string . substring ( i ) + " " ) ;<br>    }<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_DAYS_TANK_WILL_BECOME_EMPTY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minDaysToEmpty ( int C , int l ) {<br>  if ( l >= C ) return C ;<br>  double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ;<br>  return ( int ) ( Math . ceil ( eq_root ) + l ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDaysToEmpty ( int C , int l ) {<br>  if ( ( l >= C ) && ( l <= C ) ) return C ;<br>  double eqRoot = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ;<br>  return Math . ceil ( eqRoot ) + l ;<br>}<br></td>
  </tr><tr>
    <th>REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String reversingString ( char [ ] str , int start , int end ) {<br>  while ( start < end ) {<br>    str [ start ] ^= str [ end ] ;<br>    str [ end ] ^= str [ start ] ;<br>    str [ start ] ^= str [ end ] ;<br>    ++ start ;<br>    -- end ;<br>  }<br>  return String . valueOf ( str ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String reversingString ( String str , int start , int end ) {<br>  while ( ( start < end ) && ( start < end ) ) {<br>    str = ( str . substring ( 0 , start ) + ( char ) ( ( char ) ( str . charAt ( start ) ^ ( char ) ( str . charAt ( end ) ) ) + str . substring ( start + 1 ) ) ) ;<br>    ;<br>    str = ( str . substring ( 0 , end ) + ( char ) ( ( char ) ( str . charAt ( start ) ^ ( char ) ( str . charAt ( end ) ) ) + str . substring ( end + 1 ) ) ) ;<br>    ;<br>    str = ( str . substring ( 0 , start ) + ( char ) ( ( char ) ( str . charAt ( start ) ^ ( char ) ( str . charAt ( end ) ) ) + str . substring ( start + 1 ) ) ) ;<br>    start ++ ;<br>    end -- ;<br>  }<br>  return str ;<br>}<br></td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countFreq ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ;<br>  SortedMap < Integer , Integer > st = new TreeMap < > ( ) ;<br>  for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) {<br>    st . put ( x . getKey ( ) , x . getValue ( ) ) ;<br>  }<br>  int cumul = 0 ;<br>  for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) {<br>    cumul += x . getValue ( ) ;<br>    System . out . println ( x . getKey ( ) + " " + cumul ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void countFreq ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ;<br>  Set < Pair < Integer , Integer >> st = new HashSet < Pair < Integer , Integer >> ( ) ;<br>  for ( int x : hm . keySet ( ) ) st . add ( new Pair < Integer , Integer > ( x , hm . get ( x ) ) ) ;<br>  int cumul = 0 ;<br>  for ( Pair < Integer , Integer > x : Collections . reverse ( st ) ) {<br>    cumul += x . second ;<br>    System . out . println ( x . first + " " + cumul ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotations ( int arr [ ] , int n ) {<br>  int min = arr [ 0 ] , min_index = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( min > arr [ i ] ) {<br>      min = arr [ i ] ;<br>      min_index = i ;<br>    }<br>  }<br>  return min_index ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotations ( int [ ] arr , int n ) {<br>  int min = arr [ 0 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( min > arr [ i ] ) && ( min < arr [ i + 1 ] ) ) {<br>      min = arr [ i ] ;<br>      min_index = i ;<br>    }<br>  };<br>  return min_index ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  int lis [ ] = new int [ n ] ;<br>  int i , j , max = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) for ( j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>  int n = arr . length ;<br>  int [ ] lis = new int [ n ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) {<br>        lis [ i ] = lis [ j ] + 1 ;<br>      }<br>    }<br>  }<br>  int maximum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    maximum = Math . max ( maximum , lis [ i ] ) ;<br>  }<br>  return maximum ;<br>}<br></td>
  </tr><tr>
    <th>MEDIAN_OF_TWO_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  int count ;<br>  int m1 = - 1 , m2 = - 1 ;<br>  for ( count = 0 ;<br>  count <= n ;<br>  count ++ ) {<br>    if ( i == n ) {<br>      m1 = m2 ;<br>      m2 = ar2 [ 0 ] ;<br>      break ;<br>    }<br>    else if ( j == n ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ 0 ] ;<br>      break ;<br>    }<br>    if ( ar1 [ i ] < ar2 [ j ] ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ i ] ;<br>      i ++ ;<br>    }<br>    else {<br>      m1 = m2 ;<br>      m2 = ar2 [ j ] ;<br>      j ++ ;<br>    }<br>  }<br>  return ( m1 + m2 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMedian ( int [ ] ar1 , int [ ] ar2 , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  int m1 = - 1 ;<br>  int m2 = - 1 ;<br>  int count = 0 ;<br>  while ( count < n + 1 ) {<br>    count ++ ;<br>    if ( i == n ) {<br>      m1 = m2 ;<br>      m2 = ar2 [ 0 ] ;<br>      break ;<br>    }<br>    else if ( j == n ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ 0 ] ;<br>      break ;<br>    }<br>    if ( ar1 [ i ] < ar2 [ j ] ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ i ] ;<br>      i ++ ;<br>    }<br>    else {<br>      m1 = m2 ;<br>      m2 = ar2 [ j ] ;<br>      j ++ ;<br>    }<br>  }<br>  return ( m1 + m2 ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String minLexRotation ( String str ) {<br>  int n = str . length ( ) ;<br>  String arr [ ] = new String [ n ] ;<br>  String concat = str + str ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = concat . substring ( i , i + n ) ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  return arr [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] minLexRotation ( String str_ ) {<br>  int n = str_ . length ( ) ;<br>  int [ ] arr = new int [ n ] ;<br>  Arrays . fill ( arr , 0 ) ;<br>  String concat = str_ + str_ ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = concat . substring ( i , n + i ) ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  return arr ;<br>}<br></td>
  </tr><tr>
    <th>INTERPOLATION_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int interpolationSearch ( int x ) {<br>  int lo = 0 , hi = ( arr . length - 1 ) ;<br>  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {<br>    if ( lo == hi ) {<br>      if ( arr [ lo ] == x ) return lo ;<br>      return - 1 ;<br>    }<br>    int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ;<br>    if ( arr [ pos ] == x ) return pos ;<br>    if ( arr [ pos ] < x ) lo = pos + 1 ;<br>    else hi = pos - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int interpolationSearch ( int [ ] arr , int n , int x ) {<br>  int lo = 0 ;<br>  int hi = ( n - 1 ) ;<br>  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {<br>    if ( lo == hi ) {<br>      if ( arr [ lo ] == x ) return lo ;<br>      ;<br>      return - 1 ;<br>    };<br>    int pos = lo + ( int ) ( ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) ;<br>    if ( arr [ pos ] == x ) return pos ;<br>    if ( arr [ pos ] < x ) lo = pos + 1 ;<br>    else hi = pos - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 ;<br>  int l = 0 , r = n - 1 ;<br>  while ( l < m && r >= 0 ) {<br>    if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) {<br>      l ++ ;<br>      r -- ;<br>      count ++ ;<br>    }<br>    else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ;<br>    else r -- ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 , l = 0 , r = n - 1 ;<br>  while ( ( l < m && r >= 0 ) || ( l < n && arr1 [ l ] == arr2 [ r ] ) ) {<br>    if ( ( ( arr1 [ l ] + arr2 [ r ] ) == x ) && ( arr1 [ l ] + arr2 [ r ] ) < x ) {<br>      l ++ ;<br>      r -- ;<br>      count ++ ;<br>    }<br>    else if ( ( ( arr1 [ l ] + arr2 [ r ] ) < x ) && ( arr1 [ l ] + arr2 [ r ] ) > x ) {<br>      l ++ ;<br>    }<br>    else {<br>      r -- ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubsets ( int arr [ ] , int n ) {<br>  HashSet < Integer > us = new HashSet < > ( ) ;<br>  int even_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ;<br>  even_count = us . size ( ) ;<br>  return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubSets ( int [ ] arr , int n ) {<br>  HashSet < Integer > us = new HashSet < Integer > ( ) ;<br>  int evenCount = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] % 2 == 0 ) {<br>      us . add ( arr [ i ] ) ;<br>    }<br>  }<br>  for ( int i : us ) {<br>    evenCount ++ ;<br>  }<br>  return Math . pow ( 2 , evenCount ) - 1 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOccurrences ( int arr [ ] , int n , int x ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( x == arr [ i ] ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOccurrences ( int [ ] arr , int n , int x ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( x == arr [ i ] ) {<br>      res ++ ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int [ ] Restore_Tree ( int [ ] S , int [ ] End ) {<br>  int [ ] Identity = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) Identity [ S [ i ] ] = i ;<br>  int [ ] parent = new int [ N ] ;<br>  Arrays . fill ( parent , - 1 ) ;<br>  int curr_parent = Identity [ 0 ] ;<br>  for ( int j = 1 ;<br>  j < N ;<br>  j ++ ) {<br>    int child = Identity [ j ] ;<br>    if ( End [ child ] - j > 1 ) {<br>      parent [ child ] = curr_parent ;<br>      curr_parent = child ;<br>    }<br>    else {<br>      parent [ child ] = curr_parent ;<br>      while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) {<br>        child = parent [ child ] ;<br>        curr_parent = parent [ child ] ;<br>        if ( curr_parent == Identity [ 0 ] ) break ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) parent [ i ] += 1 ;<br>  return parent ;<br>}<br></td>
    <td>translated code: <br><br> public static int Restore_Tree ( int S , int E ) {<br>  int Identity [ ] = new int [ N * new int [ S ] ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) Identity [ Start [ i ] ] = i ;<br>  int parent [ ] = new int [ N * new int [ S - 1 ] ] ;<br>  int currParent = Identity [ 0 ] ;<br>  for ( int j = 1 ;<br>  j < N ;<br>  j ++ ) {<br>    int child = Identity [ j ] ;<br>    if ( End [ child ] - j > 1 ) {<br>      parent [ child ] = currParent ;<br>      currParent = child ;<br>    }<br>    else {<br>      parent [ child ] = currParent ;<br>      while ( End [ child ] == End [ parent [ child ] ] ) {<br>        int child = parent [ child ] ;<br>        currParent = parent [ child ] ;<br>        if ( currParent == Identity [ 0 ] ) break ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) parent [ i ] ++ ;<br>  return parent [ S - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOccurrences ( String s , int K ) {<br>  int n = s . length ( ) ;<br>  int C = 0 , c1 = 0 , c2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == 'a' ) c1 ++ ;<br>    if ( s . charAt ( i ) == 'b' ) {<br>      c2 ++ ;<br>      C += c1 ;<br>    }<br>  }<br>  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOccurrences ( String s , int K ) {<br>  int n = s . length ( ) ;<br>  int c1 = 0 ;<br>  int c2 = 0 ;<br>  int C = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == 'a' ) c1 ++ ;<br>    if ( s . charAt ( i ) == 'b' ) {<br>      c2 ++ ;<br>      C += c1 ;<br>    }<br>  }<br>  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNonEmptySubstr ( String str ) {<br>  int n = str . length ( ) ;<br>  return n * ( n + 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonEmptySubstr ( String str ) {<br>  int n = str . length ( ) ;<br>  ;<br>  return ( int ) ( n * ( n + 1 ) / 2 ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumChars ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = - 1 ;<br>  int [ ] firstInd = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) firstInd [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int first_ind = firstInd [ str . charAt ( i ) ] ;<br>    if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ;<br>    else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumChars ( String str1 ) {<br>  int n = str1 . length ( ) ;<br>  int res = - 1 ;<br>  int [ ] firstInd = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    firstInd [ ( char ) str1 . charAt ( i ) ] = - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int firstInd [ ( char ) str1 . charAt ( i ) ] = i ;<br>    if ( ( firstInd [ i ] == - 1 ) && ( firstInd [ i ] > 0 ) ) {<br>      firstInd [ ( char ) str1 . charAt ( i ) ] = i ;<br>    }<br>    else {<br>      res = Math . max ( res , Math . abs ( i - firstInd [ i ] - 1 ) ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>SUM_SQUARES_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumofsquare ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  int i , j ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j <= min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumofsquare ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( ( j == 0 || j == i ) && ( C [ i ] [ j ] == 0 ) ) {<br>        C [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSubsequences ( String s ) {<br>  char [ ] str = s . toCharArray ( ) ;<br>  int n = str . length ;<br>  int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ;<br>  for ( int counter = 0 ;<br>  counter < opsize ;<br>  counter ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      System . out . print ( str [ j ] ) ;<br>      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSubsequences ( String str ) {<br>  int n = str . length ( ) ;<br>  int opsize = ( int ) Math . pow ( 2 , n - 1 ) ;<br>  for ( int counter = 0 ;<br>  counter < opsize ;<br>  counter ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      System . out . print ( str . charAt ( j ) + "" ) ;<br>      if ( ( counter & ( 1 << j ) ) != 0 ) System . out . print ( "" ) ;<br>    }<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NON_REPEATING_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstNonRepeating ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;<br>    if ( j == n ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstNonRepeating ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j = 0 ;<br>    while ( ( j < n ) && ( arr [ i ] == arr [ j ] ) ) {<br>      if ( ( i != j && arr [ i ] == arr [ j ] ) || ( j == n ) ) {<br>        break ;<br>      }<br>      j ++ ;<br>    }<br>    if ( ( j == n ) && ( arr [ i ] == arr [ j ] ) ) {<br>      return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long calculateSum ( int n ) {<br>  long sum = 0 ;<br>  for ( int row = 0 ;<br>  row < n ;<br>  row ++ ) {<br>    sum = sum + ( 1 << row ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int n ) {<br>  int sum = 0 ;<br>  for ( int row = 0 ;<br>  row < n ;<br>  row ++ ) {<br>    sum = sum + ( 1 << row ) ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_TWO_STRINGS_K_ANAGRAMS_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean arekAnagrams ( String str1 , String str2 , int k ) {<br>  int n = str1 . length ( ) ;<br>  if ( str2 . length ( ) != n ) return false ;<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ;<br>  return ( count <= k ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arekAnagrams ( String str1 , String str2 , int k ) {<br>  int n = str1 . length ( ) ;<br>  if ( ( str2 . length ( ) != n ) || ( str1 . length ( ) != n ) ) return false ;<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count1 [ ( char ) str1 . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count2 [ ( char ) str2 . charAt ( i ) - 'a' ] ++ ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( ( count1 [ i ] > count2 [ i ] ) && ( count1 [ i ] == count2 [ i ] ) ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ;<br>  }<br>  return ( count <= k ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestCommonSum ( int n ) {<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int sum1 = 0 , sum2 = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      sum1 += arr1 [ j ] ;<br>      sum2 += arr2 [ j ] ;<br>      if ( sum1 == sum2 ) {<br>        int len = j - i + 1 ;<br>        if ( len > maxLen ) maxLen = len ;<br>      }<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestCommonSum ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    int sum1 = 0 ;<br>    int sum2 = 0 ;<br>    for ( int j = i ;<br>    j <= n ;<br>    j ++ ) {<br>      sum1 += arr1 [ j ] ;<br>      sum2 += arr2 [ j ] ;<br>      if ( ( sum1 == sum2 ) && ( j > 0 ) ) {<br>        int len = j - i + 1 ;<br>        if ( ( len > maxLen ) && ( j > 0 ) ) {<br>          maxLen = len ;<br>        }<br>      }<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
  </tr><tr>
    <th>REMAINDER_7_LARGE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int remainderWith7 ( String num ) {<br>  int series [ ] = {<br>    1 , 3 , 2 , - 1 , - 3 , - 2 };<br>    int series_index = 0 ;<br>    int result = 0 ;<br>    for ( int i = num . length ( ) - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      int digit = num . charAt ( i ) - '0' ;<br>      result += digit * series [ series_index ] ;<br>      series_index = ( series_index + 1 ) % 6 ;<br>      result %= 7 ;<br>    }<br>    if ( result < 0 ) result = ( result + 7 ) % 7 ;<br>    return result ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int remainderWith7 ( String num ) {<br>  int [ ] series = {<br>    1 , 3 , 2 , - 1 , - 3 , - 2 };<br>    ;<br>    int seriesIndex = 0 ;<br>    int result = 0 ;<br>    for ( int i = ( num . length ( ) - 1 ) ;<br>    i >= 0 ;<br>    i -- ) {<br>      int digit = ( int ) num . charAt ( i ) - 48 ;<br>      result += digit * series [ seriesIndex ] ;<br>      seriesIndex = ( seriesIndex + 1 ) % 6 ;<br>      result %= 7 ;<br>    }<br>    if ( ( result < 0 ) && ( result > 7 ) ) {<br>      result = ( result + 7 ) % 7 ;<br>    }<br>    return result ;<br>  }<br>  </td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean prevPermutation ( char [ ] str ) {<br>  int n = str . length - 1 ;<br>  int i = n ;<br>  while ( i > 0 && str [ i - 1 ] <= str [ i ] ) {<br>    i -- ;<br>  }<br>  if ( i <= 0 ) {<br>    return false ;<br>  }<br>  int j = i - 1 ;<br>  while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) {<br>    j ++ ;<br>  }<br>  swap ( str , i - 1 , j ) ;<br>  StringBuilder sb = new StringBuilder ( String . valueOf ( str ) ) ;<br>  sb . reverse ( ) ;<br>  str = sb . toString ( ) . toCharArray ( ) ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean prevPermutation ( String str ) {<br>  int n = str . length ( ) - 1 ;<br>  int i = n ;<br>  while ( ( i > 0 ) && ( str . charAt ( i - 1 ) <= str . charAt ( i ) ) ) i -- ;<br>  if ( ( i <= 0 ) && ( str . charAt ( i ) <= str . charAt ( n - 1 ) ) ) return false ;<br>  int j = i - 1 ;<br>  while ( ( j + 1 <= n ) && ( str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) ) j ++ ;<br>  str = Arrays . copyOf ( str , str . length ( ) ) ;<br>  String temp = str . substring ( i - 1 ) ;<br>  str . substring ( i - 1 , j ) ;<br>  str . replace ( j , temp ) ;<br>  str = new String ( str ) ;<br>  str . substring ( 0 , str . length ( ) - 1 ) ;<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubsequences ( String s ) {<br>  int aCount = 0 ;<br>  int bCount = 0 ;<br>  int cCount = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ;<br>    else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ;<br>    else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ;<br>  }<br>  return cCount ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubsequences ( String s ) {<br>  int aCount = 0 ;<br>  int bCount = 0 ;<br>  int cCount = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == 'a' ) || ( s . charAt ( i ) == 'b' ) ) {<br>      aCount = ( 1 + 2 * aCount ) ;<br>    }<br>    else if ( ( s . charAt ( i ) == 'c' ) || ( s . charAt ( i ) == 'c' ) ) {<br>      bCount = ( aCount + 2 * bCount ) ;<br>    }<br>    else if ( ( s . charAt ( i ) == 'd' ) || ( s . charAt ( i ) == 'd' ) ) {<br>      cCount = ( bCount + 2 * cCount ) ;<br>    }<br>  }<br>  return cCount ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isIdentity ( int mat [ ] [ ] , int N ) {<br>  for ( int row = 0 ;<br>  row < N ;<br>  row ++ ) {<br>    for ( int col = 0 ;<br>    col < N ;<br>    col ++ ) {<br>      if ( row == col && mat [ row ] [ col ] != 1 ) return false ;<br>      else if ( row != col && mat [ row ] [ col ] != 0 ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isIdentity ( int [ ] [ ] mat , int N ) {<br>  for ( int row = 0 ;<br>  row < N ;<br>  row ++ ) {<br>    for ( int col = 0 ;<br>    col < N ;<br>    col ++ ) {<br>      if ( ( row == col && mat [ row ] [ col ] != 1 ) || ( row != col && mat [ row ] [ col ] != 0 ) ) {<br>        return false ;<br>      };<br>    }<br>    else if ( ( row != col && mat [ row ] [ col ] != 0 ) || ( row == col && mat [ row ] [ col ] != 0 ) ) {<br>      return false ;<br>    };<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDiff ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ;<br>    else i ++ ;<br>  }<br>  if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDiff ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( ( Math . abs ( arr [ i ] ) != Math . abs ( arr [ i + 1 ] ) ) && ( arr [ i ] > 0 ) ) {<br>      result += Math . abs ( arr [ i ] ) ;<br>    }<br>    else {<br>    }<br>  }<br>  if ( ( arr [ n - 2 ] != arr [ n - 1 ] ) && ( arr [ n - 1 ] > 0 ) ) {<br>    result += Math . abs ( arr [ n - 1 ] ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_SUM_GIVEN_NTH_TERM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int summingSeries ( long n ) {<br>  int S = 0 ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ;<br>  return S ;<br>}<br></td>
    <td>translated code: <br><br> public static long summingSeries ( int n ) {<br>  long S = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ;<br>  return S ;<br>}<br></td>
  </tr><tr>
    <th>PREFIX_SUM_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void prefixSum2D ( int a [ ] [ ] ) {<br>  int R = a . length ;<br>  int C = a [ 0 ] . length ;<br>  int psa [ ] [ ] = new int [ R ] [ C ] ;<br>  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < C ;<br>  i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ;<br>  for ( int i = 1 ;<br>  i < R ;<br>  i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < R ;<br>  i ++ ) for ( int j = 1 ;<br>  j < C ;<br>  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void prefixSum2D ( int [ ] [ ] a ) {<br>  C = a . length ;<br>  R = a [ 0 ] . length ;<br>  int [ ] [ ] psa = new int [ C ] [ R ] ;<br>  for ( int y = 0 ;<br>  y < R ;<br>  y ++ ) {<br>    psa [ 0 ] [ y ] = new int [ C ] ;<br>    for ( int i = 1 ;<br>    i < C ;<br>    i ++ ) {<br>      psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) ;<br>    }<br>    for ( int i = 0 ;<br>    i < R ;<br>    i ++ ) {<br>      psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) ;<br>    }<br>    for ( int i = 1 ;<br>    i < R ;<br>    i ++ ) {<br>      for ( int j = 1 ;<br>      j < C ;<br>      j ++ ) {<br>        psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ;<br>      }<br>    }<br>    for ( int i = 0 ;<br>    i < R ;<br>    i ++ ) {<br>      for ( int j = 0 ;<br>      j < C ;<br>      j ++ ) {<br>        System . out . print ( psa [ i ] [ j ] + " " ) ;<br>      }<br>      System . out . println ( ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int numberOfSquares ( int base ) {<br>  base = ( base - 2 ) ;<br>  base = base / 2 ;<br>  return base * ( base + 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfSquares ( int base ) {<br>  base = ( base - 2 ) ;<br>  base = base / 2 ;<br>  return base * ( base + 1 ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countSubStr ( char str [ ] , int n ) {<br>  int m = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( str [ i ] == '1' ) m ++ ;<br>  }<br>  return m * ( m - 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubStr ( String st , int n ) {<br>  int m = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( st . charAt ( i ) == '1' ) && ( st . charAt ( i + 1 ) == '2' ) ) {<br>      m = m + 1 ;<br>    }<br>  }<br>  return m * ( m - 1 ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isConvertible ( String str1 , String str2 , int k ) {<br>  if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ;<br>  int commonLength = 0 ;<br>  for ( int i = 0 ;<br>  i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ;<br>  i ++ ) {<br>    if ( str1 == str2 ) commonLength ++ ;<br>    else break ;<br>  }<br>  if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isConvertible ( String str1 , String str2 , int k ) {<br>  if ( ( ( str1 . length ( ) + str2 . length ( ) ) < k ) && ( ( str1 . length ( ) + str2 . length ( ) ) < k ) ) return true ;<br>  int commonLength = 0 ;<br>  for ( int i = 0 ;<br>  i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ;<br>  i ++ ) {<br>    if ( ( str1 . charAt ( i ) == str2 . charAt ( i ) ) && ( str1 . charAt ( i ) == str2 . charAt ( i ) ) ) commonLength ++ ;<br>    else break ;<br>  }<br>  if ( ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) && ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) ) return true ;<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getOddOccurrence ( int ar [ ] , int ar_size ) {<br>  int i ;<br>  int res = 0 ;<br>  for ( i = 0 ;<br>  i < ar_size ;<br>  i ++ ) {<br>    res = res ^ ar [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getOddOccurrence ( int [ ] arr ) {<br>  int res = 0 ;<br>  for ( int element : arr ) {<br>    res = res ^ element ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>SUM_MIDDLE_ROW_COLUMN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void middlesum ( int mat [ ] [ ] , int n ) {<br>  int row_sum = 0 , col_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) row_sum += mat [ n / 2 ] [ i ] ;<br>  System . out . println ( "Sum of middle row = " + row_sum ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) col_sum += mat [ i ] [ n / 2 ] ;<br>  System . out . println ( "Sum of middle column = " + col_sum ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void middlesum ( int [ ] [ ] mat , int n ) {<br>  int rowSum = 0 ;<br>  int colSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    rowSum += mat [ n / 2 ] [ i ] ;<br>  }<br>  System . out . println ( "Sum of middle row = " + rowSum ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    colSum += mat [ i ] [ n / 2 ] ;<br>  }<br>  System . out . println ( "Sum of middle column = " + colSum ) ;<br>}<br></td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printKDistinct ( int arr [ ] , int n , int k ) {<br>  int dist_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ;<br>    if ( j == n ) dist_count ++ ;<br>    if ( dist_count == k ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int printKDistinct ( int [ ] arr , int n , int k ) {<br>  int distCount = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j = 0 ;<br>    while ( j < n ) {<br>      if ( ( i != j && arr [ j ] == arr [ i ] ) || ( j == n ) ) break ;<br>      j ++ ;<br>    }<br>    if ( ( j == n ) && ( arr [ j ] == arr [ i ] ) ) distCount ++ ;<br>    if ( ( distCount == k ) && ( arr [ i ] == arr [ j ] ) ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>MERGING_INTERVALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void mergeIntervals ( Interval arr [ ] ) {<br>  Arrays . sort ( arr , new Comparator < Interval > ( ) {<br>    public int compare ( Interval i1 , Interval i2 ) {<br>      return i2 . start - i1 . start ;<br>    }<br>  }<br>  ) ;<br>  int index = 0 ;<br>  for ( int i = 1 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( arr [ index ] . end >= arr [ i ] . start ) {<br>      arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ;<br>      arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ;<br>    }<br>    else {<br>      arr [ index ] = arr [ i ] ;<br>      index ++ ;<br>    }<br>  }<br>  System . out . print ( "The Merged Intervals are: " ) ;<br>  for ( int i = 0 ;<br>  i <= index ;<br>  i ++ ) {<br>    System . out . print ( "[" + arr [ i ] . start + "," + arr [ i ] . end + "]" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void mergeIntervals ( int [ ] arr ) {<br>  Arrays . sort ( arr , new Comparator < Integer > ( ) {<br>    public int compare ( Integer o1 , Integer o2 ) {<br>      return o1 . compareTo ( o2 ) ;<br>    }<br>  }<br>  ) ;<br>  ArrayList < Integer > m = new ArrayList < Integer > ( ) ;<br>  int s = - 10000 ;<br>  int max = - 100000 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    Integer a = arr [ i ] ;<br>    if ( a . intValue ( ) > max ) {<br>      if ( i != 0 ) {<br>        m . add ( new Integer ( s ) ) ;<br>      }<br>      max = a . intValue ( ) ;<br>      s = a . intValue ( ) ;<br>    }<br>    else {<br>      if ( a . intValue ( ) >= max ) {<br>        max = a . intValue ( ) ;<br>      }<br>    }<br>  }<br>  if ( max != - 100000 && new Integer ( s ) != null ) {<br>    m . add ( new Integer ( s ) ) ;<br>  }<br>  System . out . println ( "The Merged Intervals are :" + m . size ( ) ) ;<br>  for ( int i = 0 ;<br>  i < m . size ( ) ;<br>  i ++ ) {<br>    System . out . println ( m . get ( i ) + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> double countSquares ( int a , int b ) {<br>  return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountSquares ( double a , double b ) {<br>  return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void findFibSubset ( Integer [ ] x ) {<br>  Integer max = Collections . max ( Arrays . asList ( x ) ) ;<br>  List < Integer > fib = new ArrayList < Integer > ( ) ;<br>  List < Integer > result = new ArrayList < Integer > ( ) ;<br>  Integer a = 0 ;<br>  Integer b = 1 ;<br>  while ( b < max ) {<br>    Integer c = a + b ;<br>    a = b ;<br>    b = c ;<br>    fib . add ( c ) ;<br>  }<br>  for ( Integer i = 0 ;<br>  i < x . length ;<br>  i ++ ) {<br>    if ( fib . contains ( x [ i ] ) ) {<br>      result . add ( x [ i ] ) ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findFibSubset ( int [ ] arr , int n ) {<br>  int m = Math . max ( arr . length ) ;<br>  int a = 0 ;<br>  int b = 1 ;<br>  int [ ] hash = new int [ m ] ;<br>  hash [ 0 ] = a ;<br>  hash [ 1 ] = b ;<br>  while ( ( b < m ) && ( a < m ) ) {<br>    int c = a + b ;<br>    a = b ;<br>    b = c ;<br>    hash [ b ] = c ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < hash . length ) {<br>      System . out . print ( arr [ i ] + " " ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String lexicographicSubConcat ( String s ) {<br>  int n = s . length ( ) ;<br>  int sub_count = n * ( n + 1 ) / 2 ;<br>  String [ ] arr = new String [ sub_count ] ;<br>  int index = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int len = 1 ;<br>  len <= n - i ;<br>  len ++ ) {<br>    arr [ index ++ ] = s . substring ( i , i + len ) ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < sub_count ;<br>  i ++ ) res += arr [ i ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String lexicographicSubConcat ( String s ) {<br>  int n = s . length ( ) ;<br>  ;<br>  int subCount = ( n * ( n + 1 ) ) / 2 ;<br>  int [ ] arr = new int [ subCount ] ;<br>  int index = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n - i + 1 ;<br>    j ++ ) {<br>      arr [ index ] = s . charAt ( i ) ;<br>      index ++ ;<br>    }<br>  }<br>  Arrays . sort ( arr ) ;<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < subCount ;<br>  i ++ ) {<br>    res += arr [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_OPERATIONS_MAKE_STRINGAB_FREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int abFree ( char [ ] s ) {<br>  int b_count = 0 ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ;<br>  i ++ ) {<br>    if ( s [ s . length - i - 1 ] == 'a' ) {<br>      res = ( res + b_count ) ;<br>      b_count = ( b_count * 2 ) ;<br>    }<br>    else {<br>      b_count += 1 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int abFree ( String s ) {<br>  int bCount = 0 ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( ~ i ) == 'a' ) {<br>      res = ( res + bCount ) ;<br>      bCount = ( bCount * 2 ) ;<br>    }<br>    else {<br>      bCount ++ ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumHeight ( int a [ ] , int n ) {<br>  return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumHeight ( int a , int n ) {<br>  return ( - 1 + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxvolume ( int s ) {<br>  int maxvalue = 0 ;<br>  for ( int i = 1 ;<br>  i <= s - 2 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= s - 1 ;<br>    j ++ ) {<br>      int k = s - i - j ;<br>      maxvalue = Math . max ( maxvalue , i * j * k ) ;<br>    }<br>  }<br>  return maxvalue ;<br>}<br></td>
    <td>translated code: <br><br> public static double maxvolume ( int s ) {<br>  double maxvalue = 0 ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < s - 1 ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < s ;<br>    j ++ ) {<br>      int k = s - i - j ;<br>      maxvalue = Math . max ( maxvalue , i * j * k ) ;<br>    }<br>  }<br>  return maxvalue ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void decToHexa ( int n ) {<br>  char [ ] hexaDeciNum = new char [ 100 ] ;<br>  int i = 0 ;<br>  while ( n != 0 ) {<br>    int temp = 0 ;<br>    temp = n % 16 ;<br>    if ( temp < 10 ) {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;<br>      i ++ ;<br>    }<br>    else {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;<br>      i ++ ;<br>    }<br>    n = n / 16 ;<br>  }<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) System . out . print ( hexaDeciNum [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void decToHexa ( int n ) {<br>  char [ ] hexaDeciNum = new char [ 100 ] ;<br>  hexaDeciNum [ 0 ] = '0' ;<br>  ;<br>  int i = 0 ;<br>  ;<br>  while ( ( n != 0 ) && ( i < 10 ) ) {<br>    int temp ;<br>    temp = n % 16 ;<br>    if ( ( temp < 10 ) && ( temp > 0 ) ) {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;<br>      i = i + 1 ;<br>    }<br>    else {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;<br>      i = i + 1 ;<br>    }<br>    n = ( int ) ( n / 16 ) ;<br>  }<br>  int j = i - 1 ;<br>  while ( ( j >= 0 ) && ( j < 10 ) ) {<br>    System . out . print ( ( hexaDeciNum [ j ] ) + " " ) ;<br>    j = j - 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void smallestSubsegment ( int a [ ] , int n ) {<br>  HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ;<br>  HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>  int mx = 0 ;<br>  int mn = - 1 , strindex = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    if ( count . get ( x ) == null ) {<br>      left . put ( x , i ) ;<br>      count . put ( x , 1 ) ;<br>    }<br>    else count . put ( x , count . get ( x ) + 1 ) ;<br>    if ( count . get ( x ) > mx ) {<br>      mx = count . get ( x ) ;<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>    else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) {<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>  }<br>  for ( int i = strindex ;<br>  i < strindex + mn ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void smallestSubsegment ( int [ ] a , int n ) {<br>  Map < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ;<br>  Map < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>  int mx = 0 ;<br>  int mn = 0 , strindex = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    Integer x = a [ i ] ;<br>    if ( ( x != null ) && ( x < count . keySet ( ) ) ) {<br>      left . put ( x , i ) ;<br>      count . put ( x , 1 ) ;<br>    }<br>    else {<br>      count . put ( x , 1 ) ;<br>    }<br>    if ( ( count . get ( x ) > mx ) && ( count . get ( x ) == mx ) ) {<br>      mx = count . get ( x ) ;<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>    else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) {<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>  }<br>  for ( int i = strindex ;<br>  i < strindex + mn ;<br>  i ++ ) {<br>    System . out . print ( a [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLastIndex ( String str , Character x ) {<br>  for ( int i = str . length ( ) - 1 ;<br>  i >= 0 ;<br>  i -- ) if ( str . charAt ( i ) == x ) return i ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLastIndex ( String str , char x ) {<br>  for ( int i = str . length ( ) - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( str . charAt ( i ) == x ) && ( str . charAt ( i + 1 ) == x ) ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>RECAMANS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void recaman ( int n ) {<br>  int arr [ ] = new int [ n ] ;<br>  arr [ 0 ] = 0 ;<br>  System . out . print ( arr [ 0 ] + " ," ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr = arr [ i - 1 ] - i ;<br>    int j ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ j ] == curr ) || curr < 0 ) {<br>        curr = arr [ i - 1 ] + i ;<br>        break ;<br>      }<br>    }<br>    arr [ i ] = curr ;<br>    System . out . print ( arr [ i ] + ", " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void recaman ( int n ) {<br>  int [ ] arr = new int [ n ] ;<br>  arr [ 0 ] = 0 ;<br>  System . out . print ( arr [ 0 ] + ", " ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr = arr [ i - 1 ] - i ;<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( ( ( arr [ j ] == curr ) || curr < 0 ) && ( arr [ j ] == curr ) ) {<br>        curr = arr [ i - 1 ] + i ;<br>        break ;<br>      }<br>    }<br>    arr [ i ] = curr ;<br>    System . out . print ( arr [ i ] + ", " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char getSecondMostFreq ( String str ) {<br>  int [ ] count = new int [ NO_OF_CHARS ] ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) ( count [ str . charAt ( i ) ] ) ++ ;<br>  int first = 0 , second = 0 ;<br>  for ( i = 0 ;<br>  i < NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( count [ i ] > count [ first ] ) {<br>      second = first ;<br>      first = i ;<br>    }<br>    else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ;<br>  }<br>  return ( char ) second ;<br>}<br></td>
    <td>translated code: <br><br> public static char getSecondMostFreq ( String str ) {<br>  final int NO_OF_CHARS = 256 ;<br>  int [ ] count = new int [ NO_OF_CHARS ] ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    count [ Character . codePointAt ( str , i ) ] ++ ;<br>  }<br>  int first = 0 , second = 0 ;<br>  for ( int i = 0 ;<br>  i < NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( count [ i ] > count [ first ] ) {<br>      second = first ;<br>      first = i ;<br>    }<br>    else if ( ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) || ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) ) {<br>      second = i ;<br>    }<br>  }<br>  return ( char ) second ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLevel ( int [ ] boxes , int n ) {<br>  Arrays . sort ( boxes ) ;<br>  int ans = 1 ;<br>  int prev_width = boxes [ 0 ] ;<br>  int prev_count = 1 ;<br>  int curr_count = 0 ;<br>  int curr_width = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_width += boxes [ i ] ;<br>    curr_count += 1 ;<br>    if ( curr_width > prev_width && curr_count > prev_count ) {<br>      prev_width = curr_width ;<br>      prev_count = curr_count ;<br>      curr_count = 0 ;<br>      curr_width = 0 ;<br>      ans ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLevel ( int [ ] boxes , int n ) {<br>  Arrays . sort ( boxes ) ;<br>  int ans = 1 ;<br>  int prevWidth = boxes [ 0 ] ;<br>  int prevCount = 1 ;<br>  int currCount = 0 ;<br>  int currWidth = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    currWidth += boxes [ i ] ;<br>    currCount ++ ;<br>    if ( ( currWidth > prevWidth && currCount > prevCount ) || ( currWidth < prevWidth && currCount < prevCount ) ) {<br>      prevWidth = currWidth ;<br>      prevCount = currCount ;<br>      currCount = 0 ;<br>      currWidth = 0 ;<br>      ans ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>COUNTING_INVERSIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getInvCount ( int n ) {<br>  int inv_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;<br>  return inv_count ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr , int n ) {<br>  int inv_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ i ] > arr [ j ] ) && ( arr [ i ] < arr [ j ] ) ) {<br>        inv_count ++ ;<br>      }<br>    }<br>  }<br>  return inv_count ;<br>}<br></td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) {<br>  System . out . print ( "Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < column ;<br>    j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ;<br>  }<br>  System . out . println ( ) ;<br>  System . out . print ( "Diagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < column ;<br>    j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void diagonalsquare ( int [ ] [ ] mat , int row , int column ) {<br>  System . out . print ( "Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i <= row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= column ;<br>    j ++ ) {<br>      if ( ( i == j ) && ( i != column ) ) {<br>        System . out . print ( "{}<br> " ) ;<br>      }<br>    }<br>  }<br>  System . out . print ( " \n\nDiagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i <= row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= column ;<br>    j ++ ) {<br>      if ( ( i + j == column - 1 ) && ( i != column ) ) {<br>        System . out . print ( "{}<br> " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countCommon ( int mat [ ] [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countCommon ( int [ ] [ ] mat , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) {<br>      res = res + 1 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>EULERIAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int eulerian ( int n , int m ) {<br>  if ( m >= n || n == 0 ) return 0 ;<br>  if ( m == 0 ) return 1 ;<br>  return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double eulerian ( int n , int m ) {<br>  if ( ( m >= n || n == 0 ) && ( m == 0 ) ) return 0 ;<br>  ;<br>  if ( ( m == 0 ) && ( n == 0 ) ) return 1 ;<br>  ;<br>  return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) ;<br>}<br></td>
  </tr><tr>
    <th>EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean squareRootExists ( int n , int p ) {<br>  n = n % p ;<br>  for ( int x = 2 ;<br>  x < p ;<br>  x ++ ) if ( ( x * x ) % p == n ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean squareRootExists ( int n , int p ) {<br>  n = n % p ;<br>  for ( int x = 2 ;<br>  x > p ;<br>  x >>= 1 ) {<br>    if ( ( ( x * x ) % p == n ) && ( ( x * x ) % p == n ) ) {<br>      return true ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  int path = 1 ;<br>  for ( int i = n ;<br>  i < ( m + n - 1 ) ;<br>  i ++ ) {<br>    path *= i ;<br>    path /= ( i - n + 1 ) ;<br>  }<br>  return path ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>  for ( int i = n ;<br>  i < ( m + n - 1 ) ;<br>  i ++ ) {<br>    path *= i ;<br>    path /= ( i - n + 1 ) ;<br>  }<br>  return path ;<br>}<br></td>
  </tr><tr>
    <th>MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumDifferenceSum ( int arr [ ] , int N ) {<br>  int dp [ ] [ ] = new int [ N ] [ 2 ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < ( N - 1 ) ;<br>  i ++ ) {<br>    dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ;<br>    dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ;<br>  }<br>  return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumDifferenceSum ( int [ ] arr , int N ) {<br>  int [ ] [ ] dp = new int [ N ] [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i < N - 1 ;<br>  i ++ ) {<br>    dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ;<br>    dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ;<br>  }<br>  return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;<br>}<br></td>
  </tr><tr>
    <th>STERN_BROCOT_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) {<br>  for ( int i = 1 ;<br>  BrocotSequence . size ( ) < n ;<br>  i ++ ) {<br>    int considered_element = BrocotSequence . get ( i ) ;<br>    int precedent = BrocotSequence . get ( i - 1 ) ;<br>    BrocotSequence . add ( considered_element + precedent ) ;<br>    BrocotSequence . add ( considered_element ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < 15 ;<br>  ++ i ) System . out . print ( BrocotSequence . get ( i ) + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void SternSequenceFunc ( List < Integer > BrocotSequence , int n ) {<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    Integer consideredElement = BrocotSequence . get ( i ) ;<br>    Integer precedent = BrocotSequence . get ( i - 1 ) ;<br>    BrocotSequence . add ( consideredElement + precedent ) ;<br>    BrocotSequence . add ( consideredElement ) ;<br>  }<br>  for ( int i = 0 ;<br>  i <= 15 ;<br>  i ++ ) {<br>    System . out . print ( BrocotSequence . get ( i ) + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDivisibleSubseq ( String str , int n ) {<br>  int len = str . length ( ) ;<br>  int dp [ ] [ ] = new int [ len ] [ n ] ;<br>  dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;<br>      dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return dp [ len - 1 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDivisibleSubseq ( String str , int n ) {<br>  int l = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ l ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) {<br>    dp [ 0 ] [ ( Character . digit ( str . charAt ( 0 ) , 16 ) - '0' ) % n ] ++ ;<br>  }<br>  for ( int i = 1 ;<br>  i < l ;<br>  i ++ ) {<br>    dp [ i ] [ ( Character . digit ( str . charAt ( i ) , 16 ) - '0' ) % n ] ++ ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;<br>      dp [ i ] [ ( j * 10 + ( Character . digit ( str . charAt ( i ) , 16 ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return dp [ l - 1 ] [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) return i ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int x ) {<br>  int n = arr . length ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) {<br>    if ( ( x == arr [ j ] ) && ( x != 0 ) ) {<br>      return j ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getPairsCount ( int n , int sum ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ;<br>    hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;<br>  }<br>  int twice_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ;<br>    if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;<br>  }<br>  return twice_count / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getPairsCount ( int [ ] arr , int n , int sum ) {<br>  int [ ] m = new int [ 1000 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    m [ arr [ i ] ] ++ ;<br>    m [ arr [ i ] ] ++ ;<br>  }<br>  int twiceCount = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    twiceCount += m [ sum - arr [ i ] ] ;<br>    if ( ( sum - arr [ i ] == arr [ i ] ) && ( sum - arr [ i ] == arr [ i ] ) ) {<br>      twiceCount -- ;<br>    }<br>  }<br>  return ( int ) ( twiceCount / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int minDist ( int arr [ ] , int n , int x , int y ) {<br>  int i , j ;<br>  int min_dist = Integer . MAX_VALUE ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ;<br>    }<br>  }<br>  return min_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDist ( int [ ] arr , int n , int x , int y ) {<br>  int min_dist = 99999999 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) {<br>        min_dist = Math . abs ( i - j ) ;<br>      }<br>    }<br>    return min_dist ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ;<br>  res = res ^ arr [ n - 1 ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    res = res ^ ( i + 1 ) ^ arr [ i ] ;<br>  }<br>  res = res ^ arr [ n - 1 ] ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) {<br>  int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ;<br>  for ( int e = 0 ;<br>  e <= k ;<br>  e ++ ) {<br>    for ( int i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( int j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        sp [ i ] [ j ] [ e ] = INF ;<br>        if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ;<br>        if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ;<br>        if ( e > 1 ) {<br>          for ( int a = 0 ;<br>          a < V ;<br>          a ++ ) {<br>            if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return sp [ u ] [ v ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestPath ( int [ ] [ ] graph , int u , int v , int k ) {<br>  V = graph . length ;<br>  INF = 0 ;<br>  int [ ] [ ] sp = new int [ V ] [ V ] ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < V ;<br>    j ++ ) {<br>      sp [ i ] [ j ] = new int [ k + 1 ] ;<br>    }<br>  }<br>  for ( int e = 0 ;<br>  e < k + 1 ;<br>  e ++ ) {<br>    for ( int i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( int j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        sp [ i ] [ j ] [ e ] = INF ;<br>        if ( ( e == 0 && i == j ) || ( e == 1 && graph [ i ] [ j ] != INF ) ) {<br>          sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ;<br>        }<br>        if ( ( e > 1 ) && ( graph [ i ] [ a ] != INF ) ) {<br>          for ( int a = 0 ;<br>          a < V ;<br>          a ++ ) {<br>            if ( ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) ) {<br>              sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return sp [ u ] [ v ] [ k ] ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longest ( int a [ ] , int n , int k ) {<br>  int [ ] freq = new int [ 7 ] ;<br>  int start = 0 , end = 0 , now = 0 , l = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    freq [ a [ i ] ] ++ ;<br>    if ( freq [ a [ i ] ] == 1 ) now ++ ;<br>    while ( now > k ) {<br>      freq [ a [ l ] ] -- ;<br>      if ( freq [ a [ l ] ] == 0 ) now -- ;<br>      l ++ ;<br>    }<br>    if ( i - l + 1 >= end - start + 1 ) {<br>      end = i ;<br>      start = l ;<br>    }<br>  }<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longest ( int [ ] a , int n , int k ) {<br>  int [ ] freq = new int [ n ] ;<br>  int start = 0 ;<br>  int end = 0 ;<br>  int now = 0 ;<br>  int l = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    freq [ a [ i ] ] ++ ;<br>    if ( ( freq [ a [ i ] ] == 1 ) && ( freq [ a [ i ] ] == 0 ) ) now ++ ;<br>    while ( ( now > k ) && ( freq [ a [ l ] ] == 0 ) ) {<br>      freq [ a [ l ] ] -- ;<br>      if ( ( freq [ a [ l ] ] == 0 ) && ( freq [ a [ l ] ] == 1 ) ) now -- ;<br>      l ++ ;<br>    }<br>    if ( ( i - l + 1 >= end - start + 1 ) && ( freq [ a [ l ] ] == 0 ) ) {<br>      end = i ;<br>      start = l ;<br>    }<br>  }<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_XOR_VALUE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxXOR ( int mat [ ] [ ] , int N ) {<br>  int r_xor , c_xor ;<br>  int max_xor = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    r_xor = 0 ;<br>    c_xor = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      r_xor = r_xor ^ mat [ i ] [ j ] ;<br>      c_xor = c_xor ^ mat [ j ] [ i ] ;<br>    }<br>    if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ;<br>  }<br>  return max_xor ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxXOR ( int [ ] [ ] mat , int N ) {<br>  int maxXor = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int rXor = 0 ;<br>    int cXor = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      rXor = rXor ^ mat [ i ] [ j ] ;<br>      cXor = cXor ^ mat [ j ] [ i ] ;<br>    }<br>    if ( ( maxXor < Math . max ( rXor , cXor ) ) && ( maxXor < Math . max ( rXor , cXor ) ) ) {<br>      maxXor = Math . max ( rXor , cXor ) ;<br>    }<br>  }<br>  return maxXor ;<br>}<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestNull ( String str ) {<br>  ArrayList < Pair > arr = new ArrayList < > ( ) ;<br>  arr . add ( new Pair ( '@' , - 1 ) ) ;<br>  int maxlen = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    arr . add ( new Pair ( str . charAt ( i ) , i ) ) ;<br>    while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . first == '1' && arr . get ( arr . size ( ) - 2 ) . first == '0' && arr . get ( arr . size ( ) - 1 ) . first == '0' ) {<br>      arr . remove ( arr . size ( ) - 3 ) ;<br>      arr . remove ( arr . size ( ) - 2 ) ;<br>      arr . remove ( arr . size ( ) - 1 ) ;<br>    }<br>    int tmp = arr . get ( arr . size ( ) - 1 ) . second ;<br>    maxlen = Math . max ( maxlen , i - tmp ) ;<br>  }<br>  return maxlen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestNull ( String S ) {<br>  ArrayList < Integer > arr = new ArrayList < Integer > ( ) ;<br>  arr . add ( new Integer ( '@' ) ) ;<br>  int maxlen = 0 ;<br>  for ( int i = 0 ;<br>  i < S . length ( ) ;<br>  i ++ ) {<br>    arr . add ( new Integer ( S . charAt ( i ) ) ) ;<br>    while ( ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . charAt ( 0 ) == '1' && arr . get ( arr . size ( ) - 2 ) . charAt ( 0 ) == '0' && arr . get ( arr . size ( ) - 1 ) . charAt ( 0 ) == '0' ) ) {<br>      arr . remove ( arr . size ( ) - 1 ) ;<br>      arr . remove ( arr . size ( ) - 2 ) ;<br>      arr . remove ( arr . size ( ) - 1 ) ;<br>    }<br>    Integer tmp = arr . get ( arr . size ( ) - 1 ) ;<br>    maxlen = Math . max ( maxlen , i - tmp . intValue ( ) ) ;<br>  }<br>  return maxlen ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSubarray ( boolean arr [ ] , int n ) {<br>  int len [ ] = new int [ n ] ;<br>  len [ n - 1 ] = 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  -- i ) {<br>    if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ;<br>    else len [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) System . out . print ( len [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSubarray ( boolean [ ] arr , int n ) {<br>  int len [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) len [ i ] = 0 ;<br>  len [ n - 1 ] = 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( arr [ i ] ^ arr [ i + 1 ] == true ) && ( arr [ i ] ^ arr [ i + 1 ] == false ) ) len [ i ] = len [ i + 1 ] + 1 ;<br>    else len [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( len [ i ] + "" + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>WILDCARD_CHARACTER_MATCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean match ( String first , String second ) {<br>  if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ;<br>  if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ;<br>  if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ;<br>  if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean match ( String first , String second ) {<br>  if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ;<br>  if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ;<br>  if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ;<br>  ;<br>  if ( first . length ( ) != 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ;<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFactorialNums ( int n ) {<br>  int fact = 1 ;<br>  int x = 2 ;<br>  while ( fact <= n ) {<br>    System . out . print ( fact + " " ) ;<br>    fact = fact * x ;<br>    x ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFactorialNums ( int n ) {<br>  int fact = 1 ;<br>  int x = 2 ;<br>  while ( fact <= n ) {<br>    System . out . print ( fact + " " ) ;<br>    fact = fact * x ;<br>    x ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  int a = 1 , b = 2 , c = 0 ;<br>  if ( n <= 2 ) {<br>    return n ;<br>  }<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    c = b + ( i - 1 ) * a ;<br>    a = b ;<br>    b = c ;<br>  }<br>  return c ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>  int a = 1 , b = 2 , c = 0 ;<br>  ;<br>  if ( ( n <= 2 ) && ( n > 0 ) ) return n ;<br>  ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    c = b + ( i - 1 ) * a ;<br>    a = b ;<br>    b = c ;<br>  };<br>  return c ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxArea ( int mat [ ] [ ] ) {<br>  int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ;<br>  for ( int i = 0 ;<br>  i < C ;<br>  i ++ ) {<br>    hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;<br>    for ( int j = 1 ;<br>    j < R ;<br>    j ++ ) {<br>      hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    int count [ ] = new int [ R + 1 ] ;<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      count [ hist [ i ] [ j ] ] ++ ;<br>    }<br>    int col_no = 0 ;<br>    for ( int j = R ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( count [ j ] > 0 ) {<br>        for ( int k = 0 ;<br>        k < count [ j ] ;<br>        k ++ ) {<br>          hist [ i ] [ col_no ] = j ;<br>          col_no ++ ;<br>        }<br>      }<br>    }<br>  }<br>  int curr_area , max_area = 0 ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;<br>      if ( curr_area > max_area ) {<br>        max_area = curr_area ;<br>      }<br>    }<br>  }<br>  return max_area ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxArea ( int [ ] [ ] mat ) {<br>  int [ ] [ ] hist = new int [ C + 1 ] [ R + 1 ] ;<br>  for ( int i = 0 ;<br>  i < C ;<br>  i ++ ) {<br>    hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;<br>    for ( int j = 1 ;<br>    j < R ;<br>    j ++ ) {<br>      if ( ( ( mat [ j ] [ i ] == 0 ) && ( mat [ j ] [ i ] > 0 ) ) || ( ( mat [ j ] [ i ] > 0 ) && ( mat [ j ] [ i ] < 0 ) ) ) hist [ j ] [ i ] = 0 ;<br>      else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    int [ ] count = new int [ R + 1 ] ;<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      count [ hist [ i ] [ j ] ] ++ ;<br>    }<br>    int colNo = 0 ;<br>    int j = R ;<br>    while ( ( j >= 0 ) && ( count [ j ] > 0 ) ) {<br>      if ( ( count [ j ] > 0 ) && ( count [ j ] > 1 ) ) {<br>        for ( int k = 0 ;<br>        k < count [ j ] ;<br>        k += 1 ) {<br>          hist [ i ] [ colNo ] = j ;<br>          colNo ++ ;<br>        }<br>      }<br>      j -- ;<br>    }<br>  }<br>  int maxArea = 0 ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      int currArea = ( j + 1 ) * hist [ i ] [ j ] ;<br>      if ( ( currArea > maxArea ) && ( currArea > maxArea ) ) maxArea = currArea ;<br>    }<br>  }<br>  return maxArea ;<br>}<br></td>
  </tr><tr>
    <th>SUM_SEQUENCE_2_22_222</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumOfSeries ( int n ) {<br>  return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double sumOfSeries ( int n ) {<br>  return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < allocation . length ;<br>  i ++ ) allocation [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>    }<br>  }<br>  System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ;<br>    else System . out . print ( "Not Allocated" ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void firstFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>  int [ ] allocation = new int [ n ] ;<br>  allocation [ 0 ] = - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>    }<br>  }<br>  System . out . println ( " Process No.Process Size      Block no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( " " + i + "         " + processSize [ i ] + "         " + " " ) ;<br>    if ( allocation [ i ] != - 1 ) {<br>      System . out . print ( allocation [ i ] + " " ) ;<br>    }<br>    else {<br>      System . out . println ( "Not Allocated" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isPower ( int x , int y ) {<br>  if ( x == 1 ) return ( y == 1 ) ;<br>  int pow = 1 ;<br>  while ( pow < y ) pow = pow * x ;<br>  return ( pow == y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPower ( int x , int y ) {<br>  if ( ( x == 1 ) || ( y == 1 ) ) {<br>    return ( y == 1 ) ;<br>  }<br>  int pow = 1 ;<br>  while ( ( pow < y ) && ( pow < x ) ) {<br>    pow = pow * x ;<br>  }<br>  return ( pow == y ) ;<br>}<br></td>
  </tr><tr>
    <th>DIVIDE_LARGE_NUMBER_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longDivision ( String number , int divisor ) {<br>  String ans = "" ;<br>  int idx = 0 ;<br>  char [ ] num = number . toCharArray ( ) ;<br>  int temp = num [ idx ] - '0' ;<br>  while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ;<br>  idx += 1 ;<br>  while ( num . length > idx ) {<br>    ans += ( temp / divisor ) ;<br>    temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ;<br>  }<br>  if ( ans . length ( ) == 0 ) return "0" ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static String longDivision ( String number , int divisor ) {<br>  String ans = "" ;<br>  ;<br>  int idx = 0 ;<br>  int temp = ( char ) ( number . charAt ( idx ) - '0' ) ;<br>  ;<br>  while ( ( temp < divisor ) && ( temp > 0 ) ) {<br>    temp = ( temp * 10 + ( char ) ( number . charAt ( idx + 1 ) - '0' ) ) ;<br>    ;<br>    idx ++ ;<br>  };<br>  idx ++ ;<br>  while ( ( ( int ) number . length ( ) ) > idx ) {<br>    ans += ( char ) ( Math . floor ( temp / divisor ) + ( char ) '0' ) ;<br>    ;<br>    temp = ( ( temp % divisor ) * 10 + ( char ) ( number . charAt ( idx ) - '0' ) ) ;<br>    ;<br>    idx ++ ;<br>  };<br>  ans += ( char ) ( Math . floor ( temp / divisor ) + ( char ) '0' ) ;<br>  ;<br>  if ( ( ans . length ( ) == 0 ) && ( temp > 0 ) ) return "0" ;<br>  ;<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMax ( int arr [ ] [ ] ) {<br>  int row = 0 , i , j ;<br>  for ( i = 0 , j = N - 1 ;<br>  i < N ;<br>  i ++ ) {<br>    while ( j >= 0 && arr [ i ] [ j ] == 1 ) {<br>      row = i ;<br>      j -- ;<br>    }<br>  }<br>  System . out . print ( "Row number = " + ( row + 1 ) ) ;<br>  System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMax ( int [ ] [ ] arr ) {<br>  int row = 0 ;<br>  int j = N - 1 ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    while ( ( arr [ i ] [ j ] == 1 && j >= 0 ) || ( arr [ i ] [ j ] == 0 && j >= 1 ) ) {<br>      row = i ;<br>      j -- ;<br>    }<br>  }<br>  System . out . println ( "Row number = " + row + ", MaxCount = " + N - 1 - j ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_ROTATIONS_REQUIRED_GET_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRotations ( String str ) {<br>  String tmp = str + str ;<br>  int n = str . length ( ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    String substring = tmp . substring ( i , str . length ( ) ) ;<br>    if ( str == substring ) return i ;<br>  }<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRotations ( String str ) {<br>  String tmp = str + str ;<br>  int n = str . length ( ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    String substring = tmp . substring ( i , n ) ;<br>    if ( ( str . equals ( substring ) ) && ( str . equals ( substring ) ) ) {<br>      return i ;<br>    }<br>  }<br>  return n ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  if ( m == 1 || n == 1 ) return 1 ;<br>  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>  if ( ( m == 1 || n == 1 ) && ( m > 0 && n > 0 ) ) return 1 ;<br>  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  for ( int curr = 19 ;<br>  ;<br>  curr += 9 ) {<br>    int sum = 0 ;<br>    for ( int x = curr ;<br>    x > 0 ;<br>    x = x / 10 ) sum = sum + x % 10 ;<br>    if ( sum == 10 ) count ++ ;<br>    if ( count == n ) return curr ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  ;<br>  int curr = 19 ;<br>  while ( ( true ) && ( count < 10 ) ) {<br>    int sum = 0 ;<br>    int x = curr ;<br>    while ( ( x > 0 ) && ( x < 10 ) ) {<br>      sum = sum + x % 10 ;<br>      x = ( int ) ( x / 10 ) ;<br>    }<br>    if ( ( sum == 10 ) && ( count == 10 ) ) {<br>      count ++ ;<br>    }<br>    if ( ( count == n ) && ( curr == 19 ) ) {<br>      return curr ;<br>    }<br>    curr += 9 ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumAtKthLevel ( String tree , int k , int level ) {<br>  if ( tree . charAt ( i ++ ) == '(' ) {<br>    if ( tree . charAt ( i ) == ')' ) return 0 ;<br>    int sum = 0 ;<br>    if ( level == k ) sum = tree . charAt ( i ) - '0' ;<br>    ++ i ;<br>    int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ;<br>    ++ i ;<br>    int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ;<br>    ++ i ;<br>    return sum + leftsum + rightsum ;<br>  }<br>  return Integer . MIN_VALUE ;<br>}<br></td>
    <td>translated code: <br><br> static int sumAtKthLevel ( char [ ] tree , int k , int i , int level ) {<br>  if ( ( tree [ i ] == '(' ) && ( i + 1 < tree . length ) ) ) {<br>    i ++ ;<br>    if ( ( tree [ i ] == ')' ) && ( i + 1 < tree . length ) ) return 0 ;<br>    int sum = 0 ;<br>    if ( ( level == k ) || ( level == 0 ) ) sum = Integer . parseInt ( tree [ i ] ) ;<br>    i ++ ;<br>    int leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ;<br>    i ++ ;<br>    int rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ;<br>    i ++ ;<br>    return sum + leftsum + rightsum ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n ) {<br>  int DP [ ] = new int [ n + 1 ] ;<br>  DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ;<br>  DP [ 3 ] = 2 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ;<br>  return DP [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>  int [ ] DP = new int [ n + 1 ] ;<br>  DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ;<br>  DP [ 3 ] = 2 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i ++ ) {<br>    DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ;<br>  }<br>  return DP [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_EQULIBRIUM_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxSum ( int [ ] arr , int n ) {<br>  int res = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int prefix_sum = arr [ i ] ;<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) prefix_sum += arr [ j ] ;<br>    int suffix_sum = arr [ i ] ;<br>    for ( int j = n - 1 ;<br>    j > i ;<br>    j -- ) suffix_sum += arr [ j ] ;<br>    if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxSum ( int [ ] arr , int n ) {<br>  int res = - Integer . MAX_VALUE - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int prefixSum = arr [ i ] ;<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      prefixSum += arr [ j ] ;<br>    }<br>    int suffixSum = arr [ i ] ;<br>    int j = n - 1 ;<br>    while ( ( j > i ) && ( j < n ) ) {<br>      suffixSum += arr [ j ] ;<br>      j -- ;<br>    }<br>    if ( ( prefixSum == suffixSum ) || ( suffixSum == 0 ) ) {<br>      res = Math . max ( res , prefixSum ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>STEINS_ALGORITHM_FOR_FINDING_GCD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int gcd ( int a , int b ) {<br>  if ( a == b ) return a ;<br>  if ( a == 0 ) return b ;<br>  if ( b == 0 ) return a ;<br>  if ( ( ~ a & 1 ) == 1 ) {<br>    if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ;<br>    else return gcd ( a >> 1 , b >> 1 ) << 1 ;<br>  }<br>  if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ;<br>  if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;<br>  return gcd ( ( b - a ) >> 1 , a ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int gcd ( int a , int b ) {<br>  if ( ( a == b ) && ( a == 0 ) ) return a ;<br>  if ( ( a == 0 ) && ( b == 0 ) ) return b ;<br>  if ( ( b == 0 ) && ( a == 0 ) ) return a ;<br>  if ( ( ( ~ a & 1 ) == 1 ) && ( ( b & 1 ) == 1 ) ) {<br>    if ( ( ( b & 1 ) == 1 ) && ( ( a & 1 ) == 1 ) ) return gcd ( a >>> 1 , b ) ;<br>    else return ( gcd ( a >>> 1 , b >>> 1 ) << 1 ) ;<br>  }<br>  if ( ( ( ~ b & 1 ) == 1 ) && ( ( a & 1 ) == 1 ) ) return gcd ( a , b >>> 1 ) ;<br>  if ( ( a > b ) && ( ( a - b ) >>> 1 ) ) return gcd ( ( a - b ) >>> 1 , b ) ;<br>  return gcd ( ( b - a ) >>> 1 , a ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float findVolume ( float l , float b , float h ) {<br>  float volume = ( l * b * h ) / 2 ;<br>  return volume ;<br>}<br></td>
    <td>translated code: <br><br> static float findVolume ( float l , float b , float h ) {<br>  return ( ( l * b * h ) / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRectangle ( int m [ ] [ ] ) {<br>  int rows = m . length ;<br>  if ( rows == 0 ) return false ;<br>  int columns = m [ 0 ] . length ;<br>  for ( int y1 = 0 ;<br>  y1 < rows ;<br>  y1 ++ ) for ( int x1 = 0 ;<br>  x1 < columns ;<br>  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ;<br>  y2 < rows ;<br>  y2 ++ ) for ( int x2 = x1 + 1 ;<br>  x2 < columns ;<br>  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRectangle ( int [ ] [ ] m ) {<br>  int rows = m . length ;<br>  if ( ( rows == 0 ) || ( rows == 1 ) ) return false ;<br>  int columns = m [ 0 ] . length ;<br>  for ( int y1 = 0 ;<br>  y1 < rows ;<br>  y1 ++ ) {<br>    for ( int x1 = 0 ;<br>    x1 < columns ;<br>    x1 ++ ) {<br>      if ( ( m [ y1 ] [ x1 ] == 1 ) && ( m [ y2 ] [ x1 ] == 1 ) && ( m [ y2 ] [ x2 ] == 1 ) ) {<br>        for ( int y2 = y1 + 1 ;<br>        y2 < rows ;<br>        y2 ++ ) {<br>          for ( int x2 = x1 + 1 ;<br>          x2 < columns ;<br>          x2 ++ ) {<br>            if ( ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) && ( m [ y1 ] [ x2 ] == 1 ) ) {<br>              return true ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( String str , int n ) {<br>  int len = str . length ( ) ;<br>  if ( len >= n ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( String str , int n ) {<br>  int l = str . length ( ) ;<br>  if ( ( l >= n ) && ( l < n ) ) {<br>    return true ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_STAR_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkStar ( int mat [ ] [ ] ) {<br>  int vertexD1 = 0 , vertexDn_1 = 0 ;<br>  if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ;<br>  if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int degreeI = 0 ;<br>    for ( int j = 0 ;<br>    j < size ;<br>    j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ;<br>    if ( degreeI == 1 ) vertexD1 ++ ;<br>    else if ( degreeI == size - 1 ) vertexDn_1 ++ ;<br>  }<br>  return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkStar ( int [ ] [ ] mat ) {<br>  size = mat . length ;<br>  vertexD1 = 0 ;<br>  vertexDn_1 = 0 ;<br>  if ( ( size == 1 ) && ( mat [ 0 ] [ 0 ] == 0 ) ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    int degreeI = 0 ;<br>    for ( int j = 0 ;<br>    j <= size ;<br>    j ++ ) {<br>      if ( ( mat [ i ] [ j ] ) ) degreeI = degreeI + 1 ;<br>    }<br>    if ( ( degreeI == 1 ) && ( mat [ 0 ] [ 0 ] == 1 ) ) vertexD1 = vertexD1 + 1 ;<br>    else if ( ( degreeI == size - 1 ) && ( mat [ 0 ] [ 0 ] == 0 ) ) vertexDn_1 = vertexDn_1 + 1 ;<br>  }<br>  return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>ROOTS_OF_UNITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printRoots ( int n ) {<br>  double theta = 3.14 * 2 / n ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    double real = Math . cos ( k * theta ) ;<br>    double img = Math . sin ( k * theta ) ;<br>    System . out . println ( real ) ;<br>    if ( img >= 0 ) System . out . println ( " + i " ) ;<br>    else System . out . println ( " - i " ) ;<br>    System . out . println ( Math . abs ( img ) ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRoots ( int n ) {<br>  double theta = Math . PI * 2 / n ;<br>  for ( int k = 0 ;<br>  k <= n ;<br>  k ++ ) {<br>    double real = Math . cos ( k * theta ) ;<br>    double img = Math . sin ( k * theta ) ;<br>    System . out . print ( real + " " ) ;<br>    if ( ( img >= 0 ) && ( img < 1 ) ) System . out . print ( " + i " ) ;<br>    else System . out . print ( " - i " ) ;<br>    System . out . print ( Math . abs ( img ) ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLargestd ( int [ ] S , int n ) {<br>  boolean found = false ;<br>  Arrays . sort ( S ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) continue ;<br>      for ( int k = j + 1 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( i == k ) continue ;<br>        for ( int l = k + 1 ;<br>        l < n ;<br>        l ++ ) {<br>          if ( i == l ) continue ;<br>          if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {<br>            found = true ;<br>            return S [ i ] ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  if ( found == false ) return Integer . MAX_VALUE ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLargestd ( int [ ] S , int n ) {<br>  boolean found = false ;<br>  Arrays . sort ( S ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( i == j ) && ( S [ j ] == 0 ) ) continue ;<br>      for ( int k = j + 1 ;<br>      k <= n ;<br>      k ++ ) {<br>        if ( ( i == k ) && ( S [ k ] == 0 ) ) continue ;<br>        for ( int l = k + 1 ;<br>        l <= n ;<br>        l ++ ) {<br>          if ( ( i == l ) && ( S [ l ] == 0 ) ) continue ;<br>          if ( ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) && ( S [ i ] == S [ k ] + S [ l ] ) ) {<br>            found = true ;<br>            return S [ i ] ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  if ( ( found == false ) && ( S [ n ] == 0 ) && ( S [ n ] == 1 ) ) return - 1 ;<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count9s ( char number [ ] ) {<br>  int n = number . length ;<br>  int d [ ] = new int [ 9 ] ;<br>  d [ 0 ] = 1 ;<br>  int result = 0 ;<br>  int mod_sum = 0 , continuous_zero = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( number [ i ] - '0' ) == 0 ) {<br>      continuous_zero ++ ;<br>    }<br>    else {<br>      continuous_zero = 0 ;<br>    }<br>    mod_sum += ( number [ i ] - '0' ) ;<br>    mod_sum %= 9 ;<br>    result += d [ mod_sum ] ;<br>    d [ mod_sum ] ++ ;<br>    result -= continuous_zero ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int count9s ( String number ) {<br>  int n = number . length ( ) ;<br>  int [ ] d = new int [ 9 ] ;<br>  for ( int i = 0 ;<br>  i < 9 ;<br>  i ++ ) {<br>    d [ i ] = 0 ;<br>  }<br>  d [ 0 ] = 1 ;<br>  int result = 0 ;<br>  int modSum = 0 ;<br>  int continuousZero = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( Character . digit ( number . charAt ( i ) , 10 ) - '0' ) == 0 ) {<br>      continuousZero ++ ;<br>    }<br>    else {<br>      continuousZero = 0 ;<br>    }<br>    modSum += Character . digit ( number . charAt ( i ) , 10 ) - '0' ;<br>    modSum %= 9 ;<br>    result += d [ modSum ] ;<br>    d [ modSum ] ++ ;<br>    result -= continuousZero ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String LexicographicalMaxString ( String str ) {<br>  String mx = "" ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) {<br>      mx = str . substring ( i ) ;<br>    }<br>  }<br>  return mx ;<br>}<br></td>
    <td>translated code: <br><br> public static String LexicographicalMaxString ( String str ) {<br>  String mx = "" ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    mx = Math . max ( mx , str . substring ( i ) ) ;<br>  }<br>  return mx ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) {<br>  int i = 0 , j = 0 ;<br>  Arrays . sort ( set1 ) ;<br>  Arrays . sort ( set2 ) ;<br>  while ( i < set1 . length && j < set2 . length ) {<br>    if ( set1 [ i ] < set2 [ j ] ) i ++ ;<br>    else if ( set1 [ i ] > set2 [ j ] ) j ++ ;<br>    else return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) {<br>  Arrays . sort ( set1 ) ;<br>  Arrays . sort ( set2 ) ;<br>  int i = 0 ;<br>  int j = 0 ;<br>  while ( ( i < m && j < n ) || ( i < n && set1 [ i ] < set2 [ j ] ) ) {<br>    if ( ( set1 [ i ] < set2 [ j ] ) || ( set2 [ j ] < set1 [ i ] ) ) {<br>      i ++ ;<br>    }<br>    else if ( ( set2 [ j ] < set1 [ i ] ) || ( set1 [ i ] > set2 [ j ] ) ) {<br>      j ++ ;<br>    }<br>    else {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>EQUILIBRIUM_INDEX_OF_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int equilibrium ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  int leftsum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) sum += arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    sum -= arr [ i ] ;<br>    if ( leftsum == sum ) return i ;<br>    leftsum += arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int equilibrium ( int [ ] arr ) {<br>  int totalSum = Integer . MAX_VALUE ;<br>  int leftSum = 0 ;<br>  for ( int i = 0 , num = arr . length ;<br>  i < num ;<br>  i ++ ) {<br>    totalSum -= arr [ i ] ;<br>    if ( leftSum == totalSum ) {<br>      return i ;<br>    }<br>    leftSum += arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>AREA_CIRCUMSCRIBED_CIRCLE_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float areacircumscribed ( float a ) {<br>  float PI = 3.14159265f ;<br>  return ( a * a * ( PI / 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double areacircumscribed ( double a ) {<br>  return ( a * a * ( PI / 2 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longestRepeatedSubstring ( String str ) {<br>  int n = str . length ( ) ;<br>  int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  String res = "" ;<br>  int res_length = 0 ;<br>  int i , index = 0 ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) {<br>        LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ;<br>        if ( LCSRe [ i ] [ j ] > res_length ) {<br>          res_length = LCSRe [ i ] [ j ] ;<br>          index = Math . max ( i , index ) ;<br>        }<br>      }<br>      else {<br>        LCSRe [ i ] [ j ] = 0 ;<br>      }<br>    }<br>  }<br>  if ( res_length > 0 ) {<br>    for ( i = index - res_length + 1 ;<br>    i <= index ;<br>    i ++ ) {<br>      res += str . charAt ( i - 1 ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String longestRepeatedSubstring ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] LCSRe = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) {<br>    LCSRe [ y ] [ y ] = 0 ;<br>  }<br>  String res = "" ;<br>  int resLength = 0 ;<br>  int index = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) || ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] > ( j - i ) ) ) {<br>        LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ;<br>        if ( ( LCSRe [ i ] [ j ] > resLength ) && ( LCSRe [ i ] [ j ] < resLength ) ) {<br>          resLength = LCSRe [ i ] [ j ] ;<br>          index = Math . max ( i , index ) ;<br>        }<br>      }<br>      else {<br>        LCSRe [ i ] [ j ] = 0 ;<br>      }<br>    }<br>  }<br>  if ( ( resLength > 0 ) && ( index > 0 ) ) {<br>    for ( int i = index - resLength + 1 ;<br>    i <= index ;<br>    i ++ ) {<br>      res = res + str . charAt ( i - 1 ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long mulmod ( long a , long b , long mod ) {<br>  long res = 0 ;<br>  a = a % mod ;<br>  while ( b > 0 ) {<br>    if ( b % 2 == 1 ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( a * 2 ) % mod ;<br>    b /= 2 ;<br>  }<br>  return res % mod ;<br>}<br></td>
    <td>translated code: <br><br> public static int mulmod ( int a , int b , int mod ) {<br>  int res = 0 ;<br>  ;<br>  a = a % mod ;<br>  ;<br>  while ( ( b > 0 ) && ( b % 2 == 1 ) ) {<br>    if ( ( b % 2 == 1 ) || ( b % 2 == 0 ) ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( a * 2 ) % mod ;<br>    b /= 2 ;<br>  }<br>  return res % mod ;<br>}<br></td>
  </tr><tr>
    <th>PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isProduct ( int arr [ ] , int n , int x ) {<br>  HashSet < Integer > hset = new HashSet < > ( ) ;<br>  if ( n < 2 ) return false ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 0 ) {<br>      if ( x == 0 ) return true ;<br>      else continue ;<br>    }<br>    if ( x % arr [ i ] == 0 ) {<br>      if ( hset . contains ( x / arr [ i ] ) ) return true ;<br>      hset . add ( arr [ i ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isProduct ( int [ ] arr , int n , int x ) {<br>  if ( n < 2 ) return false ;<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 0 ) {<br>      if ( x == 0 ) return true ;<br>      else continue ;<br>    }<br>    if ( x % arr [ i ] == 0 ) {<br>      if ( x / arr [ i ] < s . size ( ) ) return true ;<br>      s . add ( arr [ i ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int kthgroupsum ( int k ) {<br>  int cur = ( k * ( k - 1 ) ) + 1 ;<br>  int sum = 0 ;<br>  while ( k -- > 0 ) {<br>    sum += cur ;<br>    cur += 2 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int kthGroupSum ( int k ) {<br>  int cur = ( int ) ( ( k * ( k - 1 ) ) + 1 ) ;<br>  int sum = 0 ;<br>  while ( k > 0 ) {<br>    sum += cur ;<br>    cur += 2 ;<br>    k = k - 1 ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findElements ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) System . out . print ( arr [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findElements ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i <= n - 2 ;<br>  i ++ ) {<br>    System . out . print ( arr [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minStepToDeleteString ( String str ) {<br>  int N = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= N ;<br>  j ++ ) dp [ i ] [ j ] = 0 ;<br>  for ( int len = 1 ;<br>  len <= N ;<br>  len ++ ) {<br>    for ( int i = 0 , j = len - 1 ;<br>    j < N ;<br>    i ++ , j ++ ) {<br>      if ( len == 1 ) dp [ i ] [ j ] = 1 ;<br>      else {<br>        dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ;<br>        if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ;<br>        for ( int K = i + 2 ;<br>        K <= j ;<br>        K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ 0 ] [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minStepToDeleteString ( String str ) {<br>  int N = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ;<br>  for ( int l = 1 ;<br>  l <= N ;<br>  l ++ ) {<br>    int i = 0 ;<br>    int j = l - 1 ;<br>    while ( j < N ) {<br>      if ( ( l == 1 ) && ( str . charAt ( i ) == str . charAt ( i + 1 ) ) ) {<br>        dp [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ;<br>        if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) && ( str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) ) {<br>          dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ;<br>        }<br>        for ( int K = i + 2 ;<br>        K <= j ;<br>        K ++ ) {<br>          if ( ( str . charAt ( i ) == str . charAt ( K ) ) && ( str . charAt ( K + 1 ) == str . charAt ( K + 2 ) ) ) {<br>            dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ;<br>          }<br>        }<br>      }<br>      i ++ ;<br>      j ++ ;<br>    }<br>  }<br>  return dp [ 0 ] [ N - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>CALCULATE_AREA_TETRAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double vol_tetra ( int side ) {<br>  double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ;<br>  return volume ;<br>}<br></td>
    <td>translated code: <br><br> public static int volTetra ( int side ) {<br>  double volume = ( side * side / ( 6 * Math . sqrt ( 2 ) ) ) ;<br>  return Math . round ( volume ) ;<br>}<br></td>
  </tr><tr>
    <th>SIEVE_OF_ATKIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int SieveOfAtkin ( int limit ) {<br>  if ( limit > 2 ) System . out . print ( 2 + " " ) ;<br>  if ( limit > 3 ) System . out . print ( 3 + " " ) ;<br>  boolean sieve [ ] = new boolean [ limit ] ;<br>  for ( int i = 0 ;<br>  i < limit ;<br>  i ++ ) sieve [ i ] = false ;<br>  for ( int x = 1 ;<br>  x * x < limit ;<br>  x ++ ) {<br>    for ( int y = 1 ;<br>    y * y < limit ;<br>    y ++ ) {<br>      int n = ( 4 * x * x ) + ( y * y ) ;<br>      if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) + ( y * y ) ;<br>      if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) - ( y * y ) ;<br>      if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ;<br>    }<br>  }<br>  for ( int r = 5 ;<br>  r * r < limit ;<br>  r ++ ) {<br>    if ( sieve [ r ] ) {<br>      for ( int i = r * r ;<br>      i < limit ;<br>      i += r * r ) sieve [ i ] = false ;<br>    }<br>  }<br>  for ( int a = 5 ;<br>  a < limit ;<br>  a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void SieveOfAtkin ( int limit ) {<br>  if ( ( limit > 2 ) && ( limit % 12 == 1 || limit % 12 == 5 ) ) System . out . print ( 2 + " " ) ;<br>  if ( ( limit > 3 ) && ( limit % 12 == 7 ) ) System . out . print ( 3 + " " ) ;<br>  boolean [ ] sieve = new boolean [ limit ] ;<br>  sieve [ 0 ] = false ;<br>  for ( int i = 0 ;<br>  i <= limit ;<br>  i ++ ) sieve [ i ] = false ;<br>  int x = 1 ;<br>  while ( ( x * x < limit ) && ( x < limit ) ) {<br>    int y = 1 ;<br>    while ( ( y * y < limit ) && ( y < limit ) ) {<br>      int n = ( 4 * x * x ) + ( y * y ) ;<br>      if ( ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) || ( n <= limit && ( n % 12 == 7 ) ) ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) + ( y * y ) ;<br>      if ( ( n <= limit && n % 12 == 11 ) ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) - ( y * y ) ;<br>      if ( ( x > y && n <= limit && n % 12 == 11 ) ) sieve [ n ] ^= true ;<br>      y ++ ;<br>    }<br>    x ++ ;<br>  }<br>  int r = 5 ;<br>  while ( ( r * r < limit ) && ( r < limit ) ) {<br>    if ( ( sieve [ r ] ) ) for ( int i = r * r ;<br>    i < limit ;<br>    i += r ) sieve [ i ] = false ;<br>  }<br>  for ( int a = 5 ;<br>  a < limit ;<br>  a ++ ) if ( ( sieve [ a ] ) ) System . out . print ( a + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenghtOfLongestAP ( int set [ ] , int n ) {<br>  if ( n <= 2 ) return n ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  int llap = 2 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ n - 1 ] = 2 ;<br>  for ( int j = n - 2 ;<br>  j >= 1 ;<br>  j -- ) {<br>    int i = j - 1 , k = j + 1 ;<br>    while ( i >= 0 && k <= n - 1 ) {<br>      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;<br>      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {<br>        L [ i ] [ j ] = 2 ;<br>        i -- ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        llap = Math . max ( llap , L [ i ] [ j ] ) ;<br>        i -- ;<br>        k ++ ;<br>      }<br>    }<br>    while ( i >= 0 ) {<br>      L [ i ] [ j ] = 2 ;<br>      i -- ;<br>    }<br>  }<br>  return llap ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenghtOfLongestAP ( int [ ] set , int n ) {<br>  if ( ( n <= 2 ) && ( set [ 0 ] == set [ 1 ] ) ) return n ;<br>  int [ ] [ ] L = new int [ n ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) L [ y ] [ n - 1 ] = 0 ;<br>  int llap = 2 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ n - 1 ] = 2 ;<br>  for ( int j = n - 2 ;<br>  j > 0 ;<br>  j -- ) {<br>    int i = j - 1 ;<br>    int k = j + 1 ;<br>    while ( ( i >= 0 ) && ( k <= n - 1 ) ) {<br>      if ( ( set [ i ] + set [ k ] < 2 * set [ j ] ) && ( set [ i ] + set [ k ] > 2 * set [ j ] ) ) {<br>        k ++ ;<br>      }<br>      else if ( ( set [ i ] + set [ k ] > 2 * set [ j ] ) && ( set [ i ] + set [ k ] < 2 * set [ j ] ) ) {<br>        L [ i ] [ j ] = 2 ;<br>        i -- ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        llap = Math . max ( llap , L [ i ] [ j ] ) ;<br>        i -- ;<br>        k ++ ;<br>        while ( ( i >= 0 ) && ( k > 0 ) ) {<br>          L [ i ] [ j ] = 2 ;<br>          i -- ;<br>        }<br>      }<br>    }<br>  }<br>  return llap ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countGroups ( int position , int previous_sum , int length , char [ ] num ) {<br>  if ( position == length ) return 1 ;<br>  if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ;<br>  dp [ position ] [ previous_sum ] = 0 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum += ( num [ i ] - '0' ) ;<br>    if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  dp [ position ] [ previous_sum ] = res ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countGroups ( int position , int previousSum , int length , char [ ] num ) {<br>  if ( ( position == length ) && ( previousSum != - 1 ) ) return 1 ;<br>  if ( ( dp [ position ] [ previousSum ] != - 1 ) && ( previousSum != 0 ) ) return dp [ position ] [ previousSum ] ;<br>  dp [ position ] [ previousSum ] = 0 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum += ( ( int ) num [ i ] - ( int ) '0' ) ;<br>    if ( ( sum >= previousSum ) && ( sum < previousSum ) ) res += countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  dp [ position ] [ previousSum ] = res ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestCommonSum ( int n ) {<br>  int maxLen = 0 ;<br>  int preSum1 = 0 , preSum2 = 0 ;<br>  int diff [ ] = new int [ 2 * n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < diff . length ;<br>  i ++ ) {<br>    diff [ i ] = - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    preSum1 += arr1 [ i ] ;<br>    preSum2 += arr2 [ i ] ;<br>    int curr_diff = preSum1 - preSum2 ;<br>    int diffIndex = n + curr_diff ;<br>    if ( curr_diff == 0 ) maxLen = i + 1 ;<br>    else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i ;<br>    else {<br>      int len = i - diff [ diffIndex ] ;<br>      if ( len > maxLen ) maxLen = len ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestCommonSum ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>  int maxLen = 0 ;<br>  int presum1 = presum2 = 0 ;<br>  int [ ] diff = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    presum1 += arr1 [ i ] ;<br>    presum2 += arr2 [ i ] ;<br>    int currDiff = presum1 - presum2 ;<br>    if ( currDiff == 0 ) {<br>      maxLen = i + 1 ;<br>    }<br>    else if ( currDiff != 0 ) {<br>      diff [ currDiff ] = i ;<br>    }<br>    else {<br>      int length = i - diff [ currDiff ] ;<br>      maxLen = Math . max ( maxLen , length ) ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFibonacciNumbers ( int n ) {<br>  int f1 = 0 , f2 = 1 , i ;<br>  if ( n < 1 ) return ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . print ( f2 + " " ) ;<br>    int next = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = next ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFibonacciNumbers ( int n ) {<br>  int f1 = 0 ;<br>  int f2 = 1 ;<br>  if ( ( n < 1 ) || ( n > n ) ) return ;<br>  for ( int x = 0 ;<br>  x <= n ;<br>  x ++ ) {<br>    System . out . print ( f2 + " " ) ;<br>    int next = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = next ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here += a [ i ] ;<br>    if ( max_so_far < max_ending_here ) {<br>      max_so_far = max_ending_here ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( max_ending_here < 0 ) {<br>      max_ending_here = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  System . out . println ( "Maximum contiguous sum is " + max_so_far ) ;<br>  System . out . println ( "Starting index " + start ) ;<br>  System . out . println ( "Ending index " + end ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maxSubArraySum ( int [ ] a , int size ) {<br>  int maxSo_far = - Integer . MAX_VALUE - 1 ;<br>  int maxEndingHere = 0 ;<br>  int start = 0 ;<br>  int end = 0 ;<br>  int s = 0 ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    maxEndingHere += a [ i ] ;<br>    if ( maxSo_far < maxEndingHere ) {<br>      maxSo_far = maxEndingHere ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( maxEndingHere < 0 ) {<br>      maxEndingHere = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  System . out . println ( "Maximum contiguous sum is " + ( maxSo_far ) ) ;<br>  System . out . println ( "Starting Index " + ( start ) ) ;<br>  System . out . println ( "Ending Index " + ( end ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_EQUAL_POINT_STRING_BRACKETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findIndex ( String str ) {<br>  int len = str . length ( ) ;<br>  int open [ ] = new int [ len + 1 ] ;<br>  int close [ ] = new int [ len + 1 ] ;<br>  int index = - 1 ;<br>  open [ 0 ] = 0 ;<br>  close [ len ] = 0 ;<br>  if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ;<br>  if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ;<br>    else open [ i + 1 ] = open [ i ] ;<br>  }<br>  for ( int i = len - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ;<br>    else close [ i ] = close [ i + 1 ] ;<br>  }<br>  if ( open [ len ] == 0 ) return len ;<br>  if ( close [ 0 ] == 0 ) return 0 ;<br>  for ( int i = 0 ;<br>  i <= len ;<br>  i ++ ) if ( open [ i ] == close [ i ] ) index = i ;<br>  return index ;<br>}<br></td>
    <td>translated code: <br><br> public static int findIndex ( String str ) {<br>  int l = str . length ( ) ;<br>  int [ ] open = new int [ l + 1 ] ;<br>  int [ ] close = new int [ l + 1 ] ;<br>  int index = - 1 ;<br>  open [ 0 ] = 0 ;<br>  close [ l ] = 0 ;<br>  if ( ( str . charAt ( 0 ) == '(' ) && ( str . charAt ( 1 ) == ')' ) ) open [ 1 ] = 1 ;<br>  if ( ( str . charAt ( l - 1 ) == ')' ) && ( str . charAt ( l - 1 ) == '(' ) ) close [ l - 1 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < l ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == '(' ) && ( str . charAt ( i + 1 ) == ')' ) ) open [ i + 1 ] = open [ i ] + 1 ;<br>    else open [ i + 1 ] = open [ i ] ;<br>  }<br>  for ( int i = l - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( str . charAt ( i ) == ')' ) && ( str . charAt ( i + 1 ) == ')' ) ) close [ i ] = close [ i + 1 ] + 1 ;<br>    else close [ i ] = close [ i + 1 ] ;<br>  }<br>  if ( ( open [ l ] == 0 ) && ( close [ 0 ] == 0 ) ) return len ;<br>  for ( int i = 0 ;<br>  i < l + 1 ;<br>  i ++ ) {<br>    if ( ( open [ i ] == close [ i ] ) && ( open [ i + 1 ] == close [ i ] ) ) index = i ;<br>  }<br>  return index ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countP ( int n , int k ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) dp [ 0 ] [ k ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= k ;<br>  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;<br>  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;<br>  return dp [ n ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countP ( int n , int k ) {<br>  int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    dp [ 0 ] [ k ] = 0 ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= k ;<br>    j ++ ) {<br>      if ( ( j == 1 || i == j ) && ( dp [ i ] [ j ] == 0 ) ) {<br>        dp [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ k ] ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  max_ref = 1 ;<br>  _lis ( arr , n ) ;<br>  return max_ref ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>  maximum = 0 ;<br>  int n = arr . length ;<br>  maximum = 1 ;<br>  _lis ( arr , n ) ;<br>  return maximum ;<br>}<br></td>
  </tr><tr>
    <th>FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeatFirstN2 ( String s ) {<br>  int p = - 1 , i , j ;<br>  for ( i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      if ( s . charAt ( i ) == s . charAt ( j ) ) {<br>        p = i ;<br>        break ;<br>      }<br>    }<br>    if ( p != - 1 ) break ;<br>  }<br>  return p ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeatFirstN2 ( String s ) {<br>  int p = - 1 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      if ( ( s . charAt ( i ) == s . charAt ( j ) ) && ( s . charAt ( j ) != ' ' ) ) {<br>        p = i ;<br>        break ;<br>      }<br>    }<br>    if ( ( p != - 1 ) && ( p < s . length ( ) ) ) break ;<br>  }<br>  return p ;<br>}<br></td>
  </tr><tr>
    <th>K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int ksmallest ( int arr [ ] , int n , int k ) {<br>  int b [ ] = new int [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    b [ arr [ i ] ] = 1 ;<br>  }<br>  for ( int j = 1 ;<br>  j < MAX ;<br>  j ++ ) {<br>    if ( b [ j ] != 1 ) {<br>      k -- ;<br>    }<br>    if ( k != 1 ) {<br>      return j ;<br>    }<br>  }<br>  return Integer . MAX_VALUE ;<br>}<br></td>
    <td>translated code: <br><br> public static int ksmallest ( int [ ] arr , int n , int k ) {<br>  int [ ] b = new int [ MAX ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) b [ arr [ i ] ] = 1 ;<br>  ;<br>  for ( int j = 1 ;<br>  j < MAX ;<br>  j ++ ) {<br>    if ( ( b [ j ] != 1 ) && ( b [ j ] != 0 ) ) k -- ;<br>    if ( ( k != 1 ) && ( k != 0 ) ) return j ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean pairWiseConsecutive ( Stack < Integer > s ) {<br>  Stack < Integer > aux = new Stack < Integer > ( ) ;<br>  while ( ! s . isEmpty ( ) ) {<br>    aux . push ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  boolean result = true ;<br>  while ( aux . size ( ) > 1 ) {<br>    int x = aux . peek ( ) ;<br>    aux . pop ( ) ;<br>    int y = aux . peek ( ) ;<br>    aux . pop ( ) ;<br>    if ( Math . abs ( x - y ) != 1 ) result = false ;<br>    s . push ( x ) ;<br>    s . push ( y ) ;<br>  }<br>  if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean pairWiseConsecutive ( Stack < Integer > s ) {<br>  Stack < Integer > aux = new Stack < Integer > ( ) ;<br>  while ( ( s . size ( ) != 0 ) && ( aux . size ( ) == 0 ) ) {<br>    aux . push ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  boolean result = true ;<br>  while ( ( aux . size ( ) > 1 ) && ( aux . size ( ) == 0 ) ) {<br>    int x = aux . pop ( ) ;<br>    aux . pop ( ) ;<br>    int y = aux . pop ( ) ;<br>    aux . pop ( ) ;<br>    if ( ( Math . abs ( x - y ) != 1 ) && ( x != y ) ) {<br>      result = false ;<br>    }<br>    s . push ( x ) ;<br>    s . push ( y ) ;<br>  }<br>  if ( ( aux . size ( ) == 1 ) && ( aux . peek ( ) == 0 ) ) {<br>    s . push ( aux . pop ( ) ) ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>BINARY_SEARCH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int binarySearch ( int arr [ ] , int x ) {<br>  int l = 0 , r = arr . length - 1 ;<br>  while ( l <= r ) {<br>    int m = l + ( r - l ) / 2 ;<br>    if ( arr [ m ] == x ) return m ;<br>    if ( arr [ m ] < x ) l = m + 1 ;<br>    else r = m - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int l , int r , int x ) {<br>  while ( l <= r ) {<br>    int mid = l + ( r - l ) / 2 ;<br>    ;<br>    if ( arr [ mid ] == x ) return mid ;<br>    else if ( arr [ mid ] < x ) l = mid + 1 ;<br>    else r = mid - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSubsequenceCount ( String S , String T ) {<br>  int m = T . length ( ) ;<br>  int n = S . length ( ) ;<br>  if ( m > n ) return 0 ;<br>  int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) mat [ i ] [ 0 ] = 0 ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) mat [ 0 ] [ j ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;<br>      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  return mat [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubsequenceCount ( String S , String T ) {<br>  int m = T . length ( ) ;<br>  int n = S . length ( ) ;<br>  if ( m > n ) return 0 ;<br>  int [ ] [ ] mat = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int __ = 0 ;<br>  __ < m ;<br>  __ ++ ) mat [ __ ] [ __ ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) mat [ i ] [ 0 ] = 0 ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) mat [ 0 ] [ j ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;<br>      else mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return mat [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swap ( int [ ] xp , int [ ] yp ) {<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void swap ( int [ ] xp , int [ ] yp ) {<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>POLICEMEN_CATCH_THIEVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int policeThief ( char arr [ ] , int n , int k ) {<br>  int res = 0 ;<br>  ArrayList < Integer > thi = new ArrayList < Integer > ( ) ;<br>  ArrayList < Integer > pol = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 'P' ) pol . add ( i ) ;<br>    else if ( arr [ i ] == 'T' ) thi . add ( i ) ;<br>  }<br>  int l = 0 , r = 0 ;<br>  while ( l < thi . size ( ) && r < pol . size ( ) ) {<br>    if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) {<br>      res ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ;<br>    else r ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int policeThief ( char [ ] arr , int n , int k ) {<br>  int i = 0 ;<br>  int l = 0 ;<br>  int r = 0 ;<br>  int res = 0 ;<br>  int [ ] thi = new int [ n ] ;<br>  int [ ] pol = new int [ n ] ;<br>  while ( i < n ) {<br>    if ( arr [ i ] == 'P' ) pol [ i ] = i ;<br>    else if ( arr [ i ] == 'T' ) thi [ i ] = i ;<br>    i ++ ;<br>  }<br>  while ( l < thi . length && r < pol . length ) {<br>    if ( ( Math . abs ( thi [ l ] - pol [ r ] ) <= k ) && ( thi [ l ] < pol [ r ] ) ) {<br>      res ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( thi [ l ] < pol [ r ] ) l ++ ;<br>    else r ++ ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int maxLen ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ;<br>  int sum = 0 ;<br>  int max_len = 0 ;<br>  int ending_index = - 1 ;<br>  int start_index = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    if ( sum == 0 ) {<br>      max_len = i + 1 ;<br>      ending_index = i ;<br>    }<br>    if ( hM . containsKey ( sum + n ) ) {<br>      if ( max_len < i - hM . get ( sum + n ) ) {<br>        max_len = i - hM . get ( sum + n ) ;<br>        ending_index = i ;<br>      }<br>    }<br>    else hM . put ( sum + n , i ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;<br>  }<br>  int end = ending_index - max_len + 1 ;<br>  System . out . println ( end + " to " + ending_index ) ;<br>  return max_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLen ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > hashMap = new HashMap < Integer , Integer > ( ) ;<br>  ;<br>  int currSum = 0 ;<br>  int maxLen = 0 ;<br>  int endingIndex = - 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == 0 ) && ( arr [ i ] != - 1 ) ) {<br>      arr [ i ] = - 1 ;<br>    }<br>    else {<br>      arr [ i ] = 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    currSum = currSum + arr [ i ] ;<br>    if ( ( currSum == 0 ) && ( arr [ i ] != - 1 ) ) {<br>      maxLen = i + 1 ;<br>      endingIndex = i ;<br>    }<br>    if ( ( currSum + n ) < hashMap . size ( ) ) {<br>      maxLen = Math . max ( maxLen , i - hashMap . get ( currSum + n ) ) ;<br>    }<br>    else {<br>      hashMap . put ( currSum , i ) ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] == - 1 ) && ( arr [ i ] != 0 ) ) {<br>      arr [ i ] = 0 ;<br>    }<br>    else {<br>      arr [ i ] = 1 ;<br>    }<br>  }<br>  System . out . print ( endingIndex - maxLen + " " ) ;<br>  System . out . print ( "to" ) ;<br>  System . out . print ( endingIndex ) ;<br>  return maxLen ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findLength ( String str , int n ) {<br>  int current_sum = 0 ;<br>  int max_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ;<br>    if ( current_sum < 0 ) current_sum = 0 ;<br>    max_sum = Math . max ( current_sum , max_sum ) ;<br>  }<br>  return max_sum == 0 ? - 1 : max_sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string , int n ) {<br>  int currentSum = 0 ;<br>  int maxSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    currentSum += ( 1 == string . charAt ( i ) ? - 1 : string . charAt ( i ) ) ;<br>    if ( currentSum < 0 ) currentSum = 0 ;<br>    maxSum = Math . max ( currentSum , maxSum ) ;<br>  }<br>  return maxSum == 0 ? 0 : maxSum ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestConseqSubseq ( int arr [ ] , int n ) {<br>  HashSet < Integer > S = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) S . add ( arr [ i ] ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( S . contains ( arr [ i ] ) ) {<br>      int j = arr [ i ] ;<br>      while ( S . contains ( j ) ) j ++ ;<br>      ans = Math . max ( ans , j - arr [ i ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestConseqSubseq ( int [ ] arr , int n ) {<br>  Set < Integer > S = new HashSet < Integer > ( ) ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) S . add ( arr [ i ] ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( S . contains ( arr [ i ] ) ) {<br>      int j = arr [ i ] ;<br>      while ( ( S . contains ( j ) ) && ( j != arr [ i ] ) ) j ++ ;<br>      ans = Math . max ( ans , j - arr [ i ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_NEXT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String nextWord ( String str ) {<br>  if ( str == "" ) return "a" ;<br>  int i = str . length ( ) - 1 ;<br>  while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ;<br>  if ( i == - 1 ) str = str + 'a' ;<br>  else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ;<br>  return str ;<br>}<br></td>
    <td>translated code: <br><br> public static String nextWord ( String s ) {<br>  if ( ( s . equals ( " " ) ) || ( s . equals ( "a" ) ) ) return "a" ;<br>  int i = s . length ( ) - 1 ;<br>  while ( ( s . charAt ( i ) == 'z' ) && i >= 0 ) -- i ;<br>  if ( ( i == - 1 ) || ( s . charAt ( i ) == 'a' ) ) s = s + 'a' ;<br>  else s = s . replace ( s . charAt ( i ) , ( char ) ( Character . digit ( s . charAt ( i ) , 16 ) + 1 ) , 1 ) ;<br>  return s ;<br>}<br></td>
  </tr><tr>
    <th>SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int a [ ] , int b [ ] , int n ) {<br>  int i ;<br>  int s = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) s += ( a [ i ] + b [ i ] ) ;<br>  if ( n == 1 ) return a [ 0 ] + b [ 0 ] ;<br>  if ( s % n != 0 ) return - 1 ;<br>  int x = s / n ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > x ) return - 1 ;<br>    if ( i > 0 ) {<br>      a [ i ] += b [ i - 1 ] ;<br>      b [ i - 1 ] = 0 ;<br>    }<br>    if ( a [ i ] == x ) continue ;<br>    int y = a [ i ] + b [ i ] ;<br>    if ( i + 1 < n ) y += b [ i + 1 ] ;<br>    if ( y == x ) {<br>      a [ i ] = y ;<br>      b [ i ] = 0 ;<br>      continue ;<br>    }<br>    if ( a [ i ] + b [ i ] == x ) {<br>      a [ i ] += b [ i ] ;<br>      b [ i ] = 0 ;<br>      continue ;<br>    }<br>    if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) {<br>      a [ i ] += b [ i + 1 ] ;<br>      b [ i + 1 ] = 0 ;<br>      continue ;<br>    }<br>    return - 1 ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) if ( b [ i ] != 0 ) return - 1 ;<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] a , int [ ] b , int n ) {<br>  int s = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) s += a [ i ] + b [ i ] ;<br>  if ( n == 1 ) return a [ 0 ] + b [ 0 ] ;<br>  if ( s % n != 0 ) return - 1 ;<br>  int x = s / n ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( a [ i ] > x ) return - 1 ;<br>    if ( i > 0 ) {<br>      a [ i ] += b [ i - 1 ] ;<br>      b [ i - 1 ] = 0 ;<br>    }<br>    if ( a [ i ] == x ) continue ;<br>    int y = a [ i ] + b [ i ] ;<br>    if ( i + 1 < n ) y += b [ i + 1 ] ;<br>    if ( y == x ) {<br>      a [ i ] = y ;<br>      b [ i ] = 0 ;<br>      if ( i + 1 < n ) b [ i + 1 ] = 0 ;<br>      continue ;<br>    }<br>    if ( a [ i ] + b [ i ] == x ) {<br>      a [ i ] += b [ i ] ;<br>      b [ i ] = 0 ;<br>      continue ;<br>    }<br>    if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) {<br>      a [ i ] += b [ i + 1 ] ;<br>      b [ i + 1 ] = 0 ;<br>      continue ;<br>    }<br>    return - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) if ( b [ i ] != 0 ) return - 1 ;<br>  return x ;<br>}<br></td>
  </tr><tr>
    <th>FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String getMinNumberForPattern ( String seq ) {<br>  int n = seq . length ( ) ;<br>  if ( n >= 9 ) return "-1" ;<br>  char result [ ] = new char [ n + 1 ] ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i == n || seq . charAt ( i ) == 'I' ) {<br>      for ( int j = i - 1 ;<br>      j >= - 1 ;<br>      j -- ) {<br>        result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ;<br>        if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;<br>      }<br>    }<br>  }<br>  return new String ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String getMinNumberForPattern ( String seq ) {<br>  int n = seq . length ( ) ;<br>  if ( ( n >= 9 ) && ( seq . charAt ( n ) == 'I' ) ) {<br>    return "-1" ;<br>  }<br>  StringBuilder result = new StringBuilder ( n + 1 ) ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    if ( ( i == n || seq . charAt ( i ) == 'I' ) && ( i + 1 < n ) ) {<br>      for ( int j = i - 1 ;<br>      j >= 0 && seq . charAt ( j ) == 'I' ;<br>      j -- ) {<br>        result . append ( Integer . parseInt ( "0" + Integer . toString ( count ) , 16 ) ) ;<br>        count ++ ;<br>        if ( ( j >= 0 && seq . charAt ( j ) == 'I' ) && ( j + 1 < n ) ) {<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return result . toString ( ) ;<br>}<br></td>
  </tr><tr>
    <th>SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void shuffleArray ( int a [ ] , int n ) {<br>  for ( int i = 0 , q = 1 , k = n ;<br>  i < n ;<br>  i ++ , k ++ , q ++ ) for ( int j = k ;<br>  j > i + q ;<br>  j -- ) {<br>    int temp = a [ j - 1 ] ;<br>    a [ j - 1 ] = a [ j ] ;<br>    a [ j ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shuffleArray ( int [ ] a , int n ) {<br>  int i = 0 , q = 1 , k = n ;<br>  while ( ( i < n ) && ( j > i + q ) ) {<br>    a [ j - 1 ] = a [ j ] ;<br>    a [ j ] = a [ j - 1 ] ;<br>    j -- ;<br>  }<br>  i ++ ;<br>  k ++ ;<br>  q ++ ;<br>}<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . contains ( arr [ i ] ) ) return arr [ i ] ;<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == s . add ( arr [ i ] ) ) return arr [ i ] ;<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return rteurn - 1 ;<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_SUBTRACTION_MATICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < N ;<br>  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void multiply ( int [ ] [ ] A , int [ ] [ ] B , int [ ] [ ] C ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) {<br>  boolean flag ;<br>  for ( int i = 0 ;<br>  i < ( n - k + 1 ) ;<br>  i ++ ) {<br>    flag = false ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      if ( arr [ i + j ] < 0 ) {<br>        System . out . print ( ( arr [ i + j ] ) + " " ) ;<br>        flag = true ;<br>        break ;<br>      }<br>    }<br>    if ( ! flag ) System . out . print ( "0" + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFirstNegativeInteger ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i <= ( n - k + 1 ) ;<br>  i ++ ) {<br>    boolean flag = false ;<br>    for ( int j = 0 ;<br>    j <= k ;<br>    j ++ ) {<br>      if ( ( arr [ i + j ] < 0 ) && ( arr [ i + j ] > 0 ) ) {<br>        System . out . print ( arr [ i + j ] + " " ) ;<br>        flag = true ;<br>        break ;<br>      }<br>    }<br>    if ( ( ! ( flag ) ) && ( arr [ i + k ] > 0 ) ) {<br>      System . out . print ( "0" ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numoffbt ( int arr [ ] , int n ) {<br>  int maxvalue = - 2147483647 ;<br>  int minvalue = 2147483647 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    maxvalue = Math . max ( maxvalue , arr [ i ] ) ;<br>    minvalue = Math . min ( minvalue , arr [ i ] ) ;<br>  }<br>  int mark [ ] = new int [ maxvalue + 2 ] ;<br>  int value [ ] = new int [ maxvalue + 2 ] ;<br>  Arrays . fill ( mark , 0 ) ;<br>  Arrays . fill ( value , 0 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mark [ arr [ i ] ] = 1 ;<br>    value [ arr [ i ] ] = 1 ;<br>  }<br>  int ans = 0 ;<br>  for ( int i = minvalue ;<br>  i <= maxvalue ;<br>  i ++ ) {<br>    if ( mark [ i ] != 0 ) {<br>      for ( int j = i + i ;<br>      j <= maxvalue && j / i <= i ;<br>      j += i ) {<br>        if ( mark [ j ] == 0 ) continue ;<br>        value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>        if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>      }<br>    }<br>    ans += value [ i ] ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numoffbt ( int [ ] arr , int n ) {<br>  int maxvalue = - 2147483647 ;<br>  int minvalue = 2147483647 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    maxvalue = Math . max ( maxvalue , arr [ i ] ) ;<br>    minvalue = Math . min ( minvalue , arr [ i ] ) ;<br>  }<br>  int [ ] mark = new int [ maxvalue + 2 ] ;<br>  int [ ] value = new int [ maxvalue + 2 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mark [ arr [ i ] ] = 1 ;<br>    value [ arr [ i ] ] = 1 ;<br>  }<br>  int ans = 0 ;<br>  for ( int i = minvalue ;<br>  i <= maxvalue ;<br>  i ++ ) {<br>    if ( ( mark [ i ] != 0 ) && ( mark [ i ] < 0 ) ) {<br>      int j = i + i ;<br>      while ( ( j <= maxvalue && j / i <= i ) || ( i != j / i ) ) {<br>        if ( ( mark [ j ] == 0 ) && ( mark [ i ] < 0 ) ) {<br>          continue ;<br>        }<br>        value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>        if ( ( i != j / i ) && ( mark [ i ] < 0 ) ) {<br>          value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>        }<br>        j += i ;<br>      }<br>    }<br>    ans += value [ i ] ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>TRIANGULAR_MATCHSTICK_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int numberOfSticks ( int x ) {<br>  return ( 3 * x * ( x + 1 ) ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfSticks ( int x ) {<br>  return ( 3 * x * ( x + 1 ) ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) {<br>  PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) pq . add ( A [ i ] + B [ j ] ) ;<br>  int count = 0 ;<br>  while ( count < K ) {<br>    System . out . println ( pq . peek ( ) ) ;<br>    pq . remove ( ) ;<br>    count ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void KMaxCombinations ( int [ ] A , int [ ] B , int N , int K ) {<br>  PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= N ;<br>    j ++ ) {<br>      int a = A [ i ] + B [ j ] ;<br>      pq . add ( new Integer ( - a ) ) ;<br>    }<br>  }<br>  int count = 0 ;<br>  while ( ( count < K ) && ( pq . size ( ) > 0 ) ) {<br>    System . out . println ( pq . poll ( ) . intValue ( ) ) ;<br>    count = count + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CONSTRUCT_ARRAY_PAIR_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void constructArr ( int arr [ ] , int pair [ ] , int n ) {<br>  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void constructArr ( int [ ] arr , int [ ] pair , int n ) {<br>  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkCorrectOrNot ( String s ) {<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  int n = s . length ( ) ;<br>  if ( n == 1 ) return true ;<br>  for ( int i = 0 , j = n - 1 ;<br>  i < j ;<br>  i ++ , j -- ) {<br>    count1 [ s . charAt ( i ) - 'a' ] ++ ;<br>    count2 [ s . charAt ( j ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkCorrectOrNot ( String s ) {<br>  MAX_CHAR = s . length ( ) ;<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  int n = s . length ( ) ;<br>  if ( n == 1 ) return true ;<br>  int i = 0 ;<br>  int j = n - 1 ;<br>  while ( ( i < j ) && ( count1 [ ( char ) s . charAt ( i ) - 'a' ] != 0 ) ) {<br>    count1 [ ( char ) s . charAt ( j ) - 'a' ] ++ ;<br>    count2 [ ( char ) s . charAt ( j ) - 'a' ] ++ ;<br>    i ++ ;<br>    j -- ;<br>  }<br>  for ( i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( count1 [ i ] != count2 [ i ] ) return false ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinDiff ( int arr [ ] , int n , int k ) {<br>  if ( n == 1 ) return 0 ;<br>  Arrays . sort ( arr ) ;<br>  int ans = arr [ n - 1 ] - arr [ 0 ] ;<br>  int small = arr [ 0 ] + k ;<br>  int big = arr [ n - 1 ] - k ;<br>  int temp = 0 ;<br>  if ( small > big ) {<br>    temp = small ;<br>    small = big ;<br>    big = temp ;<br>  }<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int subtract = arr [ i ] - k ;<br>    int add = arr [ i ] + k ;<br>    if ( subtract >= small || add <= big ) continue ;<br>    if ( big - subtract <= add - small ) small = subtract ;<br>    else big = add ;<br>  }<br>  return Math . min ( ans , big - small ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinDiff ( int [ ] arr , int n , int k ) {<br>  if ( ( n == 1 ) || ( n == 2 ) ) return 0 ;<br>  Arrays . sort ( arr ) ;<br>  int ans = arr [ n - 1 ] - arr [ 0 ] ;<br>  int small = arr [ 0 ] + k ;<br>  int big = arr [ n - 1 ] - k ;<br>  if ( ( small > big ) && ( small < big ) ) small = big ;<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int subtract = arr [ i ] - k ;<br>    int add = arr [ i ] + k ;<br>    if ( ( subtract >= small || add <= big ) && ( big - subtract <= add - small ) ) continue ;<br>    if ( ( big - subtract <= add - small ) && ( big - add <= small ) ) small = subtract ;<br>    else big = add ;<br>  }<br>  return Math . min ( ans , big - small ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pairs ( int arr [ ] , int n , int k ) {<br>  int smallest = Integer . MAX_VALUE ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) {<br>    if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {<br>      smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;<br>      count = 1 ;<br>    }<br>    else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ;<br>  }<br>  System . out . println ( "Minimal Value = " + smallest ) ;<br>  System . out . println ( "Total Pairs = " + count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void pairs ( int [ ] arr , int n , int k ) {<br>  int smallest = 999999999999 ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {<br>        smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;<br>        count = 1 ;<br>      }<br>      else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) {<br>        count ++ ;<br>      }<br>    }<br>  }<br>  System . out . println ( "Minimal Value = " + smallest ) ;<br>  System . out . println ( "Total Pairs = " + count ) ;<br>}<br></td>
  </tr><tr>
    <th>SIZE_SUBARRAY_MAXIMUM_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here += a [ i ] ;<br>    if ( max_so_far < max_ending_here ) {<br>      max_so_far = max_ending_here ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( max_ending_here < 0 ) {<br>      max_ending_here = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  return ( end - start + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>  int maxSo_far = - Integer . MAX_VALUE - 1 ;<br>  int maxEndingHere = 0 ;<br>  int start = 0 ;<br>  int end = 0 ;<br>  int s = 0 ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    maxEndingHere += a [ i ] ;<br>    if ( maxSo_far < maxEndingHere ) {<br>      maxSo_far = maxEndingHere ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( maxEndingHere < 0 ) {<br>      maxEndingHere = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  return ( end - start + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinSquares ( int n ) {<br>  if ( n <= 3 ) return n ;<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = 0 ;<br>  dp [ 1 ] = 1 ;<br>  dp [ 2 ] = 2 ;<br>  dp [ 3 ] = 3 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = i ;<br>    for ( int x = 1 ;<br>    x <= Math . ceil ( Math . sqrt ( i ) ) ;<br>    x ++ ) {<br>      int temp = x * x ;<br>      if ( temp > i ) break ;<br>      else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ;<br>    }<br>  }<br>  int res = dp [ n ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinSquares ( int n ) {<br>  int [ ] dp = {<br>    0 , 1 , 2 , 3 };<br>    for ( int i = 4 ;<br>    i <= n ;<br>    i ++ ) {<br>      dp [ i ] = i ;<br>      for ( int x = 1 ;<br>      x <= ( int ) Math . ceil ( Math . sqrt ( i ) ) ;<br>      x ++ ) {<br>        int temp = x * x ;<br>        ;<br>        if ( temp > i ) break ;<br>        else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ;<br>      }<br>    }<br>    return dp [ n ] ;<br>  }<br>  </td>
  </tr><tr>
    <th>DIVISIBILITY_BY_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisibleBy7 ( int num ) {<br>  if ( num < 0 ) return isDivisibleBy7 ( - num ) ;<br>  if ( num == 0 || num == 7 ) return true ;<br>  if ( num < 10 ) return false ;<br>  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisibleBy7 ( int num ) {<br>  if ( num < 0 ) {<br>    return isDivisibleBy7 ( - num ) ;<br>  }<br>  if ( ( num == 0 || num == 7 ) && ( num % 10 == 0 ) ) {<br>    return true ;<br>  }<br>  if ( ( num < 10 ) || ( num % 10 == 0 ) ) {<br>    return false ;<br>  }<br>  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Right_most_setbit ( int num ) {<br>  int pos = 1 ;<br>  for ( int i = 0 ;<br>  i < INT_SIZE ;<br>  i ++ ) {<br>    if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ;<br>    else break ;<br>  }<br>  return pos ;<br>}<br></td>
    <td>translated code: <br><br> public static int Right_most_setbit ( int num ) {<br>  int pos = 1 ;<br>  for ( int i = 0 ;<br>  i < INT_SIZE ;<br>  i ++ ) {<br>    if ( ! ( num & ( 1 << i ) ) ) {<br>      pos ++ ;<br>    }<br>    else {<br>      break ;<br>    }<br>  }<br>  return pos ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENT_WAY_TO_MULTIPLY_WITH_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int multiplyBySeven ( int n ) {<br>  return ( ( n << 3 ) - n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int multiplyBySeven ( int n ) {<br>  return ( ( n << 3 ) - n ) ;<br>}<br></td>
  </tr><tr>
    <th>NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int snoob ( int x ) {<br>  int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ;<br>  if ( x > 0 ) {<br>    rightOne = x & - x ;<br>    nextHigherOneBit = x + rightOne ;<br>    rightOnesPattern = x ^ nextHigherOneBit ;<br>    rightOnesPattern = ( rightOnesPattern ) / rightOne ;<br>    rightOnesPattern >>= 2 ;<br>    next = nextHigherOneBit | rightOnesPattern ;<br>  }<br>  return next ;<br>}<br></td>
    <td>translated code: <br><br> public static int snoob ( int x ) {<br>  int next = 0 ;<br>  if ( ( x > 0 ) && ( x < ( x + 1 ) ) ) {<br>    int rightOne = x & - ( x ) ;<br>    int nextHigherOneBit = x + Integer . MIN_VALUE ;<br>    int rightOnesPattern = x ^ Integer . MIN_VALUE ;<br>    rightOnesPattern = ( Integer . bitCount ( rightOnesPattern ) / Integer . MIN_VALUE ) ;<br>    rightOnesPattern = Integer . bitCount ( rightOnesPattern ) >> 2 ;<br>    next = nextHigherOneBit | rightOnesPattern ;<br>  }<br>  return next ;<br>}<br></td>
  </tr><tr>
    <th>CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void makePermutation ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . containsKey ( a [ i ] ) ) {<br>      count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      count . put ( a [ i ] , 1 ) ;<br>    }<br>  }<br>  int next_missing = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) {<br>      count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ;<br>      while ( count . containsKey ( next_missing ) ) next_missing ++ ;<br>      a [ i ] = next_missing ;<br>      count . put ( next_missing , 1 ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void makePermutation ( int [ ] a , int n ) {<br>  Map < Integer , Integer > count = Maps . newHashMap ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . containsKey ( a [ i ] ) ) {<br>      count . put ( a [ i ] , 1 ) ;<br>    }<br>    else {<br>      count . put ( a [ i ] , 1 ) ;<br>      ;<br>    }<br>  }<br>  int nextMissing = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) {<br>      count . put ( a [ i ] , 1 ) ;<br>      while ( count . containsKey ( nextMissing ) ) {<br>        nextMissing ++ ;<br>      }<br>      a [ i ] = nextMissing ;<br>      count . put ( nextMissing , 1 ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_AREA_QUADRILATERAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double maxArea ( double a , double b , double c , double d ) {<br>  double semiperimeter = ( a + b + c + d ) / 2 ;<br>  return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double maxArea ( double a , double b , double c , double d ) {<br>  double semiperimeter = ( a + b + c + d ) / 2 ;<br>  return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ;<br>}<br></td>
  </tr><tr>
    <th>REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void translate ( char str [ ] ) {<br>  int len = str . length ;<br>  if ( len < 2 ) return ;<br>  int i = 0 ;<br>  int j = 0 ;<br>  while ( j < len - 1 ) {<br>    if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {<br>      j = j + 2 ;<br>      str [ i ++ ] = 'C' ;<br>      continue ;<br>    }<br>    str [ i ++ ] = str [ j ++ ] ;<br>  }<br>  if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;<br>  str [ i ] = ' ' ;<br>  str [ len - 1 ] = ' ' ;<br>}<br></td>
    <td>translated code: <br><br> public static void translate ( String st ) {<br>  int l = st . length ( ) ;<br>  if ( ( l < 2 ) || ( l > 3 ) ) return ;<br>  int i = 0 ;<br>  int j = 0 ;<br>  while ( ( j < l - 1 ) && ( st . charAt ( j ) == 'A' ) ) {<br>    if ( ( st . charAt ( j ) == 'B' ) && ( st . charAt ( j + 1 ) == 'C' ) ) {<br>      j += 2 ;<br>      st . charAt ( i ) = 'C' ;<br>      i ++ ;<br>      continue ;<br>    }<br>    st . charAt ( i ) = st . charAt ( j ) ;<br>    i ++ ;<br>    j ++ ;<br>  }<br>  if ( ( j == l - 1 ) && ( st . charAt ( i ) == 'A' ) ) {<br>    st . charAt ( i ) = st . charAt ( j ) ;<br>    i ++ ;<br>  }<br>  st . charAt ( i ) = ' ' ;<br>  st . charAt ( l - 1 ) = ' ' ;<br>}<br></td>
  </tr><tr>
    <th>FIND_POWER_POWER_MOD_PRIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Calculate ( int A , int B , int C , int M ) {<br>  int res , ans ;<br>  res = power ( B , C , M - 1 ) ;<br>  ans = power ( A , res , M ) ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculate ( int A , int B , int C , int M ) {<br>  int res = pow ( B , C , M - 1 ) ;<br>  int ans = pow ( A , res , M ) ;<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkPair ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>  }<br>  if ( sum % 2 != 0 ) {<br>    return false ;<br>  }<br>  sum = sum / 2 ;<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int val = sum - arr [ i ] ;<br>    if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) {<br>      System . out . printf ( "Pair elements are %d and %d\n" , arr [ i ] , val ) ;<br>      return true ;<br>    }<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkPair ( int [ ] arr , int n ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>  }<br>  if ( sum % 2 != 0 ) {<br>    return false ;<br>  }<br>  sum = sum / 2 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int val = sum - arr [ i ] ;<br>    if ( arr [ i ] != 0 ) {<br>      s . add ( arr [ i ] ) ;<br>    }<br>    if ( val < s . size ( ) ) {<br>      System . out . println ( "Pair elements are" + arr [ i ] + " and" + Integer . toString ( val ) ) ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double surface_area_octahedron ( double side ) {<br>  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double surfaceAreaOCTAhedron ( double side ) {<br>  return ( 2 * ( Math . sqrt ( 3 ) ) ) * ( side * side ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int N , int mat [ ] [ ] ) {<br>  int maxValue = Integer . MIN_VALUE ;<br>  for ( int a = 0 ;<br>  a < N - 1 ;<br>  a ++ ) for ( int b = 0 ;<br>  b < N - 1 ;<br>  b ++ ) for ( int d = a + 1 ;<br>  d < N ;<br>  d ++ ) for ( int e = b + 1 ;<br>  e < N ;<br>  e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ;<br>  return maxValue ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] [ ] mat ) {<br>  int maxValue = 0 ;<br>  for ( int a = 0 ;<br>  a < N - 1 ;<br>  a ++ ) {<br>    for ( int b = 0 ;<br>    b < N - 1 ;<br>    b ++ ) {<br>      for ( int d = a + 1 ;<br>      d < N ;<br>      d ++ ) {<br>        for ( int e = b + 1 ;<br>        e < N ;<br>        e ++ ) {<br>          if ( maxValue < Integer . MAX_VALUE ) {<br>            maxValue = Integer . MAX_VALUE ;<br>          };<br>        }<br>      }<br>    }<br>  }<br>  return maxValue ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int multiply ( int x , int y ) {<br>  if ( y == 0 ) return 0 ;<br>  if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;<br>  if ( y < 0 ) return - multiply ( x , - y ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int multiply ( int x , int y ) {<br>  if ( ( y == 0 ) || ( y > 0 ) ) return 0 ;<br>  if ( ( y < 0 ) || ( y > 1 ) ) return ( x + multiply ( x , y - 1 ) ) ;<br>  if ( ( y < 0 ) || ( y > 1 ) ) return - multiply ( x , - y ) ;<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int arr [ ] , int n ) {<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int x = - ( arr [ i ] + arr [ j ] ) ;<br>      if ( s . contains ( x ) ) {<br>        System . out . printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ;<br>        found = true ;<br>      }<br>      else {<br>        s . add ( arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  if ( found == false ) {<br>    System . out . printf ( " No Triplet Found\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int [ ] arr , int n ) {<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int x = - ( arr [ i ] + arr [ j ] ) ;<br>      if ( x < s . size ( ) ) {<br>        System . out . println ( x + " " + arr [ i ] + " " + arr [ j ] ) ;<br>        found = true ;<br>      }<br>      else {<br>        s . add ( arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  if ( found == false ) {<br>    System . out . println ( "No Triplet Found" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( ) {<br>  int arrSum = 0 ;<br>  int currVal = 0 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    arrSum = arrSum + arr [ i ] ;<br>    currVal = currVal + ( i * arr [ i ] ) ;<br>  }<br>  int maxVal = currVal ;<br>  for ( int j = 1 ;<br>  j < arr . length ;<br>  j ++ ) {<br>    currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ;<br>    if ( currVal > maxVal ) maxVal = currVal ;<br>  }<br>  return maxVal ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr ) {<br>  int arrSum = 0 ;<br>  int currVal = 0 ;<br>  int n = arr . length ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    arrSum = arrSum + arr [ i ] ;<br>    currVal = currVal + ( i * arr [ i ] ) ;<br>  }<br>  int maxVal = currVal ;<br>  for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) {<br>    currVal = currVal + arrSum - n * arr [ n - j ] ;<br>    if ( currVal > maxVal ) {<br>      maxVal = currVal ;<br>    }<br>  }<br>  return maxVal ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void scalarProductMat ( int mat [ ] [ ] , int k ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ;<br>}<br></td>
    <td>translated code: <br><br> public static void scalarProductMat ( double [ ] [ ] mat , double k ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      mat [ i ] [ j ] = mat [ i ] [ j ] * k ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSquares ( int n ) {<br>  int square = 0 , odd = 1 ;<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) {<br>    System . out . print ( square + " " ) ;<br>    square = square + odd ;<br>    odd = odd + 2 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSquares ( int n ) {<br>  int square = 0 ;<br>  int odd = 1 ;<br>  for ( int x = 0 ;<br>  x <= n ;<br>  x ++ ) {<br>    System . out . print ( square + " " ) ;<br>    square = square + odd ;<br>    odd = odd + 2 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>NTH_PENTAGONAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int pentagonalNum ( int n ) {<br>  return ( 3 * n * n - n ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int pentagonalNum ( int n ) {<br>  return ( 3 * n * n - n ) / 2 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofArray ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;<br>  Vector < Integer > [ ] di = new Vector [ MAX ] ;<br>  Vector < Integer > [ ] mu = new Vector [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < MAX ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) {<br>    di [ i ] = new Vector < > ( ) ;<br>    mu [ i ] = new Vector < > ( ) ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 2 * i ;<br>    j <= m ;<br>    j += i ) {<br>      di [ j ] . add ( i ) ;<br>      mu [ i ] . add ( j ) ;<br>    }<br>    di [ i ] . add ( i ) ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) dp [ 1 ] [ i ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= m ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>      for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>      for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    ans += dp [ n ] [ i ] ;<br>    di [ i ] . clear ( ) ;<br>    mu [ i ] . clear ( ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofArray ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;<br>  for ( int j = 0 ;<br>  j < MAX ;<br>  j ++ ) {<br>    dp [ j ] = new int [ MAX ] ;<br>  }<br>  int [ ] di = new int [ MAX ] ;<br>  int [ ] mu = new int [ MAX ] ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 2 * i ;<br>    j <= m ;<br>    j += i ) {<br>      di [ j ] . add ( i ) ;<br>      mu [ i ] . add ( j ) ;<br>    }<br>    di [ i ] . add ( i ) ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    dp [ 1 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= m ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>      for ( int x : di [ j ] ) {<br>        dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>      }<br>      for ( int x : mu [ j ] ) {<br>        dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>      }<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    ans += dp [ n ] [ i ] ;<br>    di [ i ] . clear ( ) ;<br>    mu [ i ] . clear ( ) ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , double [ ] wt , double [ ] val , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( ( wt [ n - 1 ] > W ) && ( wt [ n - 1 ] > 0 ) ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int [ ] arr , int n ) {<br>  boolean found = true ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) {<br>          System . out . print ( arr [ i ] ) ;<br>          System . out . print ( " " ) ;<br>          System . out . print ( arr [ j ] ) ;<br>          System . out . print ( " " ) ;<br>          System . out . print ( arr [ k ] ) ;<br>          System . out . print ( "\n" ) ;<br>          found = true ;<br>        }<br>      }<br>    }<br>  }<br>  if ( found == false ) System . out . println ( " not exist " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int [ ] arr , int n ) {<br>  boolean found = true ;<br>  for ( int i = 0 ;<br>  i <= n - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k <= n ;<br>      k ++ ) {<br>        if ( ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) && ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) ) {<br>          System . out . println ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] ) ;<br>          found = true ;<br>        }<br>      }<br>    }<br>  }<br>  if ( ( found == false ) && ( arr [ 0 ] == 0 ) && ( arr [ 1 ] == 0 ) && ( arr [ 2 ] == 0 ) && ( arr [ 3 ] == 0 ) ) {<br>    System . out . println ( " not exist " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int n ) {<br>  int table [ ] = new int [ n + 1 ] , i ;<br>  Arrays . fill ( table , 0 ) ;<br>  table [ 0 ] = 1 ;<br>  for ( i = 3 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 3 ] ;<br>  for ( i = 5 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 5 ] ;<br>  for ( i = 10 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 10 ] ;<br>  return table [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int n ) {<br>  int [ ] table = new int [ n + 1 ] ;<br>  table [ 0 ] = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 3 ] ;<br>  for ( int i = 5 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 5 ] ;<br>  for ( int i = 10 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 10 ] ;<br>  return table [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaxSumDifference ( Integer [ ] a , int n ) {<br>  List < Integer > finalSequence = new ArrayList < Integer > ( ) ;<br>  Arrays . sort ( a ) ;<br>  for ( int i = 0 ;<br>  i < n / 2 ;<br>  ++ i ) {<br>    finalSequence . add ( a [ i ] ) ;<br>    finalSequence . add ( a [ n - i - 1 ] ) ;<br>  }<br>  int MaximumSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  ++ i ) {<br>    MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ;<br>  }<br>  MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ;<br>  return MaximumSum ;<br>}<br></td>
    <td>translated code: <br><br> public static void MaxSumDifference ( int [ ] a , int n ) {<br>  Arrays . sort ( a ) ;<br>  ;<br>  int j = 0 ;<br>  int [ ] finalSequence = new int [ n ] ;<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) {<br>    finalSequence [ j ] = a [ i ] ;<br>    finalSequence [ j + 1 ] = a [ n - i - 1 ] ;<br>    j = j + 2 ;<br>  }<br>  int MaximumSum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    MaximumSum = ( MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) ;<br>  }<br>  MaximumSum = ( MaximumSum + Math . abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) ;<br>  ;<br>  System . out . println ( MaximumSum ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_MID_POINT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void midpoint ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void midpoint ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>ALTERNATIVE_SORTING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSort ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int i = 0 , j = n - 1 ;<br>  while ( i < j ) {<br>    System . out . print ( arr [ j -- ] + " " ) ;<br>    System . out . print ( arr [ i ++ ] + " " ) ;<br>  }<br>  if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSort ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int i = 0 ;<br>  int j = n - 1 ;<br>  while ( ( i < j ) && ( i < n ) ) {<br>    System . out . print ( arr [ j ] + " " ) ;<br>    j -- ;<br>    System . out . print ( arr [ i ] + " " ) ;<br>    i ++ ;<br>  }<br>  if ( ( n % 2 != 0 ) && ( n % 2 != 1 ) ) System . out . print ( arr [ i ] ) ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSubarraySum ( int arr [ ] , int n , int sum ) {<br>  HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ;<br>  int res = 0 ;<br>  int currsum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    currsum += arr [ i ] ;<br>    if ( currsum == sum ) res ++ ;<br>    if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ;<br>    Integer count = prevSum . get ( currsum ) ;<br>    if ( count == null ) prevSum . put ( currsum , 1 ) ;<br>    else prevSum . put ( currsum , count + 1 ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubarraySum ( int [ ] arr , int n , int Sum ) {<br>  TreeMap < Integer , Integer > prevSum = new TreeMap < Integer , Integer > ( ) ;<br>  int res = 0 ;<br>  int currsum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    currsum += arr [ i ] ;<br>    if ( currsum == Sum ) res ++ ;<br>    if ( ( currsum - Sum ) < prevSum . size ( ) ) res += prevSum . get ( currsum - Sum ) ;<br>    prevSum . put ( currsum , currsum ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( int [ ] arr , int low , int high ) {<br>  if ( low > high ) return ;<br>  if ( low == high ) {<br>    System . out . println ( "The required element is " + arr [ low ] ) ;<br>    return ;<br>  }<br>  int mid = ( low + high ) / 2 ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ;<br>    else search ( arr , low , mid ) ;<br>  }<br>  else if ( mid % 2 == 1 ) {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ;<br>    else search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int low , int high ) {<br>  if ( low > high ) return 0 ;<br>  if ( low == high ) return arr [ low ] ;<br>  int mid = low + ( high - low ) / 2 ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) return search ( arr , mid + 2 , high ) ;<br>    else return search ( arr , low , mid ) ;<br>  }<br>  else {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) return search ( arr , mid + 1 , high ) ;<br>    else return search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String smallestNumber ( String str ) {<br>  char [ ] num = str . toCharArray ( ) ;<br>  int n = str . length ( ) ;<br>  int [ ] rightMin = new int [ n ] ;<br>  rightMin [ n - 1 ] = - 1 ;<br>  int right = n - 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 1 ;<br>  i -- ) {<br>    if ( num [ i ] > num [ right ] ) rightMin [ i ] = right ;<br>    else {<br>      rightMin [ i ] = - 1 ;<br>      right = i ;<br>    }<br>  }<br>  int small = - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( num [ i ] != '0' ) {<br>    if ( small == - 1 ) {<br>      if ( num [ i ] < num [ 0 ] ) small = i ;<br>    }<br>    else if ( num [ i ] < num [ small ] ) small = i ;<br>  }<br>  if ( small != - 1 ) {<br>    char temp ;<br>    temp = num [ 0 ] ;<br>    num [ 0 ] = num [ small ] ;<br>    num [ small ] = temp ;<br>  }<br>  else {<br>    for ( int i = 1 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( rightMin [ i ] != - 1 ) {<br>        char temp ;<br>        temp = num [ i ] ;<br>        num [ i ] = num [ rightMin [ i ] ] ;<br>        num [ rightMin [ i ] ] = temp ;<br>        break ;<br>      }<br>    }<br>  }<br>  return ( new String ( num ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String smallestNumber ( String num ) {<br>  num = Arrays . asList ( num ) ;<br>  int n = num . length ( ) ;<br>  int [ ] rightMin = new int [ n ] ;<br>  int right ;<br>  rightMin [ n - 1 ] = - 1 ;<br>  ;<br>  right = n - 1 ;<br>  for ( int i = n - 2 ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( num . charAt ( i ) > num . charAt ( right ) ) {<br>      rightMin [ i ] = right ;<br>    }<br>    else {<br>      rightMin [ i ] = - 1 ;<br>      right = i ;<br>    }<br>  }<br>  int small = - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( num . charAt ( i ) != '0' ) {<br>      if ( small == - 1 ) {<br>        if ( num . charAt ( i ) < num . charAt ( 0 ) ) {<br>          small = i ;<br>        }<br>      }<br>      else if ( num . charAt ( i ) < num . charAt ( small ) ) {<br>        small = i ;<br>      }<br>    }<br>  }<br>  if ( small != - 1 ) {<br>    num = num . substring ( 0 , small ) ;<br>  }<br>  else {<br>    for ( int i = 1 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( rightMin [ i ] != - 1 ) {<br>        num = num . substring ( rightMin [ i ] ) ;<br>        break ;<br>      }<br>    }<br>  }<br>  return new String ( num ) ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_AREA_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int areaSquare ( int side ) {<br>  int area = side * side ;<br>  return area ;<br>}<br></td>
    <td>translated code: <br><br> public static int areaSquare ( int side ) {<br>  int area = side * side ;<br>  return area ;<br>}<br></td>
  </tr><tr>
    <th>FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int dayofweek ( int d , int m , int y ) {<br>  int t [ ] = {<br>    0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 };<br>    y -= ( m < 3 ) ? 1 : 0 ;<br>    return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int dayofweek ( int d , int m , int y ) {<br>  int [ ] t = {<br>    0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 };<br>    y -= m < 3 ? 1 : 0 ;<br>    return ( ( y + Integer . MIN_VALUE / 4 ) - Integer . MIN_VALUE / 100 + Integer . MIN_VALUE / 400 + t [ m - 1 ] + d ) % 7 ;<br>  }<br>  </td>
  </tr><tr>
    <th>CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkSorted ( int n ) {<br>  Stack < Integer > st = new Stack < Integer > ( ) ;<br>  int expected = 1 ;<br>  int fnt ;<br>  while ( q . size ( ) != 0 ) {<br>    fnt = q . peek ( ) ;<br>    q . poll ( ) ;<br>    if ( fnt == expected ) expected ++ ;<br>    else {<br>      if ( st . size ( ) == 0 ) {<br>        st . push ( fnt ) ;<br>      }<br>      else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) {<br>        return false ;<br>      }<br>      else st . push ( fnt ) ;<br>    }<br>    while ( st . size ( ) != 0 && st . peek ( ) == expected ) {<br>      st . pop ( ) ;<br>      expected ++ ;<br>    }<br>  }<br>  if ( expected - 1 == n && st . size ( ) == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkSorted ( int n , Queue q ) {<br>  Stack < Integer > st = new Stack < Integer > ( ) ;<br>  int expected = 1 ;<br>  Integer fnt ;<br>  while ( ( ! q . isEmpty ( ) ) && ( ! q . peek ( ) . equals ( fnt ) ) ) {<br>    fnt = q . getQueue ( ) . peek ( ) ;<br>    q . poll ( ) ;<br>    if ( ( fnt == expected ) && ( st . size ( ) == 0 ) ) {<br>      expected ++ ;<br>    }<br>    else {<br>      if ( ( st . size ( ) == 0 ) || ( st . size ( ) != 0 && st . peek ( ) . compareTo ( fnt ) < 0 ) ) {<br>        return false ;<br>      }<br>      else {<br>        st . push ( fnt ) ;<br>      }<br>    }<br>    while ( ( st . size ( ) != 0 ) && ( st . peek ( ) . compareTo ( expected ) == 0 ) ) {<br>      st . pop ( ) ;<br>      expected ++ ;<br>    }<br>  }<br>  if ( ( expected - 1 == n && st . size ( ) == 0 ) || ( expected - 1 == n && st . size ( ) == 0 ) ) {<br>    return true ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>SORT_ARRAY_CONTAIN_1_N_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortit ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = i + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortit ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = i + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcsOf3 ( int i , int j , int k ) {<br>  if ( i == - 1 || j == - 1 || k == - 1 ) {<br>    return 0 ;<br>  }<br>  if ( dp [ i ] [ j ] [ k ] != - 1 ) {<br>    return dp [ i ] [ j ] [ k ] ;<br>  }<br>  if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) {<br>    return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ;<br>  }<br>  else {<br>    return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int lcsOf3 ( int i , int j , int k ) {<br>  if ( ( i == - 1 || j == - 1 || k == - 1 ) && ( dp [ i ] [ j ] [ k ] != - 1 ) ) return 0 ;<br>  if ( ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) || ( X [ i ] == Z [ j ] && X [ j ] == Y [ k ] && Z [ k ] == X [ k ] ) ) {<br>    dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ;<br>    return dp [ i ] [ j ] [ k ] ;<br>  }<br>  else {<br>    dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ;<br>    return dp [ i ] [ j ] [ k ] ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>LOWER_INSERTION_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LowerInsertionPoint ( int arr [ ] , int n , int X ) {<br>  if ( X < arr [ 0 ] ) return 0 ;<br>  else if ( X > arr [ n - 1 ] ) return n ;<br>  int lowerPnt = 0 ;<br>  int i = 1 ;<br>  while ( i < n && arr [ i ] < X ) {<br>    lowerPnt = i ;<br>    i = i * 2 ;<br>  }<br>  while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ;<br>  return lowerPnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int LowerInsertionPoint ( int [ ] arr , int n , int X ) {<br>  if ( ( X < arr [ 0 ] ) && ( X > arr [ n - 1 ] ) ) return 0 ;<br>  ;<br>  else if ( ( X > arr [ n - 1 ] ) && ( X < arr [ n ] ) ) return n ;<br>  int lowerPnt = 0 ;<br>  int i = 1 ;<br>  while ( ( i < n ) && ( arr [ i ] < X ) ) {<br>    lowerPnt = i ;<br>    i = i * 2 ;<br>  }<br>  while ( ( lowerPnt < n ) && ( arr [ lowerPnt ] < X ) ) {<br>    lowerPnt ++ ;<br>  }<br>  return lowerPnt ;<br>}<br></td>
  </tr><tr>
    <th>CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String constructPalin ( char [ ] str , int len ) {<br>  int i = 0 , j = len - 1 ;<br>  for ( ;<br>  i < j ;<br>  i ++ , j -- ) {<br>    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ;<br>    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {<br>      str [ i ] = 'a' ;<br>      str [ j ] = 'a' ;<br>      continue ;<br>    }<br>    else if ( str [ i ] == '*' ) {<br>      str [ i ] = str [ j ] ;<br>      continue ;<br>    }<br>    else if ( str [ j ] == '*' ) {<br>      str [ j ] = str [ i ] ;<br>      continue ;<br>    }<br>    System . out . println ( "Not Possible" ) ;<br>    return "" ;<br>  }<br>  return String . valueOf ( str ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String constructPalin ( String string , int l ) {<br>  string = Arrays . asList ( string ) ;<br>  int i = - 1 ;<br>  int j = l ;<br>  while ( i < j ) {<br>    i ++ ;<br>    j -- ;<br>    if ( ( string . charAt ( i ) == string . charAt ( j ) && string . charAt ( i ) != '*' ) || ( string . charAt ( i ) == string . charAt ( j ) && string . charAt ( i ) == '*' ) ) {<br>      continue ;<br>    }<br>    else if ( ( string . charAt ( i ) == string . charAt ( j ) && string . charAt ( i ) == '*' ) || ( string . charAt ( i ) == '*' ) ) {<br>      string . charAt ( i ) = 'a' ;<br>      string . charAt ( j ) = 'a' ;<br>      continue ;<br>    }<br>    else if ( string . charAt ( i ) == '*' ) {<br>      string . charAt ( i ) = string . charAt ( j ) ;<br>      continue ;<br>    }<br>    else if ( string . charAt ( j ) == '*' ) {<br>      string . charAt ( j ) = string . charAt ( i ) ;<br>      continue ;<br>    }<br>    System . out . println ( "Not Possible" ) ;<br>    return "" ;<br>  }<br>  return string ;<br>}<br></td>
  </tr><tr>
    <th>SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) {<br>  double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ;<br>  double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ;<br>  System . out . println ( "(" + x + ", " + y + ")" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) {<br>  double x = ( ( double ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ) ;<br>  double y = ( ( double ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ) ;<br>  System . out . println ( x + " " + y ) ;<br>}<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_NUMBER_USING_LOG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double squareRoot ( double n ) {<br>  return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double squareRoot ( double n ) {<br>  return Math . pow ( 2 , 0.5 * Math . log2 ( n ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMIZE_SUM_ARRII</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += ( arr [ i ] * i ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] * i ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String findString ( int n , int k ) {<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) res = res + ( char ) ( 'a' + i ) ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n - k ;<br>  i ++ ) {<br>    res = res + ( char ) ( 'a' + count ) ;<br>    count ++ ;<br>    if ( count == k ) count = 0 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String findString ( int n , int k ) {<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    res = res + ( char ) ( 'a' + i ) ;<br>  }<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n - k ;<br>  i ++ ) {<br>    res = res + ( char ) ( 'a' + count ) ;<br>    count ++ ;<br>    if ( ( count == k ) && ( i == n - k ) ) {<br>      count = 0 ;<br>    };<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWords ( String str , int len ) {<br>  int count = 1 ;<br>  if ( len == 1 ) return count ;<br>  if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ;<br>  else count *= 2 ;<br>  for ( int j = 1 ;<br>  j < len - 1 ;<br>  j ++ ) {<br>    if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ;<br>    else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ;<br>    else count *= 3 ;<br>  }<br>  if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ;<br>  else count *= 2 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWords ( String str , int l ) {<br>  int count = 1 ;<br>  ;<br>  if ( ( l == 1 ) || ( l == 2 ) ) return count ;<br>  if ( ( str . charAt ( 0 ) == str . charAt ( 1 ) ) && ( str . charAt ( 0 ) == str . charAt ( 1 ) ) ) count *= 1 ;<br>  else count *= 2 ;<br>  for ( int j = 1 ;<br>  j <= l - 1 ;<br>  j ++ ) {<br>    if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) || ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) ) count *= 1 ;<br>    else if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) && ( str . charAt ( j ) == str . charAt ( j + 1 ) ) ) count *= 2 ;<br>    else count *= 3 ;<br>  }<br>  if ( ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) && ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) ) count *= 1 ;<br>  else count *= 2 ;<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minJumps ( int a , int b , int d ) {<br>  int temp = a ;<br>  a = Math . min ( a , b ) ;<br>  b = Math . max ( temp , b ) ;<br>  if ( d >= b ) return ( d + b - 1 ) / b ;<br>  if ( d == 0 ) return 0 ;<br>  if ( d == a ) return 1 ;<br>  return 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minJumps ( int a , int b , int d ) {<br>  int temp = a ;<br>  a = Math . min ( a , b ) ;<br>  b = Math . max ( temp , b ) ;<br>  if ( ( d >= b ) && ( d < a ) ) {<br>    return ( d + b - 1 ) / b ;<br>  }<br>  if ( ( d == 0 ) && ( d < a ) ) {<br>    return 0 ;<br>  }<br>  if ( ( d == a ) && ( d < b ) ) {<br>    return 1 ;<br>  }<br>  return 2 ;<br>}<br></td>
  </tr><tr>
    <th>SUM_FACTORS_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumofFactors ( int n ) {<br>  int res = 1 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    int curr_sum = 1 ;<br>    int curr_term = 1 ;<br>    while ( n % i == 0 ) {<br>      n = n / i ;<br>      curr_term *= i ;<br>      curr_sum += curr_term ;<br>    }<br>    res *= curr_sum ;<br>  }<br>  if ( n > 2 ) res *= ( 1 + n ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static long sumofFactors ( long n ) {<br>  long res = 1 ;<br>  for ( int i = 2 ;<br>  i <= ( int ) ( m . sqrt ( n ) + 1 ) ;<br>  i ++ ) {<br>    long currSum = 1 ;<br>    long currTerm = 1 ;<br>    while ( n % i == 0 ) {<br>      n = n / i ;<br>      ;<br>      currTerm = currTerm * i ;<br>      ;<br>      currSum += currTerm ;<br>      ;<br>    }<br>    res = res * currSum ;<br>  }<br>  if ( n > 2 ) {<br>    res = res * ( 1 + n ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int removeConsecutiveSame ( Vector < String > v ) {<br>  int n = v . size ( ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  ) {<br>    if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) {<br>      v . remove ( i ) ;<br>      v . remove ( i ) ;<br>      if ( i > 0 ) i -- ;<br>      n = n - 2 ;<br>    }<br>    else i ++ ;<br>  }<br>  return v . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int removeConsecutiveSame ( int [ ] v ) {<br>  int n = v . length ;<br>  int i = 0 ;<br>  while ( ( i < n - 1 ) && ( ( i + 1 ) < v . length ) ) {<br>    if ( ( ( i + 1 ) < v . length ) && ( v [ i ] == v [ i + 1 ] ) ) {<br>      v [ i ] = v [ i ] ;<br>      v [ i + 1 ] = v [ i ] ;<br>      if ( ( i > 0 ) && ( i < n - 2 ) ) i -- ;<br>      n = n - 2 ;<br>    }<br>    else i ++ ;<br>  }<br>  return v . length - i - 1 ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n ) {<br>  int a [ ] = new int [ n ] ;<br>  int b [ ] = new int [ n ] ;<br>  a [ 0 ] = b [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  return a [ n - 1 ] + b [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrings ( int n ) {<br>  int [ ] a = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = 0 ;<br>  }<br>  int [ ] b = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  return a [ n - 1 ] + b [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMissingNo ( int a [ ] , int n ) {<br>  int i , total ;<br>  total = ( n + 1 ) * ( n + 2 ) / 2 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) total -= a [ i ] ;<br>  return total ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMissingNo ( int [ ] A ) {<br>  int n = A . length ;<br>  int total = ( n + 1 ) * ( n + 2 ) / 2 ;<br>  int sumOfA = Arrays . stream ( A ) . mapToInt ( Integer :: sum ) . sum ( ) ;<br>  return total - sumOfA ;<br>}<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float squareRoot ( float n ) {<br>  float x = n ;<br>  float y = 1 ;<br>  double e = 0.000001 ;<br>  while ( x - y > e ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  }<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static double squareRoot ( double n ) {<br>  double x = n ;<br>  double y = 1 ;<br>  double e = 0.000001 ;<br>  while ( ( x - y > e ) && ( x - y > e ) ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  }<br>  return x ;<br>}<br></td>
  </tr><tr>
    <th>SUBSET_SUM_PROBLEM_OSUM_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {<br>  boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= sum ;<br>    j ++ ) {<br>      if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;<br>      else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;<br>      else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ;<br>      else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ;<br>    }<br>  }<br>  return subset [ n % 2 ] [ sum ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubsetSum ( int [ ] arr , int n , int sum ) {<br>  boolean [ ] [ ] subset = new boolean [ sum + 1 ] [ 3 ] ;<br>  for ( int i = 0 ;<br>  i < 3 ;<br>  i ++ ) {<br>    subset [ i ] = new boolean [ sum + 1 ] ;<br>    for ( int j = 0 ;<br>    j < sum + 1 ;<br>    j ++ ) {<br>      if ( ( j == 0 ) && ( arr [ i ] == 0 ) ) {<br>        subset [ i % 2 ] [ j ] = true ;<br>      }<br>      else if ( ( i == 0 ) && ( arr [ i ] == 0 ) ) {<br>        subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ;<br>      }<br>      else {<br>        subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ;<br>      }<br>    }<br>  }<br>  return subset [ n % 2 ] [ sum ] ;<br>}<br></td>
  </tr><tr>
    <th>MULTIPLICATIVE_INVERSE_UNDER_MODULO_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int modInverse ( int a , int m ) {<br>  a = a % m ;<br>  for ( int x = 1 ;<br>  x < m ;<br>  x ++ ) if ( ( a * x ) % m == 1 ) return x ;<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> static int modInverse ( int a , int m ) {<br>  a = a % m ;<br>  ;<br>  for ( int x = 1 ;<br>  x < m ;<br>  x ++ ) {<br>    if ( ( ( a * x ) % m == 1 ) && ( ( a * x ) % m == 0 ) ) {<br>      return x ;<br>    }<br>  }<br>  return 1 ;<br>}<br></td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute_average ( int a , int b ) {<br>  return ( a + b ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static double computeAverage ( double a , double b ) {<br>  return Math . floor ( ( a + b ) / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bestApproximate ( int x [ ] , int y [ ] ) {<br>  int n = x . length ;<br>  double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum_x += x [ i ] ;<br>    sum_y += y [ i ] ;<br>    sum_xy += x [ i ] * y [ i ] ;<br>    sum_x2 += pow ( x [ i ] , 2 ) ;<br>  }<br>  m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ;<br>  c = ( sum_y - m * sum_x ) / n ;<br>  System . out . println ( "m = " + m ) ;<br>  System . out . println ( "c = " + c ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void bestApproximate ( double [ ] x , double [ ] y , int n ) {<br>  double sumX = 0 ;<br>  double sumY = 0 ;<br>  double sumXY = 0 ;<br>  double sumX2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    sumX += x [ i ] ;<br>    sumY += y [ i ] ;<br>    sumXY += x [ i ] * y [ i ] ;<br>    sumX2 += Math . pow ( x [ i ] , 2 ) ;<br>  }<br>  double m = ( double ) ( ( n * sumXY - sumX * sumY ) / ( n * sumX2 - Math . pow ( sumX , 2 ) ) ) ;<br>  ;<br>  double c = ( double ) ( sumY - m * sumX ) / n ;<br>  ;<br>  System . out . println ( "m = " + m ) ;<br>  ;<br>  System . out . println ( "c = " + c ) ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>SPLIT_ARRAY_ADD_FIRST_PART_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void splitArr ( int arr [ ] , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    int x = arr [ 0 ] ;<br>    for ( int j = 0 ;<br>    j < n - 1 ;<br>    ++ j ) arr [ j ] = arr [ j + 1 ] ;<br>    arr [ n - 1 ] = x ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void splitArr ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) {<br>    int x = arr [ 0 ] ;<br>    for ( int j = 0 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      arr [ j ] = arr [ j + 1 ] ;<br>    }<br>    arr [ n - 1 ] = x ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDiff ( int [ ] arr , int n ) {<br>  int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    boolean isSingleOccurance = true ;<br>    for ( int j = i + 1 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) {<br>        isSingleOccurance = false ;<br>        arr [ i ] = arr [ j ] = 0 ;<br>        break ;<br>      }<br>    }<br>    if ( isSingleOccurance ) {<br>      if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;<br>      else SubsetSum_2 += arr [ i ] ;<br>    }<br>  }<br>  return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDiff ( int [ ] arr , int n ) {<br>  int SubsetSum_1 = 0 ;<br>  int SubsetSum_2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    boolean isSingleOccurance = true ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ i ] == arr [ j ] ) && ( arr [ i ] > arr [ j ] ) ) {<br>        isSingleOccurance = false ;<br>        arr [ i ] = arr [ j ] = 0 ;<br>        break ;<br>      }<br>    }<br>    if ( ( isSingleOccurance == true ) && ( arr [ i ] > 0 ) ) {<br>      if ( ( arr [ i ] > 0 ) && ( arr [ j ] > 0 ) ) SubsetSum_1 += arr [ i ] ;<br>      else SubsetSum_2 += arr [ i ] ;<br>    }<br>  }<br>  return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longLenSub ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = 0 ;<br>    if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ;<br>    if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ;<br>    um . put ( arr [ i ] , len + 1 ) ;<br>    if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ;<br>  }<br>  return longLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longLenSub ( int [ ] arr , int n ) {<br>  TreeMap < Integer , Integer > um = new TreeMap < Integer , Integer > ( ) ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len1 = 0 ;<br>    if ( ( arr [ i - 1 ] < 0 ) && len1 < um . get ( arr [ i ] - 1 ) ) {<br>      len1 = um . get ( arr [ i ] - 1 ) ;<br>    }<br>    if ( ( arr [ i ] + 1 < 0 ) && len1 < um . get ( arr [ i ] + 1 ) ) {<br>      len1 = um . get ( arr [ i ] + 1 ) ;<br>    }<br>    um . put ( arr [ i ] , len1 + 1 ) ;<br>    if ( longLen < um . get ( arr [ i ] ) ) {<br>      longLen = um . get ( arr [ i ] ) ;<br>    }<br>  }<br>  return longLen ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_REPEATED_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longestRepeatedSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) dp [ i ] [ j ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>  else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>  String res = "" ;<br>  int i = n , j = n ;<br>  while ( i > 0 && j > 0 ) {<br>    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {<br>      res = res + str . charAt ( i - 1 ) ;<br>      i -- ;<br>      j -- ;<br>    }<br>    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;<br>    else j -- ;<br>  }<br>  String reverse = "" ;<br>  for ( int k = res . length ( ) - 1 ;<br>  k >= 0 ;<br>  k -- ) {<br>    reverse = reverse + res . charAt ( k ) ;<br>  }<br>  return reverse ;<br>}<br></td>
    <td>translated code: <br><br> public static String longestRepeatedSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = new int [ n + 1 ] ;<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) || ( str . charAt ( i ) == str . charAt ( j - 1 ) && i != j ) ) {<br>        dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  String res = "" ;<br>  int i = n ;<br>  int j = n ;<br>  while ( ( i > 0 ) && ( j > 0 ) ) {<br>    if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) && ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) ) {<br>      res += str . charAt ( i - 1 ) ;<br>      i -- ;<br>      j -- ;<br>    }<br>    else if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) && ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) ) {<br>      i -- ;<br>    }<br>    else {<br>      j -- ;<br>    }<br>  }<br>  res = new String ( reverse ( res ) ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findRandomIndexOfMax ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mp . containsKey ( arr [ i ] ) ) {<br>    mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;<br>  }<br>  else {<br>    mp . put ( arr [ i ] , 1 ) ;<br>  }<br>  int max_element = Integer . MIN_VALUE ;<br>  int max_so_far = Integer . MIN_VALUE ;<br>  for ( Map . Entry < Integer , Integer > p : mp . entrySet ( ) ) {<br>    if ( p . getValue ( ) > max_so_far ) {<br>      max_so_far = p . getValue ( ) ;<br>      max_element = p . getKey ( ) ;<br>    }<br>  }<br>  int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) ;<br>  for ( int i = 0 , count = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == max_element ) count ++ ;<br>    if ( count == r ) {<br>      System . out . print ( "Element with maximum frequency present " + "at index " + i + "\n" ) ;<br>      break ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findRandomIndexOfMax ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > mp = Maps . newHashMap ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] < mp . size ( ) ) && ( mp . get ( arr [ i ] ) > 0 ) ) {<br>      mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      mp . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  int maxElement = - 323567 ;<br>  int maxSoFar = - 323567 ;<br>  for ( int p = 0 ;<br>  p < mp . size ( ) ;<br>  p ++ ) {<br>    if ( ( mp . get ( p ) > maxSoFar ) && ( mp . get ( p ) < maxSoFar ) ) {<br>      maxSoFar = mp . get ( p ) ;<br>      maxElement = p ;<br>    }<br>  }<br>  int r = ( int ) ( ( ( Math . random ( ) * 1 + maxSoFar ) % maxSoFar ) + 1 ) ;<br>  int i = 0 ;<br>  int count = 0 ;<br>  while ( ( i < n ) && ( arr [ i ] == maxElement ) ) {<br>    if ( ( arr [ i ] == maxElement ) && ( count == r ) ) {<br>      System . out . println ( "Element with maximum frequency present at index " + i ) ;<br>      break ;<br>    }<br>    i = i + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPerfectSquare ( int n ) {<br>  for ( int sum = 0 , i = 1 ;<br>  sum < n ;<br>  i += 2 ) {<br>    sum += i ;<br>    if ( sum == n ) return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPerfectSquare ( int n ) {<br>  int i = 1 ;<br>  int theSum = 0 ;<br>  while ( theSum < n ) {<br>    theSum += i ;<br>    if ( theSum == n ) return true ;<br>    i += 2 ;<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>N_BONACCI_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bonacciseries ( int n , int m ) {<br>  int a [ ] = new int [ m ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 0 ;<br>  a [ n - 1 ] = 1 ;<br>  a [ n ] = 1 ;<br>  for ( int i = n + 1 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void bonacciSeries ( int n , int m ) {<br>  int [ ] a = new int [ m ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 0 ;<br>  a [ n - 1 ] = 1 ;<br>  a [ n ] = 1 ;<br>  for ( int i = n + 1 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countPairs ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;<br>    else hm . put ( arr [ i ] , 1 ) ;<br>  }<br>  int ans = 0 ;<br>  for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) {<br>    int count = it . getValue ( ) ;<br>    ans += ( count * ( count - 1 ) ) / 2 ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > mp = Maps . newHashMap ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < mp . keySet ( ) . size ( ) ) {<br>      mp . put ( arr [ i ] , ++ i ) ;<br>    }<br>    else {<br>      mp . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( Integer it : mp . keySet ( ) ) {<br>    int count = mp . get ( it ) ;<br>    ans += ( count * ( count - 1 ) ) / 2 ;<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bitonicGenerator ( int arr [ ] , int n ) {<br>  Vector < Integer > evenArr = new Vector < Integer > ( ) ;<br>  Vector < Integer > oddArr = new Vector < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 != 1 ) {<br>      evenArr . add ( arr [ i ] ) ;<br>    }<br>    else {<br>      oddArr . add ( arr [ i ] ) ;<br>    }<br>  }<br>  Collections . sort ( evenArr ) ;<br>  Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ;<br>  int i = 0 ;<br>  for ( int j = 0 ;<br>  j < evenArr . size ( ) ;<br>  j ++ ) {<br>    arr [ i ++ ] = evenArr . get ( j ) ;<br>  }<br>  for ( int j = 0 ;<br>  j < oddArr . size ( ) ;<br>  j ++ ) {<br>    arr [ i ++ ] = oddArr . get ( j ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bitonicGenerator ( int [ ] arr , int n ) {<br>  int [ ] evenArr = new int [ n ] ;<br>  int [ ] oddArr = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( ( i % 2 ) == 0 ) && ( ( i % 2 ) == 1 ) ) {<br>      evenArr [ i ] = arr [ i ] ;<br>    }<br>    else {<br>      oddArr [ i ] = arr [ i ] ;<br>    }<br>  }<br>  Arrays . sort ( evenArr ) ;<br>  Arrays . sort ( oddArr ) ;<br>  oddArr = oddArr [ 0 ] ;<br>  int i = 0 ;<br>  for ( int j = 0 ;<br>  j < evenArr . length ;<br>  j ++ ) {<br>    arr [ i ] = evenArr [ j ] ;<br>    i ++ ;<br>  }<br>  for ( int j = 0 ;<br>  j < oddArr . length ;<br>  j ++ ) {<br>    arr [ i ] = oddArr [ j ] ;<br>    i ++ ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binomialCoeff ( int n , int k ) {<br>  if ( k == 0 || k == n ) return 1 ;<br>  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double binomialCoeff ( int n , int k ) {<br>  if ( k == 0 || k == n ) return 1 ;<br>  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ;<br>}<br></td>
  </tr><tr>
    <th>WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean getParity ( int n ) {<br>  boolean parity = false ;<br>  while ( n != 0 ) {<br>    parity = ! parity ;<br>    n = n & ( n - 1 ) ;<br>  }<br>  return parity ;<br>}<br></td>
    <td>translated code: <br><br> public static int getParity ( int n ) {<br>  int parity = 0 ;<br>  while ( n > 0 ) {<br>    parity = ~ parity ;<br>    n = n & ( n - 1 ) ;<br>  }<br>  return parity ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisible7 ( String num ) {<br>  int n = num . length ( ) ;<br>  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( n % 3 == 1 ) num = "00" + num ;<br>  if ( n % 3 == 2 ) num = "0" + num ;<br>  n = num . length ( ) ;<br>  int gSum = 0 , p = 1 ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int group = 0 ;<br>    group += num . charAt ( i -- ) - '0' ;<br>    group += ( num . charAt ( i -- ) - '0' ) * 10 ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    gSum = gSum + group * p ;<br>    p = p * - 1 ;<br>  }<br>  return ( gSum % 7 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisible7 ( String num ) {<br>  int n = num . length ( ) ;<br>  if ( ( n == 0 ) && num . charAt ( 0 ) == '\n' ) return 1 ;<br>  if ( ( n % 3 == 1 ) && ( num . charAt ( n / 3 ) == '\n' ) ) {<br>    num = String . valueOf ( num ) + "00" ;<br>    n += 2 ;<br>  }<br>  else if ( ( n % 3 == 2 ) && ( num . charAt ( n / 3 ) == '0' ) ) {<br>    num = String . valueOf ( num ) + "0" ;<br>    n += 1 ;<br>  }<br>  int GSum = 0 ;<br>  int p = 1 ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int group = 0 ;<br>    group += ( num . charAt ( i ) - '0' ) ;<br>    i -- ;<br>    group += ( num . charAt ( i ) - '0' ) * 10 ;<br>    i -- ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    GSum = GSum + group * p ;<br>    p *= ( - 1 ) ;<br>  }<br>  return ( GSum % 7 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int productAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int product = 1 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( tree . charAt ( i ) == '(' ) level ++ ;<br>    else if ( tree . charAt ( i ) == ')' ) level -- ;<br>    else {<br>      if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ;<br>    }<br>  }<br>  return product ;<br>}<br></td>
    <td>translated code: <br><br> public static int productAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int product = 1 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( tree . charAt ( i ) == '(' ) && ( tree . charAt ( i + 1 ) == ')' ) ) {<br>      level ++ ;<br>    }<br>    else if ( ( tree . charAt ( i ) == ')' ) && ( tree . charAt ( i + 1 ) == '(' ) ) {<br>      level -- ;<br>    }<br>    else {<br>      if ( ( level == k ) && ( tree . charAt ( i + 1 ) == '(' ) ) {<br>        product *= ( Integer . parseInt ( tree . substring ( i + 1 , i + 2 ) ) - Integer . parseInt ( "0" ) ) ;<br>      }<br>    }<br>  }<br>  return product ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isEven ( int n ) {<br>  return ( n % 2 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isEven ( int n ) {<br>  return ( n % 2 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countGroups ( int position , int previous_sum , int length , String num ) {<br>  if ( position == length ) return 1 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum += ( num . charAt ( i ) - '0' ) ;<br>    if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countGroups ( int position , int previousSum , int length , int [ ] num ) {<br>  if ( ( position == length ) && ( previousSum == 0 ) ) return 1 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum = sum + Integer . bitCount ( num [ i ] ) ;<br>    if ( ( sum >= previousSum ) && ( sum < previousSum ) ) res = res + countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void search ( int arr [ ] , int low , int high ) {<br>  if ( low > high ) return ;<br>  if ( low == high ) {<br>    System . out . printf ( "The required element is %d " , arr [ low ] ) ;<br>    return ;<br>  }<br>  int mid = ( low + high ) / 2 ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ;<br>    else search ( arr , low , mid ) ;<br>  }<br>  else {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ;<br>    else search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int low , int high ) {<br>  if ( low > high ) return 0 ;<br>  if ( low == high ) return arr [ low ] ;<br>  int mid = ( low + high ) / 2 ;<br>  ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) return search ( arr , mid + 2 , high ) ;<br>    else return search ( arr , low , mid ) ;<br>  }<br>  else {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) return search ( arr , mid + 1 , high ) ;<br>    else return search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int removeConsecutiveSame ( Vector < String > v ) {<br>  Stack < String > st = new Stack < > ( ) ;<br>  for ( int i = 0 ;<br>  i < v . size ( ) ;<br>  i ++ ) {<br>    if ( st . empty ( ) ) st . push ( v . get ( i ) ) ;<br>    else {<br>      String str = st . peek ( ) ;<br>      if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ;<br>      else st . push ( v . get ( i ) ) ;<br>    }<br>  }<br>  return st . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int removeConsecutiveSame ( String v ) {<br>  Stack < String > st = new Stack < String > ( ) ;<br>  for ( int i = 0 ;<br>  i < v . length ( ) ;<br>  i ++ ) {<br>    if ( ( st . size ( ) == 0 ) && ( st . peek ( ) . equals ( v ) ) ) {<br>      st . push ( v . substring ( i ) ) ;<br>    }<br>    else {<br>      String Str = st . pop ( ) ;<br>      if ( ( Str . equals ( v ) ) && ( Str . length ( ) == 0 ) ) {<br>        st . push ( v . substring ( i ) ) ;<br>      }<br>      else {<br>        st . push ( v . substring ( i ) ) ;<br>      }<br>    }<br>  }<br>  return st . size ( ) ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minJumps ( int arr [ ] , int n ) {<br>  int [ ] jumps = new int [ n ] ;<br>  int min ;<br>  jumps [ n - 1 ] = 0 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ;<br>    else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;<br>    else {<br>      min = Integer . MAX_VALUE ;<br>      for ( int j = i + 1 ;<br>      j < n && j <= arr [ i ] + i ;<br>      j ++ ) {<br>        if ( min > jumps [ j ] ) min = jumps [ j ] ;<br>      }<br>      if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ;<br>      else jumps [ i ] = min ;<br>    }<br>  }<br>  return jumps [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minJumps ( int [ ] arr , int n ) {<br>  int [ ] jumps = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    jumps [ i ] = 0 ;<br>  }<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( arr [ i ] == 0 ) && ( arr [ i ] >= n - i - 1 ) ) {<br>      jumps [ i ] = Integer . MAX_VALUE ;<br>    }<br>    else if ( ( arr [ i ] >= n - i - 1 ) && ( arr [ i ] <= n - i - 1 ) ) {<br>      jumps [ i ] = 1 ;<br>    }<br>    else {<br>      int min = Integer . MAX_VALUE ;<br>      for ( int j = i + 1 ;<br>      j < n ;<br>      j ++ ) {<br>        if ( ( j <= arr [ i ] + i ) && ( arr [ j ] >= arr [ i ] + i ) ) {<br>          if ( ( min > jumps [ j ] ) || ( min < jumps [ j ] ) ) {<br>            min = jumps [ j ] ;<br>          }<br>        }<br>      }<br>      if ( ( min != Integer . MAX_VALUE ) && ( jumps [ i ] > min ) && ( jumps [ i ] < n - i - 1 ) ) {<br>        jumps [ i ] = min + 1 ;<br>      }<br>      else {<br>        jumps [ i ] = min ;<br>      }<br>    }<br>  }<br>  return jumps [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double gcd ( double a , double b ) {<br>  if ( a < b ) return gcd ( b , a ) ;<br>  if ( Math . abs ( b ) < 0.001 ) return a ;<br>  else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double gcd ( double a , double b ) {<br>  if ( ( a < b ) && ( b < a ) ) return gcd ( b , a ) ;<br>  if ( ( Math . abs ( b ) < 0.001 ) || ( Math . abs ( b ) > 0.0001 ) ) return a ;<br>  else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProfit ( int price [ ] , int n ) {<br>  int profit [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) profit [ i ] = 0 ;<br>  int max_price = price [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( price [ i ] > max_price ) max_price = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ;<br>  }<br>  int min_price = price [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( price [ i ] < min_price ) min_price = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ;<br>  }<br>  int result = profit [ n - 1 ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProfit ( int [ ] price , int n ) {<br>  int [ ] profit = new int [ n ] ;<br>  profit [ 0 ] = 0 ;<br>  int maxPrice = price [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( price [ i ] > maxPrice ) maxPrice = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i + 1 ] , maxPrice - price [ i ] ) ;<br>  }<br>  int minPrice = price [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( price [ i ] < minPrice ) minPrice = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - minPrice ) ) ;<br>  }<br>  int result = profit [ n - 1 ] ;<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countSetBits ( int n ) {<br>  if ( n == 0 ) return 0 ;<br>  else return ( n & 1 ) + countSetBits ( n >> 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int countSetBits ( int n ) {<br>  if ( ( n == 0 ) || ( n == 1 ) ) {<br>    return 0 ;<br>  }<br>  else {<br>    return ( n & 1 ) + countSetBits ( n >> 1 ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reorder ( ) {<br>  int temp [ ] = new int [ arr . length ] ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) temp [ index [ i ] ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    arr [ i ] = temp [ i ] ;<br>    index [ i ] = i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void reorder ( int [ ] arr , int [ ] index , int n ) {<br>  int [ ] temp = new int [ n ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    temp [ index [ i ] ] = arr [ i ] ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    arr [ i ] = temp [ i ] ;<br>    index [ i ] = i ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean canRepresentBST ( int pre [ ] , int n ) {<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  int root = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( pre [ i ] < root ) {<br>      return false ;<br>    }<br>    while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) {<br>      root = s . peek ( ) ;<br>      s . pop ( ) ;<br>    }<br>    s . push ( pre [ i ] ) ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canRepresentBST ( int [ ] pre ) {<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  int root = INT_MIN ;<br>  for ( int value : pre ) {<br>    if ( value < root ) return false ;<br>    while ( ( s . size ( ) > 0 ) && s . peek ( ) < value ) root = s . pop ( ) ;<br>    s . push ( value ) ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  int missingElement = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int element = arr [ Math . abs ( arr [ i ] ) ] ;<br>    if ( element < 0 ) {<br>      missingElement = arr [ i ] ;<br>      break ;<br>    }<br>    arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>  }<br>  return Math . abs ( missingElement ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>  int missingElement = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    int element = arr [ Math . abs ( arr [ i ] ) ] ;<br>    if ( ( element < 0 ) || ( element > arr [ i ] ) ) {<br>      missingElement = arr [ i ] ;<br>      break ;<br>    }<br>    arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>  }<br>  return Math . abs ( missingElement ) ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MatrixChainOrder ( int p [ ] , int n ) {<br>  int m [ ] [ ] = new int [ n ] [ n ] ;<br>  int i , j , k , L , q ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) m [ i ] [ i ] = 0 ;<br>  for ( L = 2 ;<br>  L < n ;<br>  L ++ ) {<br>    for ( i = 1 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( j == n ) continue ;<br>      m [ i ] [ j ] = Integer . MAX_VALUE ;<br>      for ( k = i ;<br>      k <= j - 1 ;<br>      k ++ ) {<br>        q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ;<br>        if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ;<br>      }<br>    }<br>  }<br>  return m [ 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MatrixChainOrder ( int [ ] p , int n ) {<br>  int [ ] [ ] m = new int [ n ] [ n ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) m [ i ] [ i ] = 0 ;<br>  for ( int L = 2 ;<br>  L < n ;<br>  L ++ ) {<br>    for ( int i = 1 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      int j = i + L - 1 ;<br>      m [ i ] [ j ] = Integer . MAX_VALUE ;<br>      for ( int k = i ;<br>      k < j ;<br>      k ++ ) {<br>        int q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ;<br>        if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ;<br>      }<br>    }<br>  }<br>  return m [ 1 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIslands ( int mat [ ] [ ] , int m , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( mat [ i ] [ j ] == 'X' ) {<br>        if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++ ;<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIslands ( char [ ] [ ] mat ) {<br>  int count = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= M ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= N ;<br>    j ++ ) {<br>      if ( ( mat [ i ] [ j ] == 'X' ) && ( ( mat [ i - 1 ] [ j ] == 'O' ) && ( ( mat [ i ] [ j - 1 ] == 'O' ) ) ) ) {<br>        count = count + 1 ;<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int [ ] A , int [ ] B , int [ ] C ) {<br>  int i , j , k ;<br>  i = A . length - 1 ;<br>  j = B . length - 1 ;<br>  k = C . length - 1 ;<br>  int min_diff , current_diff , max_term ;<br>  min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ;<br>  while ( i != - 1 && j != - 1 && k != - 1 ) {<br>    current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ;<br>    if ( current_diff < min_diff ) min_diff = current_diff ;<br>    max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ;<br>    if ( A [ i ] == max_term ) i -= 1 ;<br>    else if ( B [ j ] == max_term ) j -= 1 ;<br>    else k -= 1 ;<br>  }<br>  return min_diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] A , int [ ] B , int [ ] C ) {<br>  int i = A . length - 1 ;<br>  int j = B . length - 1 ;<br>  int k = C . length - 1 ;<br>  int minDiff = Math . abs ( Math . max ( A [ i ] , B [ j ] , C [ k ] ) - Math . min ( A [ i ] , B [ j ] , C [ k ] ) ) ;<br>  while ( i != - 1 && j != - 1 && k != - 1 ) {<br>    int currentDiff = Math . abs ( Math . max ( A [ i ] , B [ j ] , C [ k ] ) - Math . min ( A [ i ] , B [ j ] , C [ k ] ) ) ;<br>    if ( currentDiff < minDiff ) minDiff = currentDiff ;<br>    int maxTerm = Math . max ( A [ i ] , B [ j ] , C [ k ] ) ;<br>    if ( A [ i ] == maxTerm ) i -- ;<br>    else if ( B [ j ] == maxTerm ) j -- ;<br>    else k -- ;<br>  }<br>  return minDiff ;<br>}<br></td>
  </tr><tr>
    <th>ROOTS_QUADRATIC_EQUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void findRoots ( int a , int b , int c ) {<br>  if ( a == 0 ) {<br>    System . out . println ( "Invalid" ) ;<br>    return ;<br>  }<br>  int d = b * b - 4 * a * c ;<br>  double sqrt_val = sqrt ( abs ( d ) ) ;<br>  if ( d > 0 ) {<br>    System . out . println ( "Roots are real and different \n" ) ;<br>    System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ;<br>  }<br>  else {<br>    System . out . println ( "Roots are complex \n" ) ;<br>    System . out . println ( - ( double ) b / ( 2 * a ) + " + i" + sqrt_val + "\n" + - ( double ) b / ( 2 * a ) + " - i" + sqrt_val ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findRoots ( int a , int b , int c ) {<br>  if ( a == 0 ) {<br>    System . out . println ( "Invalid" ) ;<br>    return - 1 ;<br>  }<br>  double d = b * b - 4 * a * c ;<br>  double sqrt_val = Math . sqrt ( Math . abs ( d ) ) ;<br>  if ( d > 0 ) {<br>    System . out . println ( "Roots are real and different " ) ;<br>    System . out . println ( ( - b + sqrt_val ) / ( 2 * a ) ) ;<br>    System . out . println ( ( - b - sqrt_val ) / ( 2 * a ) ) ;<br>  }<br>  else if ( d == 0 ) {<br>    System . out . println ( "Roots are real and same" ) ;<br>    System . out . println ( - b / ( 2 * a ) ) ;<br>  }<br>  else {<br>    System . out . println ( "Roots are complex" ) ;<br>    System . out . println ( - b / ( 2 * a ) + " + i" + sqrt_val ) ;<br>    System . out . println ( - b / ( 2 * a ) + " - i" + sqrt_val ) ;<br>  }<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMinHeap ( int [ ] level ) {<br>  int n = level . length - 1 ;<br>  for ( int i = ( n / 2 - 1 ) ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;<br>    if ( 2 * i + 2 < n ) {<br>      if ( level [ i ] > level [ 2 * i + 2 ] ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMinHeap ( int [ ] level , int n ) {<br>  for ( int i = Integer . MAX_VALUE / 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( level [ i ] > level [ 2 * i + 1 ] ) {<br>      return false ;<br>    }<br>    if ( 2 * i + 2 < n ) {<br>      if ( level [ i ] > level [ 2 * i + 2 ] ) {<br>        return false ;<br>      }<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMin ( int arr [ ] , int low , int high ) {<br>  if ( high < low ) return arr [ 0 ] ;<br>  if ( high == low ) return arr [ low ] ;<br>  int mid = low + ( high - low ) / 2 ;<br>  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;<br>  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ;<br>  return findMin ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMin ( int [ ] arr , int low , int high ) {<br>  if ( high < low ) return arr [ 0 ] ;<br>  if ( high == low ) return arr [ low ] ;<br>  int mid = ( int ) ( ( low + high ) / 2 ) ;<br>  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;<br>  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ;<br>  return findMin ( arr , mid + 1 , high ) ;<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTINCT_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int stringReduction ( String str ) {<br>  int n = str . length ( ) ;<br>  int count [ ] = new int [ 3 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    count [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) {<br>    return n ;<br>  }<br>  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) {<br>    return 2 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int stringReduction ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] count = new int [ 3 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    count [ ( char ) str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  if ( ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) && ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) ) {<br>    return n ;<br>  }<br>  if ( ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) && ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 2 ] % 2 ) == ( count [ 0 ] % 2 ) ) ) {<br>    return 2 ;<br>  }<br>  return 1 ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int digitSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;<br>  return ( digitSum % 3 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int num ) {<br>  int digitSum = 0 ;<br>  while ( num > 0 ) {<br>    int rem = num % 10 ;<br>    digitSum = digitSum + rem ;<br>    num = num / 10 ;<br>  }<br>  return ( digitSum % 3 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>COMPUTE_N_UNDER_MODULO_P</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int modFact ( int n , int p ) {<br>  if ( n >= p ) return 0 ;<br>  int result = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) result = ( result * i ) % p ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> static int modFact ( int n , int p ) {<br>  if ( n >= p ) return 0 ;<br>  int result = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) result = ( result * i ) % p ;<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPresent ( String s , String q ) {<br>  int [ ] freq = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) freq [ s . charAt ( i ) ] ++ ;<br>  for ( int i = 0 ;<br>  i < q . length ( ) ;<br>  i ++ ) {<br>    freq [ q . charAt ( i ) ] -- ;<br>    if ( freq [ q . charAt ( i ) ] < 0 ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPresent ( String s , String q ) {<br>  int [ ] freq = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i <= s . length ( ) ;<br>  i ++ ) freq [ ( int ) s . charAt ( i ) ] ++ ;<br>  for ( int i = 0 ;<br>  i <= q . length ( ) ;<br>  i ++ ) {<br>    freq [ ( int ) q . charAt ( i ) ] -- ;<br>    if ( ( freq [ ( int ) q . charAt ( i ) ] < 0 ) || ( freq [ ( int ) q . charAt ( i ) ] > freq [ ( int ) q . charAt ( i ) ] ) ) return false ;<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  int p = 1 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( p < n ) p <<= 1 ;<br>  return p ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>  int p = 1 ;<br>  if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;<br>  while ( ( p < n ) && ( p < ( n - 1 ) ) ) p <<= 1 ;<br>  return p ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reorder ( ) {<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    while ( index [ i ] != i ) {<br>      int oldTargetI = index [ index [ i ] ] ;<br>      char oldTargetE = ( char ) arr [ index [ i ] ] ;<br>      arr [ index [ i ] ] = arr [ i ] ;<br>      index [ index [ i ] ] = index [ i ] ;<br>      index [ i ] = oldTargetI ;<br>      arr [ i ] = oldTargetE ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void reorder ( int [ ] arr , int [ ] index , int n ) {<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( ( index [ i ] != i ) && ( index [ i ] != i ) ) {<br>      int oldTargetI = index [ index [ i ] ] ;<br>      int oldTargetE = arr [ index [ i ] ] ;<br>      arr [ index [ i ] ] = arr [ i ] ;<br>      index [ index [ i ] ] = index [ i ] ;<br>      index [ i ] = oldTargetI ;<br>      arr [ i ] = oldTargetE ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) {<br>  int dp [ ] = new int [ W + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= W ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( wt [ j ] <= i ) {<br>        dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) {<br>  int [ ] dp = new int [ W + 1 ] ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < W + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( wt [ j ] <= i ) && ( wt [ j ] > 0 ) ) {<br>        dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ W ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDiagonalMatrix ( int mat [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDiagonalMatrix ( int [ ] [ ] mat ) {<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= N ;<br>    j ++ ) {<br>      if ( ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) || ( ( i == j ) && ( mat [ i ] [ i ] == 0 ) ) ) {<br>        return false ;<br>      }<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxRemoval ( int arr [ ] , int n ) {<br>  int count = 0 ;<br>  int cummulative_sum = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] >= cummulative_sum ) {<br>      count ++ ;<br>      cummulative_sum += arr [ i ] ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxRemoval ( int [ ] arr , int n ) {<br>  int count = 0 ;<br>  int cummulativeSum = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] >= cummulativeSum ) {<br>      count ++ ;<br>      cummulativeSum += arr [ i ] ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String censor ( String text , String word ) {<br>  String [ ] word_list = text . split ( "\\s+" ) ;<br>  String result = "" ;<br>  String stars = "" ;<br>  for ( int i = 0 ;<br>  i < word . length ( ) ;<br>  i ++ ) stars += '*' ;<br>  int index = 0 ;<br>  for ( String i : word_list ) {<br>    if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ;<br>    index ++ ;<br>  }<br>  for ( String i : word_list ) result += i + ' ' ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static String censor ( String text , String word ) {<br>  char [ ] wordArray = text . toCharArray ( ) ;<br>  String result ;<br>  char stars = '*' ;<br>  int count = 0 ;<br>  int index = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i < wordArray . length ;<br>  i ++ ) {<br>    if ( wordArray [ i ] == word ) {<br>      wordArray [ index ] = stars ;<br>    }<br>    index ++ ;<br>  }<br>  result = new String ( wordArray ) ;<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_WITH_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n ) {<br>  int a [ ] = new int [ n ] , b [ ] = new int [ n ] ;<br>  a [ 0 ] = b [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> static int countStrings ( int n ) {<br>  int [ ] a = new int [ n ] ;<br>  int [ ] b = new int [ n ] ;<br>  a [ 0 ] = b [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_BALANCED_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLength ( String s , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ;<br>  for ( int l = 2 ;<br>  l < n ;<br>  l ++ ) {<br>    for ( int i = 0 , j = l ;<br>    j < n ;<br>    i ++ , j ++ ) {<br>      if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ;<br>      for ( int k = i ;<br>      k < j ;<br>      k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLength ( String s , int n ) {<br>  int [ ] [ ] dp = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) || ( s . charAt ( i + 1 ) == '(' && s . charAt ( i + 2 ) == ')' ) ) {<br>      dp [ i ] [ i + 1 ] = 2 ;<br>    }<br>  }<br>  for ( int l = 2 ;<br>  l < n ;<br>  l ++ ) {<br>    int i = - 1 ;<br>    for ( int j = l ;<br>    j < n ;<br>    j ++ ) {<br>      i ++ ;<br>      if ( ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) || ( s . charAt ( i + 1 ) == '(' && s . charAt ( j + 2 ) == ')' ) ) {<br>        dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ;<br>      }<br>      for ( int k = i ;<br>      k < j ;<br>      k ++ ) {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) {<br>  Arrays . sort ( arrl ) ;<br>  Arrays . sort ( exit ) ;<br>  int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ;<br>  int i = 1 , j = 0 ;<br>  while ( i < n && j < n ) {<br>    if ( arrl [ i ] <= exit [ j ] ) {<br>      guests_in ++ ;<br>      if ( guests_in > max_guests ) {<br>        max_guests = guests_in ;<br>        time = arrl [ i ] ;<br>      }<br>      i ++ ;<br>    }<br>    else {<br>      guests_in -- ;<br>      j ++ ;<br>    }<br>  }<br>  System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) {<br>  Arrays . sort ( arrl ) ;<br>  ;<br>  Arrays . sort ( exit ) ;<br>  int guestsIn = 1 ;<br>  int maxGuests = 1 ;<br>  int time = arrl [ 0 ] ;<br>  int i = 1 ;<br>  int j = 0 ;<br>  while ( ( i < n && j < n ) || ( i < n && j < n ) ) {<br>    if ( ( arrl [ i ] <= exit [ j ] ) && ( arrl [ i ] > exit [ j ] ) ) {<br>      guestsIn = guestsIn + 1 ;<br>      if ( ( guestsIn > maxGuests ) || ( guestsIn < maxGuests ) ) {<br>        maxGuests = guestsIn ;<br>        time = arrl [ i ] ;<br>      }<br>      i = i + 1 ;<br>    }<br>    else {<br>      guestsIn = guestsIn - 1 ;<br>      j = j + 1 ;<br>    }<br>  }<br>  System . out . println ( "Maximum Number of Guests =" + maxGuests + "at time" + time ) ;<br>}<br></td>
  </tr><tr>
    <th>EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMultipleOf10 ( int n ) {<br>  if ( n % 15 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMultipleOf10 ( int n ) {<br>  return ( n % 15 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) {<br>  Arrays . sort ( arr ) ;<br>  int dp [ ] = new int [ N ] ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    dp [ i ] = dp [ i - 1 ] ;<br>    if ( arr [ i ] - arr [ i - 1 ] < K ) {<br>      if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ;<br>      else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ;<br>    }<br>  }<br>  return dp [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int K ) {<br>  Arrays . sort ( arr ) ;<br>  int [ ] dp = new int [ N ] ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    dp [ i ] = dp [ i - 1 ] ;<br>    if ( ( arr [ i ] - arr [ i - 1 ] < K ) && ( i >= 2 ) ) {<br>      if ( ( i >= 2 ) && ( i < N ) ) {<br>        dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ;<br>        ;<br>      }<br>      else {<br>        dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ;<br>        ;<br>      }<br>    }<br>  }<br>  return dp [ N - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) {<br>  if ( k > n1 * n2 ) {<br>    System . out . print ( "k pairs don't exist" ) ;<br>    return ;<br>  }<br>  int index2 [ ] = new int [ n1 ] ;<br>  while ( k > 0 ) {<br>    int min_sum = Integer . MAX_VALUE ;<br>    int min_index = 0 ;<br>    for ( int i1 = 0 ;<br>    i1 < n1 ;<br>    i1 ++ ) {<br>      if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) {<br>        min_index = i1 ;<br>        min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;<br>      }<br>    }<br>    System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ;<br>    index2 [ min_index ] ++ ;<br>    k -- ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void kSmallestPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 , int k ) {<br>  if ( ( k > n1 * n2 ) || ( k < 0 ) ) {<br>    System . out . println ( "k pairs don't exist" ) ;<br>    return ;<br>  }<br>  int [ ] index2 = new int [ n1 ] ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    index2 [ i ] = 0 ;<br>  }<br>  while ( ( k > 0 ) && ( k < n2 ) ) {<br>    int minSum = Integer . MAX_VALUE ;<br>    int minIndex = 0 ;<br>    for ( int i1 = 0 ;<br>    i1 < n1 ;<br>    i1 += 1 ) {<br>      if ( ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < minSum ) || ( index2 [ i1 ] > n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] > minSum ) ) {<br>        minIndex = i1 ;<br>        minSum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;<br>      }<br>    }<br>    System . out . print ( "(" + arr1 [ minIndex ] + "," + arr2 [ index2 [ minIndex ] ] + ")" ) ;<br>    index2 [ minIndex ] ++ ;<br>    k -- ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char first ( String str , int i ) {<br>  if ( str . charAt ( i ) == '\0' ) return 0 ;<br>  if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ;<br>  return first ( str , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int first ( String str , int i ) {<br>  if ( ( str . charAt ( i ) == '\0' ) || ( str . charAt ( i ) == '\n' ) ) return 0 ;<br>  if ( ( str . charAt ( i ) == '' ) || ( str . charAt ( i ) == '\t' ) ) return str . charAt ( i ) ;<br>  return first ( str , i + 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIRS_B_ARRAY_B_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean printPairs ( int arr [ ] , int n , int k ) {<br>  boolean isPairFound = true ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i != j && arr [ i ] % arr [ j ] == k ) {<br>        System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ;<br>        isPairFound = true ;<br>      }<br>    }<br>  }<br>  return isPairFound ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean printPairs ( int [ ] arr , int n , int k ) {<br>  boolean isPairFound = true ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( i != j && arr [ i ] % arr [ j ] == k ) || ( i == j && arr [ i ] % arr [ j ] == k ) ) {<br>        System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" ) ;<br>        isPairFound = true ;<br>      }<br>    }<br>  }<br>  return isPairFound ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ARRANGEMENT_QUEUE_GIVEN_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solve ( int n , int t , char s [ ] ) {<br>  for ( int i = 0 ;<br>  i < t ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n - 1 ;<br>  j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {<br>    char temp = s [ j ] ;<br>    s [ j ] = s [ j + 1 ] ;<br>    s [ j + 1 ] = temp ;<br>    j ++ ;<br>  }<br>  System . out . print ( s ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void solve ( int n , int t , char [ ] p ) {<br>  char [ ] s = Arrays . copyOf ( p , p . length ) ;<br>  for ( int i = 0 ;<br>  i <= t ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      if ( ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) || ( s [ j ] == 'C' && s [ j + 1 ] == 'D' ) ) {<br>        char temp = s [ j ] ;<br>        ;<br>        s [ j ] = s [ j + 1 ] ;<br>        ;<br>        s [ j + 1 ] = temp ;<br>        j = j + 1 ;<br>      }<br>    }<br>  }<br>  System . out . println ( Arrays . toString ( s ) ) ;<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSuperSeq ( String a , String b ) {<br>  int m = a . length ( ) , n = b . length ( ) ;<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  String res = "" ;<br>  int i = m , j = n ;<br>  while ( i > 0 && j > 0 ) {<br>    if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) {<br>      res = a . charAt ( i - 1 ) + res ;<br>      i -- ;<br>      j -- ;<br>    }<br>    else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {<br>      res = a . charAt ( i - 1 ) + res ;<br>      i -- ;<br>    }<br>    else {<br>      res = b . charAt ( j - 1 ) + res ;<br>      j -- ;<br>    }<br>  }<br>  while ( i > 0 ) {<br>    res = a . charAt ( i - 1 ) + res ;<br>    i -- ;<br>  }<br>  while ( j > 0 ) {<br>    res = b . charAt ( j - 1 ) + res ;<br>    j -- ;<br>  }<br>  System . out . println ( res ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSuperSeq ( String a , String b ) {<br>  int m = a . length ( ) ;<br>  int n = b . length ( ) ;<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ! i ) {<br>        dp [ i ] [ j ] = j ;<br>      };<br>    }<br>    else if ( ! j ) {<br>      dp [ i ] [ j ] = i ;<br>    };<br>    if ( ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) && ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) ) {<br>      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>    };<br>    else {<br>      dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>    };<br>  }<br>  int index = dp [ m ] [ n ] ;<br>  ;<br>  char [ ] res = new char [ index ] ;<br>  int i = m ;<br>  int j = n ;<br>  while ( ( i > 0 ) && ( j > 0 ) ) {<br>    if ( ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) && ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) ) {<br>      res [ index - 1 ] = a . charAt ( i - 1 ) ;<br>      i -- ;<br>      j -- ;<br>      index -- ;<br>    }<br>    else if ( ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) && ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) ) {<br>      res [ index - 1 ] = a . charAt ( i - 1 ) ;<br>      i -- ;<br>      index -- ;<br>    }<br>    else {<br>      res [ index - 1 ] = b . charAt ( j - 1 ) ;<br>      j -- ;<br>      index -- ;<br>    }<br>  }<br>  while ( ( i > 0 ) && ( j > 0 ) ) {<br>    res [ index - 1 ] = a . charAt ( i - 1 ) ;<br>    i -- ;<br>    index -- ;<br>  }<br>  while ( ( j > 0 ) && ( i > 0 ) ) {<br>    res [ index - 1 ] = b . charAt ( j - 1 ) ;<br>    </td>
  </tr><tr>
    <th>COUNT_ROTATIONS_DIVISIBLE_8</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotationsDivBy8 ( String n ) {<br>  int len = n . length ( ) ;<br>  int count = 0 ;<br>  if ( len == 1 ) {<br>    int oneDigit = n . charAt ( 0 ) - '0' ;<br>    if ( oneDigit % 8 == 0 ) return 1 ;<br>    return 0 ;<br>  }<br>  if ( len == 2 ) {<br>    int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ;<br>    int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ;<br>    if ( first % 8 == 0 ) count ++ ;<br>    if ( second % 8 == 0 ) count ++ ;<br>    return count ;<br>  }<br>  int threeDigit ;<br>  for ( int i = 0 ;<br>  i < ( len - 2 ) ;<br>  i ++ ) {<br>    threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ;<br>    if ( threeDigit % 8 == 0 ) count ++ ;<br>  }<br>  threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ;<br>  if ( threeDigit % 8 == 0 ) count ++ ;<br>  threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ;<br>  if ( threeDigit % 8 == 0 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotationsDivBy8 ( String n ) {<br>  int l = n . length ( ) ;<br>  int count = 0 ;<br>  if ( ( l == 1 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>    int oneDigit = Integer . parseInt ( n . substring ( 0 , 1 ) ) ;<br>    if ( ( oneDigit % 8 == 0 ) && ( n . charAt ( 1 ) == '-' ) ) {<br>      return 1 ;<br>    }<br>    return 0 ;<br>  }<br>  if ( ( l == 2 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>    int first = Integer . parseInt ( n . substring ( 0 , 1 ) ) * 10 + Integer . parseInt ( n . substring ( 1 , 2 ) ) ;<br>    int second = Integer . parseInt ( n . substring ( 1 , 2 ) ) * 10 + Integer . parseInt ( n . substring ( 0 , 2 ) ) ;<br>    if ( ( first % 8 == 0 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>      count ++ ;<br>    }<br>    if ( ( second % 8 == 0 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>      count ++ ;<br>    }<br>    return count ;<br>  }<br>  int threeDigit ;<br>  for ( int i = 0 ;<br>  i <= ( l - 2 ) ;<br>  i ++ ) {<br>    threeDigit = ( Integer . parseInt ( n . substring ( i , i + 1 ) ) * 100 + Integer . parseInt ( n . substring ( i + 1 , i + 2 ) ) ) ;<br>    if ( ( threeDigit % 8 == 0 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>      count ++ ;<br>    }<br>  }<br>  threeDigit = ( Integer . parseInt ( n . substring ( l - 1 , l - 2 ) ) * 100 + Integer . parseInt ( n . substring ( 0 , l - 1 ) ) ) ;<br>  if ( ( threeDigit % 8 == 0 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>    count ++ ;<br>  }<br>  threeDigit = ( Integer . parseInt ( n . substring ( l - 2 , l - 3 ) ) * 100 + Integer . parseInt ( n . substring ( l - 1 , l - 3 ) ) ) ;<br>  if ( ( threeDigit % 8 == 0 ) && ( n . charAt ( 0 ) == '-' ) ) {<br>    count ++ ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) {<br>  if ( k < 0 ) return - 10000000 ;<br>  if ( n < 0 || m < 0 ) return 0 ;<br>  int ans = dp [ n ] [ m ] [ k ] ;<br>  if ( ans != - 1 ) return ans ;<br>  try {<br>    ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ;<br>    if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ;<br>    ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ;<br>  }<br>  catch ( Exception e ) {<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) {<br>  if ( k < 0 ) return - ( 10 * 7 ) ;<br>  if ( n < 0 || m < 0 ) return 0 ;<br>  int ans = dp [ n ] [ m ] [ k ] ;<br>  if ( ans != - 1 ) return ans ;<br>  ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ;<br>  if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ;<br>  ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ;<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void checkCollision ( int a , int b , int c , int x , int y , int radius ) {<br>  double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ;<br>  if ( radius == dist ) System . out . println ( "Touch" ) ;<br>  else if ( radius > dist ) System . out . println ( "Intersect" ) ;<br>  else System . out . println ( "Outside" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void checkCollision ( float a , float b , float c , float x , float y , float radius ) {<br>  float dist = ( ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ) ;<br>  if ( ( radius == dist ) && ( radius > dist ) ) {<br>    System . out . println ( "Touch" ) ;<br>  }<br>  else if ( ( radius > dist ) && ( radius > dist ) ) {<br>    System . out . println ( "Intersect" ) ;<br>  }<br>  else {<br>    System . out . println ( "Outside" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubarrayXOR ( int arr [ ] , int n ) {<br>  int ans = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_xor = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      curr_xor = curr_xor ^ arr [ j ] ;<br>      ans = Math . max ( ans , curr_xor ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubarrayXOR ( int [ ] arr , int n ) {<br>  int ans = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int currXor = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      currXor = currXor ^ arr [ j ] ;<br>      ans = Math . max ( ans , currXor ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) {<br>  if ( k == 0 && u == v ) return 0 ;<br>  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ;<br>  if ( k <= 0 ) return INF ;<br>  int res = INF ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {<br>      int rec_res = shortestPath ( graph , i , v , k - 1 ) ;<br>      if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestPath ( int [ ] [ ] graph , int u , int v , int k ) {<br>  int V = 4 ;<br>  int INF = 999999999999 ;<br>  if ( k == 0 && u == v ) return 0 ;<br>  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ;<br>  if ( k <= 0 ) return INF ;<br>  int res = INF ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {<br>      int recRes = shortestPath ( graph , i , v , k - 1 ) ;<br>      if ( recRes != INF ) res = Math . min ( res , graph [ u ] [ i ] + recRes ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int subArraySum ( int arr [ ] , int n , int sum ) {<br>  int curr_sum , i , j ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_sum = arr [ i ] ;<br>    for ( j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( curr_sum == sum ) {<br>        int p = j - 1 ;<br>        System . out . println ( "Sum found between indexes " + i + " and " + p ) ;<br>        return 1 ;<br>      }<br>      if ( curr_sum > sum || j == n ) break ;<br>      curr_sum = curr_sum + arr [ j ] ;<br>    }<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int subArraySum ( int [ ] arr , int n , int sum ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int currSum = arr [ i ] ;<br>    int j = i + 1 ;<br>    while ( j <= n ) {<br>      if ( currSum == sum ) {<br>        System . out . println ( "Sum found between" ) ;<br>        System . out . println ( "indexes " + i + " and " + j - 1 ) ;<br>        return 1 ;<br>      }<br>      if ( currSum > sum || j == n ) break ;<br>      currSum = currSum + arr [ j ] ;<br>      j ++ ;<br>    }<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>K_TH_PRIME_FACTOR_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int kPrimeFactor ( int n , int k ) {<br>  while ( n % 2 == 0 ) {<br>    k -- ;<br>    n = n / 2 ;<br>    if ( k == 0 ) return 2 ;<br>  }<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i = i + 2 ) {<br>    while ( n % i == 0 ) {<br>      if ( k == 1 ) return i ;<br>      k -- ;<br>      n = n / i ;<br>    }<br>  }<br>  if ( n > 2 && k == 1 ) return n ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int kPrimeFactor ( int n , int k ) {<br>  while ( ( n % 2 == 0 ) && ( k == 0 ) ) {<br>    k = k - 1 ;<br>    n = n / 2 ;<br>    if ( ( k == 0 ) || ( k == 1 ) ) return 2 ;<br>  }<br>  int i = 3 ;<br>  while ( i <= Math . sqrt ( n ) ) {<br>    while ( ( n % i == 0 ) && ( k == 1 ) ) {<br>      if ( ( k == 1 ) || ( k == 2 ) ) return i ;<br>      k = k - 1 ;<br>      n = n / i ;<br>    }<br>    i = i + 2 ;<br>  }<br>  if ( ( n > 2 && k == 1 ) || ( n > 2 && k == 2 ) ) return n ;<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotations ( int arr [ ] , int low , int high ) {<br>  if ( high < low ) return 0 ;<br>  if ( high == low ) return low ;<br>  int mid = low + ( high - low ) / 2 ;<br>  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ;<br>  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ;<br>  if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ;<br>  return countRotations ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotations ( int [ ] arr , int low , int high ) {<br>  if ( ( high < low ) && ( high == low ) ) return 0 ;<br>  if ( ( high == low ) || ( high == 0 ) ) return low ;<br>  long mid = low + ( high - low ) / 2 ;<br>  ;<br>  mid = ( int ) mid ;<br>  if ( ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) || ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) ) return ( mid + 1 ) ;<br>  if ( ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) || ( mid > high && arr [ mid ] > arr [ mid - 1 ] ) ) return mid ;<br>  if ( ( arr [ high ] > arr [ mid ] ) || ( high == 0 ) ) return countRotations ( arr , low , mid - 1 ) ;<br>  ;<br>  return countRotations ( arr , mid + 1 , high ) ;<br>}<br></td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute_average ( int a , int b ) {<br>  return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int computeAverage ( int a , int b ) {<br>  return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ;<br>}<br></td>
  </tr><tr>
    <th>SORTING_USING_TRIVIAL_HASH_FUNCTION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortUsingHash ( int a [ ] , int n ) {<br>  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;<br>  int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAsInt ( ) ) ;<br>  int hashpos [ ] = new int [ max + 1 ] ;<br>  int hashneg [ ] = new int [ min + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;<br>    else hashneg [ Math . abs ( a [ i ] ) ] += 1 ;<br>  }<br>  for ( int i = min ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( hashneg [ i ] > 0 ) {<br>      for ( int j = 0 ;<br>      j < hashneg [ i ] ;<br>      j ++ ) {<br>        System . out . print ( ( - 1 ) * i + " " ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= max ;<br>  i ++ ) {<br>    if ( hashpos [ i ] > 0 ) {<br>      for ( int j = 0 ;<br>      j < hashpos [ i ] ;<br>      j ++ ) {<br>        System . out . print ( i + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortUsingHash ( int [ ] a , int n ) {<br>  int Max = Math . max ( a ) ;<br>  int Min = Math . abs ( Math . min ( a ) ) ;<br>  int [ ] hashpos = new int [ Max + 1 ] ;<br>  int [ ] hashneg = new int [ Min + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( a [ i ] >= 0 ) {<br>      hashpos [ a [ i ] ] ++ ;<br>    }<br>    else {<br>      hashneg [ Math . abs ( a [ i ] ) ] ++ ;<br>    }<br>  }<br>  for ( int i = Min ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( hashneg [ i ] != 0 ) {<br>      for ( int j = 0 ;<br>      j <= hashneg [ i ] ;<br>      j ++ ) {<br>        System . out . print ( ( - 1 ) * i + " " ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= Max ;<br>  i ++ ) {<br>    if ( hashpos [ i ] != 0 ) {<br>      for ( int j = 0 ;<br>      j <= hashpos [ i ] ;<br>      j ++ ) {<br>        System . out . print ( i + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int count [ ] = new int [ size ] ;<br>  int i ;<br>  System . out . println ( "Repeated elements are : " ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ;<br>    else count [ arr [ i ] ] ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>  int [ ] count = new int [ size ] ;<br>  System . out . print ( " Repeating elements are " ) ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    if ( ( count [ arr [ i ] ] == 1 ) && ( count [ arr [ i ] ] == 0 ) ) {<br>      System . out . print ( arr [ i ] + " " ) ;<br>    }<br>    else {<br>      count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinSteps ( int n ) {<br>  int table [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) table [ i ] = n - i ;<br>  for ( int i = n ;<br>  i >= 1 ;<br>  i -- ) {<br>    if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ;<br>    if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ;<br>  }<br>  return table [ 1 ] ;<br>  </td>
    <td>translated code: <br><br> public static int getMinSteps ( int n ) {<br>  int [ ] table = new int [ n + 1 ] ;<br>  table [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    table [ i ] = n - i ;<br>  }<br>  for ( int i = n ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( ( ! ( i % 2 ) ) && ( table [ i ] == 0 ) ) {<br>      table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ;<br>    }<br>    if ( ( ! ( i % 3 ) ) && ( table [ i ] == 0 ) ) {<br>      table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ;<br>    }<br>  }<br>  return table [ 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDecodingDP ( char digits [ ] , int n ) {<br>  int count [ ] = new int [ n + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  count [ 1 ] = 1 ;<br>  if ( digits [ 0 ] == '0' ) return 0 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ;<br>    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ;<br>  }<br>  return count [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDecodingDP ( char [ ] digits , int n ) {<br>  int [ ] count = new int [ n + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  ;<br>  count [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>    ;<br>    if ( ( digits [ i - 1 ] > '0' ) && ( digits [ i - 1 ] < '7' ) ) {<br>      count [ i ] = count [ i - 1 ] ;<br>      ;<br>    }<br>    if ( ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) && ( digits [ i ] == '0' ) && ( digits [ i - 2 ] == '1' ) && ( digits [ i - 1 ] == '0' ) && ( digits [ i - 2 ] == '2' ) && ( digits [ i - 1 ] == '1' ) && ( digits [ i - 2 ] == '3' ) && ( digits [ i - 1 ] == '3' ) ) {<br>      count [ i ] += count [ i - 2 ] ;<br>      ;<br>    }<br>  }<br>  return count [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>EULERS_FOUR_SQUARE_IDENTITY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void checkEulerFourSquareIdentity ( int a , int b ) {<br>  int ab = a * b ;<br>  boolean flag = false ;<br>  int i = 0 ;<br>  while ( i * i <= ab ) {<br>    int j = i ;<br>    while ( i * i + j * j <= ab ) {<br>      int k = j ;<br>      while ( i * i + j * j + k * k <= ab ) {<br>        double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ;<br>        if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) {<br>          flag = true ;<br>          System . out . print ( "i = " + i + "\n" ) ;<br>          System . out . print ( "j = " + j + "\n" ) ;<br>          System . out . print ( "k = " + k + "\n" ) ;<br>          System . out . print ( "l = " + ( int ) l + "\n" ) ;<br>          System . out . print ( "Product of " + a + " and " + b + " can be written as sum of squares" + " of i, j, k, l \n" ) ;<br>          System . out . print ( ab + " = " + i + "*" + i + " + " + j + "*" + j + " + " + k + "*" + k + " + " + ( int ) l + "*" + ( int ) l + "\n" ) ;<br>        }<br>        k += 1 ;<br>      }<br>      j += 1 ;<br>    }<br>    i += 1 ;<br>  }<br>  if ( flag == false ) {<br>    System . out . println ( "Solution doesn't exist!" ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void checkEulerFourSquareIdentity ( double a , double b ) {<br>  double ab = a * b ;<br>  boolean flag = false ;<br>  int i = 0 ;<br>  while ( i * i <= ab ) {<br>    int j = i ;<br>    while ( i * i + j * j <= ab ) {<br>      int k = j ;<br>      while ( i * i + j * j + k * k <= ab ) {<br>        double l = ( ab - ( i * i + j * j + k * k ) ) * ( 0.5 ) ;<br>        if ( l == ( int ) l && l >= k ) {<br>          flag = true ;<br>          System . out . println ( "i = " + i ) ;<br>          System . out . println ( "j = " + j ) ;<br>          System . out . println ( "k = " + k ) ;<br>          System . out . println ( "l = " + l ) ;<br>          System . out . println ( "Product of" + a + "and" + b + "can be written as sum of squares of i, j, k, l" ) ;<br>          System . out . println ( ab + " = " + i + "*" + i + "+" + j + "*" + j + "+" + k + "*" + k + "+" + l + "*" + l ) ;<br>        }<br>        k ++ ;<br>      }<br>      j ++ ;<br>    }<br>    i ++ ;<br>  }<br>  if ( flag == false ) {<br>    System . out . println ( "Solution doesn't exist!" ) ;<br>    return ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) {<br>  int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int l = 1 ;<br>  l < k ;<br>  l ++ ) {<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ l ] [ i ] = 0 ;<br>      for ( int j = l - 1 ;<br>      j < i ;<br>      j ++ ) {<br>        if ( arr [ j ] < arr [ i ] ) {<br>          dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;<br>        }<br>      }<br>    }<br>  }<br>  for ( int i = k - 1 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += dp [ k - 1 ] [ i ] ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int numOfIncSubseqOfSizeK ( int [ ] arr , int n , int k ) {<br>  int [ ] [ ] dp = new int [ n ] [ k ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ i ] [ i ] = 0 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int l = 1 ;<br>  l < k ;<br>  l ++ ) {<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ l ] [ i ] = 0 ;<br>      for ( int j = l - 1 ;<br>      j > i ;<br>      j -- ) {<br>        if ( ( arr [ j ] < arr [ i ] ) && ( arr [ j ] > arr [ i ] ) ) {<br>          dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;<br>        }<br>      }<br>    }<br>  }<br>  int Sum = 0 ;<br>  for ( int i = k - 1 ;<br>  i < n ;<br>  i ++ ) {<br>    Sum += dp [ k - 1 ] [ i ] ;<br>  }<br>  return Sum ;<br>}<br></td>
  </tr><tr>
    <th>KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>  int [ ] [ ] K = new int [ W + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int w = 0 ;<br>    w < W + 1 ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) {<br>        K [ i ] [ w ] = 0 ;<br>      }<br>      else if ( wt [ i - 1 ] <= w ) {<br>        K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      }<br>      else {<br>        K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>      }<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void drawPattern ( int N ) {<br>  int n = N ;<br>  int row = 1 ;<br>  int nst = 1 ;<br>  int nsp1 = n - 1 ;<br>  int nsp2 = - 1 ;<br>  int val1 = row ;<br>  int val2 = 1 ;<br>  while ( row <= n ) {<br>    int csp1 = 1 ;<br>    while ( csp1 <= nsp1 ) {<br>      System . out . print ( "  " ) ;<br>      csp1 = csp1 + 1 ;<br>    }<br>    int cst1 = 1 ;<br>    while ( cst1 <= nst ) {<br>      System . out . print ( val1 + " " ) ;<br>      val1 = val1 - 1 ;<br>      cst1 = cst1 + 1 ;<br>    }<br>    int csp2 = 1 ;<br>    while ( csp2 <= nsp2 ) {<br>      System . out . print ( "  " ) ;<br>      csp2 = csp2 + 1 ;<br>    }<br>    if ( row != 1 && row != n ) {<br>      int cst2 = 1 ;<br>      while ( cst2 <= nst ) {<br>        System . out . print ( val2 + " " ) ;<br>        val2 = val2 + 1 ;<br>        cst2 = cst2 + 1 ;<br>      }<br>    }<br>    System . out . println ( ) ;<br>    if ( row <= n / 2 ) {<br>      nst = nst + 1 ;<br>      nsp1 = nsp1 - 2 ;<br>      nsp2 = nsp2 + 2 ;<br>      val1 = row + 1 ;<br>      val2 = 1 ;<br>    }<br>    else {<br>      nst = nst - 1 ;<br>      nsp1 = nsp1 + 2 ;<br>      nsp2 = nsp2 - 2 ;<br>      val1 = n - row ;<br>      val2 = 1 ;<br>    }<br>    row = row + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void drawPattern ( int N ) {<br>  int n = N ;<br>  int row = 1 ;<br>  int nst = 1 ;<br>  int nsp1 = n - 1 ;<br>  int nsp2 = - 1 ;<br>  int val1 = row ;<br>  int val2 = 1 ;<br>  while ( ( row <= n ) && ( csp1 <= nsp1 ) ) {<br>    int csp1 = 1 ;<br>    while ( ( csp1 <= nsp1 ) && ( csp1 <= nsp2 ) ) {<br>      System . out . print ( " " ) ;<br>      csp1 = csp1 + 1 ;<br>    }<br>    int cst1 = 1 ;<br>    while ( ( cst1 <= nst ) && ( cst1 <= nst ) ) {<br>      System . out . print ( val1 ) ;<br>      val1 = val1 - 1 ;<br>      cst1 = cst1 + 1 ;<br>    }<br>    int csp2 = 1 ;<br>    while ( ( csp2 <= nsp2 ) && ( csp2 <= nsp1 ) ) {<br>      System . out . print ( " " ) ;<br>      csp2 = csp2 + 1 ;<br>    }<br>    if ( ( row != 1 && row != n ) || ( row != n && row != 0 ) ) {<br>      int cst2 = 1 ;<br>      while ( ( cst2 <= nst ) && ( cst2 <= nst ) ) {<br>        System . out . print ( val2 ) ;<br>        val2 = val2 + 1 ;<br>        cst2 = cst2 + 1 ;<br>      }<br>    }<br>    System . out . println ( ) ;<br>    if ( ( row <= n / 2 ) && ( row != n / 2 ) ) {<br>      nst = nst + 1 ;<br>      nsp1 = nsp1 - 2 ;<br>      nsp2 = nsp2 + 2 ;<br>      val1 = row + 1 ;<br>      val2 = 1 ;<br>    }<br>    else {<br>      nst = nst - 1 ;<br>      nsp1 = nsp1 + 2 ;<br>      nsp2 = nsp2 - 2 ;<br>      val1 = n - row ;<br>      val2 = 1 ;<br>    }<br>    row = row + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findInteger ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;<br>  int maximum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ;<br>    else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findInteger ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > hash = Maps . newHashMap ( ) ;<br>  int maximum = 0 ;<br>  for ( int i : arr ) {<br>    if ( ( i < 0 ) && ( i < n ) ) {<br>      if ( Math . abs ( i ) != 0 ) {<br>        hash . put ( Math . abs ( i ) , - 1 ) ;<br>      }<br>      else {<br>        hash . put ( Math . abs ( i ) , - 1 ) ;<br>      }<br>    }<br>    else {<br>      hash . put ( i , hash . get ( i ) + 1 ) ;<br>    }<br>  }<br>  for ( int i : arr ) {<br>    if ( i < n && hash . get ( i ) > 0 ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_SOLUTION_LCS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int lcs ( String X , String Y ) {<br>  int m = X . length ( ) , n = Y . length ( ) ;<br>  int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ;<br>  int bi = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    bi = i & 1 ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ;<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ;<br>      else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return L [ bi ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y ) {<br>  int m = X . length ;<br>  int n = Y . length ;<br>  int [ ] [ ] L = new int [ n + 1 ] [ 2 ] ;<br>  boolean bi ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    bi = i & 1 ;<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      if ( ( i == 0 || j == 0 ) && ( X [ i ] == Y [ j - 1 ] ) ) {<br>        L [ bi ] [ j ] = 0 ;<br>      }<br>      else if ( ( X [ i ] == Y [ j - 1 ] ) && ( X [ i ] == Y [ j ] ) ) {<br>        L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ;<br>      }<br>      else {<br>        L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return L [ bi ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void psuedoBinary ( int n ) {<br>  while ( n != 0 ) {<br>    int temp = n , m = 0 , p = 1 ;<br>    while ( temp != 0 ) {<br>      int rem = temp % 10 ;<br>      temp = temp / 10 ;<br>      if ( rem != 0 ) m += p ;<br>      p *= 10 ;<br>    }<br>    System . out . print ( m + " " ) ;<br>    n = n - m ;<br>  }<br>  System . out . println ( " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void psuedoBinary ( int n ) {<br>  while ( ( n > 0 ) && ( n < n + 1 ) ) {<br>    int temp = n ;<br>    ;<br>    int m = 0 ;<br>    ;<br>    int p = 1 ;<br>    while ( ( temp = temp % 10 ) != 0 ) {<br>      int rem = temp % 10 ;<br>      temp = ( int ) ( temp / 10 ) ;<br>      ;<br>      if ( ( rem != 0 ) && ( rem != 1 ) ) m += p ;<br>      ;<br>      p *= 10 ;<br>    };<br>    System . out . print ( m + " " ) ;<br>    n = n - m ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void countCurrency ( int amount ) {<br>  int [ ] notes = new int [ ] {<br>    2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 };<br>    int [ ] noteCounter = new int [ 9 ] ;<br>    for ( int i = 0 ;<br>    i < 9 ;<br>    i ++ ) {<br>      if ( amount >= notes [ i ] ) {<br>        noteCounter [ i ] = amount / notes [ i ] ;<br>        amount = amount - noteCounter [ i ] * notes [ i ] ;<br>      }<br>    }<br>    System . out . println ( "Currency Count ->" ) ;<br>    for ( int i = 0 ;<br>    i < 9 ;<br>    i ++ ) {<br>      if ( noteCounter [ i ] != 0 ) {<br>        System . out . println ( notes [ i ] + " : " + noteCounter [ i ] ) ;<br>      }<br>    }<br>  }<br>  </td>
    <td>translated code: <br><br> public static void countCurrency ( int amount ) {<br>  int [ ] notes = {<br>    2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 };<br>    int [ ] noteCounter = {<br>      0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 };<br>      System . out . print ( "Currency Count -> " ) ;<br>      for ( int i = 0 , j = 0 ;<br>      i < notes . length ;<br>      i ++ ) {<br>        if ( amount >= i ) {<br>          j = amount / i ;<br>          amount = amount - j * i ;<br>          System . out . print ( i + " : " + j ) ;<br>        }<br>      }<br>    }<br>    </td>
  </tr><tr>
    <th>POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int a [ ] , int size ) {<br>  int positive = 0 , negative = 1 , temp ;<br>  while ( true ) {<br>    while ( positive < size && a [ positive ] >= 0 ) positive += 2 ;<br>    while ( negative < size && a [ negative ] <= 0 ) negative += 2 ;<br>    if ( positive < size && negative < size ) {<br>      temp = a [ positive ] ;<br>      a [ positive ] = a [ negative ] ;<br>      a [ negative ] = temp ;<br>    }<br>    else break ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] a , int size ) {<br>  int positive = 0 ;<br>  int negative = 1 ;<br>  while ( ( true ) ) {<br>    while ( ( positive < size && a [ positive ] >= 0 ) || ( negative < size && a [ negative ] <= 0 ) ) {<br>      positive = positive + 2 ;<br>    }<br>    while ( ( negative < size && a [ negative ] <= 0 ) || ( positive < size && a [ positive ] > 0 ) ) {<br>      negative = negative + 2 ;<br>    }<br>    if ( ( positive < size && negative < size ) || ( negative < size && a [ negative ] > 0 ) ) {<br>      int temp = a [ positive ] ;<br>      a [ positive ] = a [ negative ] ;<br>      a [ negative ] = temp ;<br>    }<br>    else {<br>      break ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < m ;<br>    j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ;<br>    if ( j == m ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static int isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i ;<br>  int j ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( arr2 [ i ] == arr1 [ j ] ) && ( arr1 [ i ] == arr2 [ j ] ) ) {<br>        break ;<br>      }<br>    }<br>    if ( ( j == m ) || ( j == n ) ) {<br>      return 0 ;<br>    }<br>  }<br>  return 1 ;<br>}<br></td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  while ( l != r ) {<br>    if ( arr [ l ] + arr [ r ] == x ) return true ;<br>    if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;<br>    else r = ( n + r - 1 ) % n ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean pairInSortedRotated ( int [ ] arr , int n , int x ) {<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( ( arr [ i ] > arr [ i + 1 ] ) && ( arr [ i + 1 ] < arr [ n - 1 ] ) ) {<br>      break ;<br>    }<br>  };<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  while ( ( l != r ) && ( l < n ) ) {<br>    if ( ( arr [ l ] + arr [ r ] == x ) && ( arr [ l + 1 ] + arr [ r ] < x ) ) {<br>      return true ;<br>    }<br>    if ( ( arr [ l ] + arr [ r ] < x ) && ( arr [ l + 1 ] + arr [ r + 1 ] < x ) ) {<br>      l = ( l + 1 ) % n ;<br>    }<br>    else {<br>      r = ( n + r - 1 ) % n ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  if ( divisor == 0 ) {<br>    System . out . println ( "Error: divisor " + "can't be zero \n" ) ;<br>    return - 1 ;<br>  }<br>  if ( divisor < 0 ) divisor = - divisor ;<br>  if ( num < 0 ) num = - num ;<br>  int i = 1 ;<br>  int product = 0 ;<br>  while ( product <= num ) {<br>    product = divisor * i ;<br>    i ++ ;<br>  }<br>  return num - ( product - divisor ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getRemainder ( int num , int divisor ) {<br>  if ( ( divisor == 0 ) || ( divisor < 0 ) ) {<br>    return false ;<br>  }<br>  if ( ( divisor < 0 ) || ( divisor > num ) ) {<br>    divisor = - divisor ;<br>  }<br>  if ( ( num < 0 ) || ( num > divisor ) ) {<br>    num = - num ;<br>  }<br>  int i = 1 ;<br>  int product = 0 ;<br>  while ( ( product <= num ) && ( product > divisor ) ) {<br>    product = divisor * i ;<br>    i ++ ;<br>  }<br>  return num - ( product - divisor ) ;<br>}<br></td>
  </tr><tr>
    <th>GNOME_SORT_A_STUPID_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void gnomeSort ( int arr [ ] , int n ) {<br>  int index = 0 ;<br>  while ( index < n ) {<br>    if ( index == 0 ) index ++ ;<br>    if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;<br>    else {<br>      int temp = 0 ;<br>      temp = arr [ index ] ;<br>      arr [ index ] = arr [ index - 1 ] ;<br>      arr [ index - 1 ] = temp ;<br>      index -- ;<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] gnomeSort ( int [ ] arr , int n ) {<br>  int index = 0 ;<br>  while ( index < n ) {<br>    if ( index == 0 ) index = index + 1 ;<br>    if ( arr [ index ] >= arr [ index - 1 ] ) index = index + 1 ;<br>    else {<br>      arr [ index ] = arr [ index - 1 ] ;<br>      arr [ index - 1 ] = arr [ index ] ;<br>      index = index - 1 ;<br>    }<br>  }<br>  return arr ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberofways ( String A , String B , int N , int M ) {<br>  Vector < Integer > [ ] pos = new Vector [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) pos [ i ] = new Vector < > ( ) ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ;<br>  int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ;<br>      else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  int LCS = dpl [ N ] [ M ] ;<br>  int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) {<br>    for ( int j = M ;<br>    j >= 1 ;<br>    j -- ) {<br>      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ;<br>      else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < MAX ;<br>    j ++ ) {<br>      for ( int x : pos [ j ] ) {<br>        if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) {<br>          ans ++ ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberofways ( int [ ] A , int [ ] B , int N , int M ) {<br>  int [ ] [ ] pos = new int [ MAX ] [ M ] ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) pos [ ( byte ) B [ i ] ] [ i + 1 ] = 0 ;<br>  int [ ] [ ] dpl = new int [ N + 2 ] [ M + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ;<br>      else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  int LCS = dpl [ N ] [ M ] ;<br>  int [ ] [ ] dpr = new int [ N + 2 ] [ M + 1 ] ;<br>  for ( int i = N ;<br>  i > 0 ;<br>  i -- ) {<br>    for ( int j = M ;<br>    j > 0 ;<br>    j -- ) {<br>      if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ;<br>      else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < N + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < MAX ;<br>    j ++ ) {<br>      for ( int x = pos [ j ] . length ;<br>      x > 0 ;<br>      x -- ) {<br>        if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) {<br>          ans ++ ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int minProduct ( int [ ] arr , int n , int k ) {<br>  PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) pq . add ( arr [ i ] ) ;<br>  int count = 0 , ans = 1 ;<br>  while ( pq . isEmpty ( ) == false && count < k ) {<br>    ans = ans * pq . element ( ) ;<br>    pq . remove ( ) ;<br>    count ++ ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int minProduct ( int [ ] arr , int n , int k ) {<br>  heapq . heapify ( arr ) ;<br>  int count = 0 ;<br>  int ans = 1 ;<br>  while ( ( arr != null ) && count < k ) {<br>    int x = heapq . heappop ( arr ) ;<br>    ans = ans * x ;<br>    count = count + 1 ;<br>  };<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>FIND_UNIQUE_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void unique ( int mat [ ] [ ] , int n , int m ) {<br>  int maximum = 0 , flag = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ;<br>  int b [ ] = new int [ maximum + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) b [ mat [ i ] [ j ] ] ++ ;<br>  for ( int i = 1 ;<br>  i <= maximum ;<br>  i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + " " ) ;<br>  flag = 1 ;<br>  if ( flag == 0 ) {<br>    System . out . println ( "No unique element " + "in the matrix" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void unique ( int [ ] [ ] mat , int n , int m ) {<br>  int maximum = 0 ;<br>  ;<br>  int flag = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      if ( ( maximum < mat [ i ] [ j ] ) && ( maximum < mat [ i ] [ j ] ) ) {<br>        maximum = mat [ i ] [ j ] ;<br>        ;<br>      }<br>    }<br>  }<br>  int [ ] uniqueElementMap = new int [ maximum + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      uniqueElementMap [ mat [ i ] [ j ] ] ++ ;<br>    }<br>  }<br>  for ( int key = 0 ;<br>  key < maximum + 1 ;<br>  key ++ ) {<br>    if ( uniqueElementMap [ key ] == 1 ) {<br>      System . out . print ( key + " " ) ;<br>      flag = 1 ;<br>    }<br>  }<br>  if ( ( flag == 0 ) && ( maximum < mat [ 0 ] [ 0 ] ) ) {<br>    System . out . print ( "No unique element in the matrix" ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestSubseqWithDiffOne ( int arr [ ] , int n ) {<br>  int dp [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ;<br>    }<br>  }<br>  int result = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestSubseqWithDiffOne ( int [ ] arr , int n ) {<br>  int [ ] dp = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) && ( ( arr [ j ] == arr [ i ] ) || ( arr [ j ] == arr [ i ] - 1 ) ) ) {<br>        dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ;<br>      }<br>    }<br>  }<br>  int result = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( result < dp [ i ] ) && ( ( arr [ i ] == arr [ j ] ) || ( arr [ i ] == arr [ j ] - 1 ) ) ) {<br>      result = dp [ i ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String repeat ( String s , int n ) {<br>  String s1 = s ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) s += s1 ;<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String repeat ( String s , int n ) {<br>  String s1 = s ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    s += s1 ;<br>  }<br>  return s ;<br>}<br></td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( String txt , String pat ) {<br>  int M = pat . length ( ) ;<br>  int N = txt . length ( ) ;<br>  for ( int i = 0 ;<br>  i <= N - M ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < M ;<br>    j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ;<br>    if ( j == M ) System . out . println ( "Pattern found at index " + i ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void search ( String pat , String txt ) {<br>  int M = pat . length ( ) ;<br>  int N = txt . length ( ) ;<br>  for ( int i = 0 ;<br>  i < N - M + 1 ;<br>  i ++ ) {<br>    int j = 0 ;<br>    while ( ( j < M ) && ( txt . charAt ( i + j ) != pat . charAt ( j ) ) ) {<br>      if ( ( txt . charAt ( i + j ) != pat . charAt ( j ) ) && ( txt . charAt ( i + j ) != pat . charAt ( j ) ) ) {<br>        break ;<br>      }<br>      j ++ ;<br>    }<br>    if ( ( j == M ) && ( txt . charAt ( i + j ) != pat . charAt ( j ) ) ) {<br>      System . out . println ( "Pattern found at index " + i ) ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countwalks ( int graph [ ] [ ] , int u , int v , int k ) {<br>  if ( k == 0 && u == v ) return 1 ;<br>  if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ;<br>  if ( k <= 0 ) return 0 ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countwalks ( int [ ] [ ] graph , int u , int v , int k ) {<br>  if ( ( k == 0 && u == v ) || ( k == 1 && graph [ u ] [ v ] ) ) return 1 ;<br>  if ( ( k == 0 && graph [ u ] [ v ] ) || ( k == 2 && graph [ u ] [ v ] ) ) return 1 ;<br>  if ( ( k <= 0 ) || ( k == 3 ) ) return 0 ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i <= V ;<br>  i ++ ) {<br>    if ( ( graph [ u ] [ i ] == 1 ) && ( graph [ u ] [ i ] == 2 ) ) count += countwalks ( graph , i , v , k - 1 ) ;<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_DIVISIBLE_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDivisibles ( int arr [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDivisibles ( int [ ] arr , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) && ( arr [ i ] % arr [ j ] == 0 ) ) {<br>        res ++ ;<br>      }<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSymmetric ( int mat [ ] [ ] , int N ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSymmetric ( int [ ] [ ] mat , int N ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( ( mat [ i ] [ j ] != mat [ j ] [ i ] ) && ( mat [ i ] [ j ] != mat [ j ] [ i ] ) ) {<br>        return false ;<br>      }<br>    }<br>  }<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_PALINDROME_SUB_STRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int CountPS ( char str [ ] , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) P [ i ] [ i ] = true ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( str [ i ] == str [ i + 1 ] ) {<br>      P [ i ] [ i + 1 ] = true ;<br>      dp [ i ] [ i + 1 ] = 1 ;<br>    }<br>  }<br>  for ( int gap = 2 ;<br>  gap < n ;<br>  gap ++ ) {<br>    for ( int i = 0 ;<br>    i < n - gap ;<br>    i ++ ) {<br>      int j = gap + i ;<br>      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;<br>      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountPS ( String str , int n ) {<br>  int [ ] [ ] dp = new int [ n ] [ n ] ;<br>  for ( int y = 0 ;<br>  y < n ;<br>  y ++ ) dp [ y ] [ y ] = 0 ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) P [ i ] [ i ] = true ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) ) {<br>    P [ i ] [ i + 1 ] = true ;<br>    dp [ i ] [ i + 1 ] = 1 ;<br>  }<br>  for ( int gap = 2 ;<br>  gap < n ;<br>  gap ++ ) {<br>    for ( int i = 0 ;<br>    i < n - gap ;<br>    i ++ ) {<br>      int j = gap + i ;<br>      ;<br>      if ( ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) ) P [ i ] [ j ] = true ;<br>      if ( ( P [ i ] [ j ] == true ) || ( P [ i ] [ j ] == false ) ) dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) ;<br>      else dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
  </tr><tr>
    <th>WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int N ) {<br>  int count [ ] = new int [ N + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < arr . length ;<br>  j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ;<br>  return count [ N ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int [ ] arr , int m , int N ) {<br>  int [ ] count = new int [ N + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( ( i >= arr [ j ] ) && ( i <= arr [ j + 1 ] ) ) {<br>        count [ i ] += count [ i - arr [ j ] ] ;<br>      }<br>    }<br>  }<br>  return count [ N ] ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minOperations ( String str , int n ) {<br>  int i , lastUpper = - 1 , firstLower = - 1 ;<br>  for ( i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) {<br>      lastUpper = i ;<br>      break ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( Character . isLowerCase ( str . charAt ( i ) ) ) {<br>      firstLower = i ;<br>      break ;<br>    }<br>  }<br>  if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ;<br>  int countUpper = 0 ;<br>  for ( i = firstLower ;<br>  i < n ;<br>  i ++ ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) {<br>      countUpper ++ ;<br>    }<br>  }<br>  int countLower = 0 ;<br>  for ( i = 0 ;<br>  i < lastUpper ;<br>  i ++ ) {<br>    if ( Character . isLowerCase ( str . charAt ( i ) ) ) {<br>      countLower ++ ;<br>    }<br>  }<br>  return Math . min ( countLower , countUpper ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minOperations ( String str , int n ) {<br>  int lastUpper = - 1 ;<br>  int firstLower = - 1 ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) {<br>      lastUpper = i ;<br>      break ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) {<br>      firstLower = i ;<br>      break ;<br>    }<br>  }<br>  if ( ( lastUpper == - 1 || firstLower == - 1 ) && ( str . charAt ( n - 1 ) == ' ' ) ) {<br>    return 0 ;<br>  }<br>  int countUpper = 0 ;<br>  for ( int i = firstLower ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) {<br>      countUpper ++ ;<br>    }<br>  }<br>  int countLower = 0 ;<br>  for ( int i = 0 ;<br>  i < lastUpper ;<br>  i ++ ) {<br>    if ( ( str . charAt ( i ) == ' ' ) || ( str . charAt ( i ) == '\t' ) ) {<br>      countLower ++ ;<br>    }<br>  }<br>  return Math . min ( countLower , countUpper ) ;<br>}<br></td>
  </tr><tr>
    <th>PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void spiralPrint ( int m , int n , int a [ ] [ ] ) {<br>  int i , k = 0 , l = 0 ;<br>  while ( k < m && l < n ) {<br>    for ( i = l ;<br>    i < n ;<br>    ++ i ) {<br>      System . out . print ( a [ k ] [ i ] + " " ) ;<br>    }<br>    k ++ ;<br>    for ( i = k ;<br>    i < m ;<br>    ++ i ) {<br>      System . out . print ( a [ i ] [ n - 1 ] + " " ) ;<br>    }<br>    n -- ;<br>    if ( k < m ) {<br>      for ( i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        System . out . print ( a [ m - 1 ] [ i ] + " " ) ;<br>      }<br>      m -- ;<br>    }<br>    if ( l < n ) {<br>      for ( i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        System . out . print ( a [ i ] [ l ] + " " ) ;<br>      }<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void spiralPrint ( int m , int n , int [ ] [ ] a ) {<br>  int k = 0 ;<br>  int l = 0 ;<br>  while ( ( k < m && l < n ) || ( l < n ) ) {<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) System . out . print ( a [ k ] [ i ] + " " ) ;<br>    k ++ ;<br>    for ( int i = k ;<br>    i < m ;<br>    i ++ ) System . out . print ( a [ i ] [ n - 1 ] + " " ) ;<br>    n -- ;<br>    if ( ( k < m ) || ( k > n ) ) {<br>      for ( int i = n - 1 ;<br>      i >= ( l - 1 ) ;<br>      i -- ) System . out . print ( a [ m - 1 ] [ i ] + " " ) ;<br>      m -- ;<br>    }<br>    if ( ( l < n ) || ( l > m ) ) {<br>      for ( int i = m - 1 ;<br>      i >= k - 1 ;<br>      i -- ) System . out . print ( a [ i ] [ l ] + " " ) ;<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
  </tr><tr>
    <th>FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int x ) {<br>  Vector < Integer > fact = new Vector < Integer > ( ) ;<br>  HashSet < Integer > factors = new HashSet < Integer > ( ) ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( x ) ;<br>  i ++ ) {<br>    if ( x % i == 0 ) {<br>      fact . add ( i ) ;<br>      if ( x / i != i ) fact . add ( x / i ) ;<br>      factors . add ( i ) ;<br>      factors . add ( x / i ) ;<br>    }<br>  }<br>  boolean found = false ;<br>  int k = fact . size ( ) ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    int a = fact . get ( i ) ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      int b = fact . get ( j ) ;<br>      if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) {<br>        System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ;<br>        found = true ;<br>        break ;<br>      }<br>    }<br>    if ( found ) break ;<br>  }<br>  if ( ! found ) System . out . print ( "-1" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int x ) {<br>  int [ ] fact = new int [ 2 ] ;<br>  ;<br>  HashSet factors = new HashSet ( ) ;<br>  for ( int i = 2 ;<br>  i <= Integer . MAX_VALUE ;<br>  i ++ ) {<br>    if ( ( x % i == 0 ) && ( x / i != 0 ) ) {<br>      fact [ i ] = i ;<br>      ;<br>      if ( ( x / i != i ) && ( x / i != 1 ) ) {<br>        fact [ i ] = x / i ;<br>        ;<br>      }<br>      factors . add ( i ) ;<br>      ;<br>      factors . add ( x / i ) ;<br>      ;<br>    }<br>  }<br>  boolean found = false ;<br>  int k = fact . length ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    int a = fact [ i ] ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      int b = fact [ j ] ;<br>      if ( ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) ) {<br>        System . out . println ( a + " " + b + " " + x / ( a * b ) ) ;<br>        ;<br>        found = true ;<br>        break ;<br>      }<br>    }<br>    if ( ( found ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != 0 ) ) {<br>      break ;<br>    }<br>  }<br>  if ( ( ! found ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != 0 ) ) {<br>    System . out . println ( "-1" ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>SUM_TWO_LARGE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String findSum ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) > str2 . length ( ) ) {<br>    String t = str1 ;<br>    str1 = str2 ;<br>    str2 = t ;<br>  }<br>  String str = "" ;<br>  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;<br>  int diff = n2 - n1 ;<br>  int carry = 0 ;<br>  for ( int i = n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  for ( int i = n2 - n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;<br>  return new StringBuilder ( str ) . reverse ( ) . toString ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String findSum ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) > str2 . length ( ) ) {<br>    String temp = str1 ;<br>    str1 = str2 ;<br>    str2 = temp ;<br>  }<br>  String str3 = "" ;<br>  int n1 = str1 . length ( ) ;<br>  int n2 = str2 . length ( ) ;<br>  int diff = n2 - n1 ;<br>  int carry = 0 ;<br>  for ( int i = n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( Character . digit ( str1 . charAt ( i ) , 16 ) - '0' ) + ( Character . digit ( str2 . charAt ( i + diff ) , 16 ) - '0' ) ) + carry ;<br>    str3 = str3 + Integer . toString ( sum % 10 , 16 ) ;<br>    carry = sum / 10 ;<br>  }<br>  for ( int i = n2 - n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( Character . digit ( str2 . charAt ( i ) , 16 ) - '0' ) + carry ) ;<br>    str3 = str3 + Integer . toString ( sum % 10 , 16 ) ;<br>    carry = sum / 10 ;<br>  }<br>  if ( ( carry > 0 ) && ( carry < 10 ) ) {<br>    str3 = str3 + Integer . toString ( carry + '0' , 16 ) ;<br>  }<br>  str3 = str3 . substring ( 0 , str3 . length ( ) - 1 ) ;<br>  return str3 ;<br>}<br></td>
  </tr><tr>
    <th>COCKTAIL_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void cocktailSort ( int a [ ] ) {<br>  boolean swapped = true ;<br>  int start = 0 ;<br>  int end = a . length ;<br>  while ( swapped == true ) {<br>    swapped = false ;<br>    for ( int i = start ;<br>    i < end - 1 ;<br>    ++ i ) {<br>      if ( a [ i ] > a [ i + 1 ] ) {<br>        int temp = a [ i ] ;<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( swapped == false ) break ;<br>    swapped = false ;<br>    end = end - 1 ;<br>    for ( int i = end - 1 ;<br>    i >= start ;<br>    i -- ) {<br>      if ( a [ i ] > a [ i + 1 ] ) {<br>        int temp = a [ i ] ;<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    start = start + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void cocktailSort ( int [ ] a ) {<br>  int n = a . length ;<br>  boolean swapped = true ;<br>  int start = 0 ;<br>  int end = n - 1 ;<br>  while ( ( swapped == true ) && ( start < end ) ) {<br>    swapped = false ;<br>    for ( int i = start ;<br>    i < end ;<br>    i ++ ) {<br>      if ( ( a [ i ] > a [ i + 1 ] ) && ( a [ i + 1 ] < a [ i ] ) ) {<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = a [ i ] ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( ( swapped == false ) && ( end < start ) ) break ;<br>    swapped = false ;<br>    end = end - 1 ;<br>    for ( int i = end - 1 ;<br>    i >= start ;<br>    i -- ) {<br>      if ( ( a [ i ] > a [ i + 1 ] ) && ( a [ i + 1 ] < a [ i ] ) ) {<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = a [ i ] ;<br>        swapped = true ;<br>      }<br>    }<br>    start = start + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDer ( int n ) {<br>  int der [ ] = new int [ n + 1 ] ;<br>  der [ 0 ] = 1 ;<br>  der [ 1 ] = 0 ;<br>  der [ 2 ] = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ;<br>  return der [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDer ( int n ) {<br>  int [ ] der = new int [ n + 1 ] ;<br>  der [ 0 ] = 1 ;<br>  der [ 1 ] = 0 ;<br>  der [ 2 ] = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ;<br>  }<br>  return der [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxProduct ( int arr [ ] , int n ) {<br>  int i ;<br>  int ans = Integer . MIN_VALUE ;<br>  int maxval = 1 ;<br>  int minval = 1 ;<br>  int prevMax ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > 0 ) {<br>      maxval = maxval * arr [ i ] ;<br>      minval = Math . min ( 1 , minval * arr [ i ] ) ;<br>    }<br>    else if ( arr [ i ] == 0 ) {<br>      minval = 1 ;<br>      maxval = 0 ;<br>    }<br>    else if ( arr [ i ] < 0 ) {<br>      prevMax = maxval ;<br>      maxval = minval * arr [ i ] ;<br>      minval = prevMax * arr [ i ] ;<br>    }<br>    ans = Math . max ( ans , maxval ) ;<br>    if ( maxval <= 0 ) {<br>      maxval = 1 ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxProduct ( int [ ] arr , int n ) {<br>  int ans = - Integer . MAX_VALUE ;<br>  int maxval = 1 ;<br>  int minval = 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( arr [ i ] > 0 ) {<br>      maxval = maxval * arr [ i ] ;<br>      minval = Math . min ( 1 , minval * arr [ i ] ) ;<br>    }<br>    else if ( arr [ i ] == 0 ) {<br>      minval = 1 ;<br>      maxval = 0 ;<br>    }<br>    else if ( arr [ i ] < 0 ) {<br>      int prevMax = maxval ;<br>      maxval = minval * arr [ i ] ;<br>      minval = prevMax * arr [ i ] ;<br>    }<br>    ans = Math . max ( ans , maxval ) ;<br>    if ( maxval <= 0 ) {<br>      maxval = 1 ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void assign ( int a [ ] , int n ) {<br>  Arrays . sort ( a ) ;<br>  int ans [ ] = new int [ n ] ;<br>  int p = 0 , q = n - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;<br>    else ans [ i ] = a [ p ++ ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( ans [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void assign ( int [ ] a , int n ) {<br>  Arrays . sort ( a ) ;<br>  int [ ] ans = new int [ n ] ;<br>  int p = 0 ;<br>  int q = n - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( i + 1 ) % 2 == 0 ) {<br>      ans [ i ] = a [ q ] ;<br>      q = q - 1 ;<br>    }<br>    else {<br>      ans [ i ] = a [ p ] ;<br>      p = p + 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( ans [ i ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  int dp [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i <= 2 ) dp [ i ] = i ;<br>    else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>  int [ ] dp = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( i <= 2 ) && ( i > 0 ) ) {<br>      dp [ i ] = i ;<br>    }<br>    else {<br>      dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>PRIME_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( n % i == 0 ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n ) {<br>  if ( ( n <= 1 ) || ( n > n ) ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( ( n % i == 0 ) || ( n % i == 1 ) ) return false ;<br>  return true ;<br>}<br></td>
  </tr><tr>
    <th>PROBABILITY_REACHING_POINT_2_3_STEPS_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float find_prob ( int N , float P ) {<br>  double dp [ ] = new double [ N + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 0 ;<br>  dp [ 2 ] = P ;<br>  dp [ 3 ] = 1 - P ;<br>  for ( int i = 4 ;<br>  i <= N ;<br>  ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ;<br>  return ( ( float ) ( dp [ N ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findProb ( int N , int P ) {<br>  int [ ] dp = new int [ n + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 0 ;<br>  dp [ 2 ] = P ;<br>  dp [ 3 ] = 1 - P ;<br>  for ( int i = 4 ;<br>  i <= N ;<br>  i ++ ) {<br>    dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ;<br>  }<br>  return dp [ N ] ;<br>}<br></td>
  </tr><tr>
    <th>SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int smallest ( int x , int y , int z ) {<br>  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;<br>  return ( ( x / z ) != 1 ) ? x : z ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallest ( int x , int y , int z ) {<br>  if ( ( ! ( y / x ) ) && ( ! ( y / z ) ) ) {<br>    return y == 0 ? z : y ;<br>  }<br>  return x == 0 ? z : x ;<br>}<br></td>
  </tr><tr>
    <th>COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printCommonElements ( int mat [ ] [ ] ) {<br>  Map < Integer , Integer > mp = new HashMap < > ( ) ;<br>  for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ;<br>  for ( int i = 1 ;<br>  i < M ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) {<br>        mp . put ( mat [ i ] [ j ] , i + 1 ) ;<br>        if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printCommonElements ( int [ ] [ ] mat ) {<br>  Map < Integer , Integer > mp = Maps . newHashMap ( ) ;<br>  for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ;<br>  for ( int i = 1 ;<br>  i < M ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) if ( ( mat [ i ] [ j ] < mp . keySet ( ) . size ( ) && mp . get ( mat [ i ] [ j ] ) == i ) || ( mat [ i ] [ j ] < mp . get ( mat [ i ] [ j ] ) + 1 && mp . get ( mat [ i ] [ j ] ) == i ) ) {<br>    mp . put ( mat [ i ] [ j ] , i + 1 ) ;<br>    if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) {<br>  int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ;<br>  for ( i = 0 ;<br>  i < V ;<br>  i ++ ) for ( j = 0 ;<br>  j < V ;<br>  j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ;<br>  for ( k = 0 ;<br>  k < V ;<br>  k ++ ) {<br>    for ( i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ;<br>      }<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < V ;<br>  i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean negCyclefloydWarshall ( int [ ] [ ] graph ) {<br>  int [ ] [ ] dist = new int [ V + 1 ] [ V + 1 ] ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < V ;<br>    j ++ ) {<br>      dist [ i ] [ j ] = graph [ i ] [ j ] ;<br>    }<br>  }<br>  for ( int k = 0 ;<br>  k < V ;<br>  k ++ ) {<br>    for ( int i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( int j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        if ( ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) && ( dist [ i ] [ j ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) ) {<br>          dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ;<br>        }<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    if ( ( dist [ i ] [ i ] < 0 ) && ( dist [ i ] [ i ] < dist [ V - 1 ] ) ) {<br>      return true ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_SORT_STRING_DESCENDING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortString ( String str ) {<br>  int charCount [ ] = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    charCount [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = MAX_CHAR - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < charCount [ i ] ;<br>    j ++ ) {<br>      System . out . print ( ( char ) ( 'a' + i ) ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortString ( String str ) {<br>  int charCount [ ] = new int [ MAX_CHAR ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) charCount [ ( int ) str . charAt ( i ) - 'a' ] ++ ;<br>  ;<br>  for ( int i = MAX_CHAR - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < charCount [ i ] ;<br>    j ++ ) System . out . print ( ( char ) ( 97 + i ) ) ;<br>    ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void getPairsCount ( int [ ] arr , int sum ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < arr . length ;<br>  j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ;<br>  System . out . printf ( "Count of pairs is %d" , count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getPairsCount ( int [ ] arr , int n , int sum ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( arr [ i ] + arr [ j ] == sum ) {<br>        count ++ ;<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>SUM_SERIES_12_32_52_2N_12_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumOfSeries ( int n ) {<br>  return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ;<br>}<br></td>
    <td>translated code: <br><br> static int sumOfSeries ( int n ) {<br>  return ( int ) ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxdiff ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > freq = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ;<br>      else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxdiff ( int arr [ ] , int n ) {<br>  int freq [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) freq [ arr [ i ] ] ++ ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ;<br>      else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
  </tr><tr>
    <th>SHIFT_MATRIX_ELEMENTS_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {<br>  if ( k > N ) {<br>    System . out . print ( "Shifting is" + " not possible" ) ;<br>    return ;<br>  }<br>  int j = 0 ;<br>  while ( j < N ) {<br>    for ( int i = k ;<br>    i < N ;<br>    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;<br>    for ( int i = 0 ;<br>    i < k ;<br>    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;<br>    System . out . println ( ) ;<br>    j ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {<br>  if ( ( k > N ) || ( k < 0 ) ) {<br>    System . out . println ( "shifting is" + " not possible" ) ;<br>    return ;<br>  }<br>  int j = 0 ;<br>  while ( ( j < N ) && ( j < k ) ) {<br>    for ( int i = k ;<br>    i < N ;<br>    i ++ ) {<br>      System . out . print ( "{}<br> " ) ;<br>    }<br>    for ( int i = 0 ;<br>    i <= k ;<br>    i ++ ) {<br>      System . out . print ( "{}<br> " ) ;<br>    }<br>    System . out . println ( "" ) ;<br>    j = j + 1 ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maxMin ( int arr [ ] [ ] , int n ) {<br>  int min = + 2147483647 ;<br>  int max = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n / 2 ;<br>    j ++ ) {<br>      if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {<br>        if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ;<br>        if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;<br>      }<br>      else {<br>        if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;<br>        if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ;<br>      }<br>    }<br>  }<br>  System . out . print ( "Maximum = " + max + ", Minimum = " + min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void MAXMIN ( int [ ] [ ] arr , int n ) {<br>  int MIN = 10 * 9 ;<br>  int MAX = - 10 * 9 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n / 2 + 1 ;<br>    j ++ ) {<br>      if ( ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) && ( arr [ i ] [ j ] < arr [ i ] [ n - j - 1 ] ) ) {<br>        if ( ( MIN > arr [ i ] [ n - j - 1 ] ) && ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) ) {<br>          MIN = arr [ i ] [ n - j - 1 ] ;<br>        }<br>        if ( ( MAX < arr [ i ] [ j ] ) && ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) ) {<br>          MAX = arr [ i ] [ n - j - 1 ] ;<br>        }<br>      }<br>      else {<br>        if ( ( MIN > arr [ i ] [ j ] ) && ( arr [ i ] [ j ] < arr [ i ] [ n - j - 1 ] ) ) {<br>          MIN = arr [ i ] [ j ] ;<br>        }<br>        if ( ( MAX < arr [ i ] [ n - j - 1 ] ) && ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) ) {<br>          MAX = arr [ i ] [ n - j - 1 ] ;<br>        }<br>      }<br>    }<br>  }<br>  System . out . println ( "MAXimum =" + MAX + ", MINimum =" + MIN ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findGreatest ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > m = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( m . containsKey ( arr [ i ] ) ) {<br>      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ;<br>    }<br>  }<br>  Arrays . sort ( arr ) ;<br>  for ( int i = n - 1 ;<br>  i > 1 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ;<br>    j ++ ) {<br>      if ( arr [ i ] % arr [ j ] == 0 ) {<br>        int result = arr [ i ] / arr [ j ] ;<br>        if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) {<br>          return arr [ i ] ;<br>        }<br>        else if ( result == arr [ j ] && m . get ( result ) > 1 ) {<br>          return arr [ i ] ;<br>        }<br>      }<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findGreatest ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i : arr ) m . put ( i , m . get ( i ) + 1 ) ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    int j = 0 ;<br>    while ( ( j < i ) && arr [ j ] <= Math . sqrt ( arr [ i ] ) ) {<br>      if ( ( arr [ i ] % arr [ j ] == 0 ) && ( m . get ( i ) > 0 ) ) {<br>        int result = arr [ i ] / arr [ j ] ;<br>        if ( ( result != arr [ j ] && ( result < m . keySet ( ) . size ( ) ) ) && m . get ( result ) > 0 ) {<br>          return arr [ i ] ;<br>        }<br>        else if ( ( result == arr [ j ] && ( result < m . keySet ( ) . size ( ) ) ) && m . get ( result ) > 1 ) {<br>          return arr [ i ] ;<br>        }<br>      }<br>      j ++ ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>  int [ ] [ ] K = new int [ W + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int w = 0 ;<br>    w < W + 1 ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) {<br>        K [ i ] [ w ] = 0 ;<br>      }<br>      else if ( wt [ i - 1 ] <= w ) {<br>        K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      }<br>      else {<br>        K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>      }<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_OCTAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void decToOctal ( int n ) {<br>  int [ ] octalNum = new int [ 100 ] ;<br>  int i = 0 ;<br>  while ( n != 0 ) {<br>    octalNum [ i ] = n % 8 ;<br>    n = n / 8 ;<br>    i ++ ;<br>  }<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) System . out . print ( octalNum [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void decToOctal ( int n ) {<br>  int [ ] octalNum = new int [ 100 ] ;<br>  ;<br>  int i = 0 ;<br>  ;<br>  while ( ( n != 0 ) && ( n % 8 == 0 ) ) {<br>    octalNum [ i ] = n % 8 ;<br>    ;<br>    n = ( int ) ( n / 8 ) ;<br>    ;<br>    i ++ ;<br>  };<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) {<br>    System . out . print ( octalNum [ j ] + " " ) ;<br>    ;<br>  };<br>}<br></td>
  </tr><tr>
    <th>SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubSeq ( int A [ ] , int N , int M ) {<br>  int ans = 0 ;<br>  int h [ ] = new int [ M ] ;<br>  Arrays . fill ( h , 0 ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    A [ i ] = A [ i ] % M ;<br>    h [ A [ i ] ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < M ;<br>    j ++ ) {<br>      int rem = ( M - ( i + j ) % M ) % M ;<br>      if ( rem < j ) continue ;<br>      if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ;<br>      else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ;<br>      else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ;<br>      else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ;<br>      else ans = ans + h [ i ] * h [ j ] * h [ rem ] ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubSeq ( int [ ] A , int N , int M ) {<br>  int ans = 0 ;<br>  int [ ] h = new int [ M ] ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    A [ i ] = A [ i ] % M ;<br>    h [ A [ i ] ] = h [ A [ i ] ] + 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= M ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j <= M ;<br>    j ++ ) {<br>      int rem = ( M - ( i + j ) % M ) % M ;<br>      if ( ( rem < j ) && ( rem == j ) ) {<br>        ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ;<br>      }<br>      else if ( ( i == j ) && ( rem == j ) ) {<br>        ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) ;<br>      }<br>      else if ( ( i == rem ) && ( j == j ) ) {<br>        ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ;<br>      }<br>      else if ( ( rem == j ) && ( i == j ) ) {<br>        ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ;<br>      }<br>      else {<br>        ans = ans + h [ i ] * h [ j ] * h [ rem ] ;<br>      }<br>    }<br>    return ans ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFibs ( int low , int high ) {<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  int result = 0 ;<br>  while ( f1 <= high ) {<br>    if ( f1 >= low ) result ++ ;<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFibs ( int low , int high ) {<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  int result = 0 ;<br>  while ( ( f1 <= high ) && ( f1 >= low ) ) {<br>    if ( ( f1 >= low ) && ( f1 <= high ) ) {<br>      result ++ ;<br>    }<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isPowerOfFour ( int n ) {<br>  int count = 0 ;<br>  int x = n & ( n - 1 ) ;<br>  if ( n > 0 && x == 0 ) {<br>    while ( n > 1 ) {<br>      n >>= 1 ;<br>      count += 1 ;<br>    }<br>    return ( count % 2 == 0 ) ? 1 : 0 ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfFour ( int n ) {<br>  int count = 0 ;<br>  if ( ( n > 0 ) && ( ! ( n & ( n - 1 ) ) ) ) {<br>    while ( ( n > 1 ) ) {<br>      n >>= 1 ;<br>      count ++ ;<br>    }<br>    if ( ( count % 2 == 0 ) && ( n > 0 ) ) {<br>      return true ;<br>    }<br>    else {<br>      return false ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_EVEN_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int sumofFactors ( int n ) {<br>  if ( n % 2 != 0 ) return 0 ;<br>  int res = 1 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    int count = 0 , curr_sum = 1 ;<br>    int curr_term = 1 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n = n / i ;<br>      if ( i == 2 && count == 1 ) curr_sum = 0 ;<br>      curr_term *= i ;<br>      curr_sum += curr_term ;<br>    }<br>    res *= curr_sum ;<br>  }<br>  if ( n >= 2 ) res *= ( 1 + n ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumofFactors ( int n ) {<br>  if ( ( n % 2 != 0 ) && ( n % 3 == 0 ) ) return 0 ;<br>  int res = 1 ;<br>  for ( int i = 2 ;<br>  i <= ( int ) ( Math . sqrt ( n ) ) ;<br>  i ++ ) {<br>    int count = 0 ;<br>    int currSum = 1 ;<br>    int currTerm = 1 ;<br>    while ( ( n % i == 0 ) && ( n % 3 == 0 ) ) {<br>      count = count + 1 ;<br>      n = n / i ;<br>      if ( ( i == 2 && count == 1 ) || ( i == 3 && count == 2 ) ) currSum = 0 ;<br>      currTerm = currTerm * i ;<br>      currSum = currSum + currTerm ;<br>    }<br>    res = res * currSum ;<br>  }<br>  if ( ( n >= 2 ) && ( n <= 3 ) ) res = res * ( 1 + n ) ;<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! s . contains ( arr [ i ] ) ) {<br>      sum += arr [ i ] ;<br>      s . add ( arr [ i ] ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int [ ] arr , int n ) {<br>  Set < Integer > s = new HashSet < Integer > ( ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] != 0 ) {<br>      s . add ( arr [ i ] ) ;<br>    }<br>  }<br>  for ( int i : s ) {<br>    sum = sum + i ;<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minPalPartion ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] C = new int [ n ] ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  int i , j , k , L ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    P [ i ] [ i ] = true ;<br>  }<br>  for ( L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>      else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ;<br>    else {<br>      C [ i ] = Integer . MAX_VALUE ;<br>      for ( j = 0 ;<br>      j < i ;<br>      j ++ ) {<br>        if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ;<br>      }<br>    }<br>  }<br>  return C [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minPalPartion ( String str1 ) {<br>  int n = str1 . length ( ) ;<br>  ;<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  ;<br>  boolean [ ] [ ] P = new boolean [ n + 1 ] [ n + 1 ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) P [ i ] [ i ] = true ;<br>  ;<br>  for ( int L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( int i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      int j = i + L - 1 ;<br>      ;<br>      if ( ( L == 2 ) && ( str1 . charAt ( i ) == str1 . charAt ( j ) ) ) P [ i ] [ j ] = ( str1 . charAt ( i ) == str1 . charAt ( j ) ) ;<br>      ;<br>      else P [ i ] [ j ] = ( ( str1 . charAt ( i ) == str1 . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ) ;<br>      ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( P [ 0 ] [ i ] == true ) && ( C [ i ] [ 0 ] == true ) ) C [ i ] [ 0 ] = 0 ;<br>    else {<br>      C [ i ] = Integer . MAX_VALUE ;<br>      ;<br>      for ( int j = 0 ;<br>      j < i ;<br>      j ++ ) {<br>        if ( ( P [ j + 1 ] [ i ] == true ) && ( 1 + C [ j ] [ j ] < C [ i ] [ j ] ) ) C [ i ] [ j ] = 1 + C [ j ] ;<br>        ;<br>      }<br>    }<br>  }<br>  return C [ n - 1 ] [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInitialPoints ( int points [ ] [ ] , int R , int C ) {<br>  int dp [ ] [ ] = new int [ R ] [ C ] ;<br>  int m = R , n = C ;<br>  dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ;<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ;<br>  for ( int j = n - 2 ;<br>  j >= 0 ;<br>  j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ;<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = n - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ;<br>      dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInitialPoints ( int [ ] [ ] points ) {<br>  int [ ] [ ] dp = new int [ C + 1 ] [ R + 1 ] ;<br>  for ( int y = 0 ;<br>  y < R + 1 ;<br>  y ++ ) {<br>    dp [ y ] = new int [ R + 1 ] ;<br>  }<br>  int m = R , n = C ;<br>  if ( points [ m - 1 ] [ n - 1 ] > 0 ) {<br>    dp [ m - 1 ] [ n - 1 ] = 1 ;<br>  }<br>  else {<br>    dp [ m - 1 ] [ n - 1 ] = Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ;<br>  }<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ;<br>  }<br>  for ( int i = 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    dp [ m - 1 ] [ i ] = Math . max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) ;<br>  }<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = n - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int minPointsOnExit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ;<br>      dp [ i ] [ j ] = Math . max ( minPointsOnExit - points [ i ] [ j ] , 1 ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ 0 ] ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPair ( int a , int b ) {<br>  String s = String . valueOf ( b ) ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) != '9' ) break ;<br>  }<br>  int result ;<br>  if ( i == s . length ( ) ) result = a * s . length ( ) ;<br>  else result = a * ( s . length ( ) - 1 ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPair ( int a , int b ) {<br>  String s = Integer . toString ( b ) ;<br>  int i = 0 ;<br>  while ( i < ( s . length ( ) ) ) {<br>    if ( ( s . charAt ( i ) != '9' ) && ( s . charAt ( i ) != '.' ) ) break ;<br>    i ++ ;<br>  }<br>  int result ;<br>  if ( ( i == s . length ( ) ) && ( a == 0 ) ) result = a * s . length ( ) ;<br>  else result = a * ( s . length ( ) - 1 ) ;<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>SURVIVAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void survival ( int S , int N , int M ) {<br>  if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( "No" ) ;<br>  else {<br>    int days = ( M * S ) / N ;<br>    if ( ( ( M * S ) % N ) != 0 ) days ++ ;<br>    System . out . println ( "Yes " + days ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void survival ( int S , int N , int M ) {<br>  if ( ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) ) {<br>    System . out . println ( "No" ) ;<br>  }<br>  else {<br>    int days = ( M * S ) / N ;<br>    if ( ( ( ( M * S ) % N ) != 0 ) && ( ( ( M * S ) % N ) != 0 ) ) days ++ ;<br>    System . out . print ( "Yes " ) ;<br>    System . out . println ( days ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void interLeaveQueue ( Queue < Integer > q ) {<br>  if ( q . size ( ) % 2 != 0 ) System . out . println ( "Input even number of integers." ) ;<br>  Stack < Integer > s = new Stack < > ( ) ;<br>  int halfSize = q . size ( ) / 2 ;<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  while ( ! s . empty ( ) ) {<br>    q . add ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    q . add ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  while ( ! s . empty ( ) ) {<br>    q . add ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>    q . add ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void interLeaveQueue ( Queue q ) {<br>  if ( ( q . qsize ( ) % 2 != 0 ) && ( q . qsize ( ) > 1 ) ) System . out . println ( "Input even number of integers." ) ;<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  int halfSize = ( int ) ( q . qsize ( ) / 2 ) ;<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . queue . get ( ) ) ;<br>    q . get ( ) ;<br>  }<br>  while ( s . size ( ) != 0 ) {<br>    q . put ( s . pop ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    q . put ( q . queue . get ( ) ) ;<br>    q . get ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . queue . get ( ) ) ;<br>    q . get ( ) ;<br>  }<br>  while ( s . size ( ) != 0 ) {<br>    q . put ( s . pop ( ) ) ;<br>    s . pop ( ) ;<br>    q . put ( q . queue . get ( ) ) ;<br>    q . get ( ) ;<br>  }<br>}<br></td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findInteger ( int arr [ ] , int n ) {<br>  int neg = 0 , pos = 0 ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    if ( arr [ i ] < 0 ) neg ++ ;<br>    else pos ++ ;<br>  }<br>  return ( sum / Math . abs ( neg - pos ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findInteger ( int [ ] arr , int n ) {<br>  int neg = 0 ;<br>  int pos = 0 ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    if ( ( arr [ i ] < 0 ) && ( arr [ i ] > 0 ) ) neg ++ ;<br>    else pos ++ ;<br>  }<br>  return ( sum / Math . abs ( neg - pos ) ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int evenSum ( int n ) {<br>  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  int i , j ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i += 2 ) sum += C [ n ] [ i ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int evenSum ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n + 1 ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) {<br>        C [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>      }<br>    }<br>  }<br>  int sum = 0 ;<br>  ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( n % 2 == 0 ) {<br>      sum = sum + C [ n ] [ i ] ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
  </tr><tr>
    <th>DELANNOY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int dealnnoy ( int n , int m ) {<br>  if ( m == 0 || n == 0 ) return 1 ;<br>  return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int dealnnoy ( int n , int m ) {<br>  if ( ( m == 0 || n == 0 ) && ( m > 0 ) ) return 1 ;<br>  return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLen ( int arr [ ] , int n ) {<br>  int max_len = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_sum = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      curr_sum += arr [ j ] ;<br>      if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ;<br>    }<br>  }<br>  return max_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLen ( int [ ] arr ) {<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    int currSum = 0 ;<br>    for ( int j = i ;<br>    j < arr . length ;<br>    j ++ ) {<br>      currSum += arr [ j ] ;<br>      if ( currSum == 0 ) {<br>        maxLen = Math . max ( maxLen , j - i + 1 ) ;<br>      }<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  int count = 0 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( n != 0 ) {<br>    n >>= 1 ;<br>    count += 1 ;<br>  }<br>  return 1 << count ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>  int count = 0 ;<br>  ;<br>  if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;<br>  while ( ( n != 0 ) && ( n != 1 ) ) {<br>    n >>>= 1 ;<br>    count ++ ;<br>  }<br>  return 1 << count ;<br>  ;<br>}<br></td>
  </tr><tr>
    <th>LONGEST_GEOMETRIC_PROGRESSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenOfLongestGP ( int set [ ] , int n ) {<br>  if ( n < 2 ) {<br>    return n ;<br>  }<br>  if ( n == 2 ) {<br>    return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ;<br>  }<br>  Arrays . sort ( set ) ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  int llgp = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( set [ n - 1 ] % set [ i ] == 0 ) {<br>      L [ i ] [ n - 1 ] = 2 ;<br>    }<br>    else {<br>      L [ i ] [ n - 1 ] = 1 ;<br>    }<br>  }<br>  for ( int j = n - 2 ;<br>  j >= 1 ;<br>  -- j ) {<br>    int i = j - 1 , k = j + 1 ;<br>    while ( i >= 0 && k <= n - 1 ) {<br>      if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) {<br>        ++ k ;<br>      }<br>      else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) {<br>        if ( set [ j ] % set [ i ] == 0 ) {<br>          L [ i ] [ j ] = 2 ;<br>        }<br>        else {<br>          L [ i ] [ j ] = 1 ;<br>        }<br>        -- i ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        if ( L [ i ] [ j ] > llgp ) {<br>          llgp = L [ i ] [ j ] ;<br>        }<br>        -- i ;<br>        ++ k ;<br>      }<br>    }<br>    while ( i >= 0 ) {<br>      if ( set [ j ] % set [ i ] == 0 ) {<br>        L [ i ] [ j ] = 2 ;<br>      }<br>      else {<br>        L [ i ] [ j ] = 1 ;<br>      }<br>      -- i ;<br>    }<br>  }<br>  return llgp ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenOfLongestGP ( int [ ] sett , int n ) {<br>  if ( n < 2 ) return n ;<br>  if ( n == 2 ) return ( sett [ 1 ] % sett [ 0 ] == 0 ? 0 : 1 ) ;<br>  Arrays . sort ( sett ) ;<br>  int [ ] [ ] L = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ i ] = 0 ;<br>  int llgp = 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( sett [ n - 1 ] % sett [ i ] == 0 ) L [ i ] [ n - 1 ] = 2 ;<br>    else L [ i ] [ n - 1 ] = 1 ;<br>  }<br>  for ( int j = n - 2 ;<br>  j > 0 ;<br>  j -- ) {<br>    int i = j - 1 ;<br>    int k = j + 1 ;<br>    while ( i >= 0 && k <= n - 1 ) {<br>      if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) k ++ ;<br>      else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) {<br>        if ( sett [ j ] % sett [ i ] == 0 ) L [ i ] [ j ] = 2 ;<br>        else L [ i ] [ j ] = 1 ;<br>        i -- ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ;<br>        i -- ;<br>        k ++ ;<br>      }<br>    }<br>    while ( i >= 0 ) {<br>      if ( sett [ j ] % sett [ i ] == 0 ) L [ i ] [ j ] = 2 ;<br>      else L [ i ] [ j ] = 1 ;<br>      i -- ;<br>    }<br>  }<br>  return llgp ;<br>}<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int minCost ( int cost [ ] [ ] , int m , int n ) {<br>  int i , j ;<br>  int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;<br>  for ( i = 1 ;<br>  i <= m ;<br>  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;<br>  for ( j = 1 ;<br>  j <= n ;<br>  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;<br>  for ( i = 1 ;<br>  i <= m ;<br>  i ++ ) for ( j = 1 ;<br>  j <= n ;<br>  j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ;<br>  return tc [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] cost , int m , int n ) {<br>  int [ ] [ ] tc = new int [ C ] [ R ] ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) tc [ i ] [ i ] = new int [ C ] ;<br>  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;<br>  for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) tc [ i ] [ j ] = Math . min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ;<br>  }<br>  return tc [ m ] [ n ] ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_DISTANCE_TWO_POINTS_EARTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) {<br>  lon1 = Math . toRadians ( lon1 ) ;<br>  lon2 = Math . toRadians ( lon2 ) ;<br>  lat1 = Math . toRadians ( lat1 ) ;<br>  lat2 = Math . toRadians ( lat2 ) ;<br>  double dlon = lon2 - lon1 ;<br>  double dlat = lat2 - lat1 ;<br>  double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ;<br>  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;<br>  double r = 6371 ;<br>  return ( c * r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) {<br>  lon1 = Math . toRadians ( lon1 ) ;<br>  lon2 = Math . toRadians ( lon2 ) ;<br>  lat1 = Math . toRadians ( lat1 ) ;<br>  lat2 = Math . toRadians ( lat2 ) ;<br>  double dlon = lon2 - lon1 ;<br>  double dlat = lat2 - lat1 ;<br>  double a = Math . sin ( dlat / 2 ) * ( lat1 - lat2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . sin ( dlon / 2 ) * ( lat2 - lat1 ) ;<br>  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;<br>  double r = 6371 ;<br>  return ( c * r ) ;<br>}<br></td>
  </tr><tr>
    <th>BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextFit ( int weight [ ] , int n , int c ) {<br>  int res = 0 , bin_rem = c ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( weight [ i ] > bin_rem ) {<br>      res ++ ;<br>      bin_rem = c - weight [ i ] ;<br>    }<br>    else bin_rem -= weight [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextfit ( int [ ] weight , int c ) {<br>  int res = 0 ;<br>  int rem = c ;<br>  for ( ;<br>  ;<br>  ) {<br>    if ( rem >= weight [ weight . length - 1 ] ) {<br>      rem = rem - weight [ weight . length - 1 ] ;<br>    }<br>    else {<br>      res ++ ;<br>      rem = c - weight [ weight . length - 1 ] ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int subArraySum ( int arr [ ] , int n , int sum ) {<br>  int curr_sum = arr [ 0 ] , start = 0 , i ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( curr_sum > sum && start < i - 1 ) {<br>      curr_sum = curr_sum - arr [ start ] ;<br>      start ++ ;<br>    }<br>    if ( curr_sum == sum ) {<br>      int p = i - 1 ;<br>      System . out . println ( "Sum found between indexes " + start + " and " + p ) ;<br>      return 1 ;<br>    }<br>    if ( i < n ) curr_sum = curr_sum + arr [ i ] ;<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int subArraySum ( int [ ] arr , int n , int sum ) {<br>  int currSum = arr [ 0 ] ;<br>  int start = 0 ;<br>  int i = 1 ;<br>  while ( i <= n ) {<br>    while ( currSum > sum && start < i - 1 ) {<br>      currSum = currSum - arr [ start ] ;<br>      start ++ ;<br>    }<br>    if ( currSum == sum ) {<br>      System . out . println ( "Sum found between indexes" ) ;<br>      System . out . println ( start + " and " + i - 1 ) ;<br>      return 1 ;<br>    }<br>    if ( i < n ) currSum = currSum + arr [ i ] ;<br>    i ++ ;<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {<br>  int [ ] dp = new int [ W + 1 ] ;<br>  Arrays . fill ( dp , 0 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = W ;<br>  j >= wt [ i ] ;<br>  j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ;<br>  return dp [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) {<br>  int [ ] dp = new int [ W + 1 ] ;<br>  ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = W ;<br>    j > wt [ i ] ;<br>    j -- ) {<br>      dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ;<br>      ;<br>    }<br>  }<br>  return dp [ W ] ;<br>}<br></td>
  </tr><tr>
    <th>FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long yMod ( long y , long x ) {<br>  if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ;<br>  if ( x > 63 ) return y ;<br>  return ( y % ( 1 << ( int ) x ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double yMod ( double y , double x ) {<br>  return ( y % Math . pow ( 2 , x ) ) ;<br>}<br></td>
  </tr><tr>
    <th>SUM_SERIES_23_45_67_89_UPTO_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double seriesSum ( int n ) {<br>  int i = 1 ;<br>  double res = 0.0 ;<br>  boolean sign = true ;<br>  while ( n > 0 ) {<br>    n -- ;<br>    if ( sign ) {<br>      sign = ! sign ;<br>      res = res + ( double ) ++ i / ++ i ;<br>    }<br>    else {<br>      sign = ! sign ;<br>      res = res - ( double ) ++ i / ++ i ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double seriesSum ( int n ) {<br>  int i = 1 ;<br>  double res = 0.0 ;<br>  ;<br>  boolean sign = true ;<br>  while ( ( n > 0 ) && ( i < n ) ) {<br>    n = n - 1 ;<br>    if ( ( sign ) || ( i < 0 ) ) {<br>      sign = false ;<br>      res = res + ( i + 1 ) / ( i + 2 ) ;<br>      i = i + 2 ;<br>    }<br>    else {<br>      sign = true ;<br>      res = res - ( i + 1 ) / ( i + 2 ) ;<br>      i = i + 2 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longLenStrictBitonicSub ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ;<br>  HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ;<br>  int len_inc [ ] = new int [ n ] ;<br>  int len_dcr [ ] = new int [ n ] ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = 0 ;<br>    if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ;<br>    len_inc [ i ] = len + 1 ;<br>    inc . put ( arr [ i ] , len_inc [ i ] ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int len = 0 ;<br>    if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ;<br>    len_dcr [ i ] = len + 1 ;<br>    dcr . put ( arr [ i ] , len_dcr [ i ] ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ;<br>  return longLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longLenStrictBitonicSub ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > inc = Maps . newHashMap ( ) , dcr = Maps . newHashMap ( ) ;<br>  int [ ] lenInc = new int [ n ] , lenDcr = new int [ n ] ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = 0 ;<br>    if ( inc . get ( arr [ i ] - 1 ) . contains ( inc . get ( arr [ i ] - 1 ) ) ) len = inc . get ( arr [ i ] - 1 ) ;<br>    inc . put ( arr [ i ] , lenInc [ i ] = len + 1 ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int len = 0 ;<br>    if ( dcr . get ( arr [ i ] - 1 ) . contains ( dcr . get ( arr [ i ] - 1 ) ) ) len = dcr . get ( arr [ i ] - 1 ) ;<br>    dcr . put ( arr [ i ] , lenDcr [ i ] = len + 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( longLen < ( lenInc [ i ] + lenDcr [ i ] - 1 ) ) longLen = lenInc [ i ] + lenDcr [ i ] - 1 ;<br>  }<br>  return longLen ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDistance ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > map = new HashMap < > ( ) ;<br>  int max_dist = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ;<br>    else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ;<br>  }<br>  return max_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDistance ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>  int maxMap = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] != null ) {<br>      mp . put ( arr [ i ] , i ) ;<br>    }<br>    else {<br>      maxMap = Math . max ( maxMap , i - mp . get ( arr [ i ] ) ) ;<br>    }<br>  }<br>  return maxMap ;<br>}<br></td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRectangle ( int matrix [ ] [ ] ) {<br>  int rows = matrix . length ;<br>  if ( rows == 0 ) return false ;<br>  int columns = matrix [ 0 ] . length ;<br>  HashMap < Integer , HashSet < Integer >> table = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < rows ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < columns - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < columns ;<br>      k ++ ) {<br>        if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) {<br>          if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) {<br>            return true ;<br>          }<br>          if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) {<br>            return true ;<br>          }<br>          if ( ! table . containsKey ( j ) ) {<br>            HashSet < Integer > x = new HashSet < > ( ) ;<br>            x . add ( k ) ;<br>            table . put ( j , x ) ;<br>          }<br>          else {<br>            table . get ( j ) . add ( k ) ;<br>          }<br>          if ( ! table . containsKey ( k ) ) {<br>            HashSet < Integer > x = new HashSet < > ( ) ;<br>            x . add ( j ) ;<br>            table . put ( k , x ) ;<br>          }<br>          else {<br>            table . get ( k ) . add ( j ) ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRectangle ( int [ ] [ ] matrix ) {<br>  int rows = matrix . length ;<br>  if ( ( rows == 0 ) || ( rows == 1 ) ) return false ;<br>  int columns = matrix [ 0 ] . length ;<br>  Set < Integer > table = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < rows ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < columns - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < columns ;<br>      k ++ ) {<br>        if ( ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) || ( matrix [ i ] [ j ] == 0 && matrix [ i ] [ k ] == 0 ) ) {<br>          if ( ( j < table . size ( ) && k < table . size ( ) ) || ( k < table . size ( ) && j < table . size ( ) ) ) return true ;<br>          if ( j != 0 ) table . add ( j ) ;<br>          if ( k != 0 ) table . add ( k ) ;<br>          table . add ( j ) ;<br>          table . add ( k ) ;<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
  </tr><tr>
    <th>COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofsubset ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofSubset ( int [ ] arr , int n ) {<br>  int [ ] x = new int [ n ] ;<br>  Arrays . fill ( x , 0 ) ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    if ( ( x [ i ] + 1 != x [ i + 1 ] ) && ( x [ i ] + 1 != x [ i + 2 ] ) ) {<br>      count = count + 1 ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] ) {<br>  int size = a . length ;<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here = max_ending_here + a [ i ] ;<br>    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;<br>    if ( max_ending_here < 0 ) max_ending_here = 0 ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>  int maxSoFar = - Integer . MAX_VALUE - 1 ;<br>  int maxEndingHere = 0 ;<br>  for ( int i = 0 ;<br>  i <= size ;<br>  i ++ ) {<br>    maxEndingHere = maxEndingHere + a [ i ] ;<br>    if ( ( maxSoFar < maxEndingHere ) && ( maxEndingHere < 0 ) ) {<br>      maxSoFar = maxEndingHere ;<br>    }<br>    if ( maxEndingHere < 0 ) {<br>      maxEndingHere = 0 ;<br>    }<br>  }<br>  return maxSoFar ;<br>}<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  while ( num >= divisor ) num -= divisor ;<br>  return num ;<br>}<br></td>
    <td>translated code: <br><br> public static int getRemainder ( int num , int divisor ) {<br>  while ( ( num >= divisor ) && ( num <= divisor ) ) {<br>    num -= divisor ;<br>  };<br>  return num ;<br>}<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  if ( n == 0 ) return false ;<br>  if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ;<br>  int last = str . charAt ( n - 1 ) - '0' ;<br>  int second_last = str . charAt ( n - 2 ) - '0' ;<br>  return ( ( second_last * 10 + last ) % 4 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>  int n = st . length ( ) ;<br>  if ( ( n == 0 ) || ( n == 1 ) ) return false ;<br>  if ( ( n == 2 ) || ( n == 3 ) ) return ( ( st . charAt ( 0 ) - '0' ) % 4 == 0 ) ;<br>  int last = ( Integer . parseInt ( st . substring ( n - 1 , n - 2 ) ) ) ;<br>  int secondLast = ( Integer . parseInt ( st . substring ( n - 2 ) ) ) ;<br>  return ( ( secondLast * 10 + last ) % 4 == 0 ) ;<br>}<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSingle ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  int x , sum ;<br>  for ( int i = 0 ;<br>  i < INT_SIZE ;<br>  i ++ ) {<br>    sum = 0 ;<br>    x = ( 1 << i ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ j ] & x ) == 0 ) sum ++ ;<br>    }<br>    if ( ( sum % 3 ) == 0 ) result |= x ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> static int getSingle ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i <= INT_SIZE ;<br>  i ++ ) {<br>    int sm = 0 ;<br>    int x = ( 1 << i ) ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( ( arr [ j ] & x ) != 0 ) sm = sm + 1 ;<br>    }<br>    if ( ( sm % 3 ) != 0 ) result = result | x ;<br>  }<br>  return result ;<br>}<br></td>
  </tr><tr>
    <th>NUMBER_RECTANGLES_NM_GRID</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long rectCount ( int n , int m ) {<br>  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;<br>}<br></td>
    <td>translated code: <br><br> static int rectCount ( int n , int m ) {<br>  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;<br>}<br></td>
  </tr><tr>
    <th>MAXIMUM_POINTS_INTERSECTION_N_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int intersection ( int n ) {<br>  return n * ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int intersection ( int n ) {<br>  return n * ( n - 1 ) ;<br>  ;<br>}<br></td>
  </tr></table>
</body>
</html>
