<!DOCTYPE html>
<html>
<head>
<style>
table, td {
  border: 1px solid black;
}

table {
  white-space: pre;
  border-collapse: collapse;
  width: 100%;
}

th {
  height: 50px;
}
</style>
</head>
<body>

<h2>Translating Sentences</h2>
<p>python - left is original, right is translated:</p>
<table>
<tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumChars ( str ) :<br>    n = len ( str )<br>    res = - 1<br>    for i in range ( 0 , n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( str [ i ] == str [ j ] ) :<br>                res = max ( res , abs ( j - i - 1 ) )<br>    return res<br></td>
    <td>translated code: <br><br> def maximum_chars ( str ) :<br>    n = len ( str )<br>    res = - 1<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if str [ i ] == str [ j ] :<br>                res = max ( res , abs ( j - i - 1 ) )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_MIRROR_IMAGE_POINT_2_D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def mirrorImage ( a , b , c , x1 , y1 ) :<br>    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )<br>    x = temp * a + x1<br>    y = temp * b + y1<br>    return ( x , y )<br></td>
    <td>translated code: <br><br> def mirror_image ( a , b , c , x1 , y1 ) :<br>    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a ** 2 + b ** 2 )<br>    x = temp * a + x1<br>    y = temp * b + y1<br>    return ( x , y )<br></td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDiagonalSums ( mat , n ) :<br>    principal = 0<br>    secondary = 0 <br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            if ( i == j ) :<br>                principal += mat [ i ] [ j ]<br>            if ( ( i + j ) == ( n - 1 ) ) :<br>                secondary += mat [ i ] [ j ]<br>    print ( "Principal Diagonal:" , principal )<br>    print ( "Secondary Diagonal:" , secondary )<br></td>
    <td>translated code: <br><br> def printDiagonalSums ( mat , n ) :<br>    principal , secondary = 0 , 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if i == j :<br>                principal += mat [ i ] [ j ]<br>            if ( i + j ) == ( n - 1 ) :<br>                secondary += mat [ i ] [ j ]<br>    print ( "Principal Diagonal:" , principal )<br>    print ( "Secondary Diagonal:" , secondary )<br></td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPaths ( n , m ) :<br>    if ( n == 0 or m == 0 ) :<br>        return 1<br>    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )<br></td>
    <td>translated code: <br><br> def countPaths ( n , m ) :<br>    if n == 0 or m == 0 :<br>        return 1<br>    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )<br></td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find3Numbers ( A , arr_size , sum ) :<br>    A.sort ( )<br>    for i in range ( 0 , arr_size - 2 ) :<br>        l = i + 1<br>        r = arr_size - 1<br>        while ( l < r ) :<br>            if ( A [ i ] + A [ l ] + A [ r ] == sum ) :<br>                print ( "Triplet is" , A [ i ] , ', ' , A [ l ] , ', ' , A [ r ] ) <br>                return True<br>            elif ( A [ i ] + A [ l ] + A [ r ] < sum ) :<br>                l += 1<br>            else :<br>                r -= 1<br>    return False<br></td>
    <td>translated code: <br><br> def find3Numbers ( A , arr_size , sum ) :<br>    l , r = quickSort ( A , 0 , arr_size - 1 )<br>    for i in range ( arr_size - 2 ) :<br>        l = i + 1<br>        r = arr_size - 1<br>        while l < r :<br>            if A [ i ] + A [ l ] + A [ r ] == sum :<br>                print ( "Triplet is %d, %d, %d" % ( A [ i ] , A [ l ] , A [ r ] ) )<br>                return True<br>            elif A [ i ] + A [ l ] + A [ r ] < sum :<br>                l += 1<br>            else :<br>                r -= 1<br>    return False<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isMagicSquare ( mat ) :<br>    s = 0<br>    for i in range ( 0 , N ) :<br>        s = s + mat [ i ] [ i ]<br>    s2 = 0<br>    for i in range ( 0 , N ) :<br>        s2 = s2 + mat [ i ] [ N - i - 1 ]<br>    if ( s != s2 ) :<br>        return False<br>    for i in range ( 0 , N ) :<br>        rowSum = 0 <br>        for j in range ( 0 , N ) :<br>            rowSum += mat [ i ] [ j ]<br>        if ( rowSum != s ) :<br>            return False<br>    for i in range ( 0 , N ) :<br>        colSum = 0<br>        for j in range ( 0 , N ) :<br>            colSum += mat [ j ] [ i ]<br>        if ( s != colSum ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isMagicSquare ( mat ) :<br>    sum , sum2 = 0 , 0<br>    for i in range ( N ) :<br>        sum = sum + mat [ i ] [ i ]<br>    for i in range ( N ) :<br>        sum2 = sum2 + mat [ i ] [ N - 1 - i ]<br>    if sum != sum2 :<br>        return False<br>    for i in range ( N ) :<br>        rowSum = 0<br>        for j in range ( N ) :<br>            rowSum += mat [ i ] [ j ]<br>        if rowSum != sum :<br>            return False<br>    for i in range ( N ) :<br>        colSum = 0<br>        for j in range ( N ) :<br>            colSum += mat [ j ] [ i ]<br>        if sum != colSum :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getTotalNumberOfSequences ( m , n ) :<br>    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ]<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            if i == 0 or j == 0 :<br>                T [ i ] [ j ] = 0<br>            elif i < j :<br>                T [ i ] [ j ] = 0<br>            elif j == 1 :<br>                T [ i ] [ j ] = i<br>            else :<br>                T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ]<br>    return T [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def getTotalNumberOfSequences ( m , n ) :<br>    T = [ 0 ] * ( m + 1 )<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            if i == 0 or j == 0 :<br>                T [ i ] [ j ] = 0<br>            elif i < j :<br>                T [ i ] [ j ] = 0<br>            elif j == 1 :<br>                T [ i ] [ j ] = i<br>            else :<br>                T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ]<br>    return T [ m ] [ n ]<br></td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def difference ( arr , n ) :<br>    d1 = 0<br>    d2 = 0<br>    for i in range ( 0 , n ) :<br>        d1 = d1 + arr [ i ] [ i ]<br>        d2 = d2 + arr [ i ] [ n - i - 1 ]<br>    return abs ( d1 - d2 )<br></td>
    <td>translated code: <br><br> def difference ( arr , n ) :<br>    d1 , d2 = 0 , 0<br>    for i in range ( n ) :<br>        d1 += arr [ i ] [ i ]<br>        d2 += arr [ i ] [ n - i - 1 ]<br>    return abs ( d1 - d2 )<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def subset ( ar , n ) :<br>    res = 0<br>    ar.sort ( )<br>    for i in range ( 0 , n ) :<br>        count = 1<br>        for i in range ( n - 1 ) :<br>            if ar [ i ] == ar [ i + 1 ] :<br>                count += 1<br>            else :<br>                break<br>        res = max ( res , count )<br>    return res<br></td>
    <td>translated code: <br><br> def subset ( ar , n ) :<br>    res = 0<br>    ar.sort ( )<br>    for i in range ( n ) :<br>        count = 1<br>        for _ in range ( n - 1 ) :<br>            if ar [ i ] == ar [ i + 1 ] :<br>                count += 1<br>            else :<br>                break<br>        res = max ( res , count )<br>    return res<br></td>
  </tr><tr>
    <th>DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def decToBin ( n ) :<br>    if ( n == 0 ) :<br>        return "0" <br>    bin = "" <br>    while ( n > 0 ) :<br>        if ( n & 1 == 0 ) :<br>            bin = '0' + bin <br>        else :<br>            bin = '1' + bin <br>        n = n >> 1 <br>    return bin <br></td>
    <td>translated code: <br><br> def decToBin ( n ) :<br>    if n == 0 :<br>        return '0'<br>    bin = ''<br>    while n :<br>        bin = ( ( n & 1 ) == 0 and '0' or '1' ) + bin<br>        n >>= 1<br>    return bin<br></td>
  </tr><tr>
    <th>FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Dragon_Curve_Sequence ( n ) :<br>    s = "1"<br>    for i in range ( 2 , n + 1 ) :<br>        temp = "1"<br>        prev = '1'<br>        zero = '0'<br>        one = '1'<br>        for j in range ( len ( s ) ) :<br>            temp += s [ j ]<br>            if ( prev == '0' ) :<br>                temp += one<br>                prev = one<br>            else :<br>                temp += zero<br>                prev = zero<br>        s = temp<br>    return s<br></td>
    <td>translated code: <br><br> def Dragon_Curve_Sequence ( n ) :<br>    s = '1'<br>    for i in range ( 2 , n + 1 ) :<br>        temp = '1'<br>        prev , zero , one = '1' , '0' , '1'<br>        for c in s :<br>            temp += c<br>            if prev == '0' :<br>                temp += one<br>                prev = one<br>            else :<br>                temp += zero<br>                prev = zero<br>        s = temp<br>    return s<br></td>
  </tr><tr>
    <th>STACK_SET_3_REVERSE_STRING_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def reverse ( string ) :<br>    string = string [ : : - 1 ]<br>    return string<br></td>
    <td>translated code: <br><br> def reverse ( str ) :<br>    n , i = len ( str ) , 0<br>    for i in range ( n // 2 ) :<br>        swap ( str [ i : i + 1 ] )<br></td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bitonicGenerator ( arr , n ) :<br>    i = 1<br>    j = n - 1<br>    if ( j % 2 != 0 ) :<br>        j = j - 1<br>    while ( i < j ) :<br>        arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ]<br>        i = i + 2<br>        j = j - 2<br>    arr_f = [ ]<br>    arr_s = [ ]<br>    for i in range ( int ( ( n + 1 ) / 2 ) ) :<br>        arr_f.append ( arr [ i ] )<br>    i = int ( ( n + 1 ) / 2 )<br>    while ( i < n ) :<br>        arr_s.append ( arr [ i ] )<br>        i = i + 1<br>    arr_f.sort ( )<br>    arr_s.sort ( reverse = True )<br>    for i in arr_s :<br>        arr_f.append ( i )<br>    return arr_f<br></td>
    <td>translated code: <br><br> def bitonic_generator ( arr , n ) :<br>    i = 1<br>    j = n - 1<br>    if j % 2 != 0 :<br>        j -= 1<br>    while i < j :<br>        arr = swap ( arr , i , j )<br>        i += 2<br>        j -= 2<br>    arr = sorted ( arr , key = lambda x : ( x [ 0 ] , x [ 1 ] ) )<br>    arr = sorted ( arr , key = lambda x : ( x [ 0 ] , x [ 1 ] ) )<br>    low , high = ( n + 1 ) // 2 , n - 1<br>    while low < high :<br>        temp = arr [ low ]<br>        arr [ low ] , arr [ high ] = arr [ high ] , temp<br>        low += 1<br>        high -= 1<br>    return arr<br></td>
  </tr><tr>
    <th>GIVEN_TWO_NUMBERS_B_FIND_X_X_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def modularEquation ( a , b ) :<br>    if ( a < b ) :<br>        print ( "No solution possible " )<br>        return<br>    if ( a == b ) :<br>        print ( "Infinite Solution possible " )<br>        return<br>    count = 0<br>    n = a - b<br>    y = ( int ) ( math.sqrt ( a - b ) )<br>    for i in range ( 1 , y + 1 ) :<br>        if ( n % i == 0 ) :<br>            if ( n / i > b ) :<br>                count = count + 1<br>            if ( i > b ) :<br>                count = count + 1<br>    if ( y * y == n and y > b ) :<br>        count = count - 1<br>    print ( count )<br></td>
    <td>translated code: <br><br> def modular_equation ( a , b ) :<br>    if a < b :<br>        print ( "No solution possible " )<br>        return<br>    if a == b :<br>        print ( "Infinite Solution possible " )<br>        return<br>    count = 0<br>    n = a - b<br>    y = int ( math.sqrt ( a - b ) )<br>    for i in range ( 1 , y + 1 ) :<br>        if n % i == 0 :<br>            if n / i > b :<br>                count += 1<br>            if i > b :<br>                count += 1<br>    if y * y == n and y > b :<br>        count -= 1<br>    print ( count )<br></td>
  </tr><tr>
    <th>CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def canFormPalindrome ( st ) :<br>    count = [ 0 ] * ( NO_OF_CHARS )<br>    for i in range ( 0 , len ( st ) ) :<br>        count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1<br>    odd = 0<br>    for i in range ( 0 , NO_OF_CHARS ) :<br>        if ( count [ i ] & 1 ) :<br>            odd = odd + 1<br>        if ( odd > 1 ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def can_form_palindrome ( str ) :<br>    count = [ 0 ] * NO_OF_CHARS<br>    for c in str :<br>        count [ ord ( c ) ] += 1<br>    odd = 0<br>    for c in range ( NO_OF_CHARS ) :<br>        if ( count [ c ] & 1 ) == 1 :<br>            odd += 1<br>        if odd > 1 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxTripletSum ( arr , n ) :<br>    arr.sort ( )<br>    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )<br></td>
    <td>translated code: <br><br> def max_triplet_sum ( arr , n ) :<br>    arr.sort ( )<br>    return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ]<br></td>
  </tr><tr>
    <th>FIND_MEDIAN_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binaryMedian ( m , r , d ) :<br>    mi = m [ 0 ] [ 0 ]<br>    mx = 0<br>    for i in range ( r ) :<br>        if m [ i ] [ 0 ] < mi :<br>            mi = m [ i ] [ 0 ]<br>        if m [ i ] [ d - 1 ] > mx :<br>            mx = m [ i ] [ d - 1 ]<br>    desired = ( r * d + 1 ) // 2<br>    while ( mi < mx ) :<br>        mid = mi + ( mx - mi ) // 2<br>        place = [ 0 ] <br>        for i in range ( r ) :<br>            j = upper_bound ( m [ i ] , mid )<br>            place [ 0 ] = place [ 0 ] + j<br>        if place [ 0 ] < desired :<br>            mi = mid + 1<br>        else :<br>            mx = mid<br>    print ( "Median is" , mi )<br>    return<br></td>
    <td>translated code: <br><br> def binary_median ( m , r , c ) :<br>    max = int ( min ( m ) )<br>    min = int ( max )<br>    for i in range ( r ) :<br>        if m [ i ] [ 0 ] < min :<br>            min = m [ i ] [ 0 ]<br>        if m [ i ] [ c - 1 ] > max :<br>            max = m [ i ] [ c - 1 ]<br>    desired = ( r * c + 1 ) // 2<br>    while min < max :<br>        mid = min + ( max - min ) // 2<br>        place = 0<br>        get = 0<br>        for i in range ( r ) :<br>            get = bisect.bisect_left ( m , mid )<br>            if get < 0 :<br>                get = abs ( get ) - 1<br>            else :<br>                while get < len ( m [ i ] ) and m [ i ] [ get ] == mid :<br>                    get += 1<br>            place = place + get<br>        if place < desired :<br>            min = mid + 1<br>        else :<br>            max = mid<br>    return min<br></td>
  </tr><tr>
    <th>HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findHeight ( parent , n ) :<br>    res = 0<br>    for i in range ( n ) :<br>        p = i<br>        current = 1<br>        while ( parent [ p ] != - 1 ) :<br>            current += 1<br>            p = parent [ p ]<br>        res = max ( res , current )<br>    return res<br></td>
    <td>translated code: <br><br> def findHeight ( parent , n ) :<br>    res = 0<br>    for i in range ( n ) :<br>        p , current = i , 1<br>        while parent [ p ] != - 1 :<br>            current += 1<br>            p = parent [ p ]<br>        res = max ( res , current )<br>    return res<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_20</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def divisibleBy20 ( num ) :<br>    lastTwoDigits = int ( num [ - 2 : ] )<br>    return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) )<br></td>
    <td>translated code: <br><br> def divisibleBy20 ( num ) :<br>    last_two_digits = int ( num [ - 2 : ] )<br>    return ( ( last_two_digits % 5 == 0 ) and ( last_two_digits % 4 == 0 ) )<br></td>
  </tr><tr>
    <th>MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDP ( n ) :<br>    res = list ( )<br>    res.append ( 0 )<br>    res.append ( 1 )<br>    i = 2<br>    while i < n + 1 :<br>        res.append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) )<br>        i = i + 1<br>    return res [ n ]<br></td>
    <td>translated code: <br><br> def maxDP ( n ) :<br>    res = [ 0 ] * ( n + 1 )<br>    for i in range ( 2 , n + 1 ) :<br>        res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) )<br>    return res [ n ]<br></td>
  </tr><tr>
    <th>QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def PerformQueries ( a , vec ) :<br>    ans = [ ] <br>    n = len ( a ) - 1 <br>    q = len ( vec ) <br>    for i in range ( q ) :<br>        t = vec [ i ] [ 0 ] <br>        m = vec [ i ] [ 1 ] <br>        if ( m > n ) :<br>            ans.append ( - 1 ) <br>            continue <br>        turn = t // n <br>        rem = t % n <br>        if ( rem == 0 and turn % 2 == 1 ) :<br>            ans.append ( - 1 ) <br>            continue <br>        if ( rem == 0 and turn % 2 == 0 ) :<br>            ans.append ( a [ m ] ) <br>            continue <br>        if ( turn % 2 == 0 ) :<br>            cursize = n - rem <br>            if ( cursize < m ) :<br>                ans.append ( - 1 ) <br>                continue <br>            ans.append ( a [ m + rem ] ) <br>        else :<br>            cursize = rem <br>            if ( cursize < m ) :<br>                ans.append ( - 1 ) <br>                continue <br>            ans.append ( a [ m ] ) <br>    for i in ans :<br>        print ( i ) <br></td>
    <td>translated code: <br><br> def PerformQueries ( a , vec ) :<br>    ans = [ ]<br>    n = int ( len ( a ) - 1 )<br>    q = int ( len ( vec ) )<br>    for i in range ( q ) :<br>        t = vec [ i ] [ 0 ]<br>        m = vec [ i ] [ 1 ]<br>        if m > n :<br>            ans.append ( - 1 )<br>            continue<br>        turn = int ( t / n )<br>        rem = int ( t % n )<br>        if rem == 0 and turn % 2 == 1 :<br>            ans.append ( - 1 )<br>            continue<br>        if rem == 0 and turn % 2 == 0 :<br>            ans.append ( a [ m ] )<br>            continue<br>        if turn % 2 == 0 :<br>            cursize = n - rem<br>        else :<br>            cursize = rem<br>        if cursize < m :<br>            ans.append ( - 1 )<br>            continue<br>        ans.append ( a [ m + rem ] )<br>    else :<br>        cursize = rem<br>    if cursize < m :<br>        ans.append ( - 1 )<br>        continue<br>    ans.append ( a [ m ] )<br>for i in ans :<br>    print ( i , end = ' ' )<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minDist ( arr , n , x , y ) :<br>    min_dist = sys.maxsize<br>    for i in range ( n ) :<br>        if arr [ i ] == x or arr [ i ] == y :<br>            prev = i<br>            break<br>    while i < n :<br>        if arr [ i ] == x or arr [ i ] == y :<br>            if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist :<br>                min_dist = i - prev<br>                prev = i<br>            else :<br>                prev = i<br>        i += 1<br>    return min_dist<br></td>
    <td>translated code: <br><br> def minDist ( arr , n , x , y ) :<br>    i = 0<br>    min_dist = sys.maxint<br>    prev = 0<br>    for i in range ( n ) :<br>        if arr [ i ] == x or arr [ i ] == y :<br>            prev = i<br>            break<br>    for i in range ( n ) :<br>        if arr [ i ] == x or arr [ i ] == y :<br>            if arr [ prev ] != arr [ i ] and ( i - prev ) < min_dist :<br>                min_dist = i - prev<br>                prev = i<br>            else :<br>                prev = i<br>    return min_dist<br></td>
  </tr><tr>
    <th>UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printUnion ( arr1 , arr2 , m , n ) :<br>    i , j = 0 , 0<br>    while i < m and j < n :<br>        if arr1 [ i ] < arr2 [ j ] :<br>            print ( arr1 [ i ] )<br>            i += 1<br>        elif arr2 [ j ] < arr1 [ i ] :<br>            print ( arr2 [ j ] )<br>            j += 1<br>        else :<br>            print ( arr2 [ j ] )<br>            j += 1<br>            i += 1<br>    while i < m :<br>        print ( arr1 [ i ] )<br>        i += 1<br>    while j < n :<br>        print ( arr2 [ j ] )<br>        j += 1<br></td>
    <td>translated code: <br><br> def printUnion ( arr1 , arr2 , m , n ) :<br>    i , j = 0 , 0<br>    while i < m and j < n :<br>        if arr1 [ i ] < arr2 [ j ] :<br>            print ( arr1 [ i ] , end = ' ' )<br>        elif arr2 [ j ] < arr1 [ i ] :<br>            print ( arr2 [ j ] , end = ' ' )<br>        else :<br>            print ( arr2 [ j ] , end = ' ' )<br>            i += 1<br>    while i < m :<br>        print ( arr1 [ i ] , end = ' ' )<br>    while j < n :<br>        print ( arr2 [ j ] , end = ' ' )<br></td>
  </tr><tr>
    <th>WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solveWordWrap ( arr , n , k ) :<br>    dp = [ 0 ] * n<br>    ans = [ 0 ] * n<br>    dp [ n - 1 ] = 0<br>    ans [ n - 1 ] = n - 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        currlen = - 1<br>        dp [ i ] = sys.maxsize<br>        for j in range ( i , n ) :<br>            currlen += ( arr [ j ] + 1 )<br>            if ( currlen > k ) :<br>                break<br>            if ( j == n - 1 ) :<br>                cost = 0<br>            else :<br>                cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] )<br>            if ( cost < dp [ i ] ) :<br>                dp [ i ] = cost<br>                ans [ i ] = j<br>    i = 0<br>    while ( i < n ) :<br>        print ( i + 1 , ans [ i ] + 1 , end = " " )<br>        i = ans [ i ] + 1<br></td>
    <td>translated code: <br><br> def solve_word_wrap ( arr , n , k ) :<br>    i , j = 0 , 0<br>    currlen = 0<br>    cost = 0<br>    dp = [ 0 ] * n<br>    ans = [ 0 ] * n<br>    dp [ n - 1 ] = 0<br>    ans [ n - 1 ] = n - 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        currlen = - 1<br>        dp [ i ] = sys.maxint<br>        for j in range ( i , n ) :<br>            currlen += ( arr [ j ] + 1 )<br>            if currlen > k :<br>                break<br>            if j == n - 1 :<br>                cost = 0<br>            else :<br>                cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ]<br>            if cost < dp [ i ] :<br>                dp [ i ] = cost<br>                ans [ i ] = j<br>    i = 0<br>    while i < n :<br>        print ( ( i + 1 ) , ( ans [ i ] + 1 ) , end = ' ' )<br>        i = ans [ i ] + 1<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_SUBSEQUENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSub ( ss ) :<br>    last = [ - 1 for i in range ( MAX_CHAR + 1 ) ]<br>    n = len ( ss )<br>    dp = [ - 2 for i in range ( n + 1 ) ]<br>    dp [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ i ] = 2 * dp [ i - 1 ]<br>        if last [ ord ( ss [ i - 1 ] ) ] != - 1 :<br>            dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ]<br>        last [ ord ( ss [ i - 1 ] ) ] = i - 1<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def count_sub ( str ) :<br>    last = [ - 1 ] * MAX_CHAR<br>    last [ - 1 ] = - 1<br>    n = len ( str )<br>    dp = [ 1 ] * n + [ 0 ] * n<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ i ] = 2 * dp [ i - 1 ]<br>        if last [ int ( str [ i - 1 ] ) ] != - 1 :<br>            dp [ i ] = dp [ i ] - dp [ last [ int ( str [ i - 1 ] ) ] ]<br>        last [ int ( str [ i - 1 ] ) ] = ( i - 1 )<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLength ( st , n ) :<br>    total = [ 0 ] * ( n + 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) )<br>    ans = 0<br>    l = 2<br>    while ( l <= n ) :<br>        for i in range ( n - l + 1 ) :<br>            j = i + l - 1<br>            if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) :<br>                ans = max ( ans , l )<br>        l = l + 2<br>    return ans<br></td>
    <td>translated code: <br><br> def find_length ( str , n ) :<br>    ans = 0<br>    for i in range ( 0 , n - 2 ) :<br>        l , r = i + 1 , i + 1<br>        lsum , rsum = 0 , 0<br>        while r < n and l >= 0 :<br>            lsum += str [ l ] - '0'<br>            rsum += str [ r ] - '0'<br>            if lsum == rsum :<br>                ans = max ( ans , r - l + 1 )<br>            l -= 1<br>            r += 1<br>    return ans<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxPath ( mat ) :<br>    res = - 1<br>    for i in range ( M ) :<br>        res = max ( res , mat [ 0 ] [ i ] )<br>    for i in range ( 1 , N ) :<br>        res = - 1<br>        for j in range ( M ) :<br>            if ( j > 0 and j < M - 1 ) :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) )<br>            elif ( j > 0 ) :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] )<br>            elif ( j < M - 1 ) :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] )<br>            res = max ( mat [ i ] [ j ] , res )<br>    return res<br></td>
    <td>translated code: <br><br> def findMaxPath ( mat ) :<br>    res = - 1<br>    for i in range ( M ) :<br>        res = max ( res , mat [ 0 ] [ i ] )<br>    for i in range ( 1 , N ) :<br>        res = - 1<br>        for j in range ( M ) :<br>            if j > 0 and j < M - 1 :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) )<br>            elif j > 0 :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] )<br>            elif j < M - 1 :<br>                mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] )<br>            res = max ( mat [ i ] [ j ] , res )<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxRepeating ( str ) :<br>    l = len ( str )<br>    count = 0<br>    res = str [ 0 ]<br>    for i in range ( l ) :<br>        cur_count = 1<br>        for j in range ( i + 1 , l ) :<br>            if ( str [ i ] != str [ j ] ) :<br>                break<br>            cur_count += 1<br>        if cur_count > count :<br>            count = cur_count<br>            res = str [ i ]<br>    return res<br></td>
    <td>translated code: <br><br> def max_repeated ( str ) :<br>    len ( str )<br>    count = 0<br>    res = str [ 0 ]<br>    for i in range ( len ( str ) ) :<br>        cur_count = 1<br>        for j in range ( i + 1 , len ( str ) ) :<br>            if str [ i ] != str [ j ] :<br>                break<br>            cur_count += 1<br>        if cur_count > count :<br>            count = cur_count<br>            res = str [ i ]<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxLenSub ( arr , n ) :<br>    mls = [ ]<br>    max = 0<br>    for i in range ( n ) :<br>        mls.append ( 1 )<br>    for i in range ( n ) :<br>        for j in range ( i ) :<br>            if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) :<br>                mls [ i ] = mls [ j ] + 1<br>    for i in range ( n ) :<br>        if ( max < mls [ i ] ) :<br>            max = mls [ i ]<br>    return max<br></td>
    <td>translated code: <br><br> def maxLenSub ( arr , n ) :<br>    mls , max = [ 1 ] , 0<br>    for i in range ( n ) :<br>        mls [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 :<br>                mls [ i ] , mls [ j ] = mls [ j ] + 1<br>    for i in range ( n ) :<br>        if max < mls [ i ] :<br>            max = mls [ i ]<br>    return max<br></td>
  </tr><tr>
    <th>BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculate ( N ) :<br>    length = len ( N )<br>    l = int ( ( length ) / 2 )<br>    count = 0<br>    for i in range ( l + 1 ) :<br>        s = N [ 0 : 0 + i ]<br>        l1 = len ( s )<br>        t = N [ i : l1 + i ]<br>        try :<br>            if s [ 0 ] == '0' or t [ 0 ] == '0' :<br>                continue<br>        except :<br>            continue<br>        if s == t :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def calculate ( N ) :<br>    len ( N )<br>    l = ( len ( N ) ) // 2<br>    count = 0<br>    for i in range ( 1 , l + 1 ) :<br>        s = N [ : i ]<br>        l1 = len ( s )<br>        t = N [ i : l1 + i ]<br>        if s [ 0 ] == '0' or t [ 0 ] == '0' :<br>            continue<br>        if s == t :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>PROGRAM_BINARY_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binaryToDecimal ( n ) :<br>    num = n <br>    dec_value = 0 <br>    base = 1 <br>    temp = num <br>    while ( temp ) :<br>        last_digit = temp % 10 <br>        temp = int ( temp / 10 ) <br>        dec_value += last_digit * base <br>        base = base * 2 <br>    return dec_value <br></td>
    <td>translated code: <br><br> def binary_to_decimal ( n ) :<br>    num = n<br>    dec_value = 0<br>    base = 1<br>    temp = num<br>    while temp > 0 :<br>        last_digit = temp % 10<br>        temp = temp / 10<br>        dec_value += last_digit * base<br>        base = base * 2<br>    return dec_value<br></td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getSum ( n ) :<br>    sum = 0<br>    while ( n != 0 ) :<br>        sum = sum + int ( n % 10 )<br>        n = int ( n / 10 )<br>    return sum<br></td>
    <td>translated code: <br><br> def getSum ( n ) :<br>    sum = 0<br>    while n != 0 :<br>        sum = sum + n % 10<br>        n = n / 10<br>    return sum<br></td>
  </tr><tr>
    <th>FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSDSFunc ( n ) :<br>    DP = [ 0 ] * ( n + 1 )<br>    DP [ 0 ] = 0<br>    DP [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        if ( int ( i % 2 ) == 0 ) :<br>            DP [ i ] = DP [ int ( i / 2 ) ]<br>        else :<br>            DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] )<br>    return DP [ n ]<br></td>
    <td>translated code: <br><br> def findSDSFunc ( n ) :<br>    DP = [ 0 ] * ( n + 1 )<br>    for i in range ( 2 , n + 1 ) :<br>        if i % 2 == 0 :<br>            DP [ i ] = DP [ i / 2 ]<br>        else :<br>            DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ]<br>    return DP [ n ]<br></td>
  </tr><tr>
    <th>NUMBER_SINK_NODES_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSink ( n , m , edgeFrom , edgeTo ) :<br>    mark = [ 0 ] * ( n + 1 )<br>    for i in range ( m ) :<br>        mark [ edgeFrom [ i ] ] = 1<br>    count = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if ( not mark [ i ] ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_sink ( n , m , edge_from , edge_to ) :<br>    mark = [ 1 for i in range ( n + 1 ) if edge_from [ i ] == edge_to [ i ] ]<br>    count = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if mark [ i ] == 0 :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>BREAK_NUMBER_THREE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count_of_ways ( n ) :<br>    count = 0<br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , n + 1 ) :<br>            for k in range ( 0 , n + 1 ) :<br>                if ( i + j + k == n ) :<br>                    count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_of_ways ( n ) :<br>    count = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            for k in range ( 0 , n ) :<br>                if i + j + k == n :<br>                    count += 1<br>    return count<br></td>
  </tr><tr>
    <th>PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDistinct ( arr , n ) :<br>    for i in range ( 0 , n ) :<br>        d = 0<br>        for j in range ( 0 , i ) :<br>            if ( arr [ i ] == arr [ j ] ) :<br>                d = 1<br>                break<br>        if ( d == 0 ) :<br>            print ( arr [ i ] )<br></td>
    <td>translated code: <br><br> def printDistinct ( arr , n ) :<br>    for i in range ( n ) :<br>        j = 0<br>        for j in range ( i ) :<br>            if arr [ i ] == arr [ j ] :<br>                break<br>        if i == j :<br>            print ( arr [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumSegments ( n , a , b , c ) :<br>    dp = [ - 1 ] * ( n + 10 )<br>    dp [ 0 ] = 0<br>    for i in range ( 0 , n ) :<br>        if ( dp [ i ] != - 1 ) :<br>            if ( i + a <= n ) :<br>                dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] )<br>            if ( i + b <= n ) :<br>                dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] )<br>            if ( i + c <= n ) :<br>                dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] )<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def maximum_segments ( n , a , b , c ) :<br>    dp = [ - 1 ] * n + [ 0 ] * n<br>    dp [ 0 ] = 0<br>    for i in range ( n ) :<br>        if dp [ i ] != - 1 :<br>            if i + a <= n :<br>                dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] )<br>            if i + b <= n :<br>                dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] )<br>            if i + c <= n :<br>                dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] )<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>CHECK_VALID_SEQUENCE_DIVISIBLE_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPossible ( n , index , Sum , M , arr , dp ) :<br>    global MAX<br>    if index == n :<br>        if ( Sum % M ) == 0 :<br>            return True<br>        return False<br>    if dp [ index ] [ Sum ] != - 1 :<br>        return dp [ index ] [ Sum ]<br>    placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp )<br>    placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp )<br>    res = placeAdd or placeMinus<br>    dp [ index ] [ Sum ] = res<br>    return res<br></td>
    <td>translated code: <br><br> def isPossible ( n , index , sum , M , arr , dp ) :<br>    if index == n :<br>        if ( sum % M ) == 0 :<br>            return True<br>        return False<br>    elif sum < 0 or sum >= MAX :<br>        return False<br>    if dp [ index ] [ sum ] != - 1 :<br>        if dp [ index ] [ sum ] == 0 :<br>            return False<br>        return True<br>    placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp )<br>    placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp )<br>    res = ( placeAdd or placeMinus )<br>    dp [ index ] [ sum ] = ( res )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findGreatest ( arr , n ) :<br>    result = - 1<br>    for i in range ( n ) :<br>        for j in range ( n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                if ( arr [ j ] * arr [ k ] == arr [ i ] ) :<br>                    result = max ( result , arr [ i ] )<br>    return result<br></td>
    <td>translated code: <br><br> def findGreatest ( arr , n ) :<br>    result = - 1<br>    for i in range ( n ) :<br>        for j in range ( n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                if arr [ j ] * arr [ k ] == arr [ i ] :<br>                    result = max ( result , arr [ i ] )<br>    return result<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubArraySumRepeated ( a , n , k ) :<br>    max_so_far = - 2147483648<br>    max_ending_here = 0<br>    for i in range ( n * k ) :<br>        max_ending_here = max_ending_here + a [ i % n ]<br>        if ( max_so_far < max_ending_here ) :<br>            max_so_far = max_ending_here<br>        if ( max_ending_here < 0 ) :<br>            max_ending_here = 0<br>    return max_so_far<br></td>
    <td>translated code: <br><br> def max_subarray_sum_repeated ( a , n , k ) :<br>    max_so_far = 0<br>    INT_MIN , max_ending_here = 0 , 0<br>    for i in range ( n * k ) :<br>        max_ending_here = max_ending_here + a [ i % n ]<br>        if max_so_far < max_ending_here :<br>            max_so_far = max_ending_here<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>    return max_so_far , max_ending_here<br></td>
  </tr><tr>
    <th>LEONARDO_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def leonardo ( n ) :<br>    dp = [ ] <br>    dp.append ( 1 ) <br>    dp.append ( 1 ) <br>    for i in range ( 2 , n + 1 ) :<br>        dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) <br>    return dp [ n ] <br></td>
    <td>translated code: <br><br> def leonardo ( n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    dp [ 0 ] = dp [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumOfSubstrings ( num ) :<br>    n = len ( num )<br>    sumofdigit = [ ]<br>    sumofdigit.append ( int ( num [ 0 ] ) )<br>    res = sumofdigit [ 0 ]<br>    for i in range ( 1 , n ) :<br>        numi = int ( num [ i ] )<br>        sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] )<br>        res += sumofdigit [ i ]<br>    return res<br></td>
    <td>translated code: <br><br> def sum_of_substrings ( num ) :<br>    n = len ( num )<br>    sumofdigit = [ ]<br>    sumofdigit.append ( num [ 0 ] - '0' )<br>    res = sumofdigit [ 0 ]<br>    for i in range ( 1 , n ) :<br>        numi = num [ i ] - '0'<br>        sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] )<br>        res += sumofdigit [ i ]<br>    return res<br></td>
  </tr><tr>
    <th>PRUFER_CODE_TREE_CREATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printTreeEdges ( prufer , m ) :<br>    vertices = m + 2<br>    vertex_set = [ 0 ] * vertices<br>    for i in range ( vertices - 2 ) :<br>        vertex_set [ prufer [ i ] - 1 ] += 1<br>    print ( "The edge set E(G) is :" )<br>    j = 0<br>    for i in range ( vertices - 2 ) :<br>        for j in range ( vertices ) :<br>            if ( vertex_set [ j ] == 0 ) :<br>                vertex_set [ j ] = - 1<br>                print ( "(" , ( j + 1 ) , ", " , prufer [ i ] , ") " , sep = "" , end = "" )<br>                vertex_set [ prufer [ i ] - 1 ] -= 1<br>                break<br>    j = 0<br>    for i in range ( vertices ) :<br>        if ( vertex_set [ i ] == 0 and j == 0 ) :<br>            print ( "(" , ( i + 1 ) , ", " , sep = "" , end = "" )<br>            j += 1<br>        elif ( vertex_set [ i ] == 0 and j == 1 ) :<br>            print ( ( i + 1 ) , ")" )<br></td>
    <td>translated code: <br><br> def print_tree_edges ( prufer , m ) :<br>    vertices = m + 2<br>    vertex_set = [ ]<br>    for i in range ( vertices ) :<br>        vertex_set.append ( 0 )<br>    for i in range ( vertices - 2 ) :<br>        vertex_set [ prufer [ i ] - 1 ] += 1<br>    print ( "\nThe edge set E(G) is :\n" )<br>    j = 0<br>    for i in range ( vertices - 2 ) :<br>        for j in range ( vertices ) :<br>            if vertex_set [ j ] == 0 :<br>                vertex_set [ j ] = - 1<br>                print ( "(%d, %d) " % ( j + 1 , prufer [ i ] ) )<br>                vertex_set [ prufer [ i ] - 1 ] -= 1<br>                break<br>    j = 0<br>    for i in range ( vertices ) :<br>        if vertex_set [ i ] == 0 and j == 0 :<br>            print ( "(%d, " % ( i + 1 ) )<br>            j += 1<br>        elif vertex_set [ i ] == 0 and j == 1 :<br>            print ( ( i + 1 ) + ")\n" )<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinimumAngle ( arr , n ) :<br>    l = 0<br>    _sum = 0<br>    ans = 360<br>    for i in range ( n ) :<br>        _sum += arr [ i ]<br>        while _sum >= 180 :<br>            ans = min ( ans , 2 * abs ( 180 - _sum ) )<br>            _sum -= arr [ l ]<br>            l += 1<br>        ans = min ( ans , 2 * abs ( 180 - _sum ) )<br>    return ans<br></td>
    <td>translated code: <br><br> def find_minimum_angle ( arr , n ) :<br>    l , sum , ans = 0 , 0 , 360<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>        while sum >= 180 :<br>            ans = min ( ans , 2 * abs ( 180 - sum ) )<br>            sum -= arr [ l ]<br>            l += 1<br>        ans = min ( ans , 2 * abs ( 180 - sum ) )<br>    return ans<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxAverage ( arr , n , k ) :<br>    if k > n :<br>        return - 1<br>    csum = [ 0 ] * n<br>    csum [ 0 ] = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        csum [ i ] = csum [ i - 1 ] + arr [ i ] <br>    max_sum = csum [ k - 1 ]<br>    max_end = k - 1<br>    for i in range ( k , n ) :<br>        curr_sum = csum [ i ] - csum [ i - k ]<br>        if curr_sum > max_sum :<br>            max_sum = curr_sum<br>            max_end = i<br>    return max_end - k + 1<br></td>
    <td>translated code: <br><br> def find_max_average ( arr , n , k ) :<br>    if k > n :<br>        return - 1<br>    csum = [ arr [ 0 ] ]<br>    for i in range ( 1 , n ) :<br>        csum [ i ] = csum [ i - 1 ] + arr [ i ]<br>    max_sum , max_end = csum [ k - 1 ] , k - 1<br>    for i in range ( k , n ) :<br>        curr_sum = csum [ i ] - csum [ i - k ]<br>        if curr_sum > max_sum :<br>            max_sum = curr_sum<br>            max_end = i<br>    return max_end - k + 1<br></td>
  </tr><tr>
    <th>SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findS ( s ) :<br>    _sum = 0<br>    n = 1<br>    while ( _sum < s ) :<br>        _sum += n * n<br>        n += 1<br>    n -= 1<br>    if _sum == s :<br>        return n<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_S ( s ) :<br>    sum = 0<br>    for n in range ( 1 , s ) :<br>        sum += n ** 2<br>        if sum == s :<br>            return n<br>    return - 1<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def areaOfInscribedCircle ( a ) :<br>    return ( PI / 4 ) * a * a<br></td>
    <td>translated code: <br><br> def area_of_inscribed_circle ( a ) :<br>    return ( PI / 4 ) * a ** 2<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countToMake0lternate ( s ) :<br>    result = 0<br>    for i in range ( len ( s ) - 1 ) :<br>        if ( s [ i ] == s [ i + 1 ] ) :<br>            result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def count_to_make_0lternate ( s ) :<br>    result = 0<br>    for i in ( len ( s ) - 1 ) :<br>        if s [ i ] == s [ i + 1 ] :<br>            result += 1<br>    return result<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMissing ( a , b , n , m ) :<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if ( a [ i ] == b [ j ] ) :<br>                break<br>        if ( j == m - 1 ) :<br>            print ( a [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def find_missing ( a , b , n , m ) :<br>    for i in range ( n ) :<br>        j = 0<br>        for j in range ( m ) :<br>            if a [ i ] == b [ j ] :<br>                break<br>            if j == m :<br>                print ( a [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rearrange ( arr , n ) :<br>    temp = n * [ None ]<br>    small , large = 0 , n - 1<br>    flag = True<br>    for i in range ( n ) :<br>        if flag is True :<br>            temp [ i ] = arr [ large ]<br>            large -= 1<br>        else :<br>            temp [ i ] = arr [ small ]<br>            small += 1<br>        flag = bool ( 1 - flag )<br>    for i in range ( n ) :<br>        arr [ i ] = temp [ i ]<br>    return arr<br></td>
    <td>translated code: <br><br> def rearrange ( arr , n ) :<br>    temp = [ ]<br>    small , large = 0 , n - 1<br>    flag = True<br>    for i in range ( n ) :<br>        if flag :<br>            temp.append ( arr [ large ] )<br>        else :<br>            temp.append ( arr [ small ] )<br>        flag = not flag<br>    arr = temp [ : ]<br>    return arr<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lbs ( arr ) :<br>    n = len ( arr )<br>    lis = [ 1 for i in range ( n + 1 ) ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( 0 , i ) :<br>            if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) :<br>                lis [ i ] = lis [ j ] + 1<br>    lds = [ 1 for i in range ( n + 1 ) ]<br>    for i in reversed ( range ( n - 1 ) ) :<br>        for j in reversed ( range ( i - 1 , n ) ) :<br>            if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) :<br>                lds [ i ] = lds [ j ] + 1<br>    maximum = lis [ 0 ] + lds [ 0 ] - 1<br>    for i in range ( 1 , n ) :<br>        maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum )<br>    return maximum<br></td>
    <td>translated code: <br><br> def lbs ( arr , n ) :<br>    i , j = 0 , 0<br>    lis = [ 1 ] * n<br>    for i in range ( n ) :<br>        lis [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :<br>                lis [ i ] = lis [ j ] + 1<br>    lds = [ 1 ] * n<br>    for i in range ( n ) :<br>        lds [ i ] = 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        for j in range ( n - 1 , - 1 , - 1 ) :<br>            if arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 :<br>                lds [ i ] = lds [ j ] + 1<br>    max = lis [ 0 ] + lds [ 0 ] - 1<br>    for i in range ( 1 , n ) :<br>        if lis [ i ] + lds [ i ] - 1 > max :<br>            max = lis [ i ] + lds [ i ] - 1<br>    return max<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( arr , n ) :<br>    result = 0 <br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            product = arr [ i ] * arr [ j ] <br>            for k in range ( 0 , n ) :<br>                if ( arr [ k ] == product ) :<br>                    result = result + 1 <br>                    break <br>    return result <br></td>
    <td>translated code: <br><br> def count_pairs ( arr , n ) :<br>    result = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            product = arr [ i ] * arr [ j ]<br>            for k in range ( n ) :<br>                if arr [ k ] == product :<br>                    result += 1<br>                    break<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def compute ( graph , N ) :<br>    count = 0<br>    for i in range ( 1 , N + 1 ) :<br>        if ( len ( graph [ i ] ) == 0 ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def compute ( graph , N ) :<br>    count = 0<br>    for i in range ( 1 , 7 ) :<br>        if graph [ i ] == 0 :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>HARDY_RAMANUJAN_THEOREM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def exactPrimeFactorCount ( n ) :<br>    count = 0<br>    if ( n % 2 == 0 ) :<br>        count = count + 1<br>        while ( n % 2 == 0 ) :<br>            n = int ( n / 2 )<br>    i = 3<br>    while ( i <= int ( math.sqrt ( n ) ) ) :<br>        if ( n % i == 0 ) :<br>            count = count + 1<br>            while ( n % i == 0 ) :<br>                n = int ( n / i )<br>        i = i + 2<br>    if ( n > 2 ) :<br>        count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def exact_prime_factor_count ( n ) :<br>    count = 0<br>    if n % 2 == 0 :<br>        count += 1<br>        while n % 2 == 0 :<br>            n = n // 2<br>    for i in range ( 3 , math.sqrt ( n ) , 2 ) :<br>        if n % i == 0 :<br>            count += 1<br>            while n % i == 0 :<br>                n = n // i<br>    if n > 2 :<br>        count += 1<br>    return count<br></td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def superSeq ( X , Y , m , n ) :<br>    dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ]<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            if ( not i ) : dp [ i ] [ j ] = j<br>            elif ( not j ) : dp [ i ] [ j ] = i<br>            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]<br>            else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] )<br>    return dp [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def superSeq ( X , Y , m , n ) :<br>    dp = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m +</td>
  </tr><tr>
    <th>POWER_SET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printPowerSet ( set , set_size ) :<br>    pow_set_size = ( int ) ( math.pow ( 2 , set_size ) ) <br>    counter = 0 <br>    j = 0 <br>    for counter in range ( 0 , pow_set_size ) :<br>        for j in range ( 0 , set_size ) :<br>            if ( ( counter & ( 1 << j ) ) > 0 ) :<br>                print ( set [ j ] , end = "" ) <br>        print ( "" ) <br></td>
    <td>translated code: <br><br> def print_power_set ( set , set_size ) :<br>    pow_set_size = int ( math.pow ( 2 , set_size ) )<br>    counter , j = 0 , 0<br>    for counter in range ( pow_set_size ) :<br>        for j in range ( set_size ) :<br>            if ( counter & ( 1 << j ) ) :<br>                print ( set [ j ] )<br>        print ( )<br></td>
  </tr><tr>
    <th>CHECK_ARRAY_MAJORITY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isMajority ( a ) :<br>    mp = { }<br>    for i in a :<br>        if i in mp : mp [ i ] += 1<br>        else : mp [ i ] = 1<br>    for x in mp :<br>        if mp [ x ] >= len ( a ) // 2 :<br>            return True<br>    return False<br></td>
    <td>translated code: <br><br> def isMajority ( a , n ) :<br>    mp = { }<br>    for i in range ( n ) :<br>        if mp.has_key ( a [ i ] ) :<br>            mp [ a [ i ] ] = mp [ a [ i ] ] + 1<br>        else :<br>            mp [ a [ i ] ] = 1<br>    for x , y in mp.items ( ) :<br>        if x >= n / 2 :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def counterClockspiralPrint ( m , n , arr ) :<br>    k = 0 ; l = 0<br>    cnt = 0<br>    total = m * n<br>    while ( k < m and l < n ) :<br>        if ( cnt == total ) :<br>            break<br>        for i in range ( k , m ) :<br>            print ( arr [ i ] [ l ] , end = " " )<br>            cnt += 1<br>        l += 1<br>        if ( cnt == total ) :<br>            break<br>        for i in range ( l , n ) :<br>            print ( arr [ m - 1 ] [ i ] , end = " " )<br>            cnt += 1<br>        m -= 1<br>        if ( cnt == total ) :<br>            break<br>        if ( k < m ) :<br>            for i in range ( m - 1 , k - 1 , - 1 ) :<br>                print ( arr [ i ] [ n - 1 ] , end = " " )<br>                cnt += 1<br>            n -= 1<br>        if ( cnt == total ) :<br>            break<br>        if ( l < n ) :<br>            for i in range ( n - 1 , l - 1 , - 1 ) :<br>                print ( arr [ k ] [ i ] , end = " " )<br>                cnt += 1<br>            k += 1<br></td>
    <td>translated code: <br><br> def counterClockspiralPrint ( m , n , arr ) :<br>    i , k , l = 0 , 0 , 0<br>    cnt = 0<br>    total = m * n<br>    while k < m and l < n :<br>        if cnt == total :<br>            break<br>        for i in range ( k , m ) :<br>            print ( arr [ i ] [ l ] , end = ' ' )<br>            cnt += 1<br>        l += 1<br>        if cnt == total :<br>            break<br>        for i in range ( l , n ) :<br>            print ( arr [ m - 1 ] [ i ] , end = ' ' )<br>            cnt += 1<br>        m -= 1<br>        if cnt == total :<br>            break<br>        if k < m :<br>            for i in range ( m - 1 , k - 1 ) :<br>                print ( arr [ i ] [ n - 1 ] , end = ' ' )<br>                cnt += 1<br>            n -= 1<br>        if cnt == total :<br>            break<br>        if l < n :<br>            for i in range ( n - 1 , l - 1 ) :<br>                print ( arr [ k ] [ i ] , end = ' ' )<br>                cnt += 1<br>            k += 1<br></td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPrime ( n ) :<br>    if n <= 1 :<br>        return False<br>    for i in range ( 2 , n ) :<br>        if n % i == 0 :<br>            return False <br>    return True<br></td>
    <td>translated code: <br><br> def isPrime ( n ) :<br>    if n <= 1 :<br>        return False<br>    for i in range ( 2 , n ) :<br>        if n % i == 0 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printMinIndexChar ( Str , patt ) :<br>    minIndex = 10 ** 9<br>    m = len ( Str )<br>    n = len ( patt )<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if ( patt [ i ] == Str [ j ] and j < minIndex ) :<br>                minIndex = j<br>                break<br>    if ( minIndex != 10 ** 9 ) :<br>        print ( "Minimum Index Character = " , Str [ minIndex ] )<br>    else :<br>        print ( "No character present" )<br></td>
    <td>translated code: <br><br> def printMinIndexChar ( str , patt ) :<br>    minIndex = sys.maxint<br>    m = len ( str )<br>    n = len ( patt )<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if patt [ i ] == str [ j ] and j < minIndex :<br>                minIndex = j<br>                break<br>    if minIndex != sys.maxint :<br>        print ( "Minimum Index Character = " + str [ minIndex ] )<br>    else :<br>        print ( "No character present" )<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def transpose ( A , B ) :<br>    for i in range ( N ) :<br>        for j in range ( M ) :<br>            B [ i ] [ j ] = A [ j ] [ i ]<br></td>
    <td>translated code: <br><br> def transpose ( A , B ) :<br>    i , j = 0 , 0<br>    for i in range ( N ) :<br>        for j in range ( M ) :<br>            B [ i , j ] = A [ j , i ]<br></td>
  </tr><tr>
    <th>COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNumber ( n ) :<br>    result = 0<br>    for i in range ( 1 , 10 ) :<br>        s = [ ]<br>        if ( i <= n ) :<br>            s.append ( i )<br>            result += 1<br>        while len ( s ) != 0 :<br>            tp = s [ - 1 ]<br>            s.pop ( )<br>            for j in range ( tp % 10 , 10 ) :<br>                x = tp * 10 + j<br>                if ( x <= n ) :<br>                    s.append ( x )<br>                    result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def count_number ( n ) :<br>    result = 0<br>    for i in range ( 1 , 9 ) :<br>        s = Stack ( )<br>        if i <= n :<br>            s.push ( i )<br>            result += 1<br>        while not s.empty ( ) :<br>            tp = s.top ( )<br>            s.pop ( )<br>            for j in range ( tp % 10 , 9 ) :<br>                x = tp * 10 + j<br>                if x <= n :<br>                    s.push ( x )<br>                    result += 1<br>    return result<br></td>
  </tr><tr>
    <th>FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def firstFactorialDivisibleNumber ( x ) :<br>    i = 1 <br>    fact = 1 <br>    for i in range ( 1 , x ) :<br>        fact = fact * i<br>        if ( fact % x == 0 ) :<br>            break<br>    return i<br></td>
    <td>translated code: <br><br> def first_factorial_divisible_number ( x ) :<br>    i = 1<br>    fact = 1<br>    for i in range ( 1 , x ) :<br>        fact = fact * i<br>        if fact % x == 0 :<br>            break<br>    return i<br></td>
  </tr><tr>
    <th>PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printEqualSumSets ( arr , n ) :<br>    sum_array = sum ( arr )<br>    if ( sum_array & 1 ) :<br>        print ( "-1" )<br>        return<br>    k = sum_array >> 1<br>    dp = np.zeros ( ( n + 1 , k + 1 ) )<br>    for i in range ( 1 , k + 1 ) :<br>        dp [ 0 ] [ i ] = False<br>    for i in range ( n + 1 ) :<br>        dp [ i ] [ 0 ] = True<br>    for i in range ( 1 , n + 1 ) :<br>        for currSum in range ( 1 , k + 1 ) :<br>            dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ]<br>            if ( arr [ i - 1 ] <= currSum ) :<br>                dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] )<br>    set1 , set2 = [ ] , [ ]<br>    if ( not dp [ n ] [ k ] ) :<br>        print ( "-1" )<br>        return<br>    i = n<br>    currSum = k<br>    while ( i > 0 and currSum >= 0 ) :<br>        if ( dp [ i - 1 ] [ currSum ] ) :<br>            i -= 1<br>            set2.append ( arr [ i ] )<br>        elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) :<br>            i -= 1<br>            currSum -= arr [ i ]<br>            set1.append ( arr [ i ] )<br>    print ( "Set 1 elements:" , end = " " )<br>    for i in range ( len ( set1 ) ) :<br>        print ( set1 [ i ] , end = " " )<br>    print ( "\nSet 2 elements:" , end = " " )<br>    for i in range ( len ( set2 ) ) :<br>        print ( set2 [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def printEqualSumSets ( arr , n ) :<br>    i , currSum , sum = 0 , 0 , 0<br>    for i in range ( len ( arr ) ) :<br>        sum += arr [ i ]<br>    if ( sum & 1 ) == 1 :<br>        print ( "-1" )<br>        return<br>    k = sum >> 1<br>    dp = [ False for i in range ( n + 1 , k + 1 ) ]<br>    for i in range ( 1 , k + 1 ) :<br>        dp [ 0 ] [ i ] = False<br>    for i in range ( 0 , n + 1 ) :<br>        dp [ i ] [ 0 ] = True<br>    for i in range ( 1 , n + 1 ) :<br>        for currSum in range ( 1 , k + 1 ) :<br>            dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ]<br>            if arr [ i - 1 ] <= currSum :<br>                dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ]<br>    set1 = [ ]<br>    set2 = [ ]<br>    if not dp [ n ] [ k ] :<br>        print ( "-1\n" )<br>        return<br>    i = n<br>    currSum = k<br>    while i > 0 and currSum >= 0 :<br>        if dp [ i - 1 ] [ currSum ] :<br>            i -= 1<br>            set2.append ( arr [ i ] )<br>        elif dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] :<br>            i -= 1<br>            currSum -= arr [ i ]<br>            set1.append ( arr [ i ] )<br>    print ( "Set 1 elements: " )<br>    for i in range ( len ( set1 ) ) :<br>        print ( set1 [ i ] , end = ' ' )<br>    print ( "\nSet 2 elements: " )<br>    for i in range ( len ( set2 ) ) :<br>        print ( set2 [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfWays ( x ) :<br>    if x == 0 or x == 1 :<br>        return 1<br>    else :<br>        return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) )<br></td>
    <td>translated code: <br><br> def number_of_ways ( x ) :<br>    dp = [ 0 ] * ( x + 1 )<br>    dp [ 0 ] = dp [ 1 ] = 1<br>    for i in range ( 2 , x + 1 ) :<br>        dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]<br>    return dp [ x ]<br></td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNegative ( M , n , m ) :<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if M [ i ] [ j ] < 0 :<br>                count += 1<br>            else :<br>                break<br>    return count<br></td>
    <td>translated code: <br><br> def count_negative ( M , n , m ) :<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if M [ i ] [ j ] < 0 :<br>                count += 1<br>            else :<br>                break<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSetBits ( n ) :<br>    count = 0<br>    while ( n ) :<br>        count += n & 1<br>        n >>= 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_set_bits ( n ) :<br>    count = 0<br>    while n :<br>        count += n & 1<br>        n >>= 1<br>    return count<br></td>
  </tr><tr>
    <th>MODULUS_TWO_FLOAT_DOUBLE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMod ( a , b ) :<br>    if ( a < 0 ) :<br>        a = - a<br>    if ( b < 0 ) :<br>        b = - b<br>    mod = a<br>    while ( mod >= b ) :<br>        mod = mod - b<br>    if ( a < 0 ) :<br>        return - mod<br>    return mod<br></td>
    <td>translated code: <br><br> def findMod ( a , b ) :<br>    if a < 0 :<br>        a = - a<br>    if b < 0 :<br>        b = - b<br>    mod = a<br>    while mod >= b :<br>        mod = mod - b<br>    if a < 0 :<br>        return - mod<br>    return mod<br></td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxValue ( mat ) :<br>    maxValue = - sys.maxsize - 1<br>    maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ]<br>    maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]<br>    maxv = mat [ N - 1 ] [ N - 1 ] <br>    for j in range ( N - 2 , - 1 , - 1 ) :<br>        if ( mat [ N - 1 ] [ j ] > maxv ) :<br>            maxv = mat [ N - 1 ] [ j ]<br>        maxArr [ N - 1 ] [ j ] = maxv<br>    maxv = mat [ N - 1 ] [ N - 1 ]<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        if ( mat [ i ] [ N - 1 ] > maxv ) :<br>            maxv = mat [ i ] [ N - 1 ]<br>        maxArr [ i ] [ N - 1 ] = maxv<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        for j in range ( N - 2 , - 1 , - 1 ) :<br>            if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) :<br>                maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] )<br>            maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) )<br>    return maxValue<br></td>
    <td>translated code: <br><br> def findMaxValue ( N , mat ) :<br>    maxValue = int ( "-1" )<br>    maxArr = [ [ ] for i in range ( N ) ]<br>    maxv = mat [ N - 1 ] [ N - 1 ]<br>    for j in range ( N - 2 , - 1 , - 1 ) :<br>        if mat [ N - 1 ] [ j ] > maxv :<br>            maxv = mat [ N - 1 ] [ j ]<br>        maxArr [ N - 1 ] [ j ] = maxv<br>    maxv = mat [ N - 1 ] [ N - 1 ]<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        if mat [ i ] [ N - 1 ] > maxv :<br>            maxv = mat [ i ] [ N - 1 ]<br>        maxArr [ i ] [ N - 1 ] = maxv<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        for j in range ( N - 2 , - 1 , - 1 ) :<br>            if maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue :<br>                maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ]<br>            maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) )<br>    return maxValue<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solve ( arr , n ) :<br>    arr.sort ( )<br>    a = 0 ; b = 0<br>    for i in range ( n ) :<br>        if ( i % 2 != 0 ) :<br>            a = a * 10 + arr [ i ]<br>        else :<br>            b = b * 10 + arr [ i ]<br>    return a + b<br></td>
    <td>translated code: <br><br> def solve ( arr , n ) :<br>    arr.sort ( )<br>    a , b = 0 , 0<br>    for i in range ( n ) :<br>        if i % 2 != 0 :<br>            a = a * 10 + arr [ i ]<br>        else :<br>            b = b * 10 + arr [ i ]<br>    return a + b<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSolutions ( n ) :<br>    x = 0<br>    res = 0<br>    yCount = 0<br>    while ( yCount * yCount < n ) :<br>        yCount = yCount + 1<br>    while ( yCount != 0 ) :<br>        res = res + yCount<br>        x = x + 1<br>        while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) :<br>            yCount = yCount - 1<br>    return res<br></td>
    <td>translated code: <br><br> def count_solutions ( n ) :<br>    x , y_count , res = 0 , 0 , 0<br>    for y_count in range ( 0 , y_count * y_count , n ) :<br>        pass<br>    while y_count != 0 :<br>        res += y_count<br>        x += 1<br>        while y_count != 0 and ( x * x + ( y_count - 1 ) * ( y_count - 1 ) >= n ) :<br>            y_count -= 1<br>    return res<br></td>
  </tr><tr>
    <th>FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findIndex ( n ) :<br>    if ( n <= 1 ) :<br>        return n<br>    a = 0<br>    b = 1<br>    c = 1<br>    res = 1<br>    while ( c < n ) :<br>        c = a + b<br>        res = res + 1<br>        a = b<br>        b = c<br>    return res<br></td>
    <td>translated code: <br><br> def find_index ( n ) :<br>    if n <= 1 :<br>        return n<br>    a , b , c = 0 , 1 , 1<br>    res = 1<br>    while c < n :<br>        c , a , b , c = a + b , a , b<br>        res += 1<br>        a , b , c = b , c , a , b<br>    return res<br></td>
  </tr><tr>
    <th>PROGRAM_OCTAL_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def octalToDecimal ( n ) :<br>    num = n <br>    dec_value = 0 <br>    base = 1 <br>    temp = num <br>    while ( temp ) :<br>        last_digit = temp % 10 <br>        temp = int ( temp / 10 ) <br>        dec_value += last_digit * base <br>        base = base * 8 <br>    return dec_value <br></td>
    <td>translated code: <br><br> def octal_to_decimal ( n ) :<br>    num = n<br>    dec_value = 0<br>    base = 1<br>    temp = num<br>    while temp > 0 :<br>        last_digit = temp % 10<br>        temp = temp / 10<br>        dec_value += last_digit * base<br>        base = base * 8<br>    return dec_value<br></td>
  </tr><tr>
    <th>FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def permutatedRows ( mat , m , n , r ) :<br>    s = set ( )<br>    for j in range ( n ) :<br>        s.add ( mat [ r ] [ j ] )<br>    for i in range ( m ) :<br>        if i == r :<br>            continue<br>        for j in range ( n ) :<br>            if mat [ i ] [ j ] not in s :<br>                j = j - 2<br>                break <br>        if j + 1 != n :<br>            continue<br>        print ( i )<br></td>
    <td>translated code: <br><br> def permutated_rows ( mat , m , n , r ) :<br>    s = set ( )<br>    for j in range ( n ) :<br>        s.add ( mat [ r ] [ j ] )<br>    for i in range ( m ) :<br>        if i == r :<br>            continue<br>        j = None<br>        for j in range ( n ) :<br>            if not s.intersection ( mat [ i ] [ j ] ) :<br>                break<br>        if j != n :<br>            continue<br>        print ( i , end = ' ' )<br></td>
  </tr><tr>
    <th>PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def noAdjacentDup ( s ) :<br>    n = len ( s )<br>    for i in range ( 1 , n ) :<br>        if ( s [ i ] == s [ i - 1 ] ) :<br>            s [ i ] = "a"<br>            while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) :<br>                s [ i ] += 1<br>            i += 1<br>    return s<br></td>
    <td>translated code: <br><br> def no_adjacent_dup ( s1 ) :<br>    n = len ( s1 )<br>    s = s1 [ : ]<br>    for i in range ( 1 , n ) :<br>        if s [ i ] == s [ i - 1 ] :<br>            s [ i ] = 'a'<br>            while s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) :<br>                s [ i ] += 1<br>            i += 1<br>    return ( [ s [ i ] for i in range ( 1 , n ) ] )<br></td>
  </tr><tr>
    <th>SUM_MANHATTAN_DISTANCES_PAIRS_POINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def distancesum ( x , y , n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) )<br>    return sum<br></td>
    <td>translated code: <br><br> def distancesum ( x , y , n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) )<br>    return sum<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_STRING_START_END_GEEKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isCornerPresent ( str , corner ) :<br>    n = len ( str )<br>    cl = len ( corner )<br>    if ( n < cl ) :<br>        return False<br>    return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) )<br></td>
    <td>translated code: <br><br> def isCornerPresent ( str , corner ) :<br>    n = len ( str )<br>    cl = len ( corner )<br>    if n < cl :<br>        return False<br>    return ( str [ : cl ] == corner and str [ n - cl : ] == corner )<br></td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lenOfLongSubarr ( arr , n ) :<br>    um = { i : 0 for i in range ( 10 ) }<br>    sum = 0<br>    maxLen = 0<br>    for i in range ( n ) :<br>        if arr [ i ] == 0 :<br>            sum += - 1<br>        else :<br>            sum += 1<br>        if ( sum == 1 ) :<br>            maxLen = i + 1<br>        elif ( sum not in um ) :<br>            um [ sum ] = i<br>        if ( ( sum - 1 ) in um ) :<br>            if ( maxLen < ( i - um [ sum - 1 ] ) ) :<br>                maxLen = i - um [ sum - 1 ]<br>    return maxLen<br></td>
    <td>translated code: <br><br> def lenOfLongSubarr ( arr , n ) :<br>    um = { }<br>    sum , maxLen = 0 , 0<br>    for i in range ( n ) :<br>        sum += arr [ i ] if i > 0 else - 1<br>        if sum == 1 :<br>            maxLen = i + 1<br>        elif not um.has_key ( sum ) :<br>            um [ sum ] = i<br>        if um.has_key ( sum - 1 ) :<br>            if maxLen < ( i - um [ sum - 1 ] ) :<br>                maxLen = i - um [ sum - 1 ]<br>    return maxLen<br></td>
  </tr><tr>
    <th>DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( mat , fromRow , toRow , fromCol , toCol , key ) :<br>    i = fromRow + ( toRow - fromRow ) // 2 <br>    j = fromCol + ( toCol - fromCol ) // 2 <br>    if ( mat [ i ] [ j ] == key ) :<br>        print ( "Found " , key , " at " , i , " " , j ) <br>    else :<br>        if ( i != toRow or j != fromCol ) :<br>            search ( mat , fromRow , i , j , toCol , key ) <br>        if ( fromRow == toRow and fromCol + 1 == toCol ) :<br>            if ( mat [ fromRow ] [ toCol ] == key ) :<br>                print ( "Found " , key , " at " , fromRow , " " , toCol ) <br>        if ( mat [ i ] [ j ] < key ) :<br>            if ( i + 1 <= toRow ) :<br>                search ( mat , i + 1 , toRow , fromCol , toCol , key ) <br>        else :<br>            if ( j - 1 >= fromCol ) :<br>                search ( mat , fromRow , toRow , fromCol , j - 1 , key ) <br></td>
    <td>translated code: <br><br> def search ( mat , from_row , to_row , from_col , to_col , key ) :<br>    i = from_row + ( to_row - from_row ) / 2<br>    j = from_col + ( to_col - from_col ) / 2<br>    if mat [ i ] [ j ] == key :<br>        print ( "Found %d at %d %d" % ( key , i , j ) )<br>    else :<br>        if i != to_row or j != from_col :<br>            search ( mat , from_row , i , j , to_col , key )<br>        if from_row == to_row and from_col + 1 == to_col :<br>            if mat [ from_row ] [ to_col ] == key :<br>                print ( "Found %d at %d %d" % ( key , from_row , to_col ) )<br>            if mat [ i ] [ j ] < key :<br>                if i + 1 <= to_row :<br>                    search ( mat , i + 1 , to_row , from_col , to_col , key )<br>            else :<br>                if j - 1 >= from_col :<br>                    search ( mat , from_row , to_row , from_col , j - 1 , key )<br></td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def superSeq ( X , Y , m , n ) :<br>    if ( not m ) : return n<br>    if ( not n ) : return m<br>    if ( X [ m - 1 ] == Y [ n - 1 ] ) :<br>        return 1 + superSeq ( X , Y , m - 1 , n - 1 )<br>    return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )<br></td>
    <td>translated code: <br><br> def superSeq ( X , Y , m , n ) :<br>    if m == 0 :<br>        return n<br>    if n == 0 :<br>        return m<br>    if X [ m - 1 ] == Y [ n - 1 ] :<br>        return 1 + superSeq ( X , Y , m - 1 , n - 1 )<br>    return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) )<br></td>
  </tr><tr>
    <th>URLIFY_GIVEN_STRING_REPLACE_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def replaceSpaces ( string ) :<br>    string = string.strip ( )<br>    i = len ( string )<br>    space_count = string.count ( '' )<br>    new_length = i + space_count * 2<br>    if new_length > MAX :<br>        return - 1<br>    index = new_length - 1<br>    string = list ( string )<br>    for f in range ( i - 2 , new_length - 2 ) :<br>        string.append ( '0' )<br>    for j in range ( i - 1 , 0 , - 1 ) :<br>        if string [ j ] == '' :<br>            string [ index ] = '0'<br>            string [ index - 1 ] = '2'<br>            string [ index - 2 ] = '%'<br>            index = index - 3<br>        else :<br>            string [ index ] = string [ j ]<br>            index -= 1<br>    return ''.join ( string )<br></td>
    <td>translated code: <br><br> def replace_spaces ( str ) :<br>    space_count , i = 0 , 0<br>    for i in range ( len ( str ) ) :<br>        if str [ i ] == ' ' :<br>            space_count += 1<br>    while str [ i - 1 ] == ' ' :<br>        space_count -= 1<br>        i -= 1<br>    new_length = i + space_count * 2<br>    if new_length > MAX :<br>        return str<br>    index = new_length - 1<br>    new_str = str [ : index ]<br>    str = str [ index : ]<br>    for j in range ( i - 1 , - 1 , - 1 ) :<br>        if new_str [ j ] == ' ' :<br>            str [ index ] = '0'<br>            str [ index - 1 ] = '2'<br>            str [ index - 2 ] = '%'<br>            index = index - 3<br>        else :<br>            str [ index ] = new_str [ j ]<br>            index -= 1<br>    return str<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MaximumPath ( Mat ) :<br>    result = 0<br>    dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ]<br>    for i in range ( N ) :<br>        for j in range ( 1 , N + 1 ) :<br>            dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \<br>                Mat [ i ] [ j - 1 ]<br>    for i in range ( N + 1 ) :<br>        result = max ( result , dp [ N - 1 ] [ i ] )<br>    return result<br></td>
    <td>translated code: <br><br> def MaximumPath ( Mat ) :<br>    result = 0<br>    dp = [ [ 0 ] * N for N in range ( N + 2 ) ]<br>    for rows in dp :<br>        np.random.shuffle ( rows )<br>    for i in range ( N ) :<br>        dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ]<br>    for i in range ( 1 , N ) :<br>        for j in range ( 1 , N + 1 ) :<br>            dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ]<br>    for i in range ( 0 , N + 1 ) :<br>        result = max ( result , dp [ N - 1 ] [ i ] )<br>    return result<br></td>
  </tr><tr>
    <th>COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getAbs ( n ) :<br>    mask = n >> ( SIZE_INT * CHARBIT - 1 ) <br>    return ( ( n + mask ) ^ mask ) <br></td>
    <td>translated code: <br><br> def get_abs ( n ) :<br>    mask = n >> ( SIZE_INT * CHAR_BIT - 1 )<br>    return ( ( n + mask ) ^ mask )<br></td>
  </tr><tr>
    <th>COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPS ( i , j ) :<br>    if ( i >= n or j < 0 ) :<br>        return 0<br>    if ( dp [ i ] [ j ] != - 1 ) :<br>        return dp [ i ] [ j ]<br>    if ( abs ( i - j ) == 1 ) :<br>        if ( str [ i ] == str [ j ] ) :<br>            dp [ i ] [ j ] = 3<br>            return dp [ i ] [ j ]<br>        else :<br>            dp [ i ] [ j ] = 2<br>            return dp [ i ] [ j ]<br>    if ( i == j ) :<br>        dp [ 1 ] [ j ] = 1<br>        return dp [ 1 ] [ j ]<br>    elif ( str [ i ] == str [ j ] ) :<br>        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 )<br>        return dp [ i ] [ j ]<br>    else :<br>        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) )<br>        return dp [ i ] [ j ]<br></td>
    <td>translated code: <br><br> def countPS ( i , j ) :<br>    if i >= n or j < 0 :<br>        return 0<br>    if dp [ i ] [ j ] != - 1 :<br>        return dp [ i ] [ j ]<br>    if ( i - j == 1 ) :<br>        if str ( i ) == str ( j ) :<br>            return dp [ i ] [ j ] = 3<br>        else :<br>            return dp [ i ] [ j ] = 2<br>    if i == j :<br>        return dp [ 1 ] [ j ] = 1<br>    elif str ( i ) == str ( j ) :<br>        return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1<br>    else :<br>        return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 )<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubArraySum ( a , size ) :<br>    max_so_far = a [ 0 ]<br>    curr_max = a [ 0 ]<br>    for i in range ( 1 , size ) :<br>        curr_max = max ( a [ i ] , curr_max + a [ i ] )<br>        max_so_far = max ( max_so_far , curr_max )<br>    return max_so_far<br></td>
    <td>translated code: <br><br> def max_subarray_sum ( a , size ) :<br>    max_so_far = a [ 0 ]<br>    curr_max = a [ 0 ]<br>    for i in range ( 1 , size ) :<br>        curr_max = max ( a [ i ] , curr_max + a [ i ] )<br>        max_so_far = max ( max_so_far , curr_max )<br>    return max_so_far<br></td>
  </tr><tr>
    <th>COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countMinOperations ( target , n ) :<br>    result = 0 <br>    while ( True ) :<br>        zero_count = 0 <br>        i = 0 <br>        while ( i < n ) :<br>            if ( ( target [ i ] & 1 ) > 0 ) :<br>                break <br>            elif ( target [ i ] == 0 ) :<br>                zero_count += 1 <br>            i += 1 <br>        if ( zero_count == n ) :<br>            return result <br>        if ( i == n ) :<br>            for j in range ( n ) :<br>                target [ j ] = target [ j ] // 2 <br>            result += 1 <br>        for j in range ( i , n ) :<br>            if ( target [ j ] & 1 ) :<br>                target [ j ] -= 1 <br>                result += 1 <br></td>
    <td>translated code: <br><br> def count_min_operations ( n ) :<br>    result = 0<br>    while True :<br>        zero_count = 0<br>        i = 0<br>        for i in range ( n ) :<br>            if arr [ i ] % 2 == 1 :<br>                break<br>            elif arr [ i ] == 0 :<br>                zero_count += 1<br>        if zero_count == n :<br>            return result<br>        if i == n :<br>            for j in range ( n ) :<br>                arr [ j ] = arr [ j ] / 2<br>            result += 1<br>        for j in range ( i , n ) :<br>            if arr [ j ] % 2 == 1 :<br>                arr [ j ] -= 1<br>                result += 1<br></td>
  </tr><tr>
    <th>PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def fib ( n ) :<br>    a = 0<br>    b = 1<br>    if ( n >= 0 ) :<br>        print ( a , end = ' ' )<br>    if ( n >= 1 ) :<br>        print ( b , end = ' ' )<br>    for i in range ( 2 , n + 1 ) :<br>        print ( a + b , end = ' ' )<br>        b = a + b<br>        a = b - a<br></td>
    <td>translated code: <br><br> def fib ( n ) :<br>    a , b = 0 , 1<br>    if n >= 0 :<br>        print ( a , end = ' ' )<br>    if n >= 1 :<br>        print ( b , end = ' ' )<br>    for i in range ( 2 , n + 1 ) :<br>        print ( a + b , end = ' ' )<br>        b , a = a + b , b - a<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_INPUT_INTEGER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isNumber ( s ) :<br>    for i in range ( len ( s ) ) :<br>        if s [ i ].isdigit ( ) != True :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isNumber ( s ) :<br>    for c in s :<br>        if ord ( c ) == 0 : return False<br>    return True<br></td>
  </tr><tr>
    <th>MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minHeight ( area , base ) :<br>    return math.ceil ( ( 2 * area ) / base )<br></td>
    <td>translated code: <br><br> def minHeight ( base , area ) :<br>    d = ( 2 * area ) / base<br>    return math.ceil ( d )<br></td>
  </tr><tr>
    <th>FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findpos ( n ) :<br>    i = 0<br>    j = len ( n )<br>    pos = 0<br>    while ( i < j ) :<br>        if ( n [ i ] == '4' ) :<br>            pos = pos * 2 + 1<br>        if ( n [ i ] == '7' ) :<br>            pos = pos * 2 + 2<br>        i = i + 1<br>    return pos<br></td>
    <td>translated code: <br><br> def findpos ( n ) :<br>    k , pos , i = 0 , 0 , 0<br>    while k != len ( n ) :<br>        try :<br>            pos = pos * 2 + 1<br>        except TypeError :<br>            pass<br>        try :<br>            pos = pos * 2 + 2<br>        except TypeError :<br>            pass<br>        i += 1<br>        k += 1<br>    return pos<br></td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minOperation ( arr ) :<br>    ans = 0<br>    for i in range ( N - 1 , - 1 , - 1 ) :<br>        for j in range ( M - 1 , - 1 , - 1 ) :<br>            if ( arr [ i ] [ j ] == 0 ) :<br>                ans += 1<br>                for k in range ( i + 1 ) :<br>                    for h in range ( j + 1 ) :<br>                        if ( arr [ k ] [ h ] == 1 ) :<br>                            arr [ k ] [ h ] = 0<br>                        else :<br>                            arr [ k ] [ h ] = 1<br>    return ans<br></td>
    <td>translated code: <br><br> def minOperation ( arr ) :<br>    ans = 0<br>    for i in range ( N - 1 , - 1 , - 1 ) :<br>        for j in range ( M - 1 , - 1 , - 1 ) :<br>            if arr [ i ] [ j ] == False :<br>                ans += 1<br>                for k in range ( 0 , i + 1 ) :<br>                    for h in range ( 0 , j + 1 ) :<br>                        if arr [ k ] [ h ] == True :<br>                            arr [ k ] [ h ] = False<br>                        else :<br>                            arr [ k ] [ h ] = True<br>    return ans<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLength ( string , n ) :<br>    Sum = [ 0 ] * ( n + 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) )<br>    ans = 0<br>    for length in range ( 2 , n + 1 , 2 ) :<br>        for i in range ( 0 , n - length + 1 ) :<br>            j = i + length - 1<br>            if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) :<br>                ans = max ( ans , length )<br>    return ans<br></td>
    <td>translated code: <br><br> def find_length ( str , n ) :<br>    sum = [ 0 ] * ( n + 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' )<br>    ans = 0<br>    for len in range ( 2 , n + 1 , 2 ) :<br>        for i in range ( 0 , n - len ) :<br>            j = i + len - 1<br>            if sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] :<br>                ans = max ( ans , len )<br>    return ans<br></td>
  </tr><tr>
    <th>MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def multiply ( num1 , num2 ) :<br>    len1 = len ( num1 )<br>    len2 = len ( num2 )<br>    if len1 == 0 or len2 == 0 :<br>        return "0"<br>    result = [ 0 ] * ( len1 + len2 )<br>    i_n1 = 0<br>    i_n2 = 0<br>    for i in range ( len1 - 1 , - 1 , - 1 ) :<br>        carry = 0<br>        n1 = ord ( num1 [ i ] ) - 48<br>        i_n2 = 0<br>        for j in range ( len2 - 1 , - 1 , - 1 ) :<br>            n2 = ord ( num2 [ j ] ) - 48<br>            summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry<br>            carry = summ // 10<br>            result [ i_n1 + i_n2 ] = summ % 10<br>            i_n2 += 1<br>        if ( carry > 0 ) :<br>            result [ i_n1 + i_n2 ] += carry<br>        i_n1 += 1<br>    i = len ( result ) - 1<br>    while ( i >= 0 and result [ i ] == 0 ) :<br>        i -= 1<br>    if ( i == - 1 ) :<br>        return "0"<br>    s = ""<br>    while ( i >= 0 ) :<br>        s += chr ( result [ i ] + 48 )<br>        i -= 1<br>    return s<br></td>
    <td>translated code: <br><br> def multiply ( num1 , num2 ) :<br>    len1 = len ( num1 )<br>    len2 = len ( num2 )<br>    if len1 == 0 or len2 == 0 :<br>        return '0'<br>    result = [ 0 ] * ( len1 + len2 )<br>    i_n1 = 0<br>    i_n2 = 0<br>    for i in range ( len1 - 1 , - 1 , - 1 ) :<br>        carry = 0<br>        n1 = num1 [ i ] - '0'<br>        i_n2 = 0<br>        for j in range ( len2 - 1 , - 1 , - 1 ) :<br>            n2 = num2 [ j ] - '0'<br>            sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry<br>            carry = sum / 10<br>            result [ i_n1 + i_n2 ] = sum % 10<br>            i_n2 += 1<br>        if carry > 0 :<br>            result [ i_n1 + i_n2 ] += carry<br>        i_n1 += 1<br>    i = len ( result ) - 1<br>    while i >= 0 and result [ i ] == 0 :<br>        i -= 1<br>    if i == - 1 :<br>        return '0'<br>    s = ''<br>    while i >= 0 :<br>        s += ( result [ i ] )<br>    return s<br></td>
  </tr><tr>
    <th>PARTITION_NUMBER_TWO_DIVISBLE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findDivision ( str , a , b ) :<br>    lenn = len ( str )<br>    lr = [ 0 ] * ( lenn + 1 )<br>    lr [ 0 ] = ( int ( str [ 0 ] ) ) % a<br>    for i in range ( 1 , lenn ) :<br>        lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a<br>    rl = [ 0 ] * ( lenn + 1 )<br>    rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b<br>    power10 = 10<br>    for i in range ( lenn - 2 , - 1 , - 1 ) :<br>        rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b<br>        power10 = ( power10 * 10 ) % b<br>    for i in range ( 0 , lenn - 1 ) :<br>        if ( lr [ i ] != 0 ) :<br>            continue<br>        if ( rl [ i + 1 ] == 0 ) :<br>            print ( "YES" )<br>            for k in range ( 0 , i + 1 ) :<br>                print ( str [ k ] , end = "" )<br>            print ( "," , end = "" )<br>            for i in range ( i + 1 , lenn ) :<br>                print ( str [ k ] , end = "" )<br>                return<br>    print ( "NO" )<br></td>
    <td>translated code: <br><br> def find_division ( str , a , b ) :<br>    len = len ( str )<br>    lr = [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % a for i in range ( 1 , len ) ]<br>    for i in range ( 1 , len ) :<br>        lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % a<br>    rl = [ ( ord ( str [ len - 1 ] ) - ord ( '0' ) ) % b ) % b for i in range ( len + 1 , len ) ]<br>    power10 = 10<br>    for i in range ( len - 2 , - 1 , - 1 ) :<br>        rl [ i ] = ( rl [ i + 1 ] + ( ord ( str [ i ] ) - ord ( '0' ) ) * power10 ) % b<br>        power10 = ( power10 * 10 ) % b<br>    for i in range ( len - 1 ) :<br>        if lr [ i ] != 0 :<br>            continue<br>        if rl [ i + 1 ] == 0 :<br>            print ( "YES" )<br>            for k in range ( 0 , i + 1 ) :<br>                print ( str [ k ] )<br>            print ( ", " )<br>            for k in range ( i + 1 , len ) :<br>                print ( str [ k ] )<br>            return<br>    print ( "NO" )<br></td>
  </tr><tr>
    <th>PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bestFit ( blockSize , m , processSize , n ) :<br>    allocation = [ - 1 ] * n<br>    for i in range ( n ) :<br>        bestIdx = - 1<br>        for j in range ( m ) :<br>            if blockSize [ j ] >= processSize [ i ] :<br>                if bestIdx == - 1 :<br>                    bestIdx = j<br>                elif blockSize [ bestIdx ] > blockSize [ j ] :<br>                    bestIdx = j<br>        if bestIdx != - 1 :<br>            allocation [ i ] = bestIdx<br>            blockSize [ bestIdx ] -= processSize [ i ]<br>    print ( "Process No.Process Size     Block no." )<br>    for i in range ( n ) :<br>        print ( i + 1 , "         " , processSize [ i ] , end = "         " )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br></td>
    <td>translated code: <br><br> def bestFit ( blockSize , m , processSize , n ) :<br>    allocation = [ ]<br>    for i in range ( n ) :<br>        allocation.append ( - 1 )<br>    for i in range ( n ) :<br>        bestIdx = - 1<br>        for j in range ( m ) :<br>            if blockSize [ j ] >= processSize [ i ] :<br>                if bestIdx == - 1 :<br>                    bestIdx = j<br>                elif blockSize [ bestIdx ] > blockSize [ j ] :<br>                    bestIdx = j<br>        if bestIdx != - 1 :<br>            allocation.append ( bestIdx )<br>            blockSize [ bestIdx ] -= processSize [ i ]<br>    print ( "\nProcess No.\tProcess Size\tBlock no." )<br>    for i in range ( n ) :<br>        print ( "   " + str ( i + 1 ) + "\t\t" + str ( processSize [ i ] ) + "\t\t" )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br>        print ( )<br></td>
  </tr><tr>
    <th>FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def largestKSubmatrix ( a ) :<br>    dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ]<br>    result = 0<br>    for i in range ( Row ) :<br>        for j in range ( Col ) :<br>            if ( i == 0 or j == 0 ) :<br>                dp [ i ] [ j ] = 1<br>            else :<br>                if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) :<br>                    dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1<br>                else :<br>                    dp [ i ] [ j ] = 1<br>            result = max ( result , dp [ i ] [ j ] )<br>    return result<br></td>
    <td>translated code: <br><br> def largestKSubmatrix ( a ) :<br>    dp = [ [ 0 ] * Row ]<br>    result = 0<br>    for i in range ( Row ) :<br>        for j in range ( Col ) :<br>            if i == 0 or j == 0 :<br>                dp [ i ] [ j ] = 1<br>            else :<br>                if a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] :<br>                    dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] and dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 )<br>                    dp [ i - 1 ] [ j ] = ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] and dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 )<br>                else :<br>                    dp [ i ] [ j ] = 1<br>            result = result > dp [ i ] [ j ]<br>    return result<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFriendsPairings ( n ) :<br>    dp = [ - 1 ] * 100<br>    if ( dp [ n ] != - 1 ) :<br>        return dp [ n ]<br>    if ( n > 2 ) :<br>        dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) )<br>        return dp [ n ]<br>    else :<br>        dp [ n ] = n<br>        return dp [ n ]<br></td>
    <td>translated code: <br><br> def countFriendsPairings ( n ) :<br>    if dp [ n ] != - 1 :<br>        return dp [ n ]<br>    if n > 2 :<br>        return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 )<br>    else :<br>        return dp [ n ] = n<br></td>
  </tr><tr>
    <th>FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def firstElement ( arr , n , k ) :<br>    count_map = { } <br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] in count_map.keys ( ) ) :<br>            count_map [ arr [ i ] ] += 1<br>        else :<br>            count_map [ arr [ i ] ] = 1<br>        i += 1<br>    for i in range ( 0 , n ) :<br>        if ( count_map [ arr [ i ] ] == k ) :<br>            return arr [ i ]<br>        i += 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def first_element ( arr , n , k ) :<br>    count_dict = { }<br>    for i in range ( n ) :<br>        a = 0<br>        if count_dict.get ( arr [ i ] , 0 ) :<br>            a = count_dict [ arr [ i ] ]<br>        count_dict [ arr [ i ] ] = a + 1<br>    for i in range ( n ) :<br>        if count_dict [ arr [ i ] ] == k :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumOfSeries ( n ) :<br>    return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) <br></td>
    <td>translated code: <br><br> def sum_of_series ( n ) :<br>    return ( 0.666 ) ** ( 1 - 1 / pow ( 10 , n ) )<br></td>
  </tr><tr>
    <th>COUNT_WORDS_IN_A_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWords ( string ) :<br>    state = OUT<br>    wc = 0<br>    for i in range ( len ( string ) ) :<br>        if ( string [ i ] == ' ' or string [ i ] == '\n' or string [ i ] == '\t' ) :<br>            state = OUT<br>        elif state == OUT :<br>            state = IN<br>            wc += 1<br>    return wc<br></td>
    <td>translated code: <br><br> def countWords ( str ) :<br>    state = OUT<br>    wc = 0<br>    i = 0<br>    while i < len ( str ) :<br>        if str [ i ] in ( ' ' , '\n' , '\t' ) :<br>            state = OUT<br>        elif state == OUT :<br>            state = IN<br>            yield wc<br>        i += 1<br></td>
  </tr><tr>
    <th>PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDifference ( arr , N , k ) :<br>    S = 0<br>    S1 = 0<br>    max_difference = 0<br>    for i in range ( N ) :<br>        S += arr [ i ]<br>    arr.sort ( reverse = True )<br>    M = max ( k , N - k )<br>    for i in range ( M ) :<br>        S1 += arr [ i ]<br>    max_difference = S1 - ( S - S1 )<br>    return max_difference<br></td>
    <td>translated code: <br><br> def maxDifference ( arr , N , k ) :<br>    M , S , S1 , max_difference = 0 , 0 , 0 , 0<br>    for i in range ( N ) :<br>        S += arr [ i ]<br>    temp = 0<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            if arr [ i ] < arr [ j ] :<br>                temp = arr [ i ]<br>                arr [ i ] , arr [ j ] = arr [ j ] , temp<br>    M = max ( k , N - k )<br>    for i in range ( M ) :<br>        S1 += arr [ i ]<br>    max_difference = S1 - ( S - S1 )<br>    return max_difference<br></td>
  </tr><tr>
    <th>HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printNos ( n ) :<br>    if n > 0 :<br>        printNos ( n - 1 )<br>        print ( n , end = ' ' )<br></td>
    <td>translated code: <br><br> def print_nos ( n ) :<br>    if n > 0 :<br>        print_nos ( n - 1 )<br>        print ( n , end = ' ' )<br>    return<br></td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pairsInSortedRotated ( arr , n , x ) :<br>    for i in range ( n ) :<br>        if arr [ i ] > arr [ i + 1 ] :<br>            break<br>    l = ( i + 1 ) % n<br>    r = i<br>    cnt = 0<br>    while ( l != r ) :<br>        if arr [ l ] + arr [ r ] == x :<br>            cnt += 1<br>            if l == ( r - 1 + n ) % n :<br>                return cnt<br>            l = ( l + 1 ) % n<br>            r = ( r - 1 + n ) % n<br>        elif arr [ l ] + arr [ r ] < x :<br>            l = ( l + 1 ) % n<br>        else :<br>            r = ( n + r - 1 ) % n<br>    return cnt<br></td>
    <td>translated code: <br><br> def pairs_in_sorted_rotated ( arr , n , x ) :<br>    i = 0<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] > arr [ i + 1 ] :<br>            break<br>    l = ( i + 1 ) % n<br>    r = i<br>    cnt = 0<br>    while l != r :<br>        if arr [ l ] + arr [ r ] == x :<br>            cnt += 1<br>            if l == ( r - 1 + n ) % n :<br>                return cnt<br>            l = ( l + 1 ) % n<br>            r = ( r - 1 + n ) % n<br>        elif arr [ l ] + arr [ r ] < x :<br>            l = ( l + 1 ) % n<br>        else :<br>            r = ( n + r - 1 ) % n<br>    return cnt<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getSingle ( arr , n ) :<br>    ones = 0<br>    twos = 0<br>    for i in range ( n ) :<br>        twos = twos | ( ones & arr [ i ] )<br>        ones = ones ^ arr [ i ]<br>        common_bit_mask = ~ ( ones & twos )<br>        ones &= common_bit_mask<br>        twos &= common_bit_mask<br>    return ones<br></td>
    <td>translated code: <br><br> def getSingle ( arr , n ) :<br>    ones , twos = 0 , 0<br>    common_bit_mask = 0<br>    for i in range ( n ) :<br>        twos = twos | ( ones & arr [ i ] )<br>        ones = ones ^ arr [ i ]<br>        common_bit_mask = ~ ( ones & twos )<br>        ones &= common_bit_mask<br>        twos &= common_bit_mask<br>    return ones , twos<br></td>
  </tr><tr>
    <th>CASSINIS_IDENTITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def cassini ( n ) :<br>    return - 1 if ( n & 1 ) else 1<br></td>
    <td>translated code: <br><br> def cassini ( n ) :<br>    return ( n & 1 ) or - 1<br></td>
  </tr><tr>
    <th>DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def distributingBalls ( k , n , string ) :<br>    a = [ 0 ] * MAX_CHAR<br>    for i in range ( n ) :<br>        a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1<br>    for i in range ( MAX_CHAR ) :<br>        if ( a [ i ] > k ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def distributingBalls ( k , n , str ) :<br>    a = [ ]<br>    for i in range ( n ) :<br>        a.append ( str [ i ] - 'a' )<br>    for i in range ( MAX_CHAR ) :<br>        if a [ i ] > k :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkCount ( arr , n , k ) :<br>    for i in range ( n ) :<br>        count = 0<br>        for j in range ( n ) :<br>            if arr [ j ] == arr [ i ] :<br>                count += 1<br>            if count > 2 * k :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def check_count ( arr , n , k ) :<br>    count = 0<br>    for i in range ( n ) :<br>        count = 0<br>        for j in range ( n ) :<br>            if arr [ j ] == arr [ i ] :<br>                count += 1<br>            if count > 2 ** k :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxValue ( arr , n ) :<br>    if n < 4 :<br>        print ( "The array should have atlest 4 elements" )<br>        return MIN<br>    table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n<br>    table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] )<br>    for i in range ( n - 3 , - 1 , - 1 ) :<br>        table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] )<br>    for i in range ( n - 4 , - 1 , - 1 ) :<br>        table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] )<br>    return table4 [ 0 ]<br></td>
    <td>translated code: <br><br> def find_max_value ( arr , n ) :<br>    if n < 4 :<br>        print ( "The array should have" " atleast 4 elements" )<br>    table1 = np.zeros ( ( n + 1 , ) )<br>    table2 = np.zeros ( ( n , ) )<br>    table3 = np.zeros ( ( n - 1 , ) )<br>    table4 = np.zeros ( ( n - 2 , ) )<br>    np.fill_diagonal ( table1 , np.inf )<br>    np.fill_diagonal ( table2 , np.inf )<br>    np.fill_diagonal ( table3 , np.inf )<br>    np.fill_diagonal ( table4 , np.inf )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] )<br>    for i in range ( n - 3 , - 1 , - 1 ) :<br>        table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] )<br>    for i in range ( n - 4 , - 1 , - 1 ) :<br>        table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] )<br>    return table4 [ 0 ]<br></td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNegative ( M , n , m ) :<br>    count = 0<br>    i = 0<br>    j = m - 1<br>    while j >= 0 and i < n :<br>        if M [ i ] [ j ] < 0 :<br>            count += ( j + 1 )<br>            i += 1<br>        else :<br>            j -= 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_negative ( M , n , m ) :<br>    count = 0<br>    i = 0<br>    j = m - 1<br>    while j >= 0 and i < n :<br>        if M [ i ] [ j ] < 0 :<br>            count += j + 1<br>            i += 1<br>        else :<br>            j -= 1<br>    return count<br></td>
  </tr><tr>
    <th>SORT_AN_ARRAY_OF_0S_1S_AND_2S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sort012 ( a , arr_size ) :<br>    lo = 0<br>    hi = arr_size - 1<br>    mid = 0<br>    while mid <= hi :<br>        if a [ mid ] == 0 :<br>            a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]<br>            lo = lo + 1<br>            mid = mid + 1<br>        elif a [ mid ] == 1 :<br>            mid = mid + 1<br>        else :<br>            a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]<br>            hi = hi - 1<br></td>
    <td>translated code: <br><br> def sort012 ( a , arr_size ) :<br>    lo = 0<br>    hi = arr_size - 1<br>    mid , temp = 0 , 0<br>    while mid <= hi :<br>        try :<br>            temp = a [ mid ]<br>            a [ lo ] , a [ mid ] = a [ mid ] , a [ mid ]<br>            a [ mid ] = temp<br>            lo += 1<br>            mid += 1<br>            break<br>        except IndexError :<br>            mid += 1<br>            break<br></td>
  </tr><tr>
    <th>NTH_EVEN_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def evenFib ( n ) :<br>    if ( n < 1 ) :<br>        return n<br>    if ( n == 1 ) :<br>        return 2<br>    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )<br></td>
    <td>translated code: <br><br> def evenFib ( n ) :<br>    if n < 1 :<br>        return n<br>    if n == 1 :<br>        return 2<br>    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )<br></td>
  </tr><tr>
    <th>NEXT_GREATER_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printNGE ( arr ) :<br>    for i in range ( 0 , len ( arr ) , 1 ) :<br>        next = - 1<br>        for j in range ( i + 1 , len ( arr ) , 1 ) :<br>            if arr [ i ] < arr [ j ] :<br>                next = arr [ j ]<br>                break<br>        print ( str ( arr [ i ] ) + " -- " + str ( next ) )<br></td>
    <td>translated code: <br><br> def printNGE ( arr , n ) :<br>    next , i , j = - 1 , - 1 , - 1<br>    for i in range ( n ) :<br>        next = - 1<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] < arr [ j ] :<br>                next = arr [ j ]<br>                break<br>        print ( arr [ i ] , " -- " , next )<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_CIRCLE_INNER_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def fitOrNotFit ( R , r , x , y , rad ) :<br>    val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) )<br>    if ( val + rad <= R and val - rad >= R - r ) :<br>        print ( "Fits\n" )<br>    else :<br>        print ( "Doesn't Fit" )<br></td>
    <td>translated code: <br><br> def fit_or_not_fit ( R , r , x , y , rad ) :<br>    val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) )<br>    if val + rad <= R and val - rad >= R - r :<br>        print ( "Fits" )<br>    else :<br>        print ( "Doesn't Fit" )<br></td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gcdExtended ( a , b , x , y ) :<br>    if a == 0 :<br>        x = 0<br>        y = 1<br>        return b<br>    x1 = 1<br>    y1 = 1<br>    gcd = gcdExtended ( b % a , a , x1 , y1 )<br>    x = y1 - ( b / a ) * x1<br>    y = x1<br>    return gcd<br></td>
    <td>translated code: <br><br> def gcdExtended ( a , b , x , y ) :<br>    if a == 0 :<br>        x = 0<br>        y = 1<br>        return b<br>    x1 , y1 = 1 , 1<br>    gcd = gcdExtended ( b % a , a , x1 , y1 )<br>    x , y = y1 - ( b // a ) * x1 , x1<br>    return gcd<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSmallestRange ( arr , n , k ) :<br>    i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0<br>    for i in range ( k + 1 ) :<br>        ptr [ i ] = 0<br>    minrange = 10 ** 9<br>    while ( 1 ) :<br>        minind = - 1<br>        minval = 10 ** 9<br>        maxval = - 10 ** 9<br>        flag = 0<br>        for i in range ( k ) :<br>            if ( ptr [ i ] == n ) :<br>                flag = 1<br>                break<br>            if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) :<br>                minind = i<br>                minval = arr [ i ] [ ptr [ i ] ]<br>            if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) :<br>                maxval = arr [ i ] [ ptr [ i ] ]<br>        if ( flag ) :<br>            break<br>        ptr [ minind ] += 1<br>        if ( ( maxval - minval ) < minrange ) :<br>            minel = minval<br>            maxel = maxval<br>            minrange = maxel - minel<br>    print ( "The smallest range is [" , minel , maxel , "]" )<br></td>
    <td>translated code: <br><br> def findSmallestRange ( arr , n , k ) :<br>    i , minval , maxval , minrange , minel = 0 , 0 , 0 , 0 , 0<br>    flag , minind = 0 , 0 , 0<br>    for i in range ( 0 , k ) :<br>        ptr = [ 0 ] * k<br>    minrange = float ( 'inf' )<br>    while True :<br>        minind = - 1<br>        minval = float ( 'inf' )<br>        maxval = float ( 'inf' )<br>        flag = 0<br>        for i in range ( k ) :<br>            if ptr [ i ] == n :<br>                flag = 1<br>                break<br>            if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval :<br>                minind = i<br>                minval = arr [ i ] [ ptr [ i ] ]<br>            if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval :<br>                maxval = arr [ i ] [ ptr [ i ] ]<br>        if flag == 1 :<br>            break<br>        ptr [ minind ] += 1<br>        if ( maxval - minval ) < minrange :<br>            minel = minval<br>            maxel = maxval<br>            minrange = maxel - minel<br>    print ( "The smallest range is [%d , %d]" % ( minel , maxel ) )<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STATION_IS_CONNECTED_IN_ONE_DIRECTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minCost ( cost ) :<br>    dist = [ 0 for i in range ( N ) ]<br>    for i in range ( N ) :<br>        dist [ i ] = INF<br>    dist [ 0 ] = 0<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) :<br>                dist [ j ] = dist [ i ] + cost [ i ] [ j ]<br>    return dist [ N - 1 ]<br></td>
    <td>translated code: <br><br> def minCost ( cost ) :<br>    dist = [ INF ]<br>    for i in range ( N ) :<br>        dist.append ( INF )<br>    dist [ 0 ] = 0<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            if dist [ j ] > dist [ i ] + cost [ i ] [ j ] :<br>                dist [ j ] = dist [ i ] + cost [ i ] [ j ]<br>    return dist [ N - 1 ]<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def middleOfThree ( a , b , c ) :<br>    if a > b :<br>        if ( b > c ) :<br>            return b<br>        elif ( a > c ) :<br>            return c<br>        else :<br>            return a<br>    else :<br>        if ( a > c ) :<br>            return a<br>        elif ( b > c ) :<br>            return c<br>        else :<br>            return b<br></td>
    <td>translated code: <br><br> def middle_of_three ( a , b , c ) :<br>    if a > b :<br>        if b > c :<br>            return b<br>        elif a > c :<br>            return c<br>        else :<br>            return a<br>    else :<br>        if a > c :<br>            return a<br>        elif b > c :<br>            return c<br>        else :<br>            return b<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( st ) :<br>    n = len ( st )<br>    oddDigSum = 0<br>    evenDigSum = 0<br>    for i in range ( 0 , n ) :<br>        if ( i % 2 == 0 ) :<br>            oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) )<br>        else :<br>            evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) )<br>    return ( ( oddDigSum - evenDigSum ) % 11 == 0 )<br></td>
    <td>translated code: <br><br> def check ( str ) :<br>    n = len ( str )<br>    oddDigSum , evenDigSum = 0 , 0<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            oddDigSum += ( str [ i ] - '0' )<br>        else :<br>            evenDigSum += ( str [ i ] - '0' )<br>    return ( ( oddDigSum - evenDigSum ) % 11 == 0 )<br></td>
  </tr><tr>
    <th>COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getModulo ( n , d ) :<br>    return ( n & ( d - 1 ) )<br></td>
    <td>translated code: <br><br> def getModulo ( n , d ) :<br>    return ( n & ( d - 1 ) )<br></td>
  </tr><tr>
    <th>COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countStrings ( n , k ) :<br>    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ]<br>    dp [ 1 ] [ 0 ] [ 0 ] = 1<br>    dp [ 1 ] [ 0 ] [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( k + 1 ) :<br>            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] )<br>            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]<br>            if j >= 1 :<br>                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]<br>    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]<br></td>
    <td>translated code: <br><br> def count_strings ( n , k ) :<br>    dp = [ [ 1 , 1 ] , [ 1 , 1 ] ]<br>    dp [ 1 ] [ 0 ] [ 0 ] = 1<br>    dp [ 1 ] [ 0 ] [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( i , k + 1 ) :<br>            dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ]<br>            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]<br>            if j - 1 >= 0 :<br>                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]<br>    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]<br></td>
  </tr><tr>
    <th>FINDING_K_MODULUS_ARRAY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printEqualModNumbers ( arr , n ) :<br>    arr.sort ( ) <br>    d = arr [ n - 1 ] - arr [ 0 ] <br>    v = [ ] <br>    i = 1 <br>    while ( i * i <= d ) :<br>        if ( d % i == 0 ) :<br>            v.append ( i ) <br>            if ( i != d / i ) :<br>                v.append ( d / i ) <br>        i += 1 <br>    for i in range ( len ( v ) ) :<br>        temp = arr [ 0 ] % v [ i ] <br>        j = 1 <br>        while ( j < n ) :<br>            if ( arr [ j ] % v [ i ] != temp ) :<br>                break <br>            j += 1 <br>        if ( j == n ) :<br>            print ( v [ i ] , end = " " ) <br></td>
    <td>translated code: <br><br> def print_equal_mod_numbers ( arr , n ) :<br>    arr.sort ( )<br>    d = arr [ n - 1 ] - arr [ 0 ]<br>    v = [ ]<br>    for i in range ( 1 , d * i <= d ) :<br>        if d % i == 0 :<br>            v.append ( i )<br>            if i != d / i :<br>                v.append ( d / i )<br>    for i in range ( len ( v ) ) :<br>        temp = arr [ 0 ] % v [ i ]<br>        j = 0<br>        for j in range ( 1 , n ) :<br>            if arr [ j ] % v [ i ] != temp :<br>                break<br>        if j == n :<br>            print ( v [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def spiralFill ( m , n , a ) :<br>    val = 1<br>    k , l = 0 , 0<br>    while ( k < m and l < n ) :<br>        for i in range ( l , n ) :<br>            a [ k ] [ i ] = val<br>            val += 1<br>        k += 1<br>        for i in range ( k , m ) :<br>            a [ i ] [ n - 1 ] = val<br>            val += 1<br>        n -= 1<br>        if ( k < m ) :<br>            for i in range ( n - 1 , l - 1 , - 1 ) :<br>                a [ m - 1 ] [ i ] = val<br>                val += 1<br>            m -= 1<br>        if ( l < n ) :<br>            for i in range ( m - 1 , k - 1 , - 1 ) :<br>                a [ i ] [ l ] = val<br>                val += 1<br>            l += 1<br></td>
    <td>translated code: <br><br> def spiral_fill ( m , n , a ) :<br>    val = 1<br>    k , l = 0 , 0<br>    while k < m and l < n :<br>        for i in range ( l , n ) :<br>            a [ k ] [ i ] = val ++<br>        k += 1<br>        for i in range ( k , m ) :<br>            a [ i ] [ n - 1 ] = val ++<br>        n -= 1<br>        if k < m :<br>            for i in range ( n - 1 , l , - 1 ) :<br>                a [ m - 1 ] [ i ] = val ++<br>            m -= 1<br>        if l < n :<br>            for i in range ( m - 1 , k , - 1 ) :<br>                a [ i ] [ l ] = val ++<br>            l += 1<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRepeating ( arr , size ) :<br>    xor = arr [ 0 ]<br>    n = size - 2<br>    x = 0<br>    y = 0<br>    for i in range ( 1 , size ) :<br>        xor ^= arr [ i ]<br>    for i in range ( 1 , n + 1 ) :<br>        xor ^= i<br>    set_bit_no = xor & ~ ( xor - 1 )<br>    for i in range ( 0 , size ) :<br>        if ( arr [ i ] & set_bit_no ) :<br>            x = x ^ arr [ i ]<br>        else :<br>            y = y ^ arr [ i ]<br>    for i in range ( 1 , n + 1 ) :<br>        if ( i & set_bit_no ) :<br>            x = x ^ i<br>        else :<br>            y = y ^ i<br>    print ( "The two repeating" , "elements are" , y , x )<br></td>
    <td>translated code: <br><br> def printRepeating ( arr , size ) :<br>    xor = arr [ 0 ]<br>    set_bit_no = 0<br>    i = 0<br>    n = size - 2<br>    x , y = 0 , 0<br>    for i in range ( 1 , size ) :<br>        xor ^= arr [ i ]<br>    for i in range ( 1 , n + 1 ) :<br>        xor ^= i<br>    set_bit_no = ( xor & ~ ( xor - 1 ) )<br>    for i in range ( size ) :<br>        a = arr [ i ] & set_bit_no<br>        if a != 0 :<br>            x = x ^ arr [ i ]<br>        else :<br>            y = y ^ arr [ i ]<br>    for i in range ( 1 , n + 1 ) :<br>        a = i & set_bit_no<br>        if a != 0 :<br>            x = x ^ i<br>        else :<br>            y = y ^ i<br>    print ( "The two reppeated elements are :" )<br>    print ( x , y )<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( N ) :<br>    if ( N == 1 ) :<br>        return 4<br>    countB = 1<br>    countS = 1<br>    for i in range ( 2 , N + 1 ) :<br>        prev_countB = countB<br>        prev_countS = countS<br>        countS = prev_countB + prev_countS<br>        countB = prev_countS<br>    result = countS + countB<br>    return ( result * result )<br></td>
    <td>translated code: <br><br> def countWays ( N ) :<br>    if N == 1 :<br>        return 4<br>    countB , countS , prevCountB , prevCountS = 1 , 1 , 1 , 1<br>    for i in range ( 2 , N + 1 ) :<br>        prevCountB , prevCountS , prevCountB = countB , prevCountS , prevCountB + prevCountS , prevCountB<br>        countB , prevCountS , prevCountB = countS , prevCountS , prevCountB + prevCountS , prevCountB + prevCountS<br>    result = countS + countB<br>    return ( result * result )<br></td>
  </tr><tr>
    <th>ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def factorial ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) <br></td>
    <td>translated code: <br><br> def factorial ( n ) :<br>    return ( n if n == 1 or n == 0 else 1 ) * factorial ( n - 1 )<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_SPARSE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSparse ( array , m , n ) :<br>    counter = 0<br>    for i in range ( 0 , m ) :<br>        for j in range ( 0 , n ) :<br>            if ( array [ i ] [ j ] == 0 ) :<br>                counter = counter + 1<br>    return ( counter > ( ( m * n ) // 2 ) )<br></td>
    <td>translated code: <br><br> def isSparse ( array , m , n ) :<br>    counter = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if array [ i ] [ j ] == 0 :<br>                counter += 1<br>    return ( counter > ( ( m * n ) / 2 ) )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def knapSack ( W , wt , val , n ) :<br>    if n == 0 or W == 0 :<br>        return 0<br>    if ( wt [ n - 1 ] > W ) :<br>        return knapSack ( W , wt , val , n - 1 )<br>    else :<br>        return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )<br></td>
    <td>translated code: <br><br> def knapSack ( W , wt , val , n ) :<br>    if n == 0 or W == 0 :<br>        return 0<br>    if wt [ - 1 ] > W :<br>        return knapSack ( W , wt , val , n - 1 )<br>    else :<br>        return max ( val [ - 1 ] + knapSack ( W - wt [ - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_LEAST_AVERAGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinAvgSubarray ( arr , n , k ) :<br>    if ( n < k ) : return 0<br>    res_index = 0<br>    curr_sum = 0<br>    for i in range ( k ) :<br>        curr_sum += arr [ i ]<br>    min_sum = curr_sum<br>    for i in range ( k , n ) :<br>        curr_sum += arr [ i ] - arr [ i - k ]<br>        if ( curr_sum < min_sum ) :<br>            min_sum = curr_sum<br>            res_index = ( i - k + 1 )<br>    print ( "Subarray between [" , res_index , ", " , ( res_index + k - 1 ) , "] has minimum average" )<br></td>
    <td>translated code: <br><br> def find_min_avg_subarray ( n , k ) :<br>    if n < k :<br>        return<br>    res_index = 0<br>    curr_sum = 0<br>    for i in range ( k ) :<br>        curr_sum += arr [ i ]<br>    min_sum = curr_sum<br>    for i in range ( k , n ) :<br>        curr_sum += arr [ i ] - arr [ i - k ]<br>        if curr_sum < min_sum :<br>            min_sum = curr_sum<br>            res_index = ( i - k + 1 )<br>    print ( "Subarray between [%d, %d] has minimum average" % ( res_index , ( res_index + k - 1 ) ) )<br></td>
  </tr><tr>
    <th>QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def query ( s , i , j ) :<br>    n = len ( s )<br>    i %= n<br>    j %= n<br>    print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" )<br></td>
    <td>translated code: <br><br> def query ( s , i , j ) :<br>    n = len ( s )<br>    i %= n<br>    j %= n<br>    if s [ i ] == s [ j ] :<br>        print ( "Yes" )<br>    else :<br>        print ( "No" )<br></td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def productArray ( arr , n ) :<br>    if n == 1 :<br>        print ( 0 )<br>        return<br>    i , temp = 1 , 1<br>    prod = [ 1 for i in range ( n ) ]<br>    for i in range ( n ) :<br>        prod [ i ] = temp<br>        temp *= arr [ i ]<br>    temp = 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        prod [ i ] *= temp<br>        temp *= arr [ i ]<br>    for i in range ( n ) :<br>        print ( prod [ i ] , end = " " )<br>    return<br></td>
    <td>translated code: <br><br> def productArray ( arr , n ) :<br>    if n == 1 :<br>        print ( '0' )<br>        return<br>    i , temp = 1 , 1<br>    prod = [ ]<br>    for j in range ( n ) :<br>        prod.append ( 1 )<br>    for i in range ( n ) :<br>        prod.append ( temp )<br>        temp *= arr [ i ]<br>    temp = 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        prod.append ( temp )<br>        temp *= arr [ i ]<br>    for i in range ( n ) :<br>        print ( prod [ i ] , end = ' ' )<br>    return<br></td>
  </tr><tr>
    <th>FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pairSum ( mat , n , sum ) :<br>    for i in range ( n ) :<br>        mat [ i ].sort ( )<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            left = 0<br>            right = n - 1<br>            while ( left < n and right >= 0 ) :<br>                if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) :<br>                    print ( "(" , mat [ i ] [ left ] , ", " , mat [ j ] [ right ] , "), " , end = " " )<br>                    left += 1<br>                    right -= 1<br>                else :<br>                    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) :<br>                        left += 1<br>                    else :<br>                        right -= 1<br></td>
    <td>translated code: <br><br> def pairSum ( mat , n , sum ) :<br>    for i in range ( n ) :<br>        mat.sort ( )<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            left , right = 0 , n - 1<br>            while left < n and right >= 0 :<br>                if ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum :<br>                    print ( "(" + str ( mat [ i ] [ left ] ) + ", " + str ( mat [ j ] [ right ] ) + "), " )<br>                    left += 1<br>                    right -= 1<br>                else :<br>                    if ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum :<br>                        left += 1<br>                    else :<br>                        right -= 1<br></td>
  </tr><tr>
    <th>CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isRotated ( str1 , str2 ) :<br>    if ( len ( str1 ) != len ( str2 ) ) :<br>        return False<br>    clock_rot = ""<br>    anticlock_rot = ""<br>    l = len ( str2 )<br>    anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] )<br>    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]<br>    return ( str1 == clock_rot or str1 == anticlock_rot )<br></td>
    <td>translated code: <br><br> def is_rotated ( str1 , str2 ) :<br>    if len ( str1 ) != len ( str2 ) :<br>        return False<br>    clock_rot = ""<br>    anticlock_rot = ""<br>    _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ = str2<br>    anticlock_rot = anticlock_rot + str2 [ - 2 : ] + str2 [ : - 2 ]<br>    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ : 2 ]<br>    return ( str1 == clock_rot or str1 == anticlock_rot )<br></td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findNth ( n ) :<br>    count = 0<br>    for curr in itertools.count ( ) :<br>        sum = 0<br>        x = curr<br>        while ( x ) :<br>            sum = sum + x % 10<br>            x = x // 10<br>        if ( sum == 10 ) :<br>            count = count + 1<br>        if ( count == n ) :<br>            return curr<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_nth ( n ) :<br>    count = 0<br>    for curr in range ( 1 , 10 ) :<br>        sum = 0<br>        for x in range ( curr , 0 , 10 ) :<br>            sum = sum + x % 10<br>        if sum == 10 :<br>            count += 1<br>        if count == n :<br>            return curr<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_SLOPE_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def slope ( x1 , y1 , x2 , y2 ) :<br>    return ( float ) ( y2 - y1 ) / ( x2 - x1 )<br></td>
    <td>translated code: <br><br> def slope ( x1 , y1 , x2 , y2 ) :<br>    return ( y2 - y1 ) / ( x2 - x1 )<br></td>
  </tr><tr>
    <th>GCD_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rangeGCD ( n , m ) :<br>    return n if ( n == m ) else 1<br></td>
    <td>translated code: <br><br> def range_gcd ( n , m ) :<br>    return ( n , m )<br></td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def alternateSubarray ( arr , n ) :<br>    count = 1<br>    prev = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if ( ( arr [ i ] ^ prev ) == 0 ) :<br>            while ( count ) :<br>                print ( count , end = " " )<br>                count -= 1<br>        count += 1<br>        prev = arr [ i ]<br>    while ( count ) :<br>        print ( count , end = " " )<br>        count -= 1<br></td>
    <td>translated code: <br><br> def alternate_subarray ( arr , n ) :<br>    count = 1<br>    prev = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if ( arr [ i ] ^ prev ) == False :<br>            while count > 0 :<br>                print ( count )<br>        count += 1<br>        prev = arr [ i ]<br>    while count != 0 :<br>        print ( count )<br></td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def unitDigitXRaisedY ( x , y ) :<br>    res = 1<br>    for i in range ( y ) :<br>        res = ( res * x ) % 10<br>    return res<br></td>
    <td>translated code: <br><br> def unit_digit_x_raised_y ( x , y ) :<br>    res = 1<br>    for i in range ( y ) :<br>        res = ( res * x ) % 10<br>    return res<br></td>
  </tr><tr>
    <th>MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def moduloMultiplication ( a , b , mod ) :<br>    res = 0 <br>    a = a % mod <br>    while ( b ) :<br>        if ( b & 1 ) :<br>            res = ( res + a ) % mod <br>        a = ( 2 * a ) % mod <br>        b >>= 1 <br>    return res <br></td>
    <td>translated code: <br><br> def modulo_multiplication ( a , b , mod ) :<br>    res = 0<br>    a %= mod<br>    while b :<br>        if ( b & 1 ) :<br>            res = ( res + a ) % mod<br>        a = ( 2 * a ) % mod<br>        b >>= 1<br>    return res<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSmallest ( m , s ) :<br>    if ( s == 0 ) :<br>        if ( m == 1 ) :<br>            print ( "Smallest number is 0" )<br>        else :<br>            print ( "Not possible" )<br>        return<br>    if ( s > 9 * m ) :<br>        print ( "Not possible" )<br>        return<br>    res = [ 0 for i in range ( m + 1 ) ]<br>    s -= 1<br>    for i in range ( m - 1 , 0 , - 1 ) :<br>        if ( s > 9 ) :<br>            res [ i ] = 9<br>            s -= 9<br>        else :<br>            res [ i ] = s<br>            s = 0<br>    res [ 0 ] = s + 1<br>    print ( "Smallest number is " , end = "" )<br>    for i in range ( m ) :<br>        print ( res [ i ] , end = "" )<br></td>
    <td>translated code: <br><br> def findSmallest ( m , s ) :<br>    if s == 0 :<br>        print ( m == 1 and "Smallest number is 0" or "Not possible" )<br>        return<br>    if s > 9 * m :<br>        print ( "Not possible" )<br>        return<br>    res = [ ]<br>    s -= 1<br>    for i in range ( m - 1 , 0 , - 1 ) :<br>        if s > 9 :<br>            res.append ( 9 )<br>            s -= 9<br>        else :<br>            res.append ( s )<br>            s = 0<br>    res.append ( s + 1 )<br>    print ( "Smallest number is " )<br>    for i in range ( m ) :<br>        print ( res [ i ] )<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def largest ( arr , n ) :<br>    max = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if arr [ i ] > max :<br>            max = arr [ i ]<br>    return max<br></td>
    <td>translated code: <br><br> def largest ( ) :<br>    i = 0<br>    max = arr [ 0 ]<br>    for i in range ( 1 , len ( arr ) ) :<br>        if arr [ i ] > max :<br>            max = arr [ i ]<br>    return max<br></td>
  </tr><tr>
    <th>COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNums ( n , x , y ) :<br>    arr = [ False for i in range ( n + 2 ) ]<br>    if ( x <= n ) :<br>        arr [ x ] = True<br>    if ( y <= n ) :<br>        arr [ y ] = True<br>    result = 0<br>    for i in range ( min ( x , y ) , n + 1 ) :<br>        if ( arr [ i ] ) :<br>            if ( i + x <= n ) :<br>                arr [ i + x ] = True<br>            if ( i + y <= n ) :<br>                arr [ i + y ] = True<br>            result = result + 1<br>    return result<br></td>
    <td>translated code: <br><br> def count_nums ( n , x , y ) :<br>    arr = [ ]<br>    if x <= n :<br>        arr.append ( True )<br>    if y <= n :<br>        arr.append ( True )<br>    result = 0<br>    for i in range ( min ( x , y ) , n + 1 ) :<br>        if arr [ i ] :<br>            if i + x <= n :<br>                arr.append ( True )<br>            if i + y <= n :<br>                arr.append ( True )<br>            result += 1<br>    return result<br></td>
  </tr><tr>
    <th>BUBBLE_SORT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bubbleSort ( arr ) :<br>    n = len ( arr )<br>    for i in range ( n ) :<br>        swapped = False<br>        for j in range ( 0 , n - i - 1 ) :<br>            if arr [ j ] > arr [ j + 1 ] :<br>                arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]<br>                swapped = True<br>        if swapped == False :<br>            break<br></td>
    <td>translated code: <br><br> def bubble_sort ( arr , n ) :<br>    i , j , temp = 0 , 0 , 0<br>    swapped = 0<br>    for i in range ( n - 1 ) :<br>        swapped = 0<br>        for j in range ( n - i - 1 ) :<br>            if arr [ j ] > arr [ j + 1 ] :<br>                temp = arr [ j ]<br>                arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j + 1 ]<br>                arr [ j + 1 ] , arr [ j + 1 ] = temp , arr [ j + 1 ]<br>                swapped = 1<br>        if swapped == 0 :<br>            break<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSum ( grid , n ) :<br>    incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )<br>    excl = 0<br>    for i in range ( 1 , n ) :<br>        excl_new = max ( excl , incl )<br>        incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] )<br>        excl = excl_new<br>    return max ( excl , incl )<br></td>
    <td>translated code: <br><br> def max_sum ( grid , n ) :<br>    incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )<br>    excl , excl_new = 0 , 0<br>    for i in range ( 1 , n ) :<br>        excl_new = max ( excl , incl )<br>        incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] )<br>        excl = excl_new<br>    return max ( excl , incl )<br></td>
  </tr><tr>
    <th>GCD_FACTORIALS_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gcdOfFactorial ( m , n ) :<br>    return math.factorial ( min ( m , n ) )<br></td>
    <td>translated code: <br><br> def gcdOfFactorial ( m , n ) :<br>    min = m if m < n else n<br>    return factorial ( min )<br></td>
  </tr><tr>
    <th>AREA_OF_A_SECTOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def SectorArea ( radius , angle ) :<br>    pi = 22 / 7<br>    if angle >= 360 :<br>        print ( "Angle not possible" )<br>        return<br>    else :<br>        sector = ( pi * radius ** 2 ) * ( angle / 360 )<br>        print ( sector )<br>        return<br></td>
    <td>translated code: <br><br> def SectorArea ( radius , angle ) :<br>    if angle >= 360 :<br>        print ( "Angle not possible" )<br>    else :<br>        sector = ( ( 22 * radius ** 2 ) / 7 ) * ( angle / 360 )<br>        print ( sector )<br></td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSeq ( n ) :<br>    nCr = 1<br>    res = 1<br>    for r in range ( 1 , n + 1 ) :<br>        nCr = ( nCr * ( n + 1 - r ) ) / r <br>        res += nCr * nCr <br>    return res <br></td>
    <td>translated code: <br><br> def count_seq ( n ) :<br>    nCr , res = 1 , 1<br>    for r in range ( 1 , n + 1 ) :<br>        nCr = ( nCr * ( n + 1 - r ) ) // r<br>        res += nCr ** 2<br>    return res<br></td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLength ( string ) :<br>    n = len ( string )<br>    maxlen = 0<br>    Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]<br>    for i in range ( 0 , n ) :<br>        Sum [ i ] [ i ] = int ( string [ i ] )<br>    for length in range ( 2 , n + 1 ) :<br>        for i in range ( 0 , n - length + 1 ) :<br>            j = i + length - 1<br>            k = length // 2<br>            Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] )<br>            if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) :<br>                maxlen = length<br>    return maxlen<br></td>
    <td>translated code: <br><br> def find_length ( str ) :<br>    n = len ( str )<br>    maxlen = 0<br>    sum = [ 0 ] * n<br>    for i in range ( n ) :<br>        sum [ i ] = str [ i ] - '0'<br>    for len in range ( 2 , n + 1 ) :<br>        for i in range ( n - len + 1 ) :<br>            j = i + len - 1<br>            k = len // 2<br>            sum [ i ] = sum [ i ] + sum [ j - k + 1 ]<br>            if len % 2 == 0 and sum [ i ] == sum [ ( j - k + 1 ) ] and len > maxlen :<br>                maxlen = len<br>    return maxlen<br></td>
  </tr><tr>
    <th>SWAP_ALL_ODD_AND_EVEN_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def swapBits ( x ) :<br>    even_bits = x & 0xAAAAAAAA<br>    odd_bits = x & 0x55555555<br>    even_bits >>= 1<br>    odd_bits <<= 1<br>    return ( even_bits | odd_bits )<br></td>
    <td>translated code: <br><br> def swap_bits ( x ) :<br>    even_bits = x & 0xAAAAAAAA<br>    odd_bits = x & 0x55555555<br>    even_bits >>= 1<br>    odd_bits <<= 1<br>    return ( even_bits | odd_bits )<br></td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortInWave ( arr , n ) :<br>    arr.sort ( )<br>    for i in range ( 0 , n - 1 , 2 ) :<br>        arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]<br></td>
    <td>translated code: <br><br> def sortInWave ( arr , n ) :<br>    arr.sort ( )<br>    for i in range ( 0 , n - 1 , 2 ) :<br>        swap ( arr , i , i + 1 )<br></td>
  </tr><tr>
    <th>FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def compute ( a , b ) :<br>    AM = ( a + b ) / 2<br>    GM = math.sqrt ( a * b )<br>    HM = ( GM * GM ) / AM<br>    return HM<br></td>
    <td>translated code: <br><br> def compute ( a , b ) :<br>    AM , GM , HM = ( a + b ) / 2 , math.sqrt ( a * b ) , ( GM * GM ) / AM<br>    return HM<br></td>
  </tr><tr>
    <th>COUNT_BALANCED_BINARY_TREES_HEIGHT_H</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countBT ( h ) :<br>    MOD = 1000000007<br>    dp = [ 0 for i in range ( h + 1 ) ]<br>    dp [ 0 ] = 1<br>    dp [ 1 ] = 1<br>    for i in range ( 2 , h + 1 ) :<br>        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD<br>    return dp [ h ]<br></td>
    <td>translated code: <br><br> def count_bt ( h ) :<br>    dp = [ 1 ] * ( h + 1 )<br>    for i in range ( 2 , h + 1 ) :<br>        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD<br>    return dp [ h ]<br></td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minInsertion ( tr1 ) :<br>    n = len ( str1 )<br>    res = 0<br>    count = [ 0 for i in range ( 26 ) ]<br>    for i in range ( n ) :<br>        count [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1<br>    for i in range ( 26 ) :<br>        if ( count [ i ] % 2 == 1 ) :<br>            res += 1<br>    if ( res == 0 ) :<br>        return 0<br>    else :<br>        return res - 1<br></td>
    <td>translated code: <br><br> def minInsertion ( str ) :<br>    n = len ( str )<br>    res = 0<br>    count = [ 0 ] * 26<br>    for i in range ( n ) :<br>        count [ str [ i ] - 'a' ] += 1<br>    for i in range ( 26 ) :<br>        if count [ i ] % 2 == 1 :<br>            res += 1<br>    return ( res , 0 )<br></td>
  </tr><tr>
    <th>SHUFFLE_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def randomize ( arr , n ) :<br>    for i in range ( n - 1 , 0 , - 1 ) :<br>        j = random.randint ( 0 , i + 1 )<br>        arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]<br>    return arr<br></td>
    <td>translated code: <br><br> def randomize ( arr , n ) :<br>    r = random.Random ( )<br>    for i in range ( n - 1 , 0 , - 1 ) :<br>        j = r.randint ( i + 1 , i + 1 )<br>        temp = arr [ i ]<br>        arr [ i ] = arr [ j ]<br>        arr [ j ] = temp<br>    print ( list ( arr ) )<br></td>
  </tr><tr>
    <th>UGLY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getNthUglyNo ( n ) :<br>    ugly = [ 0 ] * n<br>    ugly [ 0 ] = 1<br>    i2 = i3 = i5 = 0<br>    next_multiple_of_2 = 2<br>    next_multiple_of_3 = 3<br>    next_multiple_of_5 = 5<br>    for l in range ( 1 , n ) :<br>        ugly [ l ] = min ( next_multiple_of_2 , next_multiple_of_3 , next_multiple_of_5 )<br>        if ugly [ l ] == next_multiple_of_2 :<br>            i2 += 1<br>            next_multiple_of_2 = ugly [ i2 ] * 2<br>        if ugly [ l ] == next_multiple_of_3 :<br>            i3 += 1<br>            next_multiple_of_3 = ugly [ i3 ] * 3<br>        if ugly [ l ] == next_multiple_of_5 :<br>            i5 += 1<br>            next_multiple_of_5 = ugly [ i5 ] * 5<br>    return ugly [ - 1 ]<br></td>
    <td>translated code: <br><br> def getNthUglyNo ( n ) :<br>    ugly = [ ]<br>    i2 , i3 , i5 = 0 , 0 , 0<br>    next_multiple_of_2 = 2<br>    next_multiple_of_3 = 3<br>    next_multiple_of_5 = 5<br>    next_ugly_no = 1<br>    ugly.append ( 1 )<br>    for i in range ( 1 , n ) :<br>        next_ugly_no = min ( next_multiple_of_2 , min ( next_multiple_of_3 , next_multiple_of_5 ) )<br>        ugly.append ( next_ugly_no )<br>        if next_ugly_no == next_multiple_of_2 :<br>            i2 = i2 + 1<br>            next_multiple_of_2 = ugly [ i2 ] * 2<br>        if next_ugly_no == next_multiple_of_3 :<br>            i3 = i3 + 1<br>            next_multiple_of_3 = ugly [ i3 ] * 3<br>        if next_ugly_no == next_multiple_of_5 :<br>            i5 = i5 + 1<br>            next_multiple_of_5 = ugly [ i5 ] * 5<br>    return next_ugly_no<br></td>
  </tr><tr>
    <th>MINIMUM_COST_CUT_BOARD_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minimumCostOfBreaking ( X , Y , m , n ) :<br>    res = 0<br>    X.sort ( reverse = True )<br>    Y.sort ( reverse = True )<br>    hzntl = 1 ; vert = 1<br>    i = 0 ; j = 0<br>    while ( i < m and j < n ) :<br>        if ( X [ i ] > Y [ j ] ) :<br>            res += X [ i ] * vert<br>            hzntl += 1<br>            i += 1<br>        else :<br>            res += Y [ j ] * hzntl<br>            vert += 1<br>            j += 1<br>    total = 0<br>    while ( i < m ) :<br>        total += X [ i ]<br>        i += 1<br>    res += total * vert<br>    total = 0<br>    while ( j < n ) :<br>        total += Y [ j ]<br>        j += 1<br>    res += total * hzntl<br>    return res<br></td>
    <td>translated code: <br><br> def minimum_cost_of_breaking ( X , Y , m , n ) :<br>    res = 0<br>    X.sort ( key = lambda x : x [ 1 ] )<br>    Y.sort ( key = lambda x : x [ 1 ] )<br>    hzntl , vert = 1 , 1<br>    i , j = 0 , 0<br>    while i < m and j < n :<br>        if X [ i ] > Y [ j ] :<br>            res += X [ i ] * vert<br>            hzntl += 1<br>            i += 1<br>        else :<br>            res += Y [ j ] * hzntl<br>            vert += 1<br>            j += 1<br>    total = 0<br>    while i < m :<br>        total += X [ i ]<br>    res += total * vert<br>    total = 0<br>    while j < n :<br>        total += Y [ j ]<br>    res += total * hzntl<br>    return res<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def knapSack ( W , wt , val , n ) :<br>    K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        for w in range ( W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
    <td>translated code: <br><br> def knapSack ( W , wt , val , n ) :<br>    i , w = 0 , 0<br>    K = [ 0 ] * ( n + 1 ) * ( W + 1 )<br>    for i in range ( 0 , n + 1 ) :<br>        for w in range ( 0 , W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
  </tr><tr>
    <th>STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkStackPermutation ( ip , op , n ) :<br>    Input = Queue ( )<br>    for i in range ( n ) :<br>        Input.put ( ip [ i ] )<br>    output = Queue ( )<br>    for i in range ( n ) :<br>        output.put ( op [ i ] )<br>    tempStack = [ ]<br>    while ( not Input.empty ( ) ) :<br>        ele = Input.queue [ 0 ]<br>        Input.get ( )<br>        if ( ele == output.queue [ 0 ] ) :<br>            output.get ( )<br>            while ( len ( tempStack ) != 0 ) :<br>                if ( tempStack [ - 1 ] == output.queue [ 0 ] ) :<br>                    tempStack.pop ( )<br>                    output.get ( )<br>                else :<br>                    break<br>        else :<br>            tempStack.append ( ele )<br>    return ( Input.empty ( ) and len ( tempStack ) == 0 )<br></td>
    <td>translated code: <br><br> def check_stack_permutation ( ip , op , n ) :<br>    input = Queue ( )<br>    for i in range ( n ) :<br>        input.put ( ip [ i ] )<br>    output = Queue ( )<br>    for i in range ( n ) :<br>        output.put ( op [ i ] )<br>    temp_stack = Stack ( )<br>    while not input.empty ( ) :<br>        ele = input.get ( )<br>        if ele == output.get ( ) :<br>            output.put ( ele )<br>            while not temp_stack.empty ( ) :<br>                if temp_stack.get ( ) == output.get ( ) :<br>                    temp_stack.pop ( )<br>                    output.put ( ele )<br>                else :<br>                    break<br>        else :<br>            temp_stack.push ( ele )<br>    return ( input.empty ( ) and temp_stack.empty ( ) )<br></td>
  </tr><tr>
    <th>PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def procal ( n ) :<br>    return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )<br></td>
    <td>translated code: <br><br> def procal ( n ) :<br>    return ( 3.0 * n ) / ( 4.0 * ( n ** 2 ) - 1 )<br></td>
  </tr><tr>
    <th>REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def simplify ( Str ) :<br>    Len = len ( Str )<br>    res = [ None ] * Len<br>    index = 0<br>    i = 0<br>    s = [ ]<br>    s.append ( 0 )<br>    while ( i < Len ) :<br>        if ( Str [ i ] == '+' ) :<br>            if ( s [ - 1 ] == 1 ) :<br>                res [ index ] = '-'<br>                index += 1<br>            if ( s [ - 1 ] == 0 ) :<br>                res [ index ] = '+'<br>                index += 1<br>        elif ( Str [ i ] == '-' ) :<br>            if ( s [ - 1 ] == 1 ) :<br>                res [ index ] = '+'<br>                index += 1<br>            elif ( s [ - 1 ] == 0 ) :<br>                res [ index ] = '-'<br>                index += 1<br>        elif ( Str [ i ] == '(' and i > 0 ) :<br>            if ( Str [ i - 1 ] == '-' ) :<br>                x = 0 if ( s [ - 1 ] == 1 ) else 1<br>                s.append ( x )<br>            elif ( Str [ i - 1 ] == '+' ) :<br>                s.append ( s [ - 1 ] )<br>        elif ( Str [ i ] == ')' ) :<br>            s.pop ( )<br>        else :<br>            res [ index ] = Str [ i ]<br>            index += 1<br>        i += 1<br>    return res<br></td>
    <td>translated code: <br><br> def simplify ( str ) :<br>    len ( str )<br>    res = [ ]<br>    index , i = 0 , 0<br>    s = Stack ( )<br>    s.push ( 0 )<br>    while i < len ( str ) :<br>        if str [ i ] == '+' :<br>            if s.pop ( ) == 1 :<br>                res.append ( '-' )<br>            if s.pop ( ) == 0 :<br>                res.append ( '+' )<br>        elif str [ i ] == '-' :<br>            if s.pop ( ) == 1 :<br>                res.append ( '+' )<br>            elif s.pop ( ) == 0 :<br>                res.append ( '-' )<br>        elif str [ i ] == '(' and i > 0 :<br>            if str [ i - 1 ] == '-' :<br>                x = ( s.pop ( ) == 1 )<br>                s.push ( x )<br>            elif str [ i - 1 ] == '+' :<br>                s.push ( s.pop ( ) )<br>        elif str [ i ] == ')' :<br>            s.pop ( )<br>        else :<br>            res.append ( str [ i ] )<br>        i += 1<br>    return ''.join ( res )<br></td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def CountSquares ( a , b ) :<br>    cnt = 0<br>    for i in range ( a , b + 1 ) :<br>        j = 1 <br>        while j * j <= i :<br>            if j * j == i :<br>                cnt = cnt + 1<br>            j = j + 1<br>        i = i + 1<br>    return cnt<br></td>
    <td>translated code: <br><br> def count_squares ( a , b ) :<br>    cnt = 0<br>    for i in range ( a , b + 1 ) :<br>        for j in range ( 1 , j ** 2 ) :<br>            if j ** 2 == i :<br>                cnt += 1<br>    return cnt<br></td>
  </tr><tr>
    <th>K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minDiff ( arr , n , k ) :<br>    result = + 2147483647<br>    arr.sort ( )<br>    for i in range ( n - k + 1 ) :<br>        result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) )<br>    return result<br></td>
    <td>translated code: <br><br> def min_diff ( arr , n , k ) :<br>    result = int ( 0 )<br>    arr.sort ( )<br>    for i in range ( 0 , n - k ) :<br>        result = min ( result , arr [ i + k - 1 ] - arr [ i ] )<br>    return result<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkDivisibility ( num ) :<br>    length = len ( num )<br>    if ( length == 1 and num [ 0 ] == '0' ) :<br>        return True<br>    if ( length % 3 == 1 ) :<br>        num = str ( num ) + "00"<br>        length += 2<br>    elif ( length % 3 == 2 ) :<br>        num = str ( num ) + "0"<br>        length += 1<br>    sum = 0<br>    p = 1<br>    for i in range ( length - 1 , - 1 , - 1 ) :<br>        group = 0<br>        group += ord ( num [ i ] ) - ord ( '0' )<br>        i -= 1<br>        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10<br>        i -= 1<br>        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100<br>        sum = sum + group * p<br>        p *= ( - 1 )<br>    sum = abs ( sum )<br>    return ( sum % 13 == 0 )<br></td>
    <td>translated code: <br><br> def checkDivisibility ( num ) :<br>    length = len ( num )<br>    if length == 1 and num [ 0 ] == '0' :<br>        return True<br>    if length % 3 == 1 :<br>        num += '00'<br>        length += 2<br>    elif length % 3 == 2 :<br>        num += '0'<br>        length += 1<br>    sum , p = 0 , 1<br>    for i in range ( length - 1 , - 1 , - 1 ) :<br>        group = 0<br>        group += num [ i ] - '0'<br>        group += ( num [ i ] - '0' ) * 10<br>        group += ( num [ i ] - '0' ) * 100<br>        sum = sum + group * p<br>        p *= ( - 1 )<br>    sum = abs ( sum )<br>    return ( sum % 13 == 0 )<br></td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSumSimple ( mat , k ) :<br>    if ( k > n ) :<br>        return<br>    for i in range ( n - k + 1 ) :<br>        for j in range ( n - k + 1 ) :<br>            sum = 0<br>            for p in range ( i , k + i ) :<br>                for q in range ( j , k + j ) :<br>                    sum += mat [ p ] [ q ]<br>            print ( sum , end = " " )<br>        print ( )<br></td>
    <td>translated code: <br><br> def printSumSimple ( mat , k ) :<br>    if k > n :<br>        return<br>    for i in range ( n - k + 1 ) :<br>        for j in range ( n - k + 1 ) :<br>            sum = 0<br>            for p in range ( i , k + i ) :<br>                for q in range ( j , k + j ) :<br>                    sum += mat [ p ] [ q ]<br>                print ( sum , end = ' ' )<br>            print ( )<br></td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxOverlap ( start , end ) :<br>    n = len ( start )<br>    maxa = max ( start )<br>    maxb = max ( end )<br>    maxc = max ( maxa , maxb )<br>    x = ( maxc + 2 ) * [ 0 ]<br>    cur = 0 ; idx = 0<br>    for i in range ( 0 , n ) :<br>        x [ start [ i ] ] += 1<br>        x [ end [ i ] + 1 ] -= 1<br>    maxy = - 1<br>    for i in range ( 0 , maxc + 1 ) :<br>        cur += x [ i ]<br>        if maxy < cur :<br>            maxy = cur<br>            idx = i<br>    print ( "Maximum value is: {0:d}".format ( maxy ) , " at position: {0:d}".format ( idx ) )<br></td>
    <td>translated code: <br><br> def max_overlap ( start , end , n ) :<br>    maxa = sum ( [ x for x in start if x != end ] )<br>    maxb = sum ( [ x for x in end if x != start ] )<br>    maxc = max ( [ maxa , maxb ] )<br>    x = [ 0 ] * ( maxc + 2 )<br>    cur , idx = 0 , 0<br>    for i in range ( n ) :<br>        yield x [ start [ i ] ]<br>        del x [ end [ i ] + 1 ]<br>    maxy = int ( 0 )<br>    for i in range ( 0 , maxc ) :<br>        cur += x [ i ]<br>        if maxy < cur :<br>            maxy = cur<br>            idx = i<br>    print ( "Maximum value is:" , maxy , " at position: " , idx , "" )<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSumWO3Consec ( n ) :<br>    if ( sum [ n ] != - 1 ) :<br>        return sum [ n ]<br>    if ( n == 0 ) :<br>        sum [ n ] = 0<br>        return sum [ n ]<br>    if ( n == 1 ) :<br>        sum [ n ] = arr [ 0 ]<br>        return sum [ n ]<br>    if ( n == 2 ) :<br>        sum [ n ] = arr [ 1 ] + arr [ 0 ]<br>        return sum [ n ]<br>    sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) )<br>    return sum [ n ]<br></td>
    <td>translated code: <br><br> def max_sum_wo3_consec ( n ) :<br>    if sum [ n ] != - 1 :<br>        return sum [ n ]<br>    if n == 0 :<br>        return sum [ n ] = 0<br>    if n == 1 :<br>        return sum [ n ] = arr [ 0 ]<br>    if n == 2 :<br>        return sum [ n ] = arr [ 1 ] + arr [ 0 ]<br>    return sum [ n ] = max ( max ( max_sum_wo3_consec ( n - 1 ) , max_sum_wo3_consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + max_sum_wo3_consec ( n - 3 ) )<br></td>
  </tr><tr>
    <th>C_PROGRAM_ADDITION_TWO_MATRICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def add ( A , B , C ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]<br></td>
    <td>translated code: <br><br> def add ( A , B , C ) :<br>    i , j = 0 , 0<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            C [ i , j ] = A [ i , j ] + B [ i , j ]<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxAverage ( arr , n , k ) :<br>    if ( k > n ) :<br>        return - 1<br>    sum = arr [ 0 ]<br>    for i in range ( 1 , k ) :<br>        sum += arr [ i ]<br>    max_sum = sum<br>    max_end = k - 1<br>    for i in range ( k , n ) :<br>        sum = sum + arr [ i ] - arr [ i - k ]<br>        if ( sum > max_sum ) :<br>            max_sum = sum<br>            max_end = i<br>    return max_end - k + 1<br></td>
    <td>translated code: <br><br> def find_max_average ( arr , n , k ) :<br>    if k > n :<br>        return - 1<br>    sum = arr [ 0 ]<br>    for i in range ( k ) :<br>        sum += arr [ i ]<br>    max_sum , max_end = sum , k - 1<br>    for i in range ( k , n ) :<br>        sum = sum + arr [ i ] - arr [ i - k ]<br>        if sum > max_sum :<br>            max_sum = sum<br>            max_end = i<br>    return max_end - k + 1<br></td>
  </tr><tr>
    <th>FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def center ( x1 , x2 , y1 , y2 ) :<br>    print ( int ( ( x1 + x2 ) / 2 ) , end = "" )<br>    print ( "," , int ( ( y1 + y2 ) / 2 ) )<br></td>
    <td>translated code: <br><br> def center ( x1 , x2 , y1 , y2 ) :<br>    print ( float ( x1 + x2 ) / 2 , float ( y1 + y2 ) / 2 )<br></td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNonDecreasing ( n ) :<br>    dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ]<br>    for i in range ( 10 ) :<br>        dp [ i ] [ 1 ] = 1<br>    for digit in range ( 10 ) :<br>        for len in range ( 2 , n + 1 ) :<br>            for x in range ( digit + 1 ) :<br>                dp [ digit ] [ len ] += dp [ x ] [ len - 1 ]<br>    count = 0<br>    for i in range ( 10 ) :<br>        count += dp [ i ] [ n ]<br>    return count<br></td>
    <td>translated code: <br><br> def count_non_decreasing ( n ) :<br>    dp = { }<br>    for i in range ( 10 ) :<br>        dp [ i ] [ 1 ] = 1<br>    for digit in range ( 0 , 9 ) :<br>        for len in range ( 2 , n + 1 ) :<br>            for x in range ( 0 , digit ) :<br>                dp [ digit ] [ len ] += dp [ x ] [ len - 1 ]<br>    count = 0<br>    for i in range ( 10 ) :<br>        count += dp [ i ] [ n ]<br>    return count<br></td>
  </tr><tr>
    <th>PRINT_REVERSE_STRING_REMOVING_VOWELS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def replaceOriginal ( s , n ) :<br>    r = [ ' ' ] * n<br>    for i in range ( n ) :<br>        r [ i ] = s [ n - 1 - i ]<br>        if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 'i' and s [ i ] != 'o' and s [ i ] != 'u' ) :<br>            print ( r [ i ] , end = "" )<br>    print ( )<br></td>
    <td>translated code: <br><br> def replace_original ( s , n ) :<br>    r = [ s [ n - 1 - i ] for i in range ( n ) ]<br>    if s [ i ] not in [ 'a' , 'e' , 'i' , 'o' , 'u' ] :<br>        print ( r [ i ] )<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMissing ( a , b , n , m ) :<br>    s = dict ( )<br>    for i in range ( m ) :<br>        s [ b [ i ] ] = 1<br>    for i in range ( n ) :<br>        if a [ i ] not in s.keys ( ) :<br>            print ( a [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def find_missing ( a , b , n , m ) :<br>    s = set ( )<br>    for i in range ( m ) :<br>        s.add ( b [ i ] )<br>    for i in range ( n ) :<br>        if not s.intersection ( a [ i ] ) :<br>            print ( a [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countStr ( n , bCount , cCount ) :<br>    if ( bCount < 0 or cCount < 0 ) :<br>        return 0<br>    if ( n == 0 ) :<br>        return 1<br>    if ( bCount == 0 and cCount == 0 ) :<br>        return 1<br>    res = countStr ( n - 1 , bCount , cCount )<br>    res += countStr ( n - 1 , bCount - 1 , cCount )<br>    res += countStr ( n - 1 , bCount , cCount - 1 )<br>    return res<br></td>
    <td>translated code: <br><br> def count_str ( n , b_count , c_count ) :<br>    if b_count < 0 or c_count < 0 :<br>        return 0<br>    if n == 0 :<br>        return 1<br>    if b_count == 0 and c_count == 0 :<br>        return 1<br>    res = count_str ( n - 1 , b_count , c_count )<br>    res += count_str ( n - 1 , b_count - 1 , c_count )<br>    res += count_str ( n - 1 , b_count , c_count - 1 )<br>    return res<br></td>
  </tr><tr>
    <th>GOLD_MINE_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMaxGold ( gold , m , n ) :<br>    goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ]<br>    for col in range ( n - 1 , - 1 , - 1 ) :<br>        for row in range ( m ) :<br>            if ( col == n - 1 ) :<br>                right = 0<br>            else :<br>                right = goldTable [ row ] [ col + 1 ]<br>            if ( row == 0 or col == n - 1 ) :<br>                right_up = 0<br>            else :<br>                right_up = goldTable [ row - 1 ] [ col + 1 ]<br>            if ( row == m - 1 or col == n - 1 ) :<br>                right_down = 0<br>            else :<br>                right_down = goldTable [ row + 1 ] [ col + 1 ]<br>            goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down )<br>    res = goldTable [ 0 ] [ 0 ]<br>    for i in range ( 1 , m ) :<br>        res = max ( res , goldTable [ i ] [ 0 ] )<br>    return res<br></td>
    <td>translated code: <br><br> def getMaxGold ( gold , m , n ) :<br>    goldTable = [ [ 0 ] * m , [ 0 ] * n ]<br>    for rows in goldTable :<br>        del rows [ 0 ]<br>    for col in range ( n - 1 , - 1 , - 1 ) :<br>        for row in range ( m ) :<br>            right = ( col == n - 1 )<br>            right_up = ( row == 0 or col == n - 1 )<br>            right_down = ( row == m - 1 or col == n - 1 )<br>            goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ;<br>    res = goldTable [ 0 ] [ 0 ]<br>    for i in range ( 1 , m ) :<br>        res = max ( res , goldTable [ i ] [ 0 ] )<br>    return res<br></td>
  </tr><tr>
    <th>COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( n ) :<br>    dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]<br>    dp [ 0 ] [ 1 ] = 1<br>    dp [ 1 ] [ 1 ] = 2<br>    for i in range ( 2 , n + 1 ) :<br>        dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]<br>        dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] )<br>    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]<br></td>
    <td>translated code: <br><br> def countWays ( n ) :<br>    dp = [ [ 0 ] * n + [ 1 ] * n + [ 2 ] * n + [ 3 ] * n + [ 4 ] * n + [ 5 ] * n + [ 6 ] * n + [ 7 ] * n + [ 8 ] * n + [ 9 ] * n + [ 10 ] * n + [ 11 ] * n + [ 12 ] * n + [ 13 ] * n + [ 14 ] * n + [ 15 ] * n + [ 16 ] * n + [ 17 ] * n + [ 18 ] * n + [ 19 ] * n + [ 20 ] * n + [ 21 ] * n + [ 22 ] * n + [ 23 ] * n + [ 24 ] * n + [ 25 ] * n + [ 26 ] * n + [ 27 ] * n + [ 28 ] * n + [ 29 ] * n + [ 30 ] * n + [ 31 ] * n + [ 32 ] * n + [ 33 ] * n + [ 34 ] * n + [ 35 ] * n + [ 36 ] * n + [ 37 ] * n + [ 38 ] * n + [ 39 ] * n + [ 40 ] * n + [ 41 ] * n + [ 42 ] * n + [ 39 ] * n + [ 42 ] * n + [ 39 ] * n + [ 40 ] * n + [ 41 ] * n + [ 42 ] * n + [ 39 ] * n + [ 41 ] * n + [ 42 ] * n + [ 39 ] * n + [ 41 ] * n + [ 42 ] * n + [ 39 ] * n + [ 39 ] * n + [ 41 ] * n + [ 42 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [ 39 ] * n + [</td>
  </tr><tr>
    <th>RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxProduct ( arr , n ) :<br>    if ( n < 2 ) :<br>        print ( "No pairs exists" )<br>        return<br>    if ( n == 2 ) :<br>        print ( arr [ 0 ] , " " , arr [ 1 ] )<br>        return<br>    posa = 0<br>    posb = 0<br>    nega = 0<br>    negb = 0<br>    for i in range ( n ) :<br>        if ( arr [ i ] > posa ) :<br>            posb = posa<br>            posa = arr [ i ]<br>        elif ( arr [ i ] > posb ) :<br>            posb = arr [ i ]<br>        if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) :<br>            negb = nega<br>            nega = arr [ i ]<br>        elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) :<br>            negb = arr [ i ]<br>    if ( nega * negb > posa * posb ) :<br>        print ( "Max product pair is {" , nega , ", " , negb , "}" )<br>    else :<br>        print ( "Max product pair is {" , posa , ", " , posb , "}" )<br></td>
    <td>translated code: <br><br> def max_product ( arr , n ) :<br>    if n < 2 :<br>        print ( "No pairs exists" )<br>        return<br>    if n == 2 :<br>        print ( arr [ 0 ] , arr [ 1 ] )<br>        return<br>    posa , posb = int ( arr [ 0 ] ) , int ( arr [ 1 ] )<br>    nega , negb = int ( arr [ 0 ] ) , int ( arr [ 1 ] )<br>    for i in range ( n ) :<br>        if arr [ i ] > posa :<br>            posb = posa<br>            posa = arr [ i ]<br>        elif arr [ i ] > posb :<br>            posb = arr [ i ]<br>        if arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) :<br>            negb = nega<br>            nega = arr [ i ]<br>        elif arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) :<br>            negb = arr [ i ]<br>    if nega * negb > posa * posb :<br>        print ( """<br>                Max product pair is {<br>                    %d, %d}<br>                    """ % ( nega , negb ) )<br>    else :<br>        print ( """<br>                 Max product pair is {<br>                     %d, %d}""" % ( posa , posb ) )<br></td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getFirstSetBitPos ( n ) :<br>    return math.log2 ( n & - n ) + 1<br></td>
    <td>translated code: <br><br> def get_first_set_bit_pos ( n ) :<br>    return int ( ( math.log10 ( n & - n ) ) / math.log10 ( 2 ) ) + 1<br></td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestSubseqWithK ( str , k ) :<br>    n = len ( str )<br>    freq = [ 0 ] * MAX_CHARS<br>    for i in range ( n ) :<br>        freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1<br>    for i in range ( n ) :<br>        if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k ) :<br>            print ( str [ i ] , end = "" )<br></td>
    <td>translated code: <br><br> def longest_subseq_with_k ( str , k ) :<br>    n = len ( str )<br>    freq = [ 0 for i in range ( n ) ]<br>    for i in range ( n ) :<br>        if freq [ str [ i ] - 'a' ] >= k :<br>            print ( str [ i ] )<br></td>
  </tr><tr>
    <th>POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPossibleToMakeDivisible ( arr , n ) :<br>    remainder = 0<br>    for i in range ( 0 , n ) :<br>        remainder = ( remainder + arr [ i ] ) % 3<br>    return ( remainder == 0 )<br></td>
    <td>translated code: <br><br> def is_possible_to_make_divisible ( arr , n ) :<br>    remainder = 0<br>    for i in range ( n ) :<br>        remainder = ( remainder + arr [ i ] ) % 3<br>    return ( remainder == 0 )<br></td>
  </tr><tr>
    <th>AREA_SQUARE_CIRCUMSCRIBED_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find_Area ( r ) :<br>    return ( 2 * r * r )<br></td>
    <td>translated code: <br><br> def find_Area ( r ) :<br>    return ( 2 * r ** 2 )<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MaxDotProduct ( A , B , m , n ) :<br>    dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 , 1 ) :<br>        for j in range ( i , m + 1 , 1 ) :<br>            dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] )<br>    return dp [ n ] [ m ]<br></td>
    <td>translated code: <br><br> def MaxDotProduct ( A , B , m , n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    for row in dp :<br>        np.random.shuffle ( row )<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i , m + 1 ) :<br>            dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] )<br>    return dp [ n ] [ m ]<br></td>
  </tr><tr>
    <th>FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDistSum ( arr , n ) :<br>    Sum = sum ( arr )<br>    dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        dp [ i ] [ 0 ] = True<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ i ] [ arr [ i - 1 ] ] = True<br>        for j in range ( 1 , Sum + 1 ) :<br>            if ( dp [ i - 1 ] [ j ] == True ) :<br>                dp [ i ] [ j ] = True<br>                dp [ i ] [ j + arr [ i - 1 ] ] = True<br>    for j in range ( Sum + 1 ) :<br>        if ( dp [ n ] [ j ] == True ) :<br>            print ( j , end = " " )<br></td>
    <td>translated code: <br><br> def print_dist_sum ( arr , n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    dp = [ [ False ] * ( n + 1 ) + [ sum + 1 ] * ( n + 1 ) for i in range ( n + 1 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        dp [ i ] [ 0 ] = True<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ i ] [ arr [ i - 1 ] ] = True<br>        for j in range ( 1 , sum + 1 ) :<br>            if dp [ i - 1 ] [ j ] == True :<br>                dp [ i ] [ j ] = True<br>                dp [ i ] [ j + arr [ i - 1 ] ] = True<br>    for j in range ( 0 , sum + 1 ) :<br>        if dp [ n ] [ j ] == True :<br>            print ( j , end = ' ' )<br></td>
  </tr><tr>
    <th>SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def splitString ( str ) :<br>    alpha = ""<br>    num = ""<br>    special = ""<br>    for i in range ( len ( str ) ) :<br>        if ( str [ i ].isdigit ( ) ) :<br>            num = num + str [ i ]<br>        elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( str [ i ] >= 'a' and str [ i ] <= 'z' ) ) :<br>            alpha += str [ i ]<br>        else :<br>            special += str [ i ]<br>    print ( alpha )<br>    print ( num )<br>    print ( special )<br></td>
    <td>translated code: <br><br> def splitString ( str ) :<br>    alpha , num , special = [ ] , [ ] , [ ]<br>    for c in str :<br>        if ord ( c ) < 128 :<br>            num.append ( c )<br>        elif ord ( c ) > 127 :<br>            alpha.append ( c )<br>        else :<br>            special.append ( c )<br>    print ( alpha )<br>    print ( num )<br>    print ( special )<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxAlternateSum ( arr , n ) :<br>    if ( n == 1 ) :<br>        return arr [ 0 ]<br>    dec = [ 0 for i in range ( n + 1 ) ]<br>    inc = [ 0 for i in range ( n + 1 ) ]<br>    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]<br>    flag = 0<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if ( arr [ j ] > arr [ i ] ) :<br>                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )<br>                flag = 1<br>            elif ( arr [ j ] < arr [ i ] and flag == 1 ) :<br>                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )<br>    result = - 2147483648<br>    for i in range ( n ) :<br>        if ( result < inc [ i ] ) :<br>            result = inc [ i ]<br>        if ( result < dec [ i ] ) :<br>            result = dec [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def max_alternate_sum ( arr , n ) :<br>    if n == 1 :<br>        return arr [ 0 ]<br>    dec = [ ]<br>    inc = [ ]<br>    dec = inc + [ arr [ 0 ] ]<br>    flag = 0<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ j ] > arr [ i ] :<br>                dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] )<br>                flag = 1<br>            elif arr [ j ] < arr [ i ] and flag == 1 :<br>                inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] )<br>    result = int ( '-' )<br>    for i in range ( n ) :<br>        if result < inc [ i ] :<br>            result = inc [ i ]<br>        if result < dec [ i ] :<br>            result = dec [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>FIND_PAIR_MAXIMUM_GCD_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxGCD ( arr , n ) :<br>    high = 0<br>    i = 0<br>    while i < n :<br>        high = max ( high , arr [ i ] )<br>        i = i + 1<br>    divisors = [ 0 ] * ( high + 1 )<br>    i = 0<br>    while i < n :<br>        j = 1<br>        while j <= math.sqrt ( arr [ i ] ) :<br>            if ( arr [ i ] % j == 0 ) :<br>                divisors [ j ] = divisors [ j ] + 1<br>                if ( j != arr [ i ] / j ) :<br>                    divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ]<br>                        + 1<br>            j = j + 1<br>        i = i + 1<br>    i = high<br>    while i >= 1 :<br>        if ( divisors [ i ] > 1 ) :<br>            return i<br>        i = i - 1<br>    return 1<br></td>
    <td>translated code: <br><br> def find_max_gcd ( arr , n ) :<br>    high = 0<br>    for i in range ( n ) :<br>        high = max ( high , arr [ i ] )<br>    divisors = [ 0 ] * ( high + 1 )<br>    for i in range ( n ) :<br>        for j in range ( 1 , math.sqrt ( arr [ i ] ) ) :<br>            if arr [ i ] % j == 0 :<br>                divisors [ j ] += 1<br>                if j != arr [ i ] / j :<br>                    divisors [ arr [ i ] / j ] += 1<br>    for i in range ( high , 1 , - 1 ) :<br>        if divisors [ i ] > 1 :<br>            return i<br>    return 1<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minCoins ( coins , m , V ) :<br>    table = [ 0 for i in range ( V + 1 ) ]<br>    table [ 0 ] = 0<br>    for i in range ( 1 , V + 1 ) :<br>        table [ i ] = sys.maxsize<br>    for i in range ( 1 , V + 1 ) :<br>        for j in range ( m ) :<br>            if ( coins [ j ] <= i ) :<br>                sub_res = table [ i - coins [ j ] ]<br>                if ( sub_res != sys.maxsize and sub_res + 1 < table [ i ] ) :<br>                    table [ i ] = sub_res + 1<br>    return table [ V ]<br></td>
    <td>translated code: <br><br> def minCoins ( coins , m , V ) :<br>    table = [ int ( i ) for i in range ( V + 1 ) ]<br>    for i in range ( 1 , V + 1 ) :<br>        table.append ( int ( coins [ i ] ) )<br>    for i in range ( 1 , V + 1 ) :<br>        for j in range ( m ) :<br>            if coins [ j ] <= i :<br>                sub_res = table [ i - coins [ j ] ]<br>                if sub_res != int ( i ) and sub_res + 1 < table [ i ] :<br>                    table [ i ] = sub_res + 1<br>    return table [ V ]<br></td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumAtKthLevel ( tree , k ) :<br>    level = - 1<br>    sum = 0<br>    n = len ( tree )<br>    for i in range ( n ) :<br>        if ( tree [ i ] == '(' ) :<br>            level += 1<br>        elif ( tree [ i ] == ')' ) :<br>            level -= 1<br>        else :<br>            if ( level == k ) :<br>                sum += ( ord ( tree [ i ] ) - ord ( '0' ) )<br>    return sum<br></td>
    <td>translated code: <br><br> def sum_at_kth_level ( tree , k ) :<br>    level = - 1<br>    sum = 0<br>    n = len ( tree )<br>    for i in range ( n ) :<br>        if tree [ i ] == '(' :<br>            level += 1<br>        elif tree [ i ] == ')' :<br>            level -= 1<br>        else :<br>            if level == k :<br>                sum += ( tree [ i ] - '0' )<br>    return sum<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcs ( X , Y , m , n ) :<br>    if m == 0 or n == 0 :<br>        return 0 <br>    elif X [ m - 1 ] == Y [ n - 1 ] :<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 ) <br>    else :<br>        return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) <br></td>
    <td>translated code: <br><br> def lcs ( X , Y , m , n ) :<br>    if m == 0 or n == 0 :<br>        return 0<br>    if X [ m - 1 ] == Y [ n - 1 ] :<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 )<br>    else :<br>        return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) )<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkSentence ( string ) :<br>    length = len ( string )<br>    if string [ 0 ] < 'A' or string [ 0 ] > 'Z' :<br>        return False<br>    if string [ length - 1 ] != '.' :<br>        return False<br>    prev_state = 0<br>    curr_state = 0<br>    index = 1<br>    while ( string [ index ] ) :<br>        if string [ index ] >= 'A' and string [ index ] <= 'Z' :<br>            curr_state = 0<br>        elif string [ index ] == ' ' :<br>            curr_state = 1<br>        elif string [ index ] >= 'a' and string [ index ] <= 'z' :<br>            curr_state = 2<br>        elif string [ index ] == '.' :<br>            curr_state = 3<br>        if prev_state == curr_state and curr_state != 2 :<br>            return False<br>        if prev_state == 2 and curr_state == 0 :<br>            return False<br>        if curr_state == 3 and prev_state != 1 :<br>            return True<br>        index += 1<br>        prev_state = curr_state<br>    return False<br></td>
    <td>translated code: <br><br> def check_sentence ( str ) :<br>    len ( str )<br>    if str [ 0 ] < 'A' or str [ 0 ] > 'Z' :<br>        return False<br>    if str [ len ( str ) - 1 ] != '.' :<br>        return False<br>    prev_state , curr_state = 0 , 0<br>    index = 1<br>    while index <= len ( str ) :<br>        if str [ index ] >= 'A' and str [ index ] <= 'Z' :<br>            curr_state = 0<br>        elif str [ index ] == ' ' :<br>            curr_state = 1<br>        elif str [ index ] >= 'a' and str [ index ] <= 'z' :<br>            curr_state = 2<br>        elif str [ index ] == '.' :<br>            curr_state = 3<br>        if prev_state == curr_state and curr_state != 2 :<br>            return False<br>        if prev_state == 2 and curr_state == 0 :<br>            return False<br>        if curr_state == 3 and prev_state != 1 :<br>            return ( index + 1 , str [ index ] )<br>        index += 1<br>        prev_state , curr_state = curr_state , curr_state<br>    return False<br></td>
  </tr><tr>
    <th>CHECK_DIVISIBILITY_LARGE_NUMBER_999</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isDivisible999 ( num ) :<br>    n = len ( num ) <br>    if ( n == 0 or num [ 0 ] == '0' ) :<br>        return true<br>    if ( ( n % 3 ) == 1 ) :<br>        num = "00" + num<br>    if ( ( n % 3 ) == 2 ) :<br>        num = "0" + num<br>    gSum = 0<br>    for i in range ( 0 , n , 3 ) :<br>        group = 0<br>        group += ( ord ( num [ i ] ) - 48 ) * 100<br>        group += ( ord ( num [ i + 1 ] ) - 48 ) * 10<br>        group += ( ord ( num [ i + 2 ] ) - 48 )<br>        gSum += group<br>    if ( gSum > 1000 ) :<br>        num = str ( gSum )<br>        n = len ( num )<br>        gSum = isDivisible999 ( num )<br>    return ( gSum == 999 )<br></td>
    <td>translated code: <br><br> def isDivisible999 ( num ) :<br>    n = len ( num )<br>    if n == 0 and num [ 0 ] == '0' :<br>        return True<br>    if n % 3 == 1 :<br>        num = '00' + num<br>    if n % 3 == 2 :<br>        num = '0' + num<br>    gSum = 0<br>    for i in range ( n ) :<br>        group = 0<br>        group += ( num [ i ] - '0' ) * 100<br>        group += ( num [ i ] - '0' ) * 10<br>        group += num [ i ] - '0'<br>        gSum += group<br>    if gSum > 1000 :<br>        num = str ( gSum )<br>        n = len ( num )<br>        gSum = isDivisible999 ( num ) and 1 or 0<br>    return ( gSum == 999 )<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( st ) :<br>    n = len ( st )<br>    digitSum = 0<br>    for i in range ( 0 , n ) :<br>        digitSum = digitSum + ( int ) ( st [ i ] )<br>    return ( digitSum % 9 == 0 )<br></td>
    <td>translated code: <br><br> def check ( str ) :<br>    n = len ( str )<br>    digitSum = 0<br>    for i in range ( n ) :<br>        digitSum += ( str [ i ] - '0' )<br>    return ( digitSum % 9 == 0 )<br></td>
  </tr><tr>
    <th>NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countTrees ( n ) :<br>    BT = [ 0 ] * ( n + 1 )<br>    BT [ 0 ] = BT [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( i ) :<br>            BT [ i ] += BT [ j ] * BT [ i - j - 1 ]<br>    return BT [ n ]<br></td>
    <td>translated code: <br><br> def countTrees ( n ) :<br>    BT = [ 0 ] * ( n + 1 )<br>    for i in range ( 0 , n + 1 ) :<br>        BT [ i ] = 0<br>    BT [ 0 ] = BT [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 0 , i + 1 ) :<br>            BT [ i ] += BT [ j ] * BT [ i - j - 1 ]<br>    return BT [ n ]<br></td>
  </tr><tr>
    <th>PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def swapUpperToLower ( arr ) :<br>    n = 4 <br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            temp = arr [ i ] [ j ] <br>            arr [ i ] [ j ] = arr [ j ] [ i ] <br>            arr [ j ] [ i ] = temp <br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            print ( arr [ i ] [ j ] , end = " " ) <br>        print ( " " ) <br></td>
    <td>translated code: <br><br> def swapUpperToLower ( arr ) :<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            temp = arr [ i ] [ j ]<br>            arr [ i ] [ j ] = arr [ j ] [ i ]<br>            arr [ j ] [ i ] = temp<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            print ( arr [ i ] [ j ] , end = ' ' )<br>        print ( )<br></td>
  </tr><tr>
    <th>FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( N , K ) :<br>    ans = 0 <br>    y = N / K <br>    x = N % K <br>    ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) <br>    return int ( ans ) <br></td>
    <td>translated code: <br><br> def find_sum ( N , K ) :<br>    ans = 0<br>    y = N / K<br>    x = N % K<br>    ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2<br>    return ans<br></td>
  </tr><tr>
    <th>WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def xorZero ( str ) :<br>    one_count = 0<br>    zero_count = 0<br>    n = len ( str )<br>    for i in range ( 0 , n , 1 ) :<br>        if ( str [ i ] == '1' ) :<br>            one_count += 1<br>        else :<br>            zero_count += 1<br>    if ( one_count % 2 == 0 ) :<br>        return zero_count<br>    return one_count<br></td>
    <td>translated code: <br><br> def xorZero ( s ) :<br>    one_count , zero_count = 0 , 0<br>    str = s.split ( ' ' )<br>    n = len ( str )<br>    for i in range ( n ) :<br>        if str [ i ] == '1' :<br>            one_count += 1<br>        else :<br>            zero_count += 1<br>    if one_count % 2 == 0 :<br>        return zero_count<br>    return one_count<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count ( S , m , n ) :<br>    if ( n == 0 ) :<br>        return 1<br>    if ( n < 0 ) :<br>        return 0 <br>    if ( m <= 0 and n >= 1 ) :<br>        return 0<br>    return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) <br></td>
    <td>translated code: <br><br> def count ( S , m , n ) :<br>    if n == 0 :<br>        return 1<br>    if n < 0 :<br>        return 0<br>    if m <= 0 and n >= 1 :<br>        return 0<br>    return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] )<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minSum ( arr , n ) :<br>    dp = [ 0 ] * n<br>    if ( n == 1 ) :<br>        return arr [ 0 ]<br>    if ( n == 2 ) :<br>        return min ( arr [ 0 ] , arr [ 1 ] )<br>    if ( n == 3 ) :<br>        return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) )<br>    if ( n == 4 ) :<br>        return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) )<br>    dp [ 0 ] = arr [ 0 ]<br>    dp [ 1 ] = arr [ 1 ]<br>    dp [ 2 ] = arr [ 2 ]<br>    dp [ 3 ] = arr [ 3 ]<br>    for i in range ( 4 , n ) :<br>        dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) )<br>    return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) )<br></td>
    <td>translated code: <br><br> def min_sum ( arr , n ) :<br>    dp = [ ]<br>    if n == 1 :<br>        return arr [ 0 ]<br>    if n == 2 :<br>        return min ( arr [ 0 ] , arr [ 1 ] )<br>    if n == 3 :<br>        return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) )<br>    if n == 4 :<br>        return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) )<br>    dp.append ( arr [ 0 ] )<br>    dp.append ( arr [ 1 ] )<br>    dp.append ( arr [ 2 ] )<br>    dp.append ( arr [ 3 ] )<br>    for i in range ( 4 , n ) :<br>        dp.append ( arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) )<br>    return min ( min ( dp [ - 1 ] , dp [ - 2 ] ) , min ( dp [ - 4 ] , dp [ - 3 ] ) )<br></td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxPathSum ( tri , m , n ) :<br>    for i in range ( m - 1 , - 1 , - 1 ) :<br>        for j in range ( i + 1 ) :<br>            if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) :<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j ]<br>            else :<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]<br>    return tri [ 0 ] [ 0 ]<br></td>
    <td>translated code: <br><br> def max_path_sum ( tri , m , n ) :<br>    for i in range ( m - 1 , - 1 , - 1 ) :<br>        for j in range ( 0 , i + 1 ) :<br>            if tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] :<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j ]<br>            else :<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]<br>    return tri [ 0 ] [ 0 ]<br></td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :<br>    for i in range ( 0 , n1 ) :<br>        for j in range ( 0 , n2 ) :<br>            for k in range ( 0 , n3 ) :<br>                if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) :<br>                    return True<br>    return False<br></td>
    <td>translated code: <br><br> def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :<br>    for i in range ( n1 ) :<br>        for j in range ( n2 ) :<br>            for k in range ( n3 ) :<br>                if a1 [ i ] + a2 [ j ] + a3 [ k ] == sum :<br>                    return True<br>    return False<br></td>
  </tr><tr>
    <th>TAIL_RECURSION_FIBONACCI</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def fib ( n , a = 0 , b = 1 ) :<br>    if n == 0 :<br>        return a<br>    if n == 1 :<br>        return b<br>    return fib ( n - 1 , b , a + b ) <br></td>
    <td>translated code: <br><br> def fib ( n , a , b ) :<br>    if n == 0 :<br>        return a<br>    if n == 1 :<br>        return b<br>    return fib ( n - 1 , b , a + b )<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isLucky ( n ) :<br>    ar = [ 0 ] * 10<br>    while ( n > 0 ) :<br>        digit = math.floor ( n % 10 )<br>        if ( ar [ digit ] ) :<br>            return 0<br>        ar [ digit ] = 1<br>        n = n / 10<br>    return 1<br></td>
    <td>translated code: <br><br> def isLucky ( n ) :<br>    arr = [ ]<br>    for i in range ( 10 ) :<br>        arr.append ( False )<br>    while n > 0 :<br>        digit = n % 10<br>        if arr [ digit ] :<br>            return False<br>        arr.append ( True )<br>        n = n / 10<br>    return True<br></td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSumTricky ( mat , k ) :<br>    global n<br>    if k > n :<br>        return<br>    stripSum = [ [ None ] * n for i in range ( n ) ]<br>    for j in range ( n ) :<br>        Sum = 0<br>        for i in range ( k ) :<br>            Sum += mat [ i ] [ j ]<br>        stripSum [ 0 ] [ j ] = Sum<br>        for i in range ( 1 , n - k + 1 ) :<br>            Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] )<br>            stripSum [ i ] [ j ] = Sum<br>    for i in range ( n - k + 1 ) :<br>        Sum = 0<br>        for j in range ( k ) :<br>            Sum += stripSum [ i ] [ j ]<br>        print ( Sum , end = " " )<br>        for j in range ( 1 , n - k + 1 ) :<br>            Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] )<br>            print ( Sum , end = " " )<br>        print ( )<br></td>
    <td>translated code: <br><br> def printSumTricky ( mat , k ) :<br>    if k > n :<br>        return<br>    stripSum = [ [ 0 ] * n for n in range ( n ) ]<br>    for j in range ( n ) :<br>        sum = 0<br>        for i in range ( k ) :<br>            sum += mat [ i ] [ j ]<br>        stripSum [ 0 ] [ j ] = sum<br>        for i in range ( 1 , n - k + 1 ) :<br>            sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] )<br>            stripSum [ i ] [ j ] = sum<br>    for i in range ( n - k + 1 ) :<br>        sum = 0<br>        for j in range ( k ) :<br>            sum += stripSum [ i ] [ j ]<br>        print ( sum , end = ' ' )<br>        for j in range ( 1 , n - k + 1 ) :<br>            sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] )<br>            print ( sum , end = ' ' )<br>        print ( )<br></td>
  </tr><tr>
    <th>SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minTime ( n , k , a ) :<br>    a.sort ( reverse = True ) <br>    minTime = 0 <br>    for i in range ( 0 , n , k ) :<br>        minTime += ( 2 * a [ i ] ) <br>    return minTime <br></td>
    <td>translated code: <br><br> def minTime ( n , k , a ) :<br>    temp = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if a [ i ] < a [ j ] :<br>                temp = a [ i ]<br>                a [ i ] , a [ j ] = a [ j ] , a [ i ]<br>                a [ j ] = temp<br>    minTime = 0<br>    for i in range ( 0 , n , k ) :<br>        minTime += ( 2 * a [ i ] )<br>    return minTime<br></td>
  </tr><tr>
    <th>ODD_EVEN_SORT_BRICK_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def oddEvenSort ( arr , n ) :<br>    isSorted = 0<br>    while isSorted == 0 :<br>        isSorted = 1<br>        temp = 0<br>        for i in range ( 1 , n - 1 , 2 ) :<br>            if arr [ i ] > arr [ i + 1 ] :<br>                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]<br>                isSorted = 0<br>        for i in range ( 0 , n - 1 , 2 ) :<br>            if arr [ i ] > arr [ i + 1 ] :<br>                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]<br>                isSorted = 0<br>    return<br></td>
    <td>translated code: <br><br> def oddEvenSort ( arr , n ) :<br>    isSorted = False<br>    while not isSorted :<br>        isSorted = True<br>        temp = 0<br>        for i in range ( 1 , n - 2 + 1 , 2 ) :<br>            if arr [ i ] > arr [ i + 1 ] :<br>                temp = arr [ i ]<br>                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i + 1 ]<br>                isSorted = False<br>        for i in range ( 0 , n - 2 + 1 , 2 ) :<br>            if arr [ i ] > arr [ i + 1 ] :<br>                temp = arr [ i ]<br>                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i + 1 ]<br>                isSorted = False<br>    return<br></td>
  </tr><tr>
    <th>RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMaxOccuringChar ( str ) :<br>    count = [ 0 ] * ASCII_SIZE<br>    max = - 1<br>    c = ''<br>    for i in str :<br>        count [ ord ( i ) ] += 1 <br>    for i in str :<br>        if max < count [ ord ( i ) ] :<br>            max = count [ ord ( i ) ]<br>            c = i<br>    return c<br></td>
    <td>translated code: <br><br> def getMaxOccuringChar ( str ) :<br>    count = [ 0 ] * ASCII_SIZE<br>    len = len ( str )<br>    for c in str :<br>        count [ c ] += 1<br>    max = - 1<br>    result = ' '<br>    for c in str :<br>        if max < count [ c ] :<br>            max = count [ c ]<br>            result = c<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def CountPairs ( n ) :<br>    k = n<br>    imin = 1<br>    ans = 0<br>    while ( imin <= n ) :<br>        imax = n / k<br>        ans += k * ( imax - imin + 1 )<br>        imin = imax + 1<br>        k = n / imin<br>    return ans<br></td>
    <td>translated code: <br><br> def CountPairs ( n ) :<br>    k = n<br>    imin = 1<br>    ans = 0<br>    while imin <= n :<br>        imax = n // k<br>        ans += k * ( imax - imin + 1 )<br>        imin = imax + 1<br>        k = n // imin<br>    return ans<br></td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printKDistinct ( arr , size , KthIndex ) :<br>    dict = { }<br>    vect = [ ]<br>    for i in range ( size ) :<br>        if ( arr [ i ] in dict ) :<br>            dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1<br>        else :<br>            dict [ arr [ i ] ] = 1<br>    for i in range ( size ) :<br>        if ( dict [ arr [ i ] ] > 1 ) :<br>            continue<br>        else :<br>            KthIndex = KthIndex - 1<br>        if ( KthIndex == 0 ) :<br>            return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def printKDistinct ( arr , n , k ) :<br>    h = { }<br>    for i in range ( n ) :<br>        if h.has_key ( arr [ i ] ) :<br>            h [ arr [ i ] ] = h [ arr [ i ] ] + 1<br>        else :<br>            h [ arr [ i ] ] = 1<br>    if len ( h ) < k :<br>        return - 1<br>    dist_count = 0<br>    for i in range ( n ) :<br>        if h [ arr [ i ] ] == 1 :<br>            dist_count += 1<br>        if dist_count == k :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def generate ( ones , zeroes , str , len1 ) :<br>    if ( len1 == len ( str ) ) :<br>        print ( str , end = " " )<br>        return<br>    generate ( ones + 1 , zeroes , str + "1" , len1 )<br>    if ( ones > zeroes ) :<br>        generate ( ones , zeroes + 1 , str + "0" , len1 )<br></td>
    <td>translated code: <br><br> def generate ( ones , zeroes , str , len ) :<br>    if len == len ( str ) :<br>        print ( str , end = ' ' )<br>        return<br>    generate ( ones + 1 , zeroes , str + '1' , len )<br>    if ones > zeroes :<br>        generate ( ones , zeroes + 1 , str + '0' , len )<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findElement ( arr , n , key ) :<br>    for i in range ( n ) :<br>        if ( arr [ i ] == key ) :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def findElement ( arr , n , key ) :<br>    for i in range ( n ) :<br>        if arr [ i ] == key :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcsOf3 ( X , Y , Z , m , n , o ) :<br>    L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ]<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            for k in range ( o + 1 ) :<br>                if ( i == 0 or j == 0 or k == 0 ) :<br>                    L [ i ] [ j ] [ k ] = 0<br>                elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) :<br>                    L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1<br>                else :<br>                    L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] )<br>    return L [ m ] [ n ] [ o ]<br></td>
    <td>translated code: <br><br> def lcsOf3 ( X , Y , Z , m , n , o ) :<br>    L = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * n + [ 0 ] * o + [ 0 ] * m + [ 0 ] * m +</td>
  </tr><tr>
    <th>MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSumSubarrayRemovingOneEle ( arr , n ) :<br>    fw = [ 0 for k in range ( n ) ]<br>    bw = [ 0 for k in range ( n ) ]<br>    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]<br>    for i in range ( n ) :<br>        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )<br>        max_so_far = max ( max_so_far , cur_max )<br>        fw [ i ] = cur_max<br>    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]<br>    i = n - 2<br>    while i >= 0 :<br>        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )<br>        max_so_far = max ( max_so_far , cur_max )<br>        bw [ i ] = cur_max<br>        i -= 1<br>    fans = max_so_far<br>    for i in range ( 1 , n - 1 ) :<br>        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )<br>    return fans<br></td>
    <td>translated code: <br><br> def max_sum_subarray_removing_one_ele ( arr , n ) :<br>    fw = [ ]<br>    bw = [ ]<br>    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]<br>    fw.append ( arr [ 0 ] )<br>    for i in range ( 1 , n ) :<br>        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )<br>        max_so_far = max ( max_so_far , cur_max )<br>        fw.append ( cur_max )<br>    cur_max = max_so_far = bw [ - 1 ] = arr [ n - 1 ]<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        cur_max = max ( arr [ i ] , cur_max + arr [ i ] )<br>        max_so_far = max ( max_so_far , cur_max )<br>        bw.append ( cur_max )<br>    fans = max_so_far<br>    for i in range ( 1 , n - 1 , - 1 ) :<br>        fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )<br>    return fans<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( n , m ) :<br>    count = [ ]<br>    for i in range ( n + 2 ) :<br>        count.append ( 0 )<br>    count [ 0 ] = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if ( i > m ) :<br>            count [ i ] = count [ i - 1 ] + count [ i - m ]<br>        elif ( i < m ) :<br>            count [ i ] = 1<br>        else :<br>            count [ i ] = 2<br>    return count [ n ]<br></td>
    <td>translated code: <br><br> def countWays ( n , m ) :<br>    count = [ 0 ] * ( n + 1 )<br>    i = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if i > m :<br>            count [ i ] = count [ i - 1 ] + count [ i - m ]<br>        elif i < m :<br>            count [ i ] = 1<br>        else :<br>            count [ i ] = 2<br>    return count [ n ]<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def middleOfThree ( a , b , c ) :<br>    if ( ( a < b and b < c ) or ( c < b and b < a ) ) :<br>        return b <br>    if ( ( b < a and a < c ) or ( c < a and a < b ) ) :<br>        return a <br>    else :<br>        return c<br></td>
    <td>translated code: <br><br> def middle_of_three ( a , b , c ) :<br>    if ( a < b and b < c ) or ( c < b and b < a ) :<br>        return b<br>    elif ( b < a and a < c ) or ( c < a and a < b ) :<br>        return a<br>    else :<br>        return c<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LCIS ( arr1 , n , arr2 , m ) :<br>    table = [ 0 ] * m<br>    for j in range ( m ) :<br>        table [ j ] = 0<br>    for i in range ( n ) :<br>        current = 0<br>        for j in range ( m ) :<br>            if ( arr1 [ i ] == arr2 [ j ] ) :<br>                if ( current + 1 > table [ j ] ) :<br>                    table [ j ] = current + 1<br>            if ( arr1 [ i ] > arr2 [ j ] ) :<br>                if ( table [ j ] > current ) :<br>                    current = table [ j ]<br>    result = 0<br>    for i in range ( m ) :<br>        if ( table [ i ] > result ) :<br>            result = table [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def LCIS ( arr1 , n , arr2 , m ) :<br>    table = [ 0 ] * m<br>    for j in range ( m ) :<br>        table [ j ] = 0<br>    for i in range ( n ) :<br>        current = 0<br>        for j in range ( m ) :<br>            if arr1 [ i ] == arr2 [ j ] :<br>                if current + 1 > table [ j ] :<br>                    table [ j ] = current + 1<br>                if arr1 [ i ] > arr2 [ j ] :<br>                    if table [ j ] > current :<br>                        current = table [ j ]<br>    result = 0<br>    for i in range ( m ) :<br>        if table [ i ] > result :<br>            result = table [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSumWO3Consec ( arr , n ) :<br>    sum = [ 0 for k in range ( n ) ]<br>    if n >= 1 :<br>        sum [ 0 ] = arr [ 0 ]<br>    if n >= 2 :<br>        sum [ 1 ] = arr [ 0 ] + arr [ 1 ]<br>    if n > 2 :<br>        sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) )<br>    for i in range ( 3 , n ) :<br>        sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] )<br>    return sum [ n - 1 ]<br></td>
    <td>translated code: <br><br> def max_sum_wo3_consec ( arr , n ) :<br>    sum = [ ]<br>    if n >= 1 :<br>        sum.append ( arr [ 0 ] )<br>    if n >= 2 :<br>        sum.append ( arr [ 0 ] + arr [ 1 ] )<br>    if n > 2 :<br>        sum.append ( max ( sum [ 1 : ] , max ( arr [ 1 : ] + arr [ 2 : ] , arr [ 0 ] + arr [ 2 ] ) ) )<br>    for i in range ( 3 , n ) :<br>        sum.append ( max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) )<br>    return sum [ - 1 ]<br></td>
  </tr><tr>
    <th>EULERIAN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def eulerian ( n , m ) :<br>    dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 0 , m + 1 ) :<br>            if ( i > j ) :<br>                if ( j == 0 ) :<br>                    dp [ i ] [ j ] = 1<br>                else :<br>                    dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) )<br>    return dp [ n ] [ m ]<br></td>
    <td>translated code: <br><br> def eulerian ( n , m ) :<br>    dp = [ [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] *</td>
  </tr><tr>
    <th>DOUBLE_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def doublefactorial ( n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return 1 <br>    return n * doublefactorial ( n - 2 ) <br></td>
    <td>translated code: <br><br> def doublefactorial ( n ) :<br>    if n == 0 or n == 1 :<br>        return 1<br>    return n * doublefactorial ( n - 2 )<br></td>
  </tr><tr>
    <th>REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rearrange ( arr , n ) :<br>    i = - 1<br>    for j in range ( n ) :<br>        if ( arr [ j ] < 0 ) :<br>            i += 1<br>            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]<br>    pos , neg = i + 1 , 0<br>    while ( pos < n and neg < pos and arr [ neg ] < 0 ) :<br>        arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ]<br>        pos += 1<br>        neg += 2<br></td>
    <td>translated code: <br><br> def rearrange ( arr , n ) :<br>    i , temp = - 1 , 0<br>    for j in range ( n ) :<br>        if arr [ j ] < 0 :<br>            i += 1<br>            temp = arr [ i ]<br>            arr [ i ] , arr [ j ] = arr [ j ] , temp<br>    pos , neg = i + 1 , 0<br>    while pos < n and neg < pos and arr [ neg ] < 0 :<br>        temp = arr [ neg ]<br>        arr [ neg ] , arr [ pos ] = arr [ pos ] , temp<br>        pos += 1<br>        neg += 2<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumSum ( arr , n , k ) :<br>    for i in range ( 1 , k + 1 ) :<br>        min = + 2147483647<br>        index = - 1<br>        for j in range ( n ) :<br>            if ( arr [ j ] < min ) :<br>                min = arr [ j ]<br>                index = j<br>        if ( min == 0 ) :<br>            break<br>        arr [ index ] = - arr [ index ]<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    return sum<br></td>
    <td>translated code: <br><br> def maximum_sum ( arr , n , k ) :<br>    for i in range ( 1 , k + 1 ) :<br>        min = + 2147483647<br>        index = - 1<br>        for j in range ( n ) :<br>            if arr [ j ] < min :<br>                min = arr [ j ]<br>                index = j<br>        if min == 0 :<br>            break<br>        arr [ index ] = - arr [ index ]<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    return sum<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ELEMENT_AFTER_PREFIX_IS_MUST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pre_compute ( a , n , index , k ) :<br>    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]<br>    for i in range ( n ) :<br>        if a [ i ] > a [ 0 ] :<br>            dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]<br>        else :<br>            dp [ 0 ] [ i ] = a [ i ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( n ) :<br>            if a [ j ] > a [ i ] and j > i :<br>                if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] :<br>                    dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ]<br>                else :<br>                    dp [ i ] [ j ] = dp [ i - 1 ] [ j ]<br>            else :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j ]<br>    return dp [ index ] [ k ]<br></td>
    <td>translated code: <br><br> def pre_compute ( a , n , index , k ) :<br>    dp = [ [ ] for i in range ( n ) ]<br>    for i in range ( n ) :<br>        if a [ i ] > a [ 0 ] :<br>            dp [ 0 ].append ( a [ i ] + a [ 0 ] )<br>        else :<br>            dp [ 0 ].append ( a [ i ] )<br>    for i in range ( 1 , n ) :<br>        for j in range ( n ) :<br>            if a [ j ] > a [ i ] and j > i :<br>                if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] :<br>                    dp [ i ].append ( dp [ i - 1 ] [ i ] + a [ j ] )<br>                else :<br>                    dp [ i ].append ( dp [ i - 1 ] [ j ] )<br>            else :<br>                dp [ i ].append ( dp [ i - 1 ] [ j ] )<br>    return dp [ index ] [ k ]<br></td>
  </tr><tr>
    <th>FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def myCopy ( s1 , s2 ) :<br>    for i in range ( len ( s1 ) ) :<br>        s2 [ i ] = s1 [ i ] <br></td>
    <td>translated code: <br><br> def my_copy ( s1 , s2 ) :<br>    i = 0<br>    for c in s1 :<br>        s2 [ i ] = c<br></td>
  </tr><tr>
    <th>GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubSequence ( str1 , str2 , m , n ) :<br>    j = 0<br>    i = 0<br>    while j < m and i < n :<br>        if str1 [ j ] == str2 [ i ] :<br>            j = j + 1<br>        i = i + 1<br>    return j == m<br></td>
    <td>translated code: <br><br> def isSubSequence ( str1 , str2 , m , n ) :<br>    j = 0<br>    for i in range ( n and j < m ) :<br>        if str1 [ j ] == str2 [ i ] :<br>            j += 1<br>    return ( j == m )<br></td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def unitnumber ( x , y ) :<br>    x = x % 10<br>    if y != 0 :<br>        y = y % 4 + 4<br>    return ( ( ( int ) ( math.pow ( x , y ) ) ) % 10 )<br></td>
    <td>translated code: <br><br> def unitnumber ( x , y = None ) :<br>    x = x % 10<br>    if y is not None :<br>        y = y % 4 + 4<br>    return ( ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y ) ) ) % 10 ) , ( ( int ( math.pow ( x , y )</td>
  </tr><tr>
    <th>PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def NextFit ( blockSize , m , processSize , n ) :<br>    allocation = [ - 1 ] * n<br>    j = 0<br>    for i in range ( n ) :<br>        while j < m :<br>            if blockSize [ j ] >= processSize [ i ] :<br>                allocation [ i ] = j<br>                blockSize [ j ] -= processSize [ i ]<br>                break<br>            j = ( j + 1 ) % m<br>    print ( "Process No.Process Size Block no." )<br>    for i in range ( n ) :<br>        print ( i + 1 , "         " , processSize [ i ] , end = "     " )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br></td>
    <td>translated code: <br><br> def NextFit ( blockSize , m , processSize , n ) :<br>    allocation , j = [ - 1 ] , 0<br>    print ( "\nProcess No.\tProcess Size\tBlock no.\n" )<br>    for i in range ( n ) :<br>        while j < m :<br>            if blockSize [ j ] >= processSize [ i ] :<br>                allocation [ i ] = j<br>                blockSize [ j ] -= processSize [ i ]<br>                break<br>            j = ( j + 1 ) % m<br>    print ( "\nProcess Size.\tProcess Size.\n" )<br>    for i in range ( n ) :<br>        print ( i + 1 , "\t\t" , processSize [ i ] , "\t\t" )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br>        print ( "" )<br></td>
  </tr><tr>
    <th>NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nobleInteger ( arr , size ) :<br>    for i in range ( 0 , size ) :<br>        count = 0<br>        for j in range ( 0 , size ) :<br>            if ( arr [ i ] < arr [ j ] ) :<br>                count += 1<br>        if ( count == arr [ i ] ) :<br>            return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def noble_integer ( arr ) :<br>    size = len ( arr )<br>    for i in range ( size ) :<br>        count = 0<br>        for j in range ( size ) :<br>            if arr [ i ] < arr [ j ] :<br>                count += 1<br>        if count == arr [ i ] :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minimumflip ( mat , n ) :<br>    transpose = [ [ 0 ] * n ] * n<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            transpose [ i ] [ j ] = mat [ j ] [ i ]<br>    flip = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if transpose [ i ] [ j ] != mat [ i ] [ j ] :<br>                flip += 1<br>    return int ( flip / 2 )<br></td>
    <td>translated code: <br><br> def minimumflip ( mat , n ) :<br>    transpose = [ ]<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            transpose.append ( mat [ j ] [ i ] )<br>    flip = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if transpose [ i ] [ j ] != mat [ i ] [ j ] :<br>                flip += 1<br>    return flip / 2<br></td>
  </tr><tr>
    <th>SEGREGATE_EVEN_ODD_NUMBERS_SET_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arrayEvenAndOdd ( arr , n ) :<br>    i = - 1<br>    j = 0<br>    while ( j != n ) :<br>        if ( arr [ j ] % 2 == 0 ) :<br>            i = i + 1<br>            arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]<br>        j = j + 1<br>    for i in arr :<br>        print ( str ( i ) + " " , end = '' )<br></td>
    <td>translated code: <br><br> def array_even_and_odd ( arr , n ) :<br>    i , j = - 1 , 0<br>    while j != n :<br>        if arr [ j ] % 2 == 0 :<br>            i += 1<br>            temp = arr [ i ]<br>            arr [ i ] , arr [ j ] = arr [ j ] , temp<br>        j += 1<br>    for k in range ( n ) :<br>        print ( arr [ k ] , end = ' ' )<br></td>
  </tr><tr>
    <th>DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def dfs ( List , node , arrival ) :<br>    print ( node )<br>    for i in range ( len ( List [ node ] ) ) :<br>        if ( List [ node ] [ i ] != arrival ) :<br>            dfs ( List , List [ node ] [ i ] , node )<br></td>
    <td>translated code: <br><br> def dfs ( list , node , arrival ) :<br>    print ( node )<br>    for i in range ( len ( list [ node ] ) ) :<br>        if list [ node ] [ i ] != arrival :<br>            dfs ( list , list [ node ] [ i ] , node )<br></td>
  </tr><tr>
    <th>HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def turnOffK ( n , k ) :<br>    if ( k <= 0 ) :<br>        return n<br>    return ( n & ~ ( 1 << ( k - 1 ) ) )<br></td>
    <td>translated code: <br><br> def turnOffK ( n , k ) :<br>    if k <= 0 :<br>        return n<br>    return ( n & ~ ( 1 << ( k - 1 ) ) )<br></td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count ( s , Len ) :<br>    global MAX<br>    cur = 0<br>    dig = 0<br>    Sum = [ 0 ] * MAX<br>    dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ]<br>    dp [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , Len + 1 ) :<br>        dig = int ( s [ i - 1 ] ) - 48<br>        cur += dig<br>        cur %= 3<br>        Sum [ i ] = cur<br>        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]<br>        dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ]<br>        dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ]<br>        dp [ i ] [ Sum [ i ] ] += 1<br>    ans = 0<br>    dprev = 0<br>    value = 0<br>    dprev2 = 0<br>    for i in range ( 1 , Len + 1 ) :<br>        dig = int ( s [ i - 1 ] ) - 48<br>        if dig == 8 :<br>            ans += 1<br>        if i - 2 >= 0 :<br>            dprev = int ( s [ i - 2 ] ) - 48<br>            value = dprev * 10 + dig<br>            if ( value % 8 == 0 ) and ( value % 3 != 0 ) :<br>                ans += 1<br>        if i - 3 >= 0 :<br>            dprev2 = int ( s [ i - 3 ] ) - 48<br>            dprev = int ( s [ i - 2 ] ) - 48<br>            value = ( dprev2 * 100 + dprev * 10 + dig )<br>            if value % 8 != 0 :<br>                continue<br>            ans += ( i - 2 )<br>            ans -= ( dp [ i - 3 ] [ Sum [ i ] ] )<br>    return ans<br></td>
    <td>translated code: <br><br> def count ( s , len ) :<br>    MAX = 1000<br>    cur , dig = 0 , 0<br>    sum = [ 0 ] * MAX<br>    dp = [ [ 0 ] * MAX , [ 0 ] * 3 ]<br>    dp [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , len ) :<br>        dig = ord ( s [ i - 1 ] ) - 48<br>        cur += dig<br>        cur %= 3<br>        sum [ i ] = cur<br>        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]<br>        dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ]<br>        dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ]<br>        dp [ i ] [ sum [ i ] ] += 1<br>    ans , dprev , value , dprev2 = 0 , 0 , 0 , 0<br>    for i in range ( 1 , len ) :<br>        dig = ord ( s [ i - 1 ] ) - 48<br>        if dig == 8 :<br>            ans += 1<br>        if i - 2 >= 0 :<br>            dprev = ord ( s [ i - 2 ] ) - 48<br>            value = dprev * 10 + dig<br>            if ( value % 8 == 0 ) :<br>                ans += 1<br>        if i - 3 >= 0 :<br>            dprev2 = ord ( s [ i - 3 ] ) - 48<br>            dprev = ord ( s [ i - 2 ] ) - 48<br>            value = dprev2 * 100 + dprev * 10 + dig<br>            if value % 8 != 0 :<br>                continue<br>            ans += ( i - 2 )<br>            ans -= ( dp [ i - 3 ] [ sum [ i ] ] )<br>    return ans<br></td>
  </tr><tr>
    <th>ADD_1_TO_A_GIVEN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def addOne ( x ) :<br>    return ( - ( ~ x ) ) <br></td>
    <td>translated code: <br><br> def add_one ( x ) :<br>    return ( - ( ~ x ) )<br></td>
  </tr><tr>
    <th>CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isAnBn ( str ) :<br>    n = len ( str )<br>    for i in range ( n ) :<br>        if ( str [ i ] != 'a' ) :<br>            break<br>    if ( i * 2 != n ) :<br>        return False<br>    for j in range ( i , n ) :<br>        if ( str [ j ] != 'b' ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def is_an_bn ( s ) :<br>    l = len ( s )<br>    if l % 2 == 1 :<br>        return False<br>    i = 0<br>    j = l - 1<br>    while i < j :<br>        if s [ i ] != 'a' or s [ j ] != 'b' :<br>            return False<br>        i += 1<br>        j -= 1<br>    return True<br></td>
  </tr><tr>
    <th>FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printFirstRepeating ( arr , n ) :<br>    Min = - 1<br>    myset = dict ( )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if arr [ i ] in myset.keys ( ) :<br>            Min = i<br>        else :<br>            myset [ arr [ i ] ] = 1<br>    if ( Min != - 1 ) :<br>        print ( "The first repeating element is" , arr [ Min ] )<br>    else :<br>        print ( "There are no repeating elements" )<br></td>
    <td>translated code: <br><br> def print_first_repeating ( arr ) :<br>    min = - 1<br>    set = set ( )<br>    for i in range ( len ( arr ) - 1 , - 1 , - 1 ) :<br>        if set.intersection ( arr [ i ] ) :<br>            min = i<br>        else :<br>            set.add ( arr [ i ] )<br>    if min != - 1 :<br>        print ( "The first repeating element is " + str ( arr [ min ] ) )<br>    else :<br>        print ( "There are no repeating elements" )<br></td>
  </tr><tr>
    <th>COST_BALANCE_PARANTHESES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def costToBalance ( s ) :<br>    if ( len ( s ) == 0 ) :<br>        print ( 0 )<br>    ans = 0<br>    o = 0<br>    c = 0<br>    for i in range ( len ( s ) ) :<br>        if ( s [ i ] == '(' ) :<br>            o += 1<br>        if ( s [ i ] == ')' ) :<br>            c += 1<br>    if ( o != c ) :<br>        return - 1<br>    a = [ 0 for i in range ( len ( s ) ) ]<br>    if ( s [ 0 ] == '(' ) :<br>        a [ 0 ] = 1<br>    else :<br>        a [ 0 ] = - 1<br>    if ( a [ 0 ] < 0 ) :<br>        ans += abs ( a [ 0 ] )<br>    for i in range ( 1 , len ( s ) ) :<br>        if ( s [ i ] == '(' ) :<br>            a [ i ] = a [ i - 1 ] + 1<br>        else :<br>            a [ i ] = a [ i - 1 ] - 1<br>        if ( a [ i ] < 0 ) :<br>            ans += abs ( a [ i ] )<br>    return ans<br></td>
    <td>translated code: <br><br> def costToBalance ( s ) :<br>    if len ( s ) == 0 :<br>        print ( 0 )<br>    ans = 0<br>    o , c = 0 , 0<br>    for c in s :<br>        if c == '(' :<br>            o += 1<br>        if c == ')' :<br>            c += 1<br>    if o != c :<br>        return - 1<br>    a = [ ]<br>    if s [ 0 ] == '(' :<br>        a.append ( 1 )<br>    else :<br>        a.append ( - 1 )<br>    if a [ 0 ] < 0 :<br>        ans += abs ( a [ 0 ] )<br>    for i in range ( 1 , len ( s ) ) :<br>        if s [ i ] == '(' :<br>            a.append ( a [ i - 1 ] + 1 )<br>        else :<br>            a.append ( a [ i - 1 ] - 1 )<br>        if a [ i ] < 0 :<br>            ans += abs ( a [ i ] )<br>    return ans<br></td>
  </tr><tr>
    <th>COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findWinner ( x , y , n ) :<br>    dp = [ 0 for i in range ( n + 1 ) ]<br>    dp [ 0 ] = False<br>    dp [ 1 ] = True<br>    for i in range ( 2 , n + 1 ) :<br>        if ( i - 1 >= 0 and not dp [ i - 1 ] ) :<br>            dp [ i ] = True<br>        elif ( i - x >= 0 and not dp [ i - x ] ) :<br>            dp [ i ] = True<br>        elif ( i - y >= 0 and not dp [ i - y ] ) :<br>            dp [ i ] = True<br>        else :<br>            dp [ i ] = False<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def find_winner ( x , y , n ) :<br>    dp = [ False ] * ( n + 1 )<br>    dp [ 0 ] = False<br>    dp [ 1 ] = True<br>    for i in range ( 2 , n + 1 ) :<br>        if i - 1 >= 0 and dp [ i - 1 ] == False :<br>            dp [ i ] = True<br>        elif i - x >= 0 and dp [ i - x ] == False :<br>            dp [ i ] = True<br>        elif i - y >= 0 and dp [ i - y ] == False :<br>            dp [ i ] = True<br>        else :<br>            dp [ i ] = False<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getTotalNumberOfSequences ( m , n ) :<br>    if m < n :<br>        return 0<br>    if n == 0 :<br>        return 1<br>    res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) )<br>    return res<br></td>
    <td>translated code: <br><br> def getTotalNumberOfSequences ( m , n ) :<br>    if m < n :<br>        return 0<br>    if n == 0 :<br>        return 1<br>    return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 )<br></td>
  </tr><tr>
    <th>FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDuplicates ( arr ) :<br>    dict = { }<br>    for ele in arr :<br>        try :<br>            dict [ ele ] += 1<br>        except :<br>            dict [ ele ] = 1<br>    for item in dict :<br>        if ( dict [ item ] > 1 ) :<br>            print ( item , end = " " )<br>    print ( "\n" )<br></td>
    <td>translated code: <br><br> def _print_duplicates ( arr , n ) :<br>    d = { }<br>    count = 0<br>    dup = False<br>    for i in range ( n ) :<br>        if d.has_key ( arr [ i ] ) :<br>            count = d [ arr [ i ] ]<br>            d [ arr [ i ] ] = count + 1<br>        else :<br>            d [ arr [ i ] ] = 1<br>    for key , value in d.items ( ) :<br>        if value > 1 :<br>            print ( key , end = ' ' )<br>            dup = True<br>    if not dup :<br>        print ( '-1' )<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLongestRepeatingSubSeq ( X , m , n ) :<br>    if ( dp [ m ] [ n ] != - 1 ) :<br>        return dp [ m ] [ n ]<br>    if ( m == 0 or n == 0 ) :<br>        dp [ m ] [ n ] = 0<br>        return dp [ m ] [ n ]<br>    if ( X [ m - 1 ] == X [ n - 1 ] and m != n ) :<br>        dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1<br>        return dp [ m ] [ n ]<br>    dp [ m ] [ n ] = max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) )<br>    return dp [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def find_longest_repetiating_subseq ( X , m , n ) :<br>    if dp [ m ] [ n ] != - 1 :<br>        return dp [ m ] [ n ]<br>    if m == 0 or n == 0 :<br>        return dp [ m ] [ n ] = 0<br>    if X [ m - 1 ] == X [ n - 1 ] and m != n :<br>        return dp [ m ] [ n ] = find_longest_repetiating_subseq ( X , m - 1 , n - 1 ) + 1<br>    return dp [ m ] [ n ] = max ( find_longest_repetiating_subseq ( X , m , n - 1 ) , find_longest_repetiating_subseq ( X , m - 1 , n ) )<br></td>
  </tr><tr>
    <th>COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findCount ( n , sum ) :<br>    start = math.pow ( 10 , n - 1 ) <br>    end = math.pow ( 10 , n ) - 1 <br>    count = 0 <br>    i = start <br>    while ( i <= end ) :<br>        cur = 0 <br>        temp = i <br>        while ( temp != 0 ) :<br>            cur += temp % 10 <br>            temp = temp // 10 <br>        if ( cur == sum ) :<br>            count = count + 1 <br>            i += 9 <br>        else :<br>            i = i + 1 <br>    print ( count ) <br></td>
    <td>translated code: <br><br> def _find_count ( n , sum ) :<br>    start = int ( math.pow ( 10 , n - 1 ) )<br>    end = int ( math.pow ( 10 , n ) ) - 1<br>    count = 0<br>    i = start<br>    while i < end :<br>        cur = 0<br>        temp = i<br>        while temp != 0 :<br>            cur += temp % 10<br>            temp = temp / 10<br>        if cur == sum :<br>            count += 1<br>            i += 9<br>        else :<br>            i += 1<br>    print ( count )<br></td>
  </tr><tr>
    <th>MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minimum_cost ( a , n ) :<br>    mn = sys.maxsize<br>    sum = 0<br>    for i in range ( n ) :<br>        mn = min ( a [ i ] , mn )<br>        sum += a [ i ]<br>    return mn * ( sum - mn )<br></td>
    <td>translated code: <br><br> def minimum_cost ( a , n ) :<br>    mn = sys.maxint<br>    sum = 0<br>    for i in range ( n ) :<br>        mn = min ( a [ i ] , mn )<br>        sum += a [ i ]<br>    return mn * ( sum - mn )<br></td>
  </tr><tr>
    <th>FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDivisors ( n ) :<br>    list = [ ]<br>    for i in range ( 1 , int ( math.sqrt ( n ) + 1 ) ) :<br>        if ( n % i == 0 ) :<br>            if ( n / i == i ) :<br>                print ( i , end = " " )<br>            else :<br>                print ( i , end = " " )<br>                list.append ( int ( n / i ) )<br>    for i in list [ : : - 1 ] :<br>        print ( i , end = " " )<br></td>
    <td>translated code: <br><br> def print_divisors ( n ) :<br>    v = [ ]<br>    for i in range ( 1 , math.sqrt ( n ) + 1 ) :<br>        if n % i == 0 :<br>            if n / i == i :<br>                print ( i , end = ' ' )<br>            else :<br>                print ( i , end = ' ' )<br>                v.append ( n / i )<br>    for i in range ( len ( v ) - 1 , - 1 , - 1 ) :<br>        print ( v [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def diagonalsquare ( mat , row , column ) :<br>    print ( "Diagonal one : " , end = "" )<br>    for i in range ( 0 , row ) :<br>        print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = "" )<br>    print ( "\n\nDiagonal two : " , end = "" )<br>    for i in range ( 0 , row ) :<br>        print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = "" )<br></td>
    <td>translated code: <br><br> def diagonalsquare ( mat , row , column ) :<br>    print ( " Diagonal one : " , end = ' ' )<br>    for i in range ( row ) :<br>        print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " , end = ' ' )<br>    print ( )<br>    print ( " Diagonal two : " , end = ' ' )<br>    for i in range ( row ) :<br>        print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " , end = ' ' )<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def polygonArea ( X , Y , n ) :<br>    area = 0.0<br>    j = n - 1<br>    for i in range ( 0 , n ) :<br>        area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )<br>        j = i<br>    return abs ( area // 2.0 )<br></td>
    <td>translated code: <br><br> def polygon_area ( X , Y , n ) :<br>    area = 0.0<br>    j = n - 1<br>    for i in range ( n ) :<br>        area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] )<br>        j = i<br>    return abs ( area / 2.0 )<br></td>
  </tr><tr>
    <th>RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findFrequency ( arr , n , left , right , element ) :<br>    count = 0<br>    for i in range ( left - 1 , right ) :<br>        if ( arr [ i ] == element ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def find_frequency ( arr , n , left , right , element ) :<br>    count = 0<br>    for i in range ( left - 1 , right ) :<br>        if arr [ i ] == element :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>SERIES_LARGEST_GCD_SUM_EQUALS_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def print_sequence ( n , k ) :<br>    b = int ( n / ( k * ( k + 1 ) / 2 ) ) <br>    if b == 0 :<br>        print ( "-1" )<br>    else :<br>        r = 1 <br>        x = 1<br>        while x ** 2 <= n :<br>            if n % x != 0 :<br>                continue <br>            elif x <= b and x > r :<br>                r = x<br>            elif n / x <= b and n / x > r :<br>                r = n / x<br>            x = x + 1<br>        i = 1<br>        while i < k :<br>            print ( r * i , end = " " )<br>            i = i + 1<br>        last_term = n - ( r * ( k * ( k - 1 ) / 2 ) )<br>        print ( last_term )<br></td>
    <td>translated code: <br><br> def print_sequence ( n , k ) :<br>    b = n // ( k * ( k + 1 ) // 2 )<br>    if b == 0 :<br>        print ( '-1' )<br>    else :<br>        r = 1<br>        for x in range ( 1 , n * x <= n ) :<br>            if n % x != 0 :<br>                continue<br>            if x <= b and x > r :<br>                r = x<br>            if n // x <= b and n // x > r :<br>                r = n // x<br>        for i in range ( 1 , k ) :<br>            print ( r * i + ' ' )<br>        res = n - ( r * ( k * ( k - 1 ) // 2 ) )<br>        print ( res )<br></td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :<br>    s = set ( )<br>    for i in range ( n1 ) :<br>        s.add ( a1 [ i ] )<br>    for i in range ( n2 ) :<br>        for j in range ( n3 ) :<br>            if sum - a2 [ i ] - a3 [ j ] in s :<br>                return True<br>    return False<br></td>
    <td>translated code: <br><br> def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :<br>    s = set ( )<br>    for i in range ( n1 ) :<br>        s.add ( a1 [ i ] )<br>    al = [ s [ i ] for i in range ( n2 ) ]<br>    for i in range ( n3 ) :<br>        for j in range ( n1 ) :<br>            if al.count ( sum - a2 [ i ] - a3 [ j ] ) & al.count ( sum - a2 [ i ] - a3 [ j ] ) != al [ - 1 ] :<br>                return True<br>    return False<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaximum ( arr , low , high ) :<br>    if low == high :<br>        return arr [ low ]<br>    if high == low + 1 and arr [ low ] >= arr [ high ] :<br>        return arr [ low ] <br>    if high == low + 1 and arr [ low ] < arr [ high ] :<br>        return arr [ high ]<br>    mid = ( low + high ) // 2<br>    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] :<br>        return arr [ mid ]<br>    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] :<br>        return findMaximum ( arr , low , mid - 1 )<br>    else :<br>        return findMaximum ( arr , mid + 1 , high )<br></td>
    <td>translated code: <br><br> def findMaximum ( arr , low , high ) :<br>    if low == high :<br>        return arr [ low ]<br>    if ( high == low + 1 ) and arr [ low ] >= arr [ high ] :<br>        return arr [ low ]<br>    if ( high == low + 1 ) and arr [ low ] < arr [ high ] :<br>        return arr [ high ]<br>    mid = ( low + high ) // 2<br>    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] :<br>        return arr [ mid ]<br>    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] :<br>        return findMaximum ( arr , low , mid - 1 )<br>    else :<br>        return findMaximum ( arr , mid + 1 , high )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def fib ( n , lookup ) :<br>    if n == 0 or n == 1 :<br>        lookup [ n ] = n<br>    if lookup [ n ] is None :<br>        lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup )<br>    return lookup [ n ]<br></td>
    <td>translated code: <br><br> def fib ( n ) :<br>    if lookup [ n ] == NIL :<br>        if n <= 1 :<br>            lookup [ n ] = n<br>        else :<br>            lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 )<br>    return lookup [ n ]<br></td>
  </tr><tr>
    <th>MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def power ( x , y , p ) :<br>    res = 1<br>    x = x % p<br>    while ( y > 0 ) :<br>        if ( ( y & 1 ) == 1 ) :<br>            res = ( res * x ) % p<br>        y = y >> 1<br>        x = ( x * x ) % p<br>    return res<br></td>
    <td>translated code: <br><br> def power ( x , y , p ) :<br>    res = 1<br>    x = x % p<br>    while y :<br>        if ( y & 1 ) == 1 :<br>            res = ( res * x ) % p<br>        y = y >> 1<br>        x = ( x * x ) % p<br>    return res<br></td>
  </tr><tr>
    <th>WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPowerOfTwo ( x ) :<br>    return ( x and ( not ( x & ( x - 1 ) ) ) )<br></td>
    <td>translated code: <br><br> def isPowerOfTwo ( x ) :<br>    return x != 0 and ( ( x & ( x - 1 ) ) == 0 )<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestString ( str1 , str2 ) :<br>    count1 = [ 0 ] * 26<br>    count2 = [ 0 ] * 26<br>    for i in range ( len ( str1 ) ) :<br>        count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1<br>    for i in range ( len ( str2 ) ) :<br>        count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1<br>    result = ""<br>    for i in range ( 26 ) :<br>        for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) :<br>            result = result + chr ( ord ( 'a' ) + i )<br>    print ( result )<br></td>
    <td>translated code: <br><br> def longest_string ( str1 , str2 ) :<br>    count1 , count2 = [ 0 ] * 26 , [ 0 ] * 26<br>    for i in range ( len ( str1 ) ) :<br>        count1 [ str1 [ i ] - 'a' ] += 1<br>    for i in range ( len ( str2 ) ) :<br>        count2 [ str2 [ i ] - 'a' ] += 1<br>    result = ""<br>    for i in range ( 26 ) :<br>        for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) :<br>            result += chr ( 'a' + str ( i ) )<br>    print ( result )<br></td>
  </tr><tr>
    <th>DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find_difference ( arr , n , m ) :<br>    max = 0 ; min = 0<br>    arr.sort ( ) <br>    j = n - 1<br>    for i in range ( m ) :<br>        min += arr [ i ]<br>        max += arr [ j ]<br>        j = j - 1<br>    return ( max - min )<br></td>
    <td>translated code: <br><br> def find_difference ( arr , n , m ) :<br>    max , min = 0 , 0<br>    arr.sort ( )<br>    for i , j in enumerate ( arr ) :<br>        min += arr [ i ]<br>        max += arr [ j ]<br>    return ( max - min )<br></td>
  </tr><tr>
    <th>PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printNumbers ( numbers ) :<br>    numbers = map ( str , numbers )<br>    result = [ ]<br>    for num in numbers :<br>        if ( '1' in num and '2' in num and '3' in num ) :<br>            result.append ( num )<br>    if not result :<br>        result = [ '-1' ]<br>    return sorted ( result ) <br></td>
    <td>translated code: <br><br> def _print_numbers ( numbers ) :<br>    array = [ ]<br>    for number in numbers :<br>        if _find_contains_one_two_three ( number ) :<br>            array.append ( number )<br>    array.sort ( )<br>    strbuf = ''<br>    items = array.items ( )<br>    for item in items :<br>        value = int ( item [ 1 ] )<br>        if len ( strbuf ) > 0 :<br>            strbuf += ', '<br>        strbuf += str ( value )<br>    return ( strbuf ) or '-1'<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lis ( arr ) :<br>    global maximum<br>    n = len ( arr )<br>    maximum = 1<br>    _lis ( arr , n )<br>    return maximum<br></td>
    <td>translated code: <br><br> def lis ( arr , n ) :<br>    global max_ref<br>    _lis ( arr , n )<br>    return max_ref<br></td>
  </tr><tr>
    <th>MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minRevolutions ( r , x1 , y1 , x2 , y2 ) :<br>    d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) )<br>    return math.ceil ( d // ( 2 * r ) )<br></td>
    <td>translated code: <br><br> def min_revolutions ( r , x1 , y1 , x2 , y2 ) :<br>    d = np.sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 )<br>    return np.ceil ( d / ( 2 * r ) )<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def areDisjoint ( set1 , set2 , m , n ) :<br>    for i in range ( 0 , m ) :<br>        for j in range ( 0 , n ) :<br>            if ( set1 [ i ] == set2 [ j ] ) :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def are_disjoint ( set1 , set2 ) :<br>    for i in range ( len ( set1 ) ) :<br>        for j in range ( len ( set2 ) ) :<br>            if set1 [ i ] == set2 [ j ] :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_SUM_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinSum ( num ) :<br>    sum = 0<br>    i = 2<br>    while ( i * i <= num ) :<br>        while ( num % i == 0 ) :<br>            sum += i<br>            num /= i<br>        i += 1<br>    sum += num<br>    return sum<br></td>
    <td>translated code: <br><br> def find_min_sum ( num ) :<br>    sum = 0<br>    for i in range ( 2 , num * i <= num + 1 ) :<br>        while num % i == 0 :<br>            sum += i<br>            num /= i<br>    sum += num<br>    return sum<br></td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def mostFrequent ( arr , n ) :<br>    arr.sort ( )<br>    max_count = 1 ; res = arr [ 0 ] ; curr_count = 1<br>    for i in range ( 1 , n ) :<br>        if ( arr [ i ] == arr [ i - 1 ] ) :<br>            curr_count += 1<br>        else :<br>            if ( curr_count > max_count ) :<br>                max_count = curr_count<br>                res = arr [ i - 1 ]<br>            curr_count = 1<br>    if ( curr_count > max_count ) :<br>        max_count = curr_count<br>        res = arr [ n - 1 ]<br>    return res<br></td>
    <td>translated code: <br><br> def most_frequent ( arr , n ) :<br>    arr.sort ( )<br>    max_count , res = 1 , arr [ 0 ]<br>    curr_count = 1<br>    for i in range ( 1 , n ) :<br>        if arr [ i ] == arr [ i - 1 ] :<br>            curr_count += 1<br>        else :<br>            if curr_count > max_count :<br>                max_count = curr_count<br>                res = arr [ i - 1 ]<br>            curr_count = 1<br>    if curr_count > max_count :<br>        max_count = curr_count<br>        res = arr [ n - 1 ]<br>    return res<br></td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minXOR ( arr , n ) :<br>    arr.sort ( )<br>    minXor = int ( sys.float_info.max )<br>    val = 0<br>    for i in range ( 0 , n - 1 ) :<br>        val = arr [ i ] ^ arr [ i + 1 ] <br>        minXor = min ( minXor , val ) <br>    return minXor<br></td>
    <td>translated code: <br><br> def minXOR ( arr , n ) :<br>    arr = np.array ( arr )<br>    minXor = np.inf<br>    val = 0<br>    for i in range ( n - 1 ) :<br>        val = arr [ i ] ^ arr [ i + 1 ]<br>        minXor = min ( minXor , val )<br>    return minXor<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_PRODUCT_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minproduct ( a , b , n , k ) :<br>    diff = 0<br>    res = 0<br>    for i in range ( n ) :<br>        pro = a [ i ] * b [ i ]<br>        res = res + pro<br>        if ( pro < 0 and b [ i ] < 0 ) :<br>            temp = ( a [ i ] + 2 * k ) * b [ i ]<br>        elif ( pro < 0 and a [ i ] < 0 ) :<br>            temp = ( a [ i ] - 2 * k ) * b [ i ]<br>        elif ( pro > 0 and a [ i ] < 0 ) :<br>            temp = ( a [ i ] + 2 * k ) * b [ i ]<br>        elif ( pro > 0 and a [ i ] > 0 ) :<br>            temp = ( a [ i ] - 2 * k ) * b [ i ]<br>        d = abs ( pro - temp )<br>        if ( d > diff ) :<br>            diff = d<br>    return res - diff<br></td>
    <td>translated code: <br><br> def minproduct ( a , b , n , k ) :<br>    diff , res = 0 , 0<br>    temp = 0<br>    for i in range ( n ) :<br>        pro = a [ i ] * b [ i ]<br>        res = res + pro<br>        if pro < 0 and b [ i ] < 0 :<br>            temp = ( a [ i ] + 2 * k ) * b [ i ]<br>        elif pro < 0 and a [ i ] < 0 :<br>            temp = ( a [ i ] - 2 * k ) * b [ i ]<br>        elif pro > 0 and a [ i ] < 0 :<br>            temp = ( a [ i ] + 2 * k ) * b [ i ]<br>        elif pro > 0 and a [ i ] > 0 :<br>            temp = ( a [ i ] - 2 * k ) * b [ i ]<br>        d = abs ( pro - temp )<br>        if d > diff :<br>            diff = d<br>    return res - diff<br></td>
  </tr><tr>
    <th>FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def russianPeasant ( a , b ) :<br>    res = 0<br>    while ( b > 0 ) :<br>        if ( b & 1 ) :<br>            res = res + a<br>        a = a << 1<br>        b = b >> 1<br>    return res<br></td>
    <td>translated code: <br><br> def russian_peasant ( a , b ) :<br>    res = 0<br>    while b :<br>        if ( b & 1 ) :<br>            res = res + a<br>        a = a << 1<br>        b = b >> 1<br>    return res<br></td>
  </tr><tr>
    <th>DIVISIBILITY_9_USING_BITWISE_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isDivBy9 ( n ) :<br>    if ( n == 0 or n == 9 ) :<br>        return True<br>    if ( n < 9 ) :<br>        return False<br>    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )<br></td>
    <td>translated code: <br><br> def isDivBy9 ( n ) :<br>    if n == 0 or n == 9 :<br>        return True<br>    if n < 9 :<br>        return False<br>    return isDivBy9 ( int ( n >> 3 ) - int ( n & 7 ) )<br></td>
  </tr><tr>
    <th>CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isInorder ( arr , n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return True<br>    for i in range ( 1 , n , 1 ) :<br>        if ( arr [ i - 1 ] > arr [ i ] ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isInorder ( arr , n ) :<br>    if n == 0 or n == 1 :<br>        return True<br>    for i in range ( 1 , n ) :<br>        if arr [ i - 1 ] > arr [ i ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findPairs ( arr1 , arr2 , n , m , x ) :<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , m ) :<br>            if ( arr1 [ i ] + arr2 [ j ] == x ) :<br>                print ( arr1 [ i ] , arr2 [ j ] )<br></td>
    <td>translated code: <br><br> def find_pairs ( arr1 , arr2 , n , m , x ) :<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if arr1 [ i ] + arr2 [ j ] == x :<br>                print ( arr1 [ i ] , arr2 [ j ] )<br></td>
  </tr><tr>
    <th>BINARY_REPRESENTATION_OF_NEXT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextGreater ( num1 ) :<br>    l = len ( num1 ) <br>    num = list ( num1 ) <br>    i = l - 1 <br>    while ( i >= 0 ) :<br>        if ( num [ i ] == '0' ) :<br>            num [ i ] = '1' <br>            break <br>        else :<br>            num [ i ] = '0' <br>        i -= 1 <br>    num1 = ''.join ( num ) <br>    if ( i < 0 ) :<br>        num1 = '1' + num1 <br>    return num1 <br></td>
    <td>translated code: <br><br> def nextGreater ( num ) :<br>    l = len ( num )<br>    i = 0<br>    for i in range ( l - 1 , - 1 , - 1 ) :<br>        if num [ i ] == '0' :<br>            num = num [ : i ] + '1' + num [ i + 1 : ]<br>            break<br>        else :<br>            num = num [ : i ] + '0' + num [ i + 1 : ]<br>    if i < 0 :<br>        num = '1' + num<br>    return num<br></td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSubArray ( arr , n ) :<br>    sum = 0<br>    maxsize = - 1<br>    for i in range ( 0 , n - 1 ) :<br>        sum = - 1 if ( arr [ i ] == 0 ) else 1<br>        for j in range ( i + 1 , n ) :<br>            sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1<br>            if ( sum == 0 and maxsize < j - i + 1 ) :<br>                maxsize = j - i + 1<br>                startindex = i<br>    if ( maxsize == - 1 ) :<br>        print ( "No such subarray" ) <br>    else :<br>        print ( startindex , "to" , startindex + maxsize - 1 ) <br>    return maxsize<br></td>
    <td>translated code: <br><br> def findSubArray ( arr , n ) :<br>    sum = 0<br>    maxsize , startindex = - 1 , 0<br>    endindex = 0<br>    for i in range ( n - 1 ) :<br>        sum = ( arr [ i ] == 0 )<br>        for j in range ( i + 1 , n ) :<br>            if arr [ j ] == 0 :<br>                sum += - 1<br>            else :<br>                sum += 1<br>            if sum == 0 and maxsize < j - i + 1 :<br>                maxsize = j - i + 1<br>                startindex = i<br>    endindex = startindex + maxsize - 1<br>    if maxsize == - 1 :<br>        print ( "No such subarray" )<br>    else :<br>        print ( startindex , endindex )<br>    return maxsize<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( arr , n ) :<br>    result = 0<br>    Hash = set ( )<br>    for i in range ( n ) :<br>        Hash.add ( arr [ i ] )<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            product = arr [ i ] * arr [ j ]<br>            if product in ( Hash ) :<br>                result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def countPairs ( arr , n ) :<br>    result = 0<br>    Hash = set ( )<br>    for i in range ( n ) :<br>        Hash.add ( arr [ i ] )<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            product = arr [ i ] * arr [ j ]<br>            if Hash.intersection ( product ) :<br>                result += 1<br>    return result<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lps ( str ) :<br>    n = len ( str )<br>    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]<br>    for i in range ( n ) :<br>        L [ i ] [ i ] = 1<br>    for cl in range ( 2 , n + 1 ) :<br>        for i in range ( n - cl + 1 ) :<br>            j = i + cl - 1<br>            if str [ i ] == str [ j ] and cl == 2 :<br>                L [ i ] [ j ] = 2<br>            elif str [ i ] == str [ j ] :<br>                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2<br>            else :<br>                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) <br>    return L [ 0 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def lps ( seq ) :<br>    n = len ( seq )<br>    i , j , cl = 0 , 0 , 0<br>    L = [ [ 1 ] * n for i in range ( n ) ]<br>    for i in range ( n ) :<br>        L [ i ] [ i ] = 1<br>    for cl in range ( 2 , n + 1 ) :<br>        for i in range ( n - cl + 1 ) :<br>            j = i + cl - 1<br>            if seq [ i ] == seq [ j ] and cl == 2 :<br>                L [ i ] [ j ] = 2<br>            elif seq [ i ] == seq [ j ] :<br>                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2<br>            else :<br>                L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] )<br>    return L [ 0 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getInvCount ( arr , n ) :<br>    invcount = 0<br>    for i in range ( 1 , n - 1 ) :<br>        small = 0<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ i ] > arr [ j ] ) :<br>                small += 1<br>        great = 0 <br>        for j in range ( i - 1 , - 1 , - 1 ) :<br>            if ( arr [ i ] < arr [ j ] ) :<br>                great += 1<br>        invcount += great * small<br>    return invcount<br></td>
    <td>translated code: <br><br> def getInvCount ( arr , n ) :<br>    invcount = 0<br>    for i in range ( n - 1 ) :<br>        small = 0<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] > arr [ j ] :<br>                small += 1<br>        great = 0<br>        for j in range ( i - 1 , - 1 , - 1 ) :<br>            if arr [ i ] < arr [ j ] :<br>                great += 1<br>        invcount += great * small<br>    return invcount<br></td>
  </tr><tr>
    <th>DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isDivisibleBy10 ( bin ) :<br>    n = len ( bin )<br>    if ( bin [ n - 1 ] == '1' ) :<br>        return False<br>    sum = 0<br>    i = n - 2<br>    while i >= 0 :<br>        if ( bin [ i ] == '1' ) :<br>            posFromRight = n - i - 1<br>            if ( posFromRight % 4 == 1 ) :<br>                sum = sum + 2<br>            elif ( posFromRight % 4 == 2 ) :<br>                sum = sum + 4<br>            elif ( posFromRight % 4 == 3 ) :<br>                sum = sum + 8<br>            elif ( posFromRight % 4 == 0 ) :<br>                sum = sum + 6<br>        i = i - 1<br>    if ( sum % 10 == 0 ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def isDivisibleBy10 ( bin ) :<br>    n = len ( bin )<br>    if bin [ n - 1 ] == '1' :<br>        return False<br>    sum = 0<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if bin [ i ] == '1' :<br>            pos_from_right = n - i - 1<br>            if pos_from_right % 4 == 1 :<br>                sum = sum + 2<br>            elif pos_from_right % 4 == 2 :<br>                sum = sum + 4<br>            elif pos_from_right % 4 == 3 :<br>                sum = sum + 8<br>            elif pos_from_right % 4 == 0 :<br>                sum = sum + 6<br>    if sum % 10 == 0 :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubset ( arr1 , arr2 , m , n ) :<br>    i = 0<br>    j = 0<br>    if m < n :<br>        return 0<br>    arr1.sort ( )<br>    arr2.sort ( )<br>    while i < n and j < m :<br>        if arr1 [ j ] < arr2 [ i ] :<br>            j += 1<br>        elif arr1 [ j ] == arr2 [ i ] :<br>            j += 1<br>            i += 1<br>        elif arr1 [ j ] > arr2 [ i ] :<br>            return 0<br>    return False if i < n else True<br></td>
    <td>translated code: <br><br> def issubset ( arr1 , arr2 , m , n ) :<br>    i , j = 0 , 0<br>    if m < n :<br>        return False<br>    arr1.sort ( )<br>    arr2.sort ( )<br>    while i < n and j < m :<br>        if arr1 [ j ] < arr2 [ i ] :<br>            j += 1<br>        elif arr1 [ j ] == arr2 [ i ] :<br>            j += 1<br>            i += 1<br>        elif arr1 [ j ] > arr2 [ i ] :<br>            return False<br>    if i < n :<br>        return False<br>    else :<br>        return True<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubsetSum ( set , n , sum ) :<br>    subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] )<br>    for i in range ( n + 1 ) :<br>        subset [ i ] [ 0 ] = True<br>        for i in range ( 1 , sum + 1 ) :<br>            subset [ 0 ] [ i ] = False<br>        for i in range ( 1 , n + 1 ) :<br>            for j in range ( 1 , sum + 1 ) :<br>                if j < set [ i - 1 ] :<br>                    subset [ i ] [ j ] = subset [ i - 1 ] [ j ]<br>                if j >= set [ i - 1 ] :<br>                    subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] )<br>    return subset [ n ] [ sum ]<br></td>
    <td>translated code: <br><br> def is_subset_sum ( set , n , sum ) :<br>    subset = [ True for i in range ( sum + 1 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        subset [ 0 ] [ i ] = True<br>    for i in range ( 1 , sum + 1 ) :<br>        subset [ i ] [ 0 ] = False<br>    for i in range ( 1 , sum + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            subset [ i ] [ j ] = subset [ i ] [ j - 1 ]<br>            if i >= set [ j - 1 ] :<br>                subset [ i ] [ j ] = subset [ i ] [ j ] or subset [ i - set [ j - 1 ] ] [ j - 1 ]<br>    return subset [ sum ] [ n ]<br></td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def kthgroupsum ( k ) :<br>    return k * k * k<br></td>
    <td>translated code: <br><br> def kthgroupsum ( k ) :<br>    return k * k * k<br></td>
  </tr><tr>
    <th>THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def thirdLargest ( arr , arr_size ) :<br>    if ( arr_size < 3 ) :<br>        print ( " Invalid Input " )<br>        return<br>    first = arr [ 0 ]<br>    for i in range ( 1 , arr_size ) :<br>        if ( arr [ i ] > first ) :<br>            first = arr [ i ]<br>    second = - sys.maxsize<br>    for i in range ( 0 , arr_size ) :<br>        if ( arr [ i ] > second and arr [ i ] < first ) :<br>            second = arr [ i ]<br>    third = - sys.maxsize<br>    for i in range ( 0 , arr_size ) :<br>        if ( arr [ i ] > third and arr [ i ] < second ) :<br>            third = arr [ i ]<br>    print ( "The Third Largest" , "element is" , third )<br></td>
    <td>translated code: <br><br> def third_largest ( arr , arr_size ) :<br>    if arr_size < 3 :<br>        print ( " Invalid Input " )<br>        return<br>    first = arr [ 0 ]<br>    for i in range ( 1 , arr_size ) :<br>        if arr [ i ] > first :<br>            first = arr [ i ]<br>    second = int ( first )<br>    for i in range ( arr_size ) :<br>        if arr [ i ] > second and arr [ i ] < first :<br>            second = arr [ i ]<br>    third = int ( second )<br>    for i in range ( arr_size ) :<br>        if arr [ i ] > third and arr [ i ] < second :<br>            third = arr [ i ]<br>    print ( "The third Largest " "element is " , third )<br></td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumNodes ( l ) :<br>    leafNodeCount = math.pow ( 2 , l - 1 ) <br>    sumLastLevel = 0 <br>    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) <br>    sum = sumLastLevel * l <br>    return int ( sum ) <br></td>
    <td>translated code: <br><br> def sum_nodes ( l ) :<br>    leaf_node_count = math.pow ( 2 , l - 1 )<br>    sum_last_level = 0<br>    sum_last_level = ( leaf_node_count * ( leaf_node_count + 1 ) ) / 2<br>    sum = sum_last_level * l<br>    return sum<br></td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def middleOfThree ( a , b , c ) :<br>    x = a - b<br>    y = b - c<br>    z = a - c<br>    if x * y > 0 :<br>        return b<br>    elif ( x * z > 0 ) :<br>        return<br>    else :<br>        return a<br></td>
    <td>translated code: <br><br> def middle_of_three ( a , b , c ) :<br>    x = a - b<br>    y = b - c<br>    z = a - c<br>    if x * y > 0 :<br>        return b<br>    elif x * z > 0 :<br>        return c<br>    else :<br>        return a<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxTripletSum ( arr , n ) :<br>    maxA = - 100000000<br>    maxB = - 100000000<br>    maxC = - 100000000<br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] > maxA ) :<br>            maxC = maxB<br>            maxB = maxA<br>            maxA = arr [ i ]<br>        elif ( arr [ i ] > maxB ) :<br>            maxC = maxB<br>            maxB = arr [ i ]<br>        elif ( arr [ i ] > maxC ) :<br>            maxC = arr [ i ]<br>    return ( maxA + maxB + maxC )<br></td>
    <td>translated code: <br><br> def max_triplet_sum ( arr , n ) :<br>    max_a , max_b = - 100000000 , - 100000000<br>    max_c = - 100000000<br>    for i in range ( n ) :<br>        if arr [ i ] > max_a :<br>            max_c = max_b<br>            max_b = max_a<br>            max_a = arr [ i ]<br>        elif arr [ i ] > max_b :<br>            max_c = max_b<br>            max_b = arr [ i ]<br>        elif arr [ i ] > max_c :<br>            max_c = arr [ i ]<br>    return ( max_a , max_b , max_c )<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( arr1 , arr2 , m , n , x ) :<br>    count = 0<br>    us = set ( )<br>    for i in range ( m ) :<br>        us.add ( arr1 [ i ] )<br>    for j in range ( n ) :<br>        if x - arr2 [ j ] in us :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_pairs ( arr1 , arr2 , m , n , x ) :<br>    count = 0<br>    us = set ( )<br>    for i in range ( m ) :<br>        us.add ( arr1 [ i ] )<br>    for j in range ( n ) :<br>        if us.intersection ( arr2 [ j ] ) :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMinStepToReachEnd ( arr , N ) :<br>    visit = [ False for i in range ( N ) ]<br>    distance = [ 0 for i in range ( N ) ]<br>    digit = [ [ 0 for i in range ( N ) ] for j in range ( 10 ) ]<br>    for i in range ( 1 , N ) :<br>        digit [ arr [ i ] ].append ( i )<br>    distance [ 0 ] = 0<br>    visit [ 0 ] = True<br>    q = [ ]<br>    q.append ( 0 )<br>    while ( len ( q ) > 0 ) :<br>        idx = q [ 0 ]<br>        q.remove ( q [ 0 ] )<br>        if ( idx == N - 1 ) :<br>            break<br>        d = arr [ idx ]<br>        for i in range ( len ( digit [ d ] ) ) :<br>            nextidx = digit [ d ] [ i ]<br>            if ( visit [ nextidx ] == False ) :<br>                visit [ nextidx ] = True<br>                q.append ( nextidx )<br>                distance [ nextidx ] = distance [ idx ] + 1<br>        if ( idx - 1 >= 0 and visit [ idx - 1 ] == False ) :<br>            visit [ idx - 1 ] = True<br>            q.append ( idx - 1 )<br>            distance [ idx - 1 ] = distance [ idx ] + 1<br>        if ( idx + 1 < N and visit [ idx + 1 ] == False ) :<br>            visit [ idx + 1 ] = True<br>            q.append ( idx + 1 )<br>            distance [ idx + 1 ] = distance [ idx ] + 1<br>    return distance [ N - 1 ]<br></td>
    <td>translated code: <br><br> def getMinStepToReachEnd ( arr , N ) :<br>    visit = [ False ] * N<br>    distance = [ 0 ] * N<br>    digit = [ [ ] for i in range ( 10 ) ]<br>    for i in range ( N ) :<br>        visit [ i ] = False<br>    for i in range ( 1 , N ) :<br>        digit [ arr [ i ] ].append ( i )<br>    distance [ 0 ] = 0<br>    visit [ 0 ] = True<br>    q = Queue ( )<br>    q.put ( 0 )<br>    while not q.empty ( ) :<br>        idx = q.get ( )<br>        q.put ( 0 )<br>        if idx == N - 1 :<br>            break<br>        d = arr [ idx ]<br>        for i in digit [ d ] :<br>            nextidx = digit [ d ] [ i ]<br>            if not visit [ nextidx ] :<br>                visit [ nextidx ] = True<br>                q.put ( nextidx )<br>                distance [ nextidx ] = distance [ idx ] + 1<br>        digit [ d ].clear ( )<br>        if idx - 1 >= 0 and not visit [ idx - 1 ] :<br>            visit [ idx - 1 ] = True<br>            q.put ( idx - 1 )<br>            distance [ idx - 1 ] = distance [ idx ] + 1<br>        if idx + 1 < N and not visit [ idx + 1 ] :<br>            visit [ idx + 1 ] = True<br>            q.put ( idx + 1 )<br>            distance [ idx + 1 ] = distance [ idx ] + 1<br>    return distance [ N - 1 ]<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minimizeWithKSwaps ( arr , n , k ) :<br>    for i in range ( n - 1 ) :<br>        pos = i<br>        for j in range ( i + 1 , n ) :<br>            if ( j - i > k ) :<br>                break<br>            if ( arr [ j ] < arr [ pos ] ) :<br>                pos = j<br>        for j in range ( pos , i , - 1 ) :<br>            arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ]<br>        k -= pos - i<br></td>
    <td>translated code: <br><br> def minimize_with_k_swapped ( arr , n , k ) :<br>    for i in range ( n - 1 and k > 0 ) :<br>        pos = i<br>        for j in range ( i + 1 , n ) :<br>            if j - i > k :<br>                break<br>            if arr [ j ] < arr [ pos ] :<br>                pos = j<br>        temp = None<br>        for j in range ( pos , i > 0 ) :<br>            temp = arr [ j ]<br>            arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , temp<br>        k -= pos - i<br></td>
  </tr><tr>
    <th>CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSequence ( arr , input ) :<br>    n = len ( input )<br>    output = ""<br>    for i in range ( n ) :<br>        if ( input [ i ] == ' ' ) :<br>            output = output + "0"<br>        else :<br>            position = ord ( input [ i ] ) - ord ( 'A' )<br>            output = output + arr [ position ]<br>    return output<br></td>
    <td>translated code: <br><br> def printSequence ( arr , input ) :<br>    output = ""<br>    n = len ( input )<br>    for i in range ( n ) :<br>        if input [ i ] == ' ' :<br>            output = output + "0"<br>        else :<br>            position = input [ i ] - 'A'<br>            output = output + arr [ position ]<br>    return output<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arraySortedOrNot ( arr ) :<br>    n = len ( arr )<br>    if n == 1 or n == 0 :<br>        return True<br>    return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] )<br></td>
    <td>translated code: <br><br> def array_sorted_or_not ( arr , n ) :<br>    if n == 1 or n == 0 :<br>        return 1<br>    if arr [ n - 1 ] < arr [ n - 2 ] :<br>        return 0<br>    return array_sorted_or_not ( arr , n - 1 )<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :<br>    distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) <br>    radSumSq = ( r1 + r2 ) * ( r1 + r2 ) <br>    if ( distSq == radSumSq ) :<br>        return 1<br>    elif ( distSq > radSumSq ) :<br>        return - 1<br>    else :<br>        return 0<br></td>
    <td>translated code: <br><br> def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :<br>    distSq = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2<br>    radSumSq = ( r1 + r2 ) ** 2<br>    if distSq == radSumSq :<br>        return 1<br>    elif distSq > radSumSq :<br>        return - 1<br>    else :<br>        return 0<br></td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextPowerOf2 ( n ) :<br>    n -= 1<br>    n |= n >> 1<br>    n |= n >> 2<br>    n |= n >> 4<br>    n |= n >> 8<br>    n |= n >> 16<br>    n += 1<br>    return n<br></td>
    <td>translated code: <br><br> def next_power_of_2 ( n ) :<br>    n -= 1<br>    n |= n >> 1<br>    n |= n >> 2<br>    n |= n >> 4<br>    n |= n >> 8<br>    n |= n >> 16<br>    n += 1<br>    return n<br></td>
  </tr><tr>
    <th>PADOVAN_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pad ( n ) :<br>    pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1<br>    for i in range ( 3 , n + 1 ) :<br>        pNext = pPrevPrev + pPrev<br>        pPrevPrev = pPrev<br>        pPrev = pCurr<br>        pCurr = pNext<br>    return pNext <br></td>
    <td>translated code: <br><br> def pad ( n ) :<br>    pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1<br>    for i in range ( 3 , n ) :<br>        pNext = pPrevPrev + pPrev<br>        pPrevPrev = pPrev<br>        pPrev = pCurr<br>        pCurr = pNext<br>    return pNext<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( s ) :<br>    if ( len ( s ) >= 10 ) :<br>        return True<br>    for i in range ( 1 , len ( s ) ) :<br>        for j in range ( i + 1 , len ( s ) ) :<br>            for k in range ( j + 1 , len ( s ) ) :<br>                s1 = s [ 0 : i ]<br>                s2 = s [ i : j - i ]<br>                s3 = s [ j : k - j ]<br>                s4 = s [ k : len ( s ) - k ]<br>                if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) :<br>                    return True<br>    return False<br></td>
    <td>translated code: <br><br> def check ( s ) :<br>    if len ( s ) >= 10 :<br>        return True<br>    for i in range ( 1 , len ( s ) ) :<br>        for j in range ( i + 1 , len ( s ) ) :<br>            for k in range ( j + 1 , len ( s ) ) :<br>                s1 , s2 , s3 , s4 = s [ : i ] , s [ i : j ] , s [ j : k ] , s [ k : ]<br>                try :<br>                    s1 = s [ i ]<br>                    s2 = s [ i ]<br>                    s3 = s [ j ]<br>                    s4 = s [ k ]<br>                except StringIndexError :<br>                    pass<br>                if strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s1 , s4 ) and strcheck ( s2 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) :<br>                    return True<br>    return False<br></td>
  </tr><tr>
    <th>PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPossible ( a , b , n , k ) :<br>    a.sort ( reverse = True )<br>    b.sort ( )<br>    for i in range ( n ) :<br>        if ( a [ i ] + b [ i ] < k ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def is_possible ( a , b , n , k ) :<br>    a.sort ( key = lambda x : x [ 1 ] )<br>    b.sort ( key = lambda x : x [ 0 ] )<br>    for i in range ( n ) :<br>        if a [ i ] + b [ i ] < k :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def winner ( a , n , k ) :<br>    if k >= n - 1 :<br>        return n<br>    best = 0<br>    times = 0<br>    for i in range ( n ) :<br>        if a [ i ] > best :<br>            best = a [ i ]<br>            if i == True :<br>                times = 1<br>        else :<br>            times += 1<br>        if times >= k :<br>            return best<br>    return best<br></td>
    <td>translated code: <br><br> def winner ( a , n , k ) :<br>    if k >= n - 1 :<br>        return n<br>    best , times = 0 , 0<br>    for i in range ( n ) :<br>        if a [ i ] > best :<br>            best = a [ i ]<br>            if i == 1 :<br>                times = 1<br>        else :<br>            times += 1<br>        if times >= k :<br>            return best<br>    return best<br></td>
  </tr><tr>
    <th>DIRECTION_LAST_SQUARE_BLOCK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def direction ( R , C ) :<br>    if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :<br>        print ( "Left" )<br>        return<br>    if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :<br>        print ( "Up" )<br>        return<br>    if R == C and R % 2 != 0 and C % 2 != 0 :<br>        print ( "Right" )<br>        return<br>    if R == C and R % 2 == 0 and C % 2 == 0 :<br>        print ( "Left" )<br>        return<br>    if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :<br>        print ( "Right" )<br>        return<br>    if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :<br>        print ( "Down" )<br>        return<br>    if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :<br>        print ( "Left" )<br>        return<br>    if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :<br>        print ( "Up" )<br>        return<br>    if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :<br>        print ( "Down" )<br>        return<br>    if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :<br>        print ( "Right" )<br>        return<br></td>
    <td>translated code: <br><br> def direction ( R , C ) :<br>    if R != C and R % 2 == 0 and C % 2 != 0 and R < C :<br>        print ( "Left" )<br>        return<br>    if R != C and R % 2 != 0 and C % 2 == 0 and R > C :<br>        print ( "Up" )<br>        return<br>    if R == C and R % 2 != 0 and C % 2 != 0 :<br>        print ( "Right" )<br>        return<br>    if R == C and R % 2 == 0 and C % 2 == 0 :<br>        print ( "Left" )<br>        return<br>    if R != C and R % 2 != 0 and C % 2 != 0 and R < C :<br>        print ( "Right" )<br>        return<br>    if R != C and R % 2 != 0 and C % 2 != 0 and R > C :<br>        print ( "Down" )<br>        return<br>    if R != C and R % 2 == 0 and C % 2 == 0 and R < C :<br>        print ( "Left" )<br>        return<br>    if R != C and R % 2 == 0 and C % 2 == 0 and R > C :<br>        print ( "Up" )<br>        return<br>    if R != C and R % 2 == 0 and C % 2 != 0 and R > C :<br>        print ( "Down" )<br>        return<br></td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countIntegralSolutions ( n ) :<br>    result = 0<br>    for i in range ( n + 1 ) :<br>        for j in range ( n + 1 ) :<br>            for k in range ( n + 1 ) :<br>                if i + j + k == n :<br>                    result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def countIntegralSolutions ( n ) :<br>    result = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n - i ) :<br>            for k in range ( 0 , ( n - i - j ) ) :<br>                if i + j + k == n :<br>                    result += 1<br>    return result<br></td>
  </tr><tr>
    <th>SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def swapDiagonal ( matrix ) :<br>    for i in range ( N ) :<br>        matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \<br>            matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]<br></td>
    <td>translated code: <br><br> def swapDiagonal ( matrix ) :<br>    for i in range ( N ) :<br>        temp = matrix [ i ] [ i ]<br>        matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ]<br>        matrix [ i ] [ N - i - 1 ] = temp<br></td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MinOperation ( a , n , k ) :<br>    result = 0<br>    for i in range ( n ) :<br>        if ( a [ i ] != 1 and a [ i ] > k ) :<br>            result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) )<br>        else :<br>            result = result + k - a [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def MinOperation ( a , n , k ) :<br>    result = 0<br>    for i in range ( n ) :<br>        if a [ i ] != 1 and a [ i ] > k :<br>            result = result + min ( a [ i ] % k , k - a [ i ] % k )<br>        else :<br>            result = result + k - a [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDecimalValue ( mat , i , j , p ) :<br>    if i >= N or j >= N :<br>        return 0<br>    result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) )<br>    if mat [ i ] [ j ] == 1 :<br>        return pow ( 2 , p ) + result<br>    else :<br>        return result<br></td>
    <td>translated code: <br><br> def maxDecimalValue ( mat , i , j , p ) :<br>    if i >= N or j >= N :<br>        return 0<br>    result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) )<br>    if mat [ i ] [ j ] == 1 :<br>        return int ( math.pow ( 2 , p ) + result )<br>    else :<br>        return result<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def squareRoot ( n ) :<br>    x = n <br>    y = 1 <br>    while ( x > y ) :<br>        x = ( x + y ) / 2 <br>        y = n / x <br>    return x <br></td>
    <td>translated code: <br><br> def square_root ( n ) :<br>    x = n<br>    y = 1<br>    while x > y :<br>        x = ( x + y ) / 2<br>        y = n // x<br>    return long ( x )<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def KMP ( m , n , str2 , str1 ) :<br>    pos = 0<br>    Len = 0<br>    p = [ 0 for i in range ( m + 1 ) ]<br>    k = 0<br>    for i in range ( 2 , n + 1 ) :<br>        while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) :<br>            k = p [ k ]<br>        if ( str1 [ k ] == str1 [ i - 1 ] ) :<br>            k += 1<br>        p [ i ] = k<br>    j = 0<br>    for i in range ( m ) :<br>        while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) :<br>            j = p [ j ]<br>        if ( j < n and str1 [ j ] == str2 [ i ] ) :<br>            j += 1<br>        if ( j > Len ) :<br>            Len = j<br>            pos = i - j + 1<br>    print ( "Shift = " , pos )<br>    print ( "Prefix = " , str1 [ : Len ] )<br></td>
    <td>translated code: <br><br> def KMP ( m , n , str2 , str1 ) :<br>    pos , len = 0 , 0<br>    p = [ 0 ] * ( m + 1 )<br>    k = 0<br>    ch1 = str1 [ : m ]<br>    ch2 = str2 [ : m ]<br>    for i in range ( 2 , n + 1 ) :<br>        while k and ch1 [ k ] != ch1 [ i - 1 ] :<br>            k = p [ k ]<br>        if ch1 [ k ] == ch1 [ i - 1 ] :<br>            k += 1<br>        p [ i ] = k<br>    for j , i in enumerate ( m ) :<br>        while j and j < n and ch1 [ j ] != ch2 [ i ] :<br>            j = p [ j ]<br>        if j < n and ch1 [ j ] == ch2 [ i ] :<br>            j += 1<br>        if j > len :<br>            len = j<br>            pos = i - j + 1<br>    print ( "Shift = " + str ( pos ) )<br>    print ( "Prefix = " + str1 [ : len ] )<br></td>
  </tr><tr>
    <th>SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSorted ( arr , start , end ) :<br>    if start > end :<br>        return<br>    printSorted ( arr , start * 2 + 1 , end )<br>    print ( arr [ start ] , end = " " )<br>    printSorted ( arr , start * 2 + 2 , end )<br></td>
    <td>translated code: <br><br> def _print_sorted ( arr , start , end ) :<br>    if start > end :<br>        return<br>    _print_sorted ( arr , start * 2 + 1 , end )<br>    print ( arr [ start ] , end )<br>    _print_sorted ( arr , start * 2 + 2 , end )<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( degree , n ) :<br>    deg_sum = sum ( degree )<br>    if ( 2 * ( n - 1 ) == deg_sum ) :<br>        return True<br>    else :<br>        return False<br></td>
    <td>translated code: <br><br> def check ( degree , n ) :<br>    deg_sum = 0<br>    for i in range ( n ) :<br>        deg_sum += degree [ i ]<br>    return ( 2 ** ( n - 1 ) == deg_sum )<br></td>
  </tr><tr>
    <th>MOVE_ZEROES_END_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pushZerosToEnd ( arr , n ) :<br>    count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] != 0 :<br>            arr [ count ] = arr [ i ]<br>            count += 1<br>    while count < n :<br>        arr [ count ] = 0<br>        count += 1<br></td>
    <td>translated code: <br><br> def push_zeros_to_end ( arr , n ) :<br>    count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] != 0 :<br>            arr [ count ] = arr [ i ]<br>    while count < n :<br>        arr [ count ] = 0<br></td>
  </tr><tr>
    <th>COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def answerQuery ( a , n , l , r ) :<br>    count = 0<br>    l = l - 1<br>    for i in range ( l , r , 1 ) :<br>        element = a [ i ]<br>        divisors = 0<br>        for j in range ( l , r , 1 ) :<br>            if ( a [ j ] % a [ i ] == 0 ) :<br>                divisors += 1<br>            else :<br>                break<br>        if ( divisors == ( r - l ) ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def answer_query ( a , n , l , r ) :<br>    count = 0<br>    l = l - 1<br>    for i in range ( l , r ) :<br>        element = a [ i ]<br>        divisors = 0<br>        for j in range ( l , r ) :<br>            if a [ j ] % a [ i ] == 0 :<br>                divisors += 1<br>            else :<br>                break<br>        if divisors == ( r - l ) :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumOfLargePrimeFactor ( n ) :<br>    prime = [ 0 ] * ( n + 1 )<br>    sum = 0<br>    max = int ( n / 2 )<br>    for p in range ( 2 , max + 1 ) :<br>        if prime [ p ] == 0 :<br>            for i in range ( p * 2 , n + 1 , p ) :<br>                prime [ i ] = p<br>    for p in range ( 2 , n + 1 ) :<br>        if prime [ p ] :<br>            sum += prime [ p ]<br>        else :<br>            sum += p<br>    return sum<br></td>
    <td>translated code: <br><br> def sum_of_large_prime_factor ( n ) :<br>    prime , sum = [ 0 ] * ( n + 1 ) , 0<br>    prime.sort ( )<br>    max = n // 2<br>    for p in range ( 2 , max + 1 ) :<br>        if prime [ p ] == 0 :<br>            for i in range ( p * 2 , n + 1 , p ) :<br>                prime [ i ] = p<br>    for p in range ( 2 , n + 1 ) :<br>        if prime [ p ] != 0 :<br>            sum += prime [ p ]<br>        else :<br>            sum += p<br>    return sum<br></td>
  </tr><tr>
    <th>REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arrangeString ( string ) :<br>    char_count = [ 0 ] * MAX_CHAR<br>    s = 0<br>    for i in range ( len ( string ) ) :<br>        if string [ i ] >= "A" and string [ i ] <= "Z" :<br>            char_count [ ord ( string [ i ] ) - ord ( "A" ) ] += 1<br>        else :<br>            s += ord ( string [ i ] ) - ord ( "0" )<br>    res = ""<br>    for i in range ( MAX_CHAR ) :<br>        ch = chr ( ord ( "A" ) + i )<br>        while char_count [ i ] :<br>            res += ch<br>            char_count [ i ] -= 1<br>    if s > 0 :<br>        res += str ( s )<br>    return res<br></td>
    <td>translated code: <br><br> def arrangeString ( str ) :<br>    char_count = [ 0 ]<br>    sum = 0<br>    for c in str :<br>        if ord ( c ) < 128 :<br>            char_count [ c - ord ( 'A' ) ] += 1<br>        else :<br>            sum = sum + ( ord ( c ) - ord ( '0' ) )<br>    res = ""<br>    for i in range ( MAX_CHAR ) :<br>        ch = chr ( ord ( 'A' ) + i )<br>        while char_count [ i ] != 0 :<br>            res = res + ch<br>    if sum :<br>        res = res + sum<br>    return res<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfPaths ( m , n ) :<br>    count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ]<br>    for i in range ( m ) :<br>        count [ i ] [ 0 ] = 1 <br>    for j in range ( n ) :<br>        count [ 0 ] [ j ] = 1 <br>    for i in range ( 1 , m ) :<br>        for j in range ( n ) :<br>            count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]<br>    return count [ m - 1 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def number_of_paths ( m , n ) :<br>    count = [ [ 0 ] * m for i in range ( m ) ]<br>    for i in range ( m ) :<br>        count [ i ] [ 0 ] = 1<br>    for j in range ( n ) :<br>        count [ 0 ] [ j ] = 1<br>    for i in range ( 1 , m ) :<br>        for j in range ( 1 , n ) :<br>            count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ]<br>    return count [ m - 1 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def editDistDP ( str1 , str2 , m , n ) :<br>    dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ]<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            if i == 0 :<br>                dp [ i ] [ j ] = j<br>            elif j == 0 :<br>                dp [ i ] [ j ] = i<br>            elif str1 [ i - 1 ] == str2 [ j - 1 ] :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] )<br>    return dp [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def edit_dist_dp ( str1 , str2 , m , n ) :<br>    dp = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m</td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSol ( coeff , start , end , rhs ) :<br>    if ( rhs == 0 ) :<br>        return 1<br>    result = 0<br>    for i in range ( start , end + 1 ) :<br>        if ( coeff [ i ] <= rhs ) :<br>            result += countSol ( coeff , i , end , rhs - coeff [ i ] )<br>    return result<br></td>
    <td>translated code: <br><br> def count_sol ( coeff , start , end , rhs ) :<br>    if rhs == 0 :<br>        return 1<br>    result = 0<br>    for i in range ( start , end + 1 ) :<br>        if coeff [ i ] <= rhs :<br>            result += count_sol ( coeff , i , end , rhs - coeff [ i ] )<br>    return result<br></td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minheapify ( a , index ) :<br>    small = index<br>    l = 2 * index + 1<br>    r = 2 * index + 2<br>    if ( l < n and a [ l ] < a [ small ] ) :<br>        small = l<br>    if ( r < n and a [ r ] < a [ small ] ) :<br>        small = r<br>    if ( small != index ) :<br>        ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] )<br>        minheapify ( a , small )<br></td>
    <td>translated code: <br><br> def minheapify ( a , index ) :<br>    small = index<br>    l = 2 * index + 1<br>    r = 2 * index + 2<br>    if l < n and a [ l ] < a [ small ] :<br>        small = l<br>    if r < n and a [ r ] < a [ small ] :<br>        small = r<br>    if small != index :<br>        t = a [ small ]<br>        a [ small ] , a [ index ] = a [ index ] , a [ small ]<br>        a [ index ] = t<br>        minheapify ( a , small )<br></td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def computeLPSArray ( pat , M , lps ) :<br>    len = 0<br>    lps [ 0 ]<br>    i = 1<br>    while i < M :<br>        if pat [ i ] == pat [ len ] :<br>            len += 1<br>            lps [ i ] = len<br>            i += 1<br>        else :<br>            if len != 0 :<br>                len = lps [ len - 1 ]<br>            else :<br>                lps [ i ] = 0<br>                i += 1<br></td>
    <td>translated code: <br><br> def computeLPSArray ( pat , M , lps ) :<br>    len = 0<br>    i = 1<br>    lps [ 0 ] = 0<br>    while i < M :<br>        if pat [ i ] == pat [ len ] :<br>            len += 1<br>            lps [ i ] = len<br>            i += 1<br>        else :<br>            if len != 0 :<br>                len = lps [ len - 1 ]<br>            else :<br>                lps [ i ] = len<br>                i += 1<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_DIFFERENCE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinDiff ( arr , n ) :<br>    diff = 10 ** 20<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if abs ( arr [ i ] - arr [ j ] ) < diff :<br>                diff = abs ( arr [ i ] - arr [ j ] )<br>    return diff<br></td>
    <td>translated code: <br><br> def findMinDiff ( arr , n ) :<br>    diff = sys.maxsize<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if abs ( ( arr [ i ] - arr [ j ] ) ) < diff :<br>                diff = abs ( ( arr [ i ] - arr [ j ] ) )<br>    return diff<br></td>
  </tr><tr>
    <th>PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Print ( n , k ) :<br>    rem = 1<br>    for i in range ( 0 , k ) :<br>        print ( math.floor ( ( ( 10 * rem ) / n ) ) , end = "" )<br>        rem = ( 10 * rem ) % n<br></td>
    <td>translated code: <br><br> def print ( n , k ) :<br>    rem = 1<br>    for i in range ( k ) :<br>        print ( ( 10 ** rem ) / n )<br>        rem = ( 10 ** rem ) % n<br></td>
  </tr><tr>
    <th>GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def groupElements ( arr , n ) :<br>    visited = [ False ] * n<br>    for i in range ( 0 , n ) :<br>        visited [ i ] = False<br>    for i in range ( 0 , n ) :<br>        if ( visited [ i ] == False ) :<br>            print ( arr [ i ] , end = " " )<br>            for j in range ( i + 1 , n ) :<br>                if ( arr [ i ] == arr [ j ] ) :<br>                    print ( arr [ i ] , end = " " )<br>                    visited [ j ] = True<br></td>
    <td>translated code: <br><br> def group_elements ( arr , n ) :<br>    visited = [ False for i in range ( n ) ]<br>    for i in range ( n ) :<br>        if not visited [ i ] :<br>            print ( arr [ i ] , end = ' ' )<br>            for j in range ( i + 1 , n ) :<br>                if arr [ i ] == arr [ j ] :<br>                    print ( arr [ i ] , end = ' ' )<br>                    visited [ j ] = True<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkIsAP ( arr , n ) :<br>    if ( n == 1 ) : return True<br>    arr.sort ( )<br>    d = arr [ 1 ] - arr [ 0 ]<br>    for i in range ( 2 , n ) :<br>        if ( arr [ i ] - arr [ i - 1 ] != d ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def checkIsAP ( arr , n ) :<br>    if n == 1 : return True<br>    arr.sort ( )<br>    d = arr [ 1 ] - arr [ 0 ]<br>    for i in range ( 2 , n ) :<br>        if arr [ i ] - arr [ i - 1 ] != d : return False<br>    return True<br></td>
  </tr><tr>
    <th>NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findPosition ( k , n ) :<br>    f1 = 0<br>    f2 = 1<br>    i = 2 <br>    while i != 0 :<br>        f3 = f1 + f2 <br>        f1 = f2 <br>        f2 = f3 <br>        if f2 % k == 0 :<br>            return n * i<br>        i += 1<br>    return<br></td>
    <td>translated code: <br><br> def find_position ( k , n ) :<br>    f1 , f2 , f3 = 0 , 1 , 0<br>    i = 2<br>    while i != 0 :<br>        f3 = f1 + f2<br>        f1 , f2 , f3 = f2 , f3<br>        if f2 % k == 0 :<br>            return n * i<br>        i += 1<br>    return 0<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_DIFFERENCE_EQUAL_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairsWithDiffK ( arr , n , k ) :<br>    count = 0<br>    arr.sort ( )<br>    l = 0<br>    r = 0<br>    while r < n :<br>        if arr [ r ] - arr [ l ] == k :<br>            count += 1<br>            l += 1<br>            r += 1<br>        elif arr [ r ] - arr [ l ] > k :<br>            l += 1<br>        else :<br>            r += 1<br>    return count<br></td>
    <td>translated code: <br><br> def countPairsWithDiffK ( arr , n , k ) :<br>    count = 0<br>    arr.sort ( )<br>    l = 0<br>    r = 0<br>    while r < n :<br>        if arr [ r ] - arr [ l ] == k :<br>            count += 1<br>            l += 1<br>            r += 1<br>        elif arr [ r ] - arr [ l ] > k :<br>            l += 1<br>        else :<br>            r += 1<br>    return count<br></td>
  </tr><tr>
    <th>ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNum ( arr , n ) :<br>    count = 0<br>    arr.sort ( )<br>    for i in range ( 0 , n - 1 ) :<br>        if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) :<br>            count += arr [ i + 1 ] - arr [ i ] - 1 <br>    return count<br></td>
    <td>translated code: <br><br> def countNum ( arr , n ) :<br>    count = 0<br>    arr.sort ( )<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 :<br>            count += arr [ i + 1 ] - arr [ i ] - 1<br>    return count<br></td>
  </tr><tr>
    <th>MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumPalinUsingKChanges ( strr , k ) :<br>    palin = strr<br>    l = 0<br>    r = len ( strr ) - 1<br>    while ( l <= r ) :<br>        if ( strr [ l ] != strr [ r ] ) :<br>            palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] )<br>            k -= 1<br>        l += 1<br>        r -= 1<br>    if ( k < 0 ) :<br>        return "Not possible"<br>    l = 0<br>    r = len ( strr ) - 1<br>    while ( l <= r ) :<br>        if ( l == r ) :<br>            if ( k > 0 ) :<br>                palin [ l ] = '9'<br>        if ( palin [ l ] < '9' ) :<br>            if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) :<br>                k -= 1<br>                palin [ l ] = palin [ r ] = '9'<br>            elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) :<br>                k -= 1<br>                palin [ l ] = palin [ r ] = '9'<br>        l += 1<br>        r -= 1<br>    return palin<br></td>
    <td>translated code: <br><br> def maximum_palin_using_k_changes ( str , k ) :<br>    palin = str.split ( )<br>    ans = ""<br>    l = 0<br>    r = len ( str ) - 1<br>    while l < r :<br>        if str [ l ] != str [ r ] :<br>            palin [ l ] = palin [ r ] = chr ( max ( str [ l ] , str [ r ] ) )<br>            k -= 1<br>        l += 1<br>        r -= 1<br>    if k < 0 :<br>        return "Not possible"<br>    l = 0<br>    r = len ( str ) - 1<br>    while l <= r :<br>        if l == r :<br>            if k > 0 :<br>                palin [ l ] = '9'<br>        if palin [ l ] < '9' :<br>            if k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] :<br>                k -= 2<br>                palin [ l ] = palin [ r ] = '9'<br>            elif k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) :<br>                k -= 1<br>                palin [ l ] = palin [ r ] = '9'<br>        l += 1<br>        r -= 1<br>    for i in palin :<br>        ans += i<br>    return ans<br></td>
  </tr><tr>
    <th>SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def subArray ( arr , n ) :<br>    for i in range ( 0 , n ) :<br>        for j in range ( i , n ) :<br>            for k in range ( i , j + 1 ) :<br>                print ( arr [ k ] , end = "" )<br>            print ( "\n" , end = "" )<br></td>
    <td>translated code: <br><br> def subArray ( n ) :<br>    for i in range ( n ) :<br>        for j in range ( i , n ) :<br>            for k in range ( i , j ) :<br>                print ( arr [ k ] , end = ' ' )<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumSum ( a , n ) :<br>    global M <br>    for i in range ( 0 , n ) :<br>        a [ i ].sort ( ) <br>    sum = a [ n - 1 ] [ M - 1 ] <br>    prev = a [ n - 1 ] [ M - 1 ] <br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        for j in range ( M - 1 , - 1 , - 1 ) :<br>            if ( a [ i ] [ j ] < prev ) :<br>                prev = a [ i ] [ j ] <br>                sum += prev <br>                break <br>        if ( j == - 1 ) :<br>            return 0 <br>    return sum <br></td>
    <td>translated code: <br><br> def maximum_sum ( a , n ) :<br>    for i in range ( n ) :<br>        sort ( a , i , n )<br>    sum = a [ n - 1 ] [ M - 1 ]<br>    prev = a [ n - 1 ] [ M - 1 ]<br>    i , j = n - 2 , n - 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        for j in range ( M - 1 , - 1 , - 1 ) :<br>            if a [ i ] [ j ] < prev :<br>                prev = a [ i ] [ j ]<br>                sum += prev<br>                break<br>        if j == - 1 :<br>            return 0<br>    return sum<br></td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def factorial ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) <br></td>
    <td>translated code: <br><br> def factorial ( n ) :<br>    if n == 0 :<br>        return 1<br>    return n * factorial ( n - 1 )<br></td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSquares ( n ) :<br>    square = 0 ; prev_x = 0 <br>    for x in range ( 0 , n ) :<br>        square = ( square + x + prev_x )<br>        print ( square , end = " " )<br>        prev_x = x<br></td>
    <td>translated code: <br><br> def print_squares ( n ) :<br>    square , prev_x = 0 , 0<br>    for x in range ( n ) :<br>        square = ( square + x + prev_x )<br>        print ( square , end = ' ' )<br>        prev_x = x<br></td>
  </tr><tr>
    <th>ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def concatenate ( a , b , c , n1 , n2 ) :<br>    i = - 1<br>    for i in range ( n1 ) :<br>        c [ i ] = a [ i ]<br>    for j in range ( n2 ) :<br>        c [ i ] = b [ j ]<br>        i += 1<br></td>
    <td>translated code: <br><br> def concatenate ( a , b , c , n1 , n2 ) :<br>    i = 0<br>    for i in range ( n1 ) :<br>        c [ i ] = a [ i ]<br>    for j in range ( n2 ) :<br>        c [ i ] += b [ j ]<br></td>
  </tr><tr>
    <th>GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printClosest ( ar1 , ar2 , m , n , x ) :<br>    diff = sys.maxsize<br>    l = 0<br>    r = n - 1<br>    while ( l < m and r >= 0 ) :<br>        if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :<br>            res_l = l<br>            res_r = r<br>            diff = abs ( ar1 [ l ] + ar2 [ r ] - x )<br>        if ar1 [ l ] + ar2 [ r ] > x :<br>            r = r - 1<br>        else :<br>            l = l + 1<br>    print ( "The closest pair is [" , ar1 [ res_l ] , "," , ar2 [ res_r ] , "]" )<br></td>
    <td>translated code: <br><br> def printClosest ( ar1 , ar2 , m , n , x ) :<br>    diff = sys.maxint<br>    res_l , res_r = 0 , 0<br>    l , r = 0 , n - 1<br>    while l < m and r >= 0 :<br>        if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :<br>            res_l = l<br>            res_r = r<br>            diff = abs ( ar1 [ l ] + ar2 [ r ] - x )<br>        if ar1 [ l ] + ar2 [ r ] > x :<br>            r -= 1<br>        else :<br>            l += 1<br>    print ( "The closest pair is [" + str ( ar1 [ res_l ] ) + ", " + str ( ar2 [ res_r ] ) + "]" )<br></td>
  </tr><tr>
    <th>CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minRemove ( arr , n ) :<br>    LIS = [ 0 for i in range ( n ) ]<br>    len = 0<br>    for i in range ( n ) :<br>        LIS [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) :<br>                LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 )<br>        len = max ( len , LIS [ i ] )<br>    return ( n - len )<br></td>
    <td>translated code: <br><br> def min_remove ( arr , n ) :<br>    LIS = [ ]<br>    len = 0<br>    for i in range ( n ) :<br>        LIS.append ( 1 )<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) :<br>                LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 )<br>        len = max ( len , LIS [ i ] )<br>    return n - len<br></td>
  </tr><tr>
    <th>TAIL_RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def fact ( n ) :<br>    if ( n == 0 ) :<br>        return 1<br>    return n * fact ( n - 1 )<br></td>
    <td>translated code: <br><br> def fact ( n ) :<br>    if n == 0 :<br>        return 1<br>    return n * fact ( n - 1 )<br></td>
  </tr><tr>
    <th>RECURSIVE_FUNCTIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def tower ( n , sourcePole , destinationPole , auxiliaryPole ) :<br>    if ( 0 == n ) :<br>        return<br>    tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole )<br>    print ( "Move the disk" , sourcePole , "from" , sourcePole , "to" , destinationPole )<br>    tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole )<br></td>
    <td>translated code: <br><br> def tower ( n , source_pole , destination_pole , auxiliary_pole ) :<br>    if 0 == n :<br>        return<br>    tower ( n - 1 , source_pole , auxiliary_pole , destination_pole )<br>    print ( "Move the disk %d from %c to %c" % ( n , source_pole , destination_pole ) )<br>    tower ( n - 1 , auxiliary_pole , destination_pole , source_pole )<br></td>
  </tr><tr>
    <th>FIND_X_Y_SATISFYING_AX_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solution ( a , b , n ) :<br>    i = 0<br>    while i * a <= n :<br>        if ( n - ( i * a ) ) % b == 0 :<br>            print ( "x = " , i , ", y = " , int ( ( n - ( i * a ) ) / b ) )<br>            return 0<br>        i = i + 1<br>    print ( "No solution" )<br></td>
    <td>translated code: <br><br> def solution ( a , b , n ) :<br>    for i in range ( 0 , a * a <= n ) :<br>        if ( n - ( i * a ) ) % b == 0 :<br>            print ( "x = %d, y = %d" % ( i , ( n - ( i * a ) ) / b ) )<br>            return<br>    print ( "No solution" )<br></td>
  </tr><tr>
    <th>EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def exponentiation ( bas , exp ) :<br>    t = 1 <br>    while ( exp > 0 ) :<br>        if ( exp % 2 != 0 ) :<br>            t = ( t * bas ) % N <br>        bas = ( bas * bas ) % N <br>        exp = int ( exp / 2 ) <br>    return t % N <br></td>
    <td>translated code: <br><br> def exponentiation ( base , exp ) :<br>    t = 1<br>    while exp > 0 :<br>        if exp % 2 != 0 :<br>            t = ( t * base ) % N<br>        base = ( base * base ) % N<br>        exp /= 2<br>    return t % N<br></td>
  </tr><tr>
    <th>CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkIfAllTogether ( s , c ) :<br>    oneSeen = False<br>    i = 0<br>    n = len ( s )<br>    while ( i < n ) :<br>        if ( s [ i ] == c ) :<br>            if ( oneSeen == True ) :<br>                return False<br>            while ( i < n and s [ i ] == c ) :<br>                i = i + 1<br>            oneSeen = True<br>        else :<br>            i = i + 1<br>    return True<br></td>
    <td>translated code: <br><br> def checkIfAllTogether ( s , c ) :<br>    oneSeen = False<br>    i , n = 0 , len ( s )<br>    while i < n :<br>        if s [ i ] == c :<br>            if oneSeen == True :<br>                return False<br>            while i < n and s [ i ] == c :<br>                i += 1<br>            oneSeen = True<br>        else :<br>            i += 1<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findArea ( arr , n ) :<br>    arr.sort ( reverse = True )<br>    dimension = [ 0 , 0 ]<br>    i = 0<br>    j = 0<br>    while ( i < n - 1 and j < 2 ) :<br>        if ( arr [ i ] == arr [ i + 1 ] ) :<br>            dimension [ j ] = arr [ i ]<br>            j += 1<br>            i += 1<br>        i += 1<br>    return ( dimension [ 0 ] * dimension [ 1 ] )<br></td>
    <td>translated code: <br><br> def findArea ( arr , n ) :<br>    arr.sort ( key = lambda x : x [ 1 ] )<br>    dimension = [ 0 , 0 ]<br>    for i , j in enumerate ( arr ) :<br>        if arr [ i ] == arr [ i + 1 ] :<br>            dimension [ j ] = arr [ i ++ ]<br>    return ( dimension [ 0 ] * dimension [ 1 ] )<br></td>
  </tr><tr>
    <th>PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Circumference ( a ) :<br>    return ( 4 * a )<br></td>
    <td>translated code: <br><br> def Circumference ( a ) :<br>    return 4 * a<br></td>
  </tr><tr>
    <th>CYCLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def cycleSort ( array ) :<br>    writes = 0<br>    for cycleStart in range ( 0 , len ( array ) - 1 ) :<br>        item = array [ cycleStart ]<br>        pos = cycleStart<br>        for i in range ( cycleStart + 1 , len ( array ) ) :<br>            if array [ i ] < item :<br>                pos += 1<br>        if pos == cycleStart :<br>            continue<br>        while item == array [ pos ] :<br>            pos += 1<br>        array [ pos ] , item = item , array [ pos ]<br>        writes += 1<br>        while pos != cycleStart :<br>            pos = cycleStart<br>            for i in range ( cycleStart + 1 , len ( array ) ) :<br>                if array [ i ] < item :<br>                    pos += 1<br>            while item == array [ pos ] :<br>                pos += 1<br>            array [ pos ] , item = item , array [ pos ]<br>            writes += 1<br>    return writes<br></td>
    <td>translated code: <br><br> def cycle_sort ( arr , n ) :<br>    writes = 0<br>    for cycle_start in range ( 0 , n - 2 ) :<br>        item = arr [ cycle_start ]<br>        pos = cycle_start<br>        for i in range ( cycle_start + 1 , n ) :<br>            if arr [ i ] < item :<br>                pos += 1<br>        if pos == cycle_start :<br>            continue<br>        while item == arr [ pos ] :<br>            pos += 1<br>        if pos != cycle_start :<br>            temp = item<br>            item = arr [ pos ]<br>            arr [ pos ] = temp<br>            writes += 1<br>        while pos != cycle_start :<br>            pos = cycle_start<br>            for i in range ( cycle_start + 1 , n ) :<br>                if arr [ i ] < item :<br>                    pos += 1<br>            while item == arr [ pos ] :<br>                pos += 1<br>            if item != arr [ pos ] :<br>                temp = item<br>                item = arr [ pos ]<br>                arr [ pos ] = temp<br>                writes += 1<br></td>
  </tr><tr>
    <th>SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def selectRandom ( x ) :<br>    res = 0 <br>    count = 0 <br>    count += 1 <br>    if ( count == 1 ) :<br>        res = x <br>    else :<br>        i = random.randrange ( count ) <br>        if ( i == count - 1 ) :<br>            res = x <br>    return res <br></td>
    <td>translated code: <br><br> def select_random ( x ) :<br>    global count<br>    if count == 1 :<br>        res = x<br>    else :<br>        r = random.Random ( )<br>        i = r.randint ( 0 , count )<br>        if i == count - 1 :<br>            res = x<br>    return res<br></td>
  </tr><tr>
    <th>HOSOYAS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printHosoya ( n ) :<br>    dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]<br>    dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1<br>    for i in range ( 2 , n ) :<br>        for j in range ( n ) :<br>            if ( i > j ) :<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] )<br>            else :<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] )<br>    for i in range ( n ) :<br>        for j in range ( i + 1 ) :<br>            print ( dp [ i ] [ j ] , end = ' ' )<br>        print ( )<br></td>
    <td>translated code: <br><br> def print_hosoya ( n ) :<br>    dp = [ [ 0 ] * N for i in range ( N ) ]<br>    dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1<br>    dp [ 1 ] [ 1 ] = 1<br>    for i in range ( 2 , n ) :<br>        for j in range ( n ) :<br>            if i > j :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ]<br>            else :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ]<br>    for i in range ( n ) :<br>        for j in range ( 0 , i + 1 ) :<br>            print ( dp [ i ] [ j ] , end = '' )<br>        print ( '' )<br></td>
  </tr><tr>
    <th>DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lastPosition ( n , m , k ) :<br>    if ( m <= n - k + 1 ) :<br>        return m + k - 1<br>    m = m - ( n - k + 1 )<br>    if ( m % n == 0 ) :<br>        return n<br>    else :<br>        return m % n<br></td>
    <td>translated code: <br><br> def last_position ( n , m , k ) :<br>    if m <= n - k + 1 :<br>        return m + k - 1<br>    m = m - ( n - k + 1 )<br>    return ( m % n == 0 )<br></td>
  </tr><tr>
    <th>PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestSubsequence ( a , n ) :<br>    mp = { i : 0 for i in range ( 13 ) }<br>    dp = [ 0 for i in range ( n ) ]<br>    maximum = - sys.maxsize - 1<br>    index = - 1<br>    for i in range ( n ) :<br>        if ( ( a [ i ] - 1 ) in mp ) :<br>            lastIndex = mp [ a [ i ] - 1 ] - 1<br>            dp [ i ] = 1 + dp [ lastIndex ]<br>        else :<br>            dp [ i ] = 1<br>        mp [ a [ i ] ] = i + 1<br>        if ( maximum < dp [ i ] ) :<br>            maximum = dp [ i ]<br>            index = i<br>    for curr in range ( a [ index ] - maximum + 1 , a [ index ] + 1 , 1 ) :<br>        print ( curr , end = " " )<br></td>
    <td>translated code: <br><br> def longest_subsequence ( a , n ) :<br>    mp = { }<br>    dp = [ ]<br>    maximum = int ( - 1 )<br>    index = - 1<br>    for i in range ( n ) :<br>        if mp [ a [ i ] - 1 ] :<br>            lastIndex = mp [ a [ i ] - 1 ] - 1<br>            dp.append ( 1 + dp [ lastIndex ] )<br>        else :<br>            dp.append ( 1 )<br>        mp [ a [ i ] ] = i + 1<br>        if maximum < dp [ i ] :<br>            maximum = dp [ i ]<br>            index = i<br>    for curr in a [ index ] - maximum + 1 :<br>        print ( curr , end = ' ' )<br></td>
  </tr><tr>
    <th>NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countTriangle ( g , isDirected ) :<br>    nodes = len ( g )<br>    count_Triangle = 0<br>    for i in range ( nodes ) :<br>        for j in range ( nodes ) :<br>            for k in range ( nodes ) :<br>                if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) :<br>                    count_Triangle += 1<br>    return count_Triangle / 3 if isDirected else count_Triangle / 6<br></td>
    <td>translated code: <br><br> def countTriangle ( graph , isDirected ) :<br>    count_Triangle = 0<br>    for i in range ( V ) :<br>        for j in range ( V ) :<br>            for k in range ( V ) :<br>                if graph [ i ] [ j ] == 1 and graph [ j ] [ k ] == 1 and graph [ k ] [ i ] == 1 :<br>                    count_Triangle += 1<br>    if isDirected == True :<br>        count_Triangle /= 3<br>    else :<br>        count_Triangle /= 6<br>    return count_Triangle<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkDuplicatesWithinK ( arr , n , k ) :<br>    myset = [ ]<br>    for i in range ( n ) :<br>        if arr [ i ] in myset :<br>            return True<br>        myset.append ( arr [ i ] )<br>        if ( i >= k ) :<br>            myset.remove ( arr [ i - k ] )<br>    return False<br></td>
    <td>translated code: <br><br> def check_duplicatesWithinK ( arr , k ) :<br>    set = set ( )<br>    for i in range ( len ( arr ) ) :<br>        if set.issubset ( arr [ i ] ) :<br>            return True<br>        set.add ( arr [ i ] )<br>        if i >= k :<br>            set.remove ( arr [ i - k ] )<br>    return False<br></td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_SORT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minInsertionStepToSortArray ( arr , N ) :<br>    lis = [ 0 ] * N<br>    for i in range ( N ) :<br>        lis [ i ] = 1<br>    for i in range ( 1 , N ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) :<br>                lis [ i ] = lis [ j ] + 1<br>    max = 0<br>    for i in range ( N ) :<br>        if ( max < lis [ i ] ) :<br>            max = lis [ i ]<br>    return ( N - max )<br></td>
    <td>translated code: <br><br> def minInsertionStepToSortArray ( arr , N ) :<br>    lis = [ 1 ] * N<br>    for i in range ( N ) :<br>        lis [ i ] = 1<br>    for i in range ( 1 , N ) :<br>        for j in range ( i ) :<br>            if arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 :<br>                lis [ i ] = lis [ j ] + 1<br>    max = 0<br>    for i in range ( N ) :<br>        if max < lis [ i ] :<br>            max = lis [ i ]<br>    return ( N - max )<br></td>
  </tr><tr>
    <th>GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDuo ( string ) :<br>    countChar = [ 0 for i in range ( MAX_CHAR ) ]<br>    n = len ( string )<br>    for i in range ( n ) :<br>        countChar [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1<br>    str1 = ""<br>    str2 = ""<br>    for i in range ( MAX_CHAR ) :<br>        if ( countChar [ i ] > 1 ) :<br>            str2 = str2 + chr ( i + ord ( 'a' ) )<br>        elif ( countChar [ i ] == 1 ) :<br>            str1 = str1 + chr ( i + ord ( 'a' ) )<br>    print ( "String with characters occurring once:" , "\n" , str1 )<br>    print ( "String with characters occurring" , "multiple times:" , "\n" , str2 )<br></td>
    <td>translated code: <br><br> def print_duo ( str ) :<br>    count_char = [ 0 ] * MAX_CHAR<br>    n = len ( str )<br>    for i in range ( n ) :<br>        count_char [ str [ i ] - 'a' ] += 1<br>    str1 , str2 = "" , ""<br>    for i in range ( MAX_CHAR ) :<br>        if count_char [ i ] > 1 :<br>            str2 = str2 + chr ( i + 'a' )<br>        elif count_char [ i ] == 1 :<br>            str1 = str1 + chr ( i + 'a' )<br>    print ( "String with characters occurring ""once:\n" )<br>    print ( str1 , end = '' )<br>    print ( "String with characters occurring ""multiple times:\n" )<br>    print ( str2 , end = '' )<br>    print ( "" )<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDigits ( a , b ) :<br>    if ( a == 0 or b == 0 ) :<br>        return 1<br>    return math.floor ( math.log10 ( abs ( a ) ) + math.log10 ( abs ( b ) ) ) + 1<br></td>
    <td>translated code: <br><br> def count_digits ( a , b ) :<br>    if a == 0 or b == 0 :<br>        return 1<br>    return int ( math.floor ( math.log10 ( abs ( a ) ) + math.log10 ( abs ( b ) ) ) ) + 1<br></td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNonDecreasing ( n ) :<br>    N = 10<br>    count = 1<br>    for i in range ( 1 , n + 1 ) :<br>        count = int ( count * ( N + i - 1 ) )<br>        count = int ( count / i )<br>    return count<br></td>
    <td>translated code: <br><br> def count_non_decreasing ( n ) :<br>    N = 10<br>    count = 1<br>    for i in range ( 1 , n + 1 ) :<br>        count *= ( N + i - 1 )<br>        count /= i<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countStrs ( n ) :<br>    dp = [ [ 0 for j in range ( 27 ) ] for i in range ( n + 1 ) ]<br>    for i in range ( 0 , 26 ) :<br>        dp [ 1 ] [ i ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 0 , 26 ) :<br>            if ( j == 0 ) :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] <br>            else :<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )<br>    sum = 0<br>    for i in range ( 0 , 26 ) :<br>        sum = sum + dp [ n ] [ i ]<br>    return sum<br></td>
    <td>translated code: <br><br> def count_strs ( n ) :<br>    dp = [ [ 0 ] * 27 for i in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        for j in range ( 27 ) :<br>            dp [ i ] [ j ] = 0<br>    for i in range ( 0 , 25 ) :<br>        dp [ 1 ] [ i ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 0 , 25 ) :<br>            if j == 0 :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]<br>            else :<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] )<br>    sum = 0<br>    for i in range ( 0 , 25 ) :<br>        sum = ( sum + dp [ n ] [ i ] )<br>    return sum<br></td>
  </tr><tr>
    <th>PROGRAM_TO_EFFICIENTLY_CALCULATE_EX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def exponential ( n , x ) :<br>    sum = 1.0<br>    for i in range ( n , 0 , - 1 ) :<br>        sum = 1 + x * sum / i<br>    print ( "e^x =" , sum )<br></td>
    <td>translated code: <br><br> def exponential ( n , x ) :<br>    sum = 1<br>    for i in range ( n - 1 , 0 , - 1 ) :<br>        sum = 1 + x * sum / i<br>    return sum<br></td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDiagonalSums ( mat , n ) :<br>    principal = 0<br>    secondary = 0<br>    for i in range ( 0 , n ) :<br>        principal += mat [ i ] [ i ]<br>        secondary += mat [ i ] [ n - i - 1 ]<br>    print ( "Principal Diagonal:" , principal )<br>    print ( "Secondary Diagonal:" , secondary )<br></td>
    <td>translated code: <br><br> def printDiagonalSums ( mat , n ) :<br>    principal , secondary = 0 , 0<br>    for i in range ( n ) :<br>        principal += mat [ i ] [ i ]<br>        secondary += mat [ i ] [ n - i - 1 ]<br>    print ( "Principal Diagonal:" , principal )<br>    print ( "Secondary Diagonal:" , secondary )<br></td>
  </tr><tr>
    <th>PRINT_WAYS_BREAK_STRING_BRACKET_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findCombinations ( string , index , out ) :<br>    if index == len ( string ) :<br>        print ( out )<br>    for i in range ( index , len ( string ) , 1 ) :<br>        findCombinations ( string , i + 1 , out + "(" + string [ index : i + 1 ] + ")" )<br></td>
    <td>translated code: <br><br> def find_combinations ( str , index , out ) :<br>    if index == len ( str ) :<br>        print ( out )<br>    for i in range ( index , len ( str ) ) :<br>        find_combinations ( str , i + 1 , out + '(' + str [ index : i + 1 ] + ')' )<br></td>
  </tr><tr>
    <th>LINEAR_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , n , x ) :<br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] == x ) :<br>            return i <br>    return - 1 <br></td>
    <td>translated code: <br><br> def search ( arr , x ) :<br>    n = len ( arr )<br>    for i in range ( n ) :<br>        if arr [ i ] == x :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def singleNumber ( nums ) :<br>    return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2<br></td>
    <td>translated code: <br><br> def single_number ( a , n ) :<br>    s = set ( )<br>    for i in a :<br>        s.add ( i )<br>    arr_sum = 0<br>    for i in a :<br>        arr_sum += i<br>    set_sum = 0<br>    for i in s :<br>        set_sum += i<br>    return ( 3 * set_sum - arr_sum ) / 2<br></td>
  </tr><tr>
    <th>SEARCH_ALMOST_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binarySearch ( arr , l , r , x ) :<br>    if ( r >= l ) :<br>        mid = int ( l + ( r - l ) / 2 )<br>        if ( arr [ mid ] == x ) : return mid<br>        if ( mid > l and arr [ mid - 1 ] == x ) :<br>            return ( mid - 1 )<br>        if ( mid < r and arr [ mid + 1 ] == x ) :<br>            return ( mid + 1 )<br>        if ( arr [ mid ] > x ) :<br>            return binarySearch ( arr , l , mid - 2 , x )<br>        return binarySearch ( arr , mid + 2 , r , x )<br>    return - 1<br></td>
    <td>translated code: <br><br> def binarySearch ( arr , l , r , x ) :<br>    if r >= l :<br>        mid = l + ( r - l ) // 2<br>        if arr [ mid ] == x :<br>            return mid<br>        if mid > l and arr [ mid - 1 ] == x :<br>            return ( mid - 1 )<br>        if mid < r and arr [ mid + 1 ] == x :<br>            return ( mid + 1 )<br>        if arr [ mid ] > x :<br>            return binarySearch ( arr , l , mid - 2 , x )<br>        return binarySearch ( arr , mid + 2 , r , x )<br>    return - 1<br></td>
  </tr><tr>
    <th>EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def computeTotient ( n ) :<br>    phi = [ ]<br>    for i in range ( n + 2 ) :<br>        phi.append ( 0 )<br>    for i in range ( 1 , n + 1 ) :<br>        phi [ i ] = i<br>    for p in range ( 2 , n + 1 ) :<br>        if ( phi [ p ] == p ) :<br>            phi [ p ] = p - 1<br>            for i in range ( 2 * p , n + 1 , p ) :<br>                phi [ i ] = ( phi [ i ] // p ) * ( p - 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        print ( "Totient of " , i , " is " , phi [ i ] )<br></td>
    <td>translated code: <br><br> def compute_totient ( n ) :<br>    phi = [ i for i in range ( 1 , n + 1 ) if i != 0 ]<br>    for p in range ( 2 , n + 1 ) :<br>        if phi [ p ] == p :<br>            phi [ p ] = p - 1<br>            for i in range ( 2 * p , n + 1 , p ) :<br>                phi [ i ] = ( phi [ i ] / p ) ** ( p - 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        print ( "Totient of %d is %d" % ( i , phi [ i ] ) )<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinNumber ( n ) :<br>    count = 0<br>    ans = 1<br>    while n % 2 == 0 :<br>        count += 1<br>        n //= 2<br>    if count % 2 is not 0 :<br>        ans *= 2<br>    for i in range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2 ) :<br>        count = 0<br>        while n % i == 0 :<br>            count += 1<br>            n //= i<br>        if count % 2 is not 0 :<br>            ans *= i<br>    if n > 2 :<br>        ans *= n<br>    return ans<br></td>
    <td>translated code: <br><br> def findMinNumber ( n ) :<br>    count , ans = 0 , 1<br>    while n % 2 == 0 :<br>        count += 1<br>        n /= 2<br>    if count % 2 == 1 :<br>        ans *= 2<br>    for i in range ( 3 , math.sqrt ( n ) , 2 ) :<br>        count = 0<br>        while n % i == 0 :<br>            count += 1<br>            n /= i<br>        if count % 2 == 1 :<br>            ans *= i<br>    if n > 2 :<br>        ans *= n<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_JUMP_REACH_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWaysToJump ( arr , n ) :<br>    count_jump = [ 0 for i in range ( n ) ]<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if ( arr [ i ] >= n - i - 1 ) :<br>            count_jump [ i ] += 1<br>        j = i + 1<br>        while ( j < n - 1 and j <= arr [ i ] + i ) :<br>            if ( count_jump [ j ] != - 1 ) :<br>                count_jump [ i ] += count_jump [ j ]<br>            j += 1<br>        if ( count_jump [ i ] == 0 ) :<br>            count_jump [ i ] = - 1<br>    for i in range ( n ) :<br>        print ( count_jump [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def count_ways_to_jump ( arr , n ) :<br>    count_jump = [ 0 ] * n<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if arr [ i ] >= n - i - 1 :<br>            count_jump [ i ] += 1<br>        for j in range ( i + 1 , n - 1 , - 1 ) :<br>            if count_jump [ j ] != - 1 :<br>                count_jump [ i ] += count_jump [ j ]<br>            if count_jump [ i ] == 0 :<br>                count_jump [ i ] = - 1<br>    for i in range ( n ) :<br>        print ( count_jump [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def substringConversions ( str1 , k , b ) :<br>    for i in range ( 0 , len ( str1 ) - k + 1 ) :<br>        sub = str1 [ i : k + i ]<br>        Sum = 0<br>        counter = 0<br>        for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :<br>            Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) )<br>            counter += 1<br>        print ( Sum , end = " " )<br></td>
    <td>translated code: <br><br> def substring_conversions ( str , k , b ) :<br>    i , sum , counter = 0 , 0 , k - 1<br>    for i in range ( k ) :<br>        sum = int ( sum + ( ( str [ i ] - '0' ) * pow ( b , counter ) ) )<br>        counter -= 1<br>    print ( sum , end = ' ' )<br>    prev = sum<br>    sum = 0<br>    counter = 0<br>    for i in range ( len ( str ) ) :<br>        sum = int ( prev - ( ( str [ i - k ] - '0' ) * pow ( b , k - 1 ) ) )<br>        sum = sum * b<br>        sum = sum + ( str [ i ] - '0' )<br>        print ( sum , end = ' ' )<br>        prev = sum<br>        counter += 1<br></td>
  </tr><tr>
    <th>TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minAbsSumPair ( arr , arr_size ) :<br>    inv_count = 0<br>    if arr_size < 2 :<br>        print ( "Invalid Input" )<br>        return<br>    min_l = 0<br>    min_r = 1<br>    min_sum = arr [ 0 ] + arr [ 1 ]<br>    for l in range ( 0 , arr_size - 1 ) :<br>        for r in range ( l + 1 , arr_size ) :<br>            sum = arr [ l ] + arr [ r ]<br>            if abs ( min_sum ) > abs ( sum ) :<br>                min_sum = sum<br>                min_l = l<br>                min_r = r<br>    print ( "The two elements whose sum is minimum are" , arr [ min_l ] , "and " , arr [ min_r ] )<br></td>
    <td>translated code: <br><br> def min_abs_sum_pair ( arr , arr_size ) :<br>    inv_count = 0<br>    l , r , min_sum , sum , min_l , min_r = 0 , 0 , 0 , 0<br>    if arr_size < 2 :<br>        print ( "Invalid Input" )<br>        return<br>    min_l = 0<br>    min_r = 1<br>    min_sum = arr [ 0 ] + arr [ 1 ]<br>    for l in range ( arr_size - 1 ) :<br>        for r in range ( l + 1 , arr_size ) :<br>            sum = arr [ l ] + arr [ r ]<br>            if abs ( min_sum ) > abs ( sum ) :<br>                min_sum = sum<br>                min_l = l<br>                min_r = r<br>    print ( " The two elements whose " "sum is minimum are " , arr [ min_l ] , arr [ min_r ] )<br></td>
  </tr><tr>
    <th>HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findoptimal ( N ) :<br>    if ( N <= 6 ) :<br>        return N<br>    screen = [ 0 ] * N<br>    for n in range ( 1 , 7 ) :<br>        screen [ n - 1 ] = n<br>    for n in range ( 7 , N + 1 ) :<br>        screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) <br>    return screen [ N - 1 ]<br></td>
    <td>translated code: <br><br> def findoptimal ( N ) :<br>    if N <= 6 :<br>        return N<br>    screen = [ ]<br>    b = 0<br>    n = 0<br>    for n in range ( 1 , 6 ) :<br>        screen.append ( n )<br>    for n in range ( 7 , N ) :<br>        screen.append ( max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) )<br>    return screen [ N - 1 ]<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_BINARY_CONVERSION_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def decimalToBinary ( N ) :<br>    B_Number = 0<br>    cnt = 0<br>    while ( N != 0 ) :<br>        rem = N % 2<br>        c = pow ( 10 , cnt )<br>        B_Number += rem * c<br>        N //= 2<br>        cnt += 1<br>    return B_Number<br></td>
    <td>translated code: <br><br> def decimal_to_binary ( N ) :<br>    B_Number = 0<br>    cnt = 0<br>    while N != 0 :<br>        rem = N % 2<br>        c = pow ( 10 , cnt )<br>        B_Number += rem * c<br>        N /= 2<br>        cnt += 1<br>    return B_Number<br></td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPaths ( n , m ) :<br>    if ( n == 0 or m == 0 ) :<br>        return 1<br>    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) )<br></td>
    <td>translated code: <br><br> def count_paths ( n , m ) :<br>    dp = [ [ 1 ] * n + [ m + 1 ] * n for i in range ( 0 , n + 1 ) ]<br>    for i in range ( 0 , m + 1 ) :<br>        dp [ i ] [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , m + 1 ) :<br>            dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ]<br>    return dp [ n ] [ m ]<br></td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumBetweenTwoKth ( arr , n , k1 , k2 ) :<br>    arr.sort ( )<br>    result = 0<br>    for i in range ( k1 , k2 - 1 ) :<br>        result += arr [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def sum_between_two_kth ( arr , k1 , k2 ) :<br>    arr.sort ( )<br>    result = 0<br>    for i in range ( k1 , k2 - 1 ) :<br>        result += arr [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minRange ( arr , n , k ) :<br>    l = 0<br>    r = n<br>    for i in range ( n ) :<br>        s = [ ]<br>        for j in range ( i , n ) :<br>            s.append ( arr [ j ] )<br>            if ( len ( s ) == k ) :<br>                if ( ( j - i ) < ( r - l ) ) :<br>                    r = j<br>                    l = i<br>                break<br>        if ( j == n ) :<br>            break<br>    if ( l == 0 and r == n ) :<br>        print ( "Invalid k" )<br>    else :<br>        print ( l , r )<br></td>
    <td>translated code: <br><br> def minRange ( arr , n , k ) :<br>    l , r = 0 , n<br>    for i in range ( n ) :<br>        s = set ( )<br>        j = 0<br>        for j in range ( i , n ) :<br>            s.add ( arr [ j ] )<br>            if len ( s ) == k :<br>                if ( j - i ) < ( r - l ) :<br>                    r = j<br>                    l = i<br>                break<br>        if j == n :<br>            break<br>    if l == 0 and r == n :<br>        print ( "Invalid k" )<br>    else :<br>        print ( l , r )<br></td>
  </tr><tr>
    <th>AREA_OF_A_HEXAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def hexagonArea ( s ) :<br>    return ( ( 3 * math.sqrt ( 3 ) * ( s * s ) ) / 2 ) <br></td>
    <td>translated code: <br><br> def hexagon_area ( s ) :<br>    return ( ( 3 * math.sqrt ( 3 ) * ( s ** 2 ) ) / 2 )<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextPowerOf2 ( n ) :<br>    n -= 1<br>    n |= n >> 1<br>    n |= n >> 2<br>    n |= n >> 4<br>    n |= n >> 8<br>    n |= n >> 16<br>    n += 1<br>    return n<br></td>
    <td>translated code: <br><br> def next_power_of_2 ( n ) :<br>    n -= 1<br>    n |= n >> 1<br>    n |= n >> 2<br>    n |= n >> 4<br>    n |= n >> 8<br>    n |= n >> 16<br>    n += 1<br>    return n<br></td>
  </tr><tr>
    <th>COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOfSubstringWithKOnes ( s , K ) :<br>    N = len ( s )<br>    res = 0<br>    countOfOne = 0<br>    freq = [ 0 for i in range ( N + 1 ) ]<br>    freq [ 0 ] = 1<br>    for i in range ( 0 , N , 1 ) :<br>        countOfOne += ord ( s [ i ] ) - ord ( '0' )<br>        if ( countOfOne >= K ) :<br>            res += freq [ countOfOne - K ]<br>        freq [ countOfOne ] += 1<br>    return res<br></td>
    <td>translated code: <br><br> def countOfSubstringWithKOnes ( s , K ) :<br>    N = len ( s )<br>    res = 0<br>    countOfOne = 0<br>    freq = [ 1 ] * ( N + 1 )<br>    for i in range ( N ) :<br>        countOfOne += ( s [ i ] - '0' )<br>        if countOfOne >= K :<br>            res += freq [ countOfOne - K ]<br>        freq [ countOfOne ] += 1<br>    return res<br></td>
  </tr><tr>
    <th>NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def answer_query ( a , n , l , r ) :<br>    count = 0<br>    for i in range ( l , r ) :<br>        if ( a [ i ] == a [ i + 1 ] ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def answer_query ( a , n , l , r ) :<br>    count = 0<br>    for i in range ( l , r ) :<br>        if a [ i ] == a [ i + 1 ] :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check_duck ( num ) :<br>    l = len ( num )<br>    count_zero = 0<br>    i = 1<br>    while i < l :<br>        ch = num [ i ]<br>        if ( ch == "0" ) :<br>            count_zero = count_zero + 1<br>        i = i + 1<br>    return count_zero<br></td>
    <td>translated code: <br><br> def check_duck ( num ) :<br>    len ( num )<br>    count_zero = 0<br>    ch = None<br>    for i in range ( 1 , len ( num ) ) :<br>        ch = num [ i ]<br>        if ch == '0' :<br>            count_zero += 1<br>    return count_zero<br></td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countIntegralSolutions ( n ) :<br>    return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 )<br></td>
    <td>translated code: <br><br> def count_integral_solutions ( n ) :<br>    return ( ( n + 1 ) * ( n + 2 ) ) / 2<br></td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxProfit ( price , n , k ) :<br>    profit = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ]<br>    for i in range ( 1 , k + 1 ) :<br>        prevDiff = float ( '-inf' )<br>        for j in range ( 1 , n ) :<br>            prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] )<br>            profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff )<br>    return profit [ k ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def max_profit ( price , n , k ) :<br>    profit = [ [ 0 ] * ( k + 1 ) for i in range ( k + 1 ) ]<br>    for i in range ( 0 , k + 1 ) :<br>        profit [ i ] [ 0 ] = 0<br>    for j in range ( 0 , n + 1 ) :<br>        profit [ 0 ] [ j ] = 0<br>    for i in range ( 1 , k + 1 ) :<br>        prev_diff = int ( 0 )<br>        for j in range ( 1 , n + 1 ) :<br>            prev_diff = max ( prev_diff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] )<br>            profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prev_diff )<br>    return profit [ k ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findCount ( str ) :<br>    result = 0<br>    for i in range ( len ( str ) ) :<br>        if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) :<br>            result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def find_count ( str ) :<br>    result = 0<br>    for c in str :<br>        if c in ( ord ( 'a' ) , ord ( 'z' ) ) :<br>            result += 1<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_GFG_SUBSEQUENCES_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSubsequence ( s , n ) :<br>    cntG = 0<br>    cntF = 0<br>    result = 0<br>    C = 0<br>    for i in range ( n ) :<br>        if ( s [ i ] == 'G' ) :<br>            cntG += 1<br>            result += C<br>            continue<br>        if ( s [ i ] == 'F' ) :<br>            cntF += 1<br>            C += cntG<br>            continue<br>        else :<br>            continue<br>    print ( result )<br></td>
    <td>translated code: <br><br> def count_subgraph ( s , n ) :<br>    cntG , cntF , result , C = 0 , 0 , 0 , 0<br>    for i in range ( n ) :<br>        try :<br>            cntG += 1<br>            result += C<br>        except :<br>            continue<br>    print ( result )<br></td>
  </tr><tr>
    <th>FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSmallest ( arr , n ) :<br>    res = 1<br>    for i in range ( 0 , n ) :<br>        if arr [ i ] <= res :<br>            res = res + arr [ i ]<br>        else :<br>            break<br>    return res<br></td>
    <td>translated code: <br><br> def findSmallest ( arr , n ) :<br>    res = 1<br>    for i in range ( n and arr [ i ] <= res :<br>        res = res + arr [ i ]<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_POINTS_COLLECTED_BY_TWO_PERSONS_ALLOWED_TO_MEET_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxPoints ( A ) :<br>    P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]<br>    P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]<br>    P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]<br>    P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( 1 , M + 1 ) :<br>            P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( N , 0 , - 1 ) :<br>        for j in range ( M , 0 , - 1 ) :<br>            P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( N , 0 , - 1 ) :<br>        for j in range ( 1 , M + 1 ) :<br>            P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( M , 0 , - 1 ) :<br>            P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    ans = 0<br>    for i in range ( 2 , N ) :<br>        for j in range ( 2 , M ) :<br>            op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \<br>                P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ]<br>            op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \<br>                P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ]<br>            ans = max ( ans , max ( op1 , op2 ) )<br>    return ans<br></td>
    <td>translated code: <br><br> def findMaxPoints ( A ) :<br>    P1S = [ [ ] for i in range ( M + 2 ) ]<br>    P1E = [ [ ] for i in range ( M + 2 ) ]<br>    P2S = [ [ ] for i in range ( M + 2 ) ]<br>    P2E = [ [ ] for i in range ( M + 2 ) ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( 1 , M + 1 ) :<br>            P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( N , - 1 , - 1 ) :<br>        for j in range ( M , - 1 , - 1 ) :<br>            P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( N , - 1 , - 1 ) :<br>        for j in range ( M , - 1 , - 1 ) :<br>            P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( M , - 1 , - 1 ) :<br>            P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ]<br>    ans = 0<br>    for i in range ( 2 , N + 1 ) :<br>        for j in range ( 2 , M + 1 ) :<br>            op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ]<br>            op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j + 1 ] + P2S [ i - 1 ] [ j ]<br>            ans += op1</td>
  </tr><tr>
    <th>PROGRAM_FIND_CIRCUMFERENCE_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def circumference ( r ) :<br>    return ( 2 * PI * r )<br></td>
    <td>translated code: <br><br> def circumference ( r ) :<br>    PI = 3.1415<br>    cir = 2 * PI * r<br>    return cir<br></td>
  </tr><tr>
    <th>QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def leftRotate ( arr , n , k ) :<br>    for i in range ( k , k + n ) :<br>        print ( str ( arr [ i % n ] ) , end = " " )<br></td>
    <td>translated code: <br><br> def left_rotate ( arr , n , k ) :<br>    for i in range ( k , k + n ) :<br>        print ( arr [ i % n ] , end = ' ' )<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minSum ( A ) :<br>    min_val = min ( A ) <br>    return min_val * ( len ( A ) - 1 )<br></td>
    <td>translated code: <br><br> def minSum ( A , n ) :<br>    min_val = sum ( A )<br>    return ( min_val * ( n - 1 ) )<br></td>
  </tr><tr>
    <th>RECURSIVE_PROGRAM_PRIME_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPrime ( n , i = 2 ) :<br>    if ( n <= 2 ) :<br>        return True if ( n == 2 ) else False<br>    if ( n % i == 0 ) :<br>        return False<br>    if ( i * i > n ) :<br>        return true<br>    return isPrime ( n , i + 1 )<br></td>
    <td>translated code: <br><br> def isPrime ( n , i ) :<br>    if n <= 2 :<br>        return ( n == 2 )<br>    if n % i == 0 :<br>        return False<br>    if i * i > n :<br>        return True<br>    return isPrime ( n , i + 1 )<br></td>
  </tr><tr>
    <th>SPARSE_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sparseSearch ( arr , key , low , high ) :<br>    left = 0 ; right = 0<br>    while low <= high :<br>        mid = ( low + high ) // 2<br>        if arr [ mid ] == '' :<br>            left = mid - 1<br>            right = mid + 1<br>            if left < low and right > high :<br>                return - 1<br>            elif right <= high and arr [ right ] != '' :<br>                mid = right<br>            elif left >= low and arr [ left ] != '' :<br>                mid = left<br>        if arr [ mid ] == key :<br>            print ( 'Found string {} at index {}'.format ( arr [ mid ] , mid ) )<br>            return<br>        elif arr [ mid ] > key :<br>            high = mid - 1<br>        elif arr [ mid ] < key :<br>            low = mid + 1<br>        left -= 1<br>        right += 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def sparseSearch ( arr , x , n ) :<br>    return binarySearch ( arr , 0 , n - 1 , x )<br></td>
  </tr><tr>
    <th>FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count ( a , b , m , n ) :<br>    if ( ( m == 0 and n == 0 ) or n == 0 ) :<br>        return 1<br>    if ( m == 0 ) :<br>        return 0<br>    if ( a [ m - 1 ] == b [ n - 1 ] ) :<br>        return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) )<br>    else :<br>        return count ( a , b , m - 1 , n )<br></td>
    <td>translated code: <br><br> def count ( a , b , m , n ) :<br>    if ( m == 0 and n == 0 ) or n == 0 :<br>        return 1<br>    if m == 0 :<br>        return 0<br>    if a [ m - 1 ] == b [ n - 1 ] :<br>        return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n )<br>    else :<br>        return count ( a , b , m - 1 , n )<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arraySortedOrNot ( arr , n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return True<br>    for i in range ( 1 , n ) :<br>        if ( arr [ i - 1 ] > arr [ i ] ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def array_sorted_or_not ( arr , n ) :<br>    if n == 0 or n == 1 :<br>        return True<br>    for i in range ( 1 , n ) :<br>        if arr [ i - 1 ] > arr [ i ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxOnesIndex ( arr , n ) :<br>    max_count = 0<br>    max_index = 0<br>    prev_zero = - 1<br>    prev_prev_zero = - 1<br>    for curr in range ( n ) :<br>        if ( arr [ curr ] == 0 ) :<br>            if ( curr - prev_prev_zero > max_count ) :<br>                max_count = curr - prev_prev_zero<br>                max_index = prev_zero<br>            prev_prev_zero = prev_zero<br>            prev_zero = curr<br>    if ( n - prev_prev_zero > max_count ) :<br>        max_index = prev_zero<br>    return max_index<br></td>
    <td>translated code: <br><br> def max_ones_index ( arr , n ) :<br>    max_count = 0<br>    max_index = 0<br>    prev_zero = - 1<br>    prev_prev_zero = - 1<br>    for curr in range ( n ) :<br>        if arr [ curr ] == 0 :<br>            if curr - prev_prev_zero > max_count :<br>                max_count = curr - prev_prev_zero<br>                max_index = prev_zero<br>            prev_prev_zero = prev_zero<br>            prev_zero = curr<br>    if n - prev_prev_zero > max_count :<br>        max_index = prev_zero<br>    return max_index<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxProduct ( arr , n ) :<br>    if n < 3 :<br>        return - 1<br>    arr.sort ( )<br>    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )<br></td>
    <td>translated code: <br><br> def max_product ( arr , n ) :<br>    if n < 3 :<br>        return - 1<br>    arr.sort ( )<br>    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] )<br></td>
  </tr><tr>
    <th>COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRect ( X , Y , n ) :<br>    Xmax = max ( X )<br>    Xmin = min ( X )<br>    Ymax = max ( Y )<br>    Ymin = min ( Y )<br>    print ( "{" , Xmin , ", " , Ymin , "}" , sep = "" )<br>    print ( "{" , Xmin , ", " , Ymax , "}" , sep = "" )<br>    print ( "{" , Xmax , ", " , Ymax , "}" , sep = "" )<br>    print ( "{" , Xmax , ", " , Ymin , "}" , sep = "" )<br></td>
    <td>translated code: <br><br> def print_rect ( X , Y , n ) :<br>    Xmax = sorted ( list ( X ) ) [ : n ]<br>    Xmin = sorted ( list ( X ) ) [ : n ]<br>    Ymax = sorted ( list ( Y ) ) [ : n ]<br>    Ymin = sorted ( list ( Y ) ) [ : n ]<br>    print ( "{" + str ( Xmin ) + ", " + str ( Ymin ) + "}" )<br>    print ( "{" + str ( Xmin ) + ", " + str ( Ymax ) + "}" )<br>    print ( "{" + str ( Xmax ) + ", " + str ( Ymax ) + "}" )<br>    print ( "{" + str ( Xmax ) + ", " + str ( Ymin ) + "}" )<br></td>
  </tr><tr>
    <th>COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOfBinaryNumberLessThanN ( N ) :<br>    q = deque ( )<br>    q.append ( 1 )<br>    cnt = 0<br>    while ( q ) :<br>        t = q.popleft ( )<br>        if ( t <= N ) :<br>            cnt = cnt + 1<br>            q.append ( t * 10 )<br>            q.append ( t * 10 + 1 )<br>    return cnt<br></td>
    <td>translated code: <br><br> def count_of_binary_number_less_N ( N ) :<br>    q = Queue ( )<br>    q.put ( 1 )<br>    cnt = 0<br>    t = None<br>    while q.size ( ) > 0 :<br>        t = q.get ( )<br>        q.put ( )<br>        if t <= N :<br>            cnt += 1<br>            q.put ( t * 10 )<br>            q.put ( t * 10 + 1 )<br>    return cnt<br></td>
  </tr><tr>
    <th>CONVERT_DECIMAL_FRACTION_BINARY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def decimalToBinary ( num , k_prec ) :<br>    binary = ""<br>    Integral = int ( num )<br>    fractional = num - Integral<br>    while ( Integral ) :<br>        rem = Integral % 2<br>        binary += str ( rem ) <br>        Integral //= 2<br>    binary = binary [ : : - 1 ]<br>    binary += '.'<br>    while ( k_prec ) :<br>        fractional *= 2<br>        fract_bit = int ( fractional )<br>        if ( fract_bit == 1 ) :<br>            fractional -= fract_bit<br>            binary += '1'<br>        else :<br>            binary += '0'<br>        k_prec -= 1<br>    return binary<br></td>
    <td>translated code: <br><br> def decimalToBinary ( num , k_prec ) :<br>    binary = ""<br>    Integral = int ( num )<br>    fractional = num - Integral<br>    while Integral > 0 :<br>        rem = Integral % 2<br>        binary += chr ( int ( rem + '0' ) )<br>        Integral /= 2<br>    binary = reverse ( binary )<br>    binary += chr ( '.' )<br>    while k_prec :<br>        fractional *= 2<br>        fract_bit = int ( fractional )<br>        if fract_bit == 1 :<br>            fractional -= fract_bit<br>            binary += chr ( 1 + '0' )<br>        else :<br>            binary += chr ( 0 + '0' )<br>    return binary<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSETS_OF_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumZeros ( arr , n , k ) :<br>    global MAX5<br>    subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ]<br>    subset [ 0 ] [ 0 ] = 0<br>    for p in arr :<br>        pw2 , pw5 = 0 , 0<br>        while not p % 2 :<br>            pw2 += 1<br>            p //= 2<br>        while not p % 5 :<br>            pw5 += 1<br>            p //= 5<br>        for i in range ( k - 1 , - 1 , - 1 ) :<br>            for j in range ( MAX5 ) :<br>                if subset [ i ] [ j ] != - 1 :<br>                    subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) )<br>    ans = 0<br>    for i in range ( MAX5 ) :<br>        ans = max ( ans , min ( i , subset [ k ] [ i ] ) )<br>    return ans<br></td>
    <td>translated code: <br><br> def maximum_zeros ( arr , n , k ) :<br>    subset = [ [ - 1 ] * MAX5 + [ 0 ] * MAX5 for row in subset ]<br>    subset [ 0 ] [ 0 ] = 0<br>    for p in range ( n ) :<br>        pw2 , pw5 = 0 , 0<br>        while arr [ p ] % 2 == 0 :<br>            pw2 += 1<br>            arr [ p ] /= 2<br>        while arr [ p ] % 5 == 0 :<br>            pw5 += 1<br>            arr [ p ] /= 5<br>        for i in range ( k - 1 , - 1 , - 1 ) :<br>            for j in range ( MAX5 ) :<br>                if subset [ i ] [ j ] != - 1 :<br>                    subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 )<br>    ans = 0<br>    for i in range ( MAX5 ) :<br>        ans = max ( ans , min ( i , subset [ k ] [ i ] ) )<br>    return ans<br></td>
  </tr><tr>
    <th>SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , l , h , key ) :<br>    if l > h :<br>        return - 1<br>    mid = ( l + h ) // 2<br>    if arr [ mid ] == key :<br>        return mid<br>    if arr [ l ] <= arr [ mid ] :<br>        if key >= arr [ l ] and key <= arr [ mid ] :<br>            return search ( arr , l , mid - 1 , key )<br>        return search ( arr , mid + 1 , h , key )<br>    if key >= arr [ mid ] and key <= arr [ h ] :<br>        return search ( a , mid + 1 , h , key )<br>    return search ( arr , l , mid - 1 , key )<br></td>
    <td>translated code: <br><br> def search ( arr , l , h , key ) :<br>    if l > h :<br>        return - 1<br>    mid = ( l + h ) // 2<br>    if arr [ mid ] == key :<br>        return mid<br>    if arr [ l ] <= arr [ mid ] :<br>        if key >= arr [ l ] and key <= arr [ mid ] :<br>            return search ( arr , l , mid - 1 , key )<br>        return search ( arr , mid + 1 , h , key )<br>    if key >= arr [ mid ] and key <= arr [ h ] :<br>        return search ( arr , mid + 1 , h , key )<br>    return search ( arr , l , mid - 1 , key )<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_AREA_CIRCULAR_SEGMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def area_of_segment ( radius , angle ) :<br>    area_of_sector = pi *<br>        ( radius * radius )<br>        * ( angle / 360 )<br>    area_of_triangle = 1 / 2 *<br>        ( radius * radius ) *<br>        math.sin ( ( angle * pi ) / 180 )<br>    return area_of_sector - area_of_triangle <br></td>
    <td>translated code: <br><br> def area_of_segment ( radius , angle ) :<br>    area_of_sector = pi * ( radius ** 2 ) * ( angle / 360 )<br>    area_of_triangle = float ( 1 ) / 2 * ( radius ** 2 ) * float ( math.sin ( ( angle * pi ) / 180 ) )<br>    return area_of_sector - area_of_triangle<br></td>
  </tr><tr>
    <th>K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSmall ( arr , n , k ) :<br>    for i in range ( k , n ) :<br>        max_var = arr [ k - 1 ]<br>        pos = k - 1<br>        for j in range ( k - 2 , - 1 , - 1 ) :<br>            if ( arr [ j ] > max_var ) :<br>                max_var = arr [ j ]<br>                pos = j<br>        if ( max_var > arr [ i ] ) :<br>            j = pos<br>            while ( j < k - 1 ) :<br>                arr [ j ] = arr [ j + 1 ]<br>                j += 1<br>            arr [ k - 1 ] = arr [ i ]<br>    for i in range ( 0 , k ) :<br>        print ( arr [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def print_small ( arr , n , k ) :<br>    for i in range ( k , n ) :<br>        max_var = arr [ k - 1 ]<br>        pos = k - 1<br>        for j in range ( k - 2 , - 1 , - 1 ) :<br>            if arr [ j ] > max_var :<br>                max_var = arr [ j ]<br>                pos = j<br>        if max_var > arr [ i ] :<br>            j = pos<br>            while j < k - 1 :<br>                arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]<br>                j += 1<br>            arr [ k - 1 ] , arr [ i ] = arr [ i ] , arr [ i ]<br>    for i in range ( k ) :<br>        print ( arr [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>NTH_NON_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nonFibonacci ( n ) :<br>    prevPrev = 1<br>    prev = 2<br>    curr = 3<br>    while n > 0 :<br>        prevPrev = prev<br>        prev = curr<br>        curr = prevPrev + prev<br>        n = n - ( curr - prev - 1 )<br>    n = n + ( curr - prev - 1 )<br>    return prev + n<br></td>
    <td>translated code: <br><br> def nonFibonacci ( n ) :<br>    prev_prev , prev , curr = 1 , 2 , 3<br>    while n > 0 :<br>        prev_prev , prev , curr = prev , curr , prev_prev + prev<br>        n = n - ( curr - prev - 1 )<br>    n = n + ( curr - prev - 1 )<br>    return prev + n<br></td>
  </tr><tr>
    <th>ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , n , x ) :<br>    i = 0<br>    for i in range ( i , n ) :<br>        if ( arr [ i ] == x ) :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def search ( arr , n , x ) :<br>    i = 0<br>    for i in range ( n ) :<br>        if arr [ i ] == x :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nearestSmallerEqFib ( n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return n<br>    f1 , f2 , f3 = 0 , 1 , 1<br>    while ( f3 <= n ) :<br>        f1 = f2 <br>        f2 = f3 <br>        f3 = f1 + f2 <br>    return f2 <br></td>
    <td>translated code: <br><br> def nearest_smaller_eq_fib ( n ) :<br>    if n == 0 or n == 1 :<br>        return n<br>    f1 , f2 , f3 = 0 , 1 , 1<br>    while f3 <= n :<br>        f1 , f2 , f3 = f2 , f3 , f1 + f2<br>    return f2<br></td>
  </tr><tr>
    <th>PRINT_MAXIMUM_SHORTEST_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find_maximum ( a , n , k ) :<br>    b = dict ( )<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        d = min ( 1 + i , n - i )<br>        if x not in b.keys ( ) :<br>            b [ x ] = d<br>        else :<br>            b [ x ] = min ( d , b [ x ] )<br>    ans = 10 ** 9<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :<br>            ans = min ( max ( b [ x ] , b [ k - x ] ) , ans )<br>    return ans<br></td>
    <td>translated code: <br><br> def find_maximum ( a , n , k ) :<br>    b = { }<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        d = min ( 1 + i , n - i )<br>        if not b.has_key ( x ) :<br>            b [ x ] = d<br>        else :<br>            b [ x ] = min ( d , b [ x ] )<br>    ans = int ( 0 )<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        if x != k - x and b.has_key ( k - x ) :<br>            ans = min ( max ( b [ x ] , b [ k - x ] ) , ans )<br>    return ans<br></td>
  </tr><tr>
    <th>GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOGRAPHIC_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def generate ( st , s ) :<br>    if len ( s ) == 0 :<br>        return<br>    if s not in st :<br>        st.add ( s )<br>        for i in range ( len ( s ) ) :<br>            t = list ( s ).copy ( )<br>            t.remove ( s [ i ] )<br>            t = ''.join ( t )<br>            generate ( st , t )<br>    return<br></td>
    <td>translated code: <br><br> def generate ( st , s ) :<br>    if len ( s ) == 0 :<br>        return<br>    if not st.has_key ( s ) :<br>        st [ s ] = [ ]<br>        for t in s :<br>            t = t.split ( ' ' )<br>            t = t [ 0 ] + t [ 1 : ]<br>            generate ( st , t )<br>    return<br></td>
  </tr><tr>
    <th>WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pow ( a , b ) :<br>    if ( b == 0 ) :<br>        return 1<br>    answer = a<br>    increment = a<br>    for i in range ( 1 , b ) :<br>        for j in range ( 1 , a ) :<br>            answer += increment<br>        increment = answer<br>    return answer<br></td>
    <td>translated code: <br><br> def pow ( a , b ) :<br>    if b == 0 :<br>        return 1<br>    answer = a<br>    increment = a<br>    i , j = 0 , 0<br>    for i in range ( 1 , b ) :<br>        for j in range ( 1 , a ) :<br>            answer += increment<br>        increment = answer<br>    return answer<br></td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxvolume ( s ) :<br>    length = int ( s / 3 )<br>    s -= length<br>    breadth = s / 2<br>    height = s - breadth<br>    return int ( length * breadth * height )<br></td>
    <td>translated code: <br><br> def maxvolume ( s ) :<br>    length = s / 3<br>    s -= length<br>    breadth = s / 2<br>    height = s - breadth<br>    return length * breadth * height<br></td>
  </tr><tr>
    <th>HORNERS_METHOD_POLYNOMIAL_EVALUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def horner ( poly , n , x ) :<br>    result = poly [ 0 ]<br>    for i in range ( 1 , n ) :<br>        result = result * x + poly [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def horner ( poly , n , x ) :<br>    result = poly [ 0 ]<br>    for i in range ( 1 , n ) :<br>        result = result * x + poly [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minTime ( arr , n , m ) :<br>    t = 0<br>    while ( 1 ) :<br>        items = 0<br>        for i in range ( n ) :<br>            items += ( t // arr [ i ] )<br>        if ( items >= m ) :<br>            return t<br>        t += 1<br></td>
    <td>translated code: <br><br> def minTime ( arr , n , m ) :<br>    t = 0<br>    while True :<br>        items = 0<br>        for i in range ( n ) :<br>            items += ( t / arr [ i ] )<br>        if items >= m :<br>            return t<br>        t += 1<br></td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def difference ( arr , n ) :<br>    d1 = 0<br>    d2 = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            if ( i == j ) :<br>                d1 += arr [ i ] [ j ]<br>            if ( i == n - j - 1 ) :<br>                d2 += arr [ i ] [ j ]<br>    return abs ( d1 - d2 ) <br></td>
    <td>translated code: <br><br> def difference ( arr , n ) :<br>    d1 , d2 = 0 , 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if i == j :<br>                d1 += arr [ i ] [ j ]<br>            if i == n - j - 1 :<br>                d2 += arr [ i ] [ j ]<br>    return abs ( d1 - d2 )<br></td>
  </tr><tr>
    <th>SHORTEST_UNCOMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shortestSeq ( S : list , T : list ) :<br>    m = len ( S )<br>    n = len ( T )<br>    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ]<br>    for i in range ( m + 1 ) :<br>        dp [ i ] [ 0 ] = 1<br>    for i in range ( n + 1 ) :<br>        dp [ 0 ] [ i ] = MAX<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            ch = S [ i - 1 ]<br>            k = j - 1<br>            while k >= 0 :<br>                if T [ k ] == ch :<br>                    break<br>                k -= 1<br>            if k == - 1 :<br>                dp [ i ] [ j ] = 1<br>            else :<br>                dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 )<br>    ans = dp [ m ] [ n ]<br>    if ans >= MAX :<br>        ans = - 1<br>    return ans<br></td>
    <td>translated code: <br><br> def shortestSeq ( S , T ) :<br>    m , n = len ( S ) , len ( T )<br>    dp = [ [ 1 ] * m + [ n + 1 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m</td>
  </tr><tr>
    <th>MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findFlips ( str , n ) :<br>    last = ' '<br>    res = 0<br>    for i in range ( n ) :<br>        if ( last != str [ i ] ) :<br>            res += 1<br>        last = str [ i ]<br>    return res // 2<br></td>
    <td>translated code: <br><br> def find_flips ( str , n ) :<br>    last = ' '<br>    res = 0<br>    for i in range ( n ) :<br>        if last != str [ i ] :<br>            res += 1<br>        last = str [ i ]<br>    return res / 2<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinInsertions ( str , l , h ) :<br>    if ( l > h ) :<br>        return sys.maxsize<br>    if ( l == h ) :<br>        return 0<br>    if ( l == h - 1 ) :<br>        return 0 if ( str [ l ] == str [ h ] ) else 1<br>    if ( str [ l ] == str [ h ] ) :<br>        return findMinInsertions ( str , l + 1 , h - 1 )<br>    else :<br>        return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 )<br></td>
    <td>translated code: <br><br> def find_min_insertions ( str , l , h ) :<br>    if l > h :<br>        return int ( l )<br>    if l == h :<br>        return 0<br>    if l == h - 1 :<br>        return ( str [ l ] , str [ h ] )<br>    return ( str [ l ] , find_min_insertions ( str , l + 1 , h - 1 ) )<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( str1 ) :<br>    result = 0 <br>    n = len ( str1 )<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) :<br>                result += 1 <br>    return result <br></td>
    <td>translated code: <br><br> def countPairs ( str ) :<br>    result = 0<br>    n = len ( str )<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if abs ( str [ i ] - str [ j ] ) == abs ( i - j ) :<br>                result += 1<br>    return result<br></td>
  </tr><tr>
    <th>MULTISTAGE_GRAPH_SHORTEST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shortestDist ( graph ) :<br>    global INF<br>    dist = [ 0 ] * N<br>    dist [ N - 1 ] = 0<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        dist [ i ] = INF<br>        for j in range ( N ) :<br>            if graph [ i ] [ j ] == INF :<br>                continue<br>            dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] )<br>    return dist [ 0 ]<br></td>
    <td>translated code: <br><br> def shortest_dist ( graph ) :<br>    dist = [ INF ]<br>    dist [ - 1 ] = 0<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        dist [ i ] = INF<br>        for j in range ( i , N ) :<br>            if graph [ i ] [ j ] == INF :<br>                continue<br>            dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] )<br>    return dist [ 0 ]<br></td>
  </tr><tr>
    <th>MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printMaxSubSquare ( M ) :<br>    R = len ( M )<br>    C = len ( M [ 0 ] )<br>    S = [ [ 0 for k in range ( C ) ] for l in range ( R ) ]<br>    for i in range ( 1 , R ) :<br>        for j in range ( 1 , C ) :<br>            if ( M [ i ] [ j ] == 1 ) :<br>                S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1<br>            else :<br>                S [ i ] [ j ] = 0<br>    max_of_s = S [ 0 ] [ 0 ]<br>    max_i = 0<br>    max_j = 0<br>    for i in range ( R ) :<br>        for j in range ( C ) :<br>            if ( max_of_s < S [ i ] [ j ] ) :<br>                max_of_s = S [ i ] [ j ]<br>                max_i = i<br>                max_j = j<br>    print ( "Maximum size sub-matrix is: " )<br>    for i in range ( max_i , max_i - max_of_s , - 1 ) :<br>        for j in range ( max_j , max_j - max_of_s , - 1 ) :<br>            print ( M [ i ] [ j ] , end = "" )<br>        print ( "" )<br></td>
    <td>translated code: <br><br> def print_max_sub_square ( M ) :<br>    i , j = 0 , 0<br>    R = len ( M )<br>    C = len ( M [ 0 ] )<br>    S = [ [ 0 ] * R , [ 0 ] * C ]<br>    max_of_s , max_i , max_j = 0 , 0 , 0<br>    for i in range ( R ) :<br>        S [ i ] [ 0 ] = M [ i ] [ 0 ]<br>    for j in range ( C ) :<br>        S [ 0 ] [ j ] = M [ 0 ] [ j ]<br>    for i in range ( 1 , R ) :<br>        for j in range ( 1 , C ) :<br>            if M [ i ] [ j ] == 1 :<br>                S [ i ] [ j ] = min ( S [ i ] [ j - 1 ] , min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1<br>            else :<br>                S [ i ] [ j ] = 0<br>    max_of_s = S [ 0 ] [ 0 ]<br>    max_i , max_j = 0 , 0<br>    for i in range ( R ) :<br>        for j in range ( C ) :<br>            if max_of_s < S [ i ] [ j ] :<br>                max_of_s = S [ i ] [ j ]<br>                max_i = i<br>                max_j = j<br>    print ( "Maximum size sub-matrix is: " )<br>    for i in range ( max_i , max_i - max_of_s , 2 ) :<br>        for j in range ( max_j , max_j - max_of_s , 2 ) :<br>            print ( M [ i ] [ j ] , end = ' ' )<br>        print ( )<br></td>
  </tr><tr>
    <th>GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printClosest ( arr , n , x ) :<br>    res_l , res_r = 0 , 0<br>    l , r , diff = 0 , n - 1 , MAX_VAL<br>    while r > l :<br>        if abs ( arr [ l ] + arr [ r ] - x ) < diff :<br>            res_l = l<br>            res_r = r<br>            diff = abs ( arr [ l ] + arr [ r ] - x )<br>        if arr [ l ] + arr [ r ] > x :<br>            r -= 1<br>        else :<br>            l += 1<br>    print ( 'The closest pair is {} and {}'.format ( arr [ res_l ] , arr [ res_r ] ) )<br></td>
    <td>translated code: <br><br> def printClosest ( arr , n , x ) :<br>    res_l , res_r = 0 , 0<br>    l , r = 0 , n - 1 , int ( x )<br>    while r > l :<br>        if abs ( arr [ l ] + arr [ r ] - x ) < diff :<br>            res_l = l<br>            res_r = r<br>            diff = abs ( arr [ l ] + arr [ r ] - x )<br>        if arr [ l ] + arr [ r ] > x :<br>            r -= 1<br>        else :<br>            l += 1<br>    print ( " The closest pair is " + str ( arr [ res_l ] ) + " and " + str ( arr [ res_r ] ) )<br></td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortedAfterSwap ( A , B , n ) :<br>    for i in range ( 0 , n - 1 ) :<br>        if B [ i ] :<br>            if A [ i ] != i + 1 :<br>                A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ]<br>    for i in range ( n ) :<br>        if A [ i ] != i + 1 :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def sortedAfterSwap ( A , B , n ) :<br>    t = 0<br>    for i in range ( n - 1 ) :<br>        if B [ i ] != 0 :<br>            if A [ i ] != i + 1 :<br>                t = A [ i ]<br>            A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i + 1 ]<br>            A [ i + 1 ] = t<br>    for i in range ( n ) :<br>        if A [ i ] != i + 1 :<br>            return 0<br>    return 1<br></td>
  </tr><tr>
    <th>TILE_STACKING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def possibleWays ( n , m , k ) :<br>    dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ]<br>    presum = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ 0 ] [ i ] = 0<br>        presum [ 0 ] [ i ] = 1<br>    for i in range ( 0 , m + 1 ) :<br>        presum [ i ] [ 0 ] = 1<br>        dp [ i ] [ 0 ] = 1<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            dp [ i ] [ j ] = presum [ i - 1 ] [ j ]<br>            if j > k :<br>                dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ]<br>        for j in range ( 1 , n + 1 ) :<br>            presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ]<br>    return dp [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def possible_ways ( n , m , k ) :<br>    dp = [ [ 0 ] * N for i in range ( N ) ]<br>    presum = [ [ 0 ] * N for i in range ( N ) ]<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            dp [ i ] [ j ] = 0<br>            presum [ i ] [ j ] = 0<br>    for i in range ( 1 , n + 1 ) :<br>        dp [ 0 ] [ i ] = 0<br>        presum [ 0 ] [ i ] = 1<br>    for i in range ( m + 1 ) :<br>        presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            dp [ i ] [ j ] = presum [ i - 1 ] [ j ]<br>            if j > k :<br>                dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ]<br>        for j in range ( 1 , n + 1 ) :<br>            presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ]<br>    return dp [ m ] [ n ]<br></td>
  </tr><tr>
    <th>NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumEqualProduct ( a , n ) :<br>    zero = 0<br>    two = 0<br>    for i in range ( n ) :<br>        if a [ i ] == 0 :<br>            zero += 1<br>        if a [ i ] == 2 :<br>            two += 1<br>    cnt = ( zero * ( zero - 1 ) ) // 2 + \<br>        ( two * ( two - 1 ) ) // 2<br>    return cnt<br></td>
    <td>translated code: <br><br> def sum_equal_product ( a , n ) :<br>    zero , two = 0 , 0<br>    for i in range ( n ) :<br>        if a [ i ] == 0 : zero += 1<br>        if a [ i ] == 2 : two += 1<br>    cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2<br>    return cnt<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minPalPartion ( str ) :<br>    n = len ( str )<br>    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]<br>    P = [ [ False for i in range ( n ) ] for i in range ( n ) ]<br>    j = 0<br>    k = 0<br>    L = 0<br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True <br>        C [ i ] [ i ] = 0 <br>    for L in range ( 2 , n + 1 ) :<br>        for i in range ( n - L + 1 ) :<br>            j = i + L - 1<br>            if L == 2 :<br>                P [ i ] [ j ] = ( str [ i ] == str [ j ] )<br>            else :<br>                P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] )<br>            if P [ i ] [ j ] == True :<br>                C [ i ] [ j ] = 0<br>            else :<br>                C [ i ] [ j ] = 100000000<br>                for k in range ( i , j ) :<br>                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )<br>    return C [ 0 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def min_palse_partion ( str ) :<br>    n = len ( str )<br>    C = [ [ ] for i in range ( n ) ]<br>    P = [ [ ] for i in range ( n ) ]<br>    i , j , k , L = 0 , 0 , 0 , 0<br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True<br>        C [ i ] [ i ] = 0<br>    for L in range ( 2 , n + 1 ) :<br>        for i in range ( n - L + 1 ) :<br>            j = i + L - 1<br>            if L == 2 :<br>                P [ i ] [ j ] = ( str [ i ] == str [ j ] )<br>            else :<br>                P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ]<br>            if P [ i ] [ j ] == True :<br>                C [ i ] [ j ] = 0<br>            else :<br>                C [ i ] [ j ] = int ( str [ i ] )<br>                for k in range ( i , j - 1 ) :<br>                    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 )<br>    return C [ 0 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRepeatingNumber ( arr , n ) :<br>    sq = sqrt ( n )<br>    range__ = int ( ( n / sq ) + 1 )<br>    count = [ 0 for i in range ( range__ ) ]<br>    for i in range ( 0 , n + 1 , 1 ) :<br>        count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1<br>    selected_block = range__ - 1<br>    for i in range ( 0 , range__ - 1 , 1 ) :<br>        if ( count [ i ] > sq ) :<br>            selected_block = i<br>            break<br>    m = { i : 0 for i in range ( n ) }<br>    for i in range ( 0 , n + 1 , 1 ) :<br>        if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) :<br>            m [ arr [ i ] ] += 1<br>            if ( m [ arr [ i ] ] > 1 ) :<br>                return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_repeating_number ( arr , n ) :<br>    sq = int ( math.sqrt ( n ) )<br>    range = ( n // sq ) + 1<br>    count = [ 0 ] * range<br>    for i in range :<br>        count [ ( arr [ i ] - 1 ) // sq ] += 1<br>    selected_block = range - 1<br>    for i in range - 1 :<br>        if count [ i ] > sq :<br>            selected_block = i<br>            break<br>    m = { }<br>    for i in range ( 0 , n ) :<br>        if ( ( selected_block * sq ) < arr [ i ] ) :<br>            m [ arr [ i ] ] = 1<br>            if m [ arr [ i ] ] == 1 :<br>                return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_PATH_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minSumPath ( A ) :<br>    memo = [ None ] * len ( A )<br>    n = len ( A ) - 1<br>    for i in range ( len ( A [ n ] ) ) :<br>        memo [ i ] = A [ n ] [ i ]<br>    for i in range ( len ( A ) - 2 , - 1 , - 1 ) :<br>        for j in range ( len ( A [ i ] ) ) :<br>            memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) <br>    return memo [ 0 ]<br></td>
    <td>translated code: <br><br> def minSumPath ( ) :<br>    memo = [ ]<br>    n = len ( A ) - 1<br>    for i in range ( len ( A [ n ] ) ) :<br>        memo.append ( A [ n ] [ i ] )<br>    for i in range ( len ( A ) - 2 , - 1 , - 1 ) :<br>        for j in range ( len ( A [ i ] ) ) :<br>            memo.append ( A [ i ] [ j ] + int ( min ( memo [ j ] , memo [ j + 1 ] ) ) )<br>    return memo [ 0 ]<br></td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getSum ( n ) :<br>    sum = 0<br>    while ( n > 0 ) :<br>        sum += int ( n % 10 )<br>        n = int ( n / 10 )<br>    return sum<br></td>
    <td>translated code: <br><br> def getSum ( n ) :<br>    sum = 0<br>    for n in range ( 0 , n ) :<br>        sum += n % 10 , n /= 10<br>    return sum<br></td>
  </tr><tr>
    <th>RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printFun ( test ) :<br>    if ( test < 1 ) :<br>        return<br>    else :<br>        print ( test , end = " " )<br>        printFun ( test - 1 )<br>        print ( test , end = " " )<br>        return<br></td>
    <td>translated code: <br><br> def print_fun ( test ) :<br>    if test < 1 :<br>        return<br>    else :<br>        print ( test , end = ' ' )<br>        print_fun ( test - 1 )<br>        print ( test , end = ' ' )<br>        return<br></td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxTripletSum ( arr , n ) :<br>    sm = - 1000000<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            for k in range ( j + 1 , n ) :<br>                if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) :<br>                    sm = arr [ i ] + arr [ j ] + arr [ k ]<br>    return sm<br></td>
    <td>translated code: <br><br> def max_triplet_sum ( arr , n ) :<br>    sum = - 1000000<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            for k in range ( j + 1 , n ) :<br>                if sum < arr [ i ] + arr [ j ] + arr [ k ] :<br>                    sum = arr [ i ] + arr [ j ] + arr [ k ]<br>    return sum<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minJumps ( arr , n ) :<br>    jumps = [ 0 for i in range ( n ) ]<br>    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :<br>        return float ( 'inf' )<br>    jumps [ 0 ] = 0<br>    for i in range ( 1 , n ) :<br>        jumps [ i ] = float ( 'inf' )<br>        for j in range ( i ) :<br>            if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( 'inf' ) ) :<br>                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )<br>                break<br>    return jumps [ n - 1 ]<br></td>
    <td>translated code: <br><br> def _min_jumps ( arr , n ) :<br>    jumps = [ ]<br>    i , j = 0 , 0<br>    if n == 0 or arr [ 0 ] == 0 :<br>        return int ( 'inf' )<br>    jumps.append ( 0 )<br>    for i in range ( 1 , n ) :<br>        jumps.append ( int ( 'inf' ) )<br>        for j in range ( i ) :<br>            if i <= j + arr [ j ] and jumps [ j ] != int ( 'inf' ) :<br>                jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 )<br>                break<br>    return jumps [ n - 1 ]<br></td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxVal ( arr , n , num , maxLimit ) :<br>    ind = - 1 <br>    val = - 1 <br>    dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] <br>    for ind in range ( n ) :<br>        for val in range ( maxLimit + 1 ) :<br>            if ( ind == 0 ) :<br>                if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) :<br>                    dp [ ind ] [ val ] = 1 <br>                else :<br>                    dp [ ind ] [ val ] = 0 <br>            else :<br>                if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) :<br>                    if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) :<br>                        dp [ ind ] [ val ] = 1 <br>                elif ( val - arr [ ind ] >= 0 ) :<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] <br>                elif ( val + arr [ ind ] <= maxLimit ) :<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] <br>                else :<br>                    dp [ ind ] [ val ] = 0 <br>    for val in range ( maxLimit , - 1 , - 1 ) :<br>        if ( dp [ n - 1 ] [ val ] == 1 ) :<br>            return val <br>    return - 1 <br></td>
    <td>translated code: <br><br> def find_max_val ( arr , n , num , max_limit ) :<br>    ind = 0<br>    val = 0<br>    dp = [ [ 0 ] * ( n + 1 ) ] * ( max_limit + 1 )<br>    for ind in range ( n ) :<br>        for val in range ( 0 , max_limit + 1 ) :<br>            if ind == 0 :<br>                if num - arr [ ind ] == val or num + arr [ ind ] == val :<br>                    dp [ ind ] [ val ] = 1<br>                else :<br>                    dp [ ind ] [ val ] = 0<br>            else :<br>                if val - arr [ ind ] >= 0 and val + arr [ ind ] <= max_limit :<br>                    if dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 :<br>                        dp [ ind ] [ val ] = 1<br>                elif val - arr [ ind ] >= 0 :<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ]<br>                elif val + arr [ ind ] <= max_limit :<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ]<br>                else :<br>                    dp [ ind ] [ val ] = 0<br>    for val in range ( max_limit , - 1 , - 1 ) :<br>        if dp [ n - 1 ] [ val ] == 1 :<br>            return val<br>    return - 1<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Resources ( process , need ) :<br>    minResources = 0<br>    minResources = process * ( need - 1 ) + 1<br>    return minResources<br></td>
    <td>translated code: <br><br> def Resources ( process , need ) :<br>    min_resources = 0<br>    min_resources = process * ( need - 1 ) + 1<br>    return min_resources<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDigits ( a , b ) :<br>    count = 0<br>    p = abs ( a * b )<br>    if ( p == 0 ) :<br>        return 1<br>    while ( p > 0 ) :<br>        count = count + 1<br>        p = p // 10<br>    return count<br></td>
    <td>translated code: <br><br> def count_digits ( a , b ) :<br>    count = 0<br>    p = abs ( a * b )<br>    if p == 0 :<br>        return 1<br>    while p > 0 :<br>        count += 1<br>        p = p / 10<br>    return count<br></td>
  </tr><tr>
    <th>FLOOR_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def floorSearch ( arr , low , high , x ) :<br>    if ( low > high ) :<br>        return - 1<br>    if ( x >= arr [ high ] ) :<br>        return high<br>    mid = int ( ( low + high ) / 2 )<br>    if ( arr [ mid ] == x ) :<br>        return mid<br>    if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) :<br>        return mid - 1<br>    if ( x < arr [ mid ] ) :<br>        return floorSearch ( arr , low , mid - 1 , x )<br>    return floorSearch ( arr , mid + 1 , high , x )<br></td>
    <td>translated code: <br><br> def floorSearch ( arr , n , x ) :<br>    if x >= arr [ n - 1 ] :<br>        return n - 1<br>    if x < arr [ 0 ] :<br>        return - 1<br>    for i in range ( 1 , n ) :<br>        if arr [ i ] > x :<br>            return ( i - 1 )<br>    return - 1<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkValidity ( a , b , c ) :<br>    if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :<br>        return False<br>    else :<br>        return True<br></td>
    <td>translated code: <br><br> def checkValidity ( a , b , c ) :<br>    if a + b <= c or a + c <= b or b + c <= a :<br>        return 0<br>    else :<br>        return 1<br></td>
  </tr><tr>
    <th>PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSpiral ( n ) :<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) )<br>            if ( i <= j ) :<br>                print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = "\t" )<br>            else :<br>                print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = "\t" )<br>        print ( )<br></td>
    <td>translated code: <br><br> def print_spiral ( n ) :<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) )<br>            if i <= j :<br>                print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" )<br>            else :<br>                print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + "\t" )<br>        print ( )<br></td>
  </tr><tr>
    <th>POSITION_ELEMENT_STABLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getIndexInSortedArray ( arr , n , idx ) :<br>    result = 0<br>    for i in range ( n ) :<br>        if ( arr [ i ] < arr [ idx ] ) :<br>            result += 1<br>        if ( arr [ i ] == arr [ idx ] and i < idx ) :<br>            result += 1<br>    return result <br></td>
    <td>translated code: <br><br> def getIndexInSortedArray ( arr , n , idx ) :<br>    result = 0<br>    for i in range ( n ) :<br>        if arr [ i ] < arr [ idx ] :<br>            result += 1<br>        if arr [ i ] == arr [ idx ] and i < idx :<br>            result += 1<br>    return result<br></td>
  </tr><tr>
    <th>MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxSegment ( s , k ) :<br>    seg_len = len ( s ) - k<br>    res = 0<br>    for i in range ( seg_len ) :<br>        res = res * 10 + ( ord ( s [ i ] ) - ord ( '0' ) )<br>    seg_len_pow = pow ( 10 , seg_len - 1 )<br>    curr_val = res<br>    for i in range ( 1 , len ( s ) - seg_len ) :<br>        curr_val = curr_val - ( ord ( s [ i - 1 ] ) - ord ( '0' ) ) * seg_len_pow<br>        curr_val = ( curr_val * 10 + ( ord ( s [ i + seg_len - 1 ] ) - ord ( '0' ) ) )<br>        res = max ( res , curr_val )<br>    return res<br></td>
    <td>translated code: <br><br> def find_max_segment ( s , k ) :<br>    seg_len = len ( s ) - k<br>    res = 0<br>    for i in range ( seg_len ) :<br>        res = res * 10 + ( s [ i ] - '0' )<br>    seg_len_pow = int ( math.pow ( 10 , seg_len - 1 ) )<br>    curr_val = res<br>    for i in range ( 1 , ( len ( s ) - seg_len ) ) :<br>        curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow<br>        curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' )<br>        res = max ( res , curr_val )<br>    return res<br></td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def PowerOFPINnfactorial ( n , p ) :<br>    ans = 0<br>    temp = p<br>    while ( temp <= n ) :<br>        ans += n / temp<br>        temp = temp * p<br>    return int ( ans )<br></td>
    <td>translated code: <br><br> def PowerOFPINnfactorial ( n , p ) :<br>    ans = 0<br>    temp = p<br>    while temp <= n :<br>        ans += n // temp<br>        temp = temp * p<br>    return ans<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Identity ( size ) :<br>    for row in range ( 0 , size ) :<br>        for col in range ( 0 , size ) :<br>            if ( row == col ) :<br>                print ( "1 " , end = " " )<br>            else :<br>                print ( "0 " , end = " " )<br>        print ( )<br></td>
    <td>translated code: <br><br> def identity ( num ) :<br>    row , col = 0 , 0<br>    for row in range ( num ) :<br>        for col in range ( num ) :<br>            if row == col :<br>                print ( 1 , end = '' )<br>            else :<br>                print ( 0 , end = '' )<br>        print ( )<br>    return 0<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( N ) :<br>    ans = 0<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( 1 , N + 1 ) :<br>            ans += i // j<br>    return ans<br></td>
    <td>translated code: <br><br> def find_sum ( n ) :<br>    ans = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            ans += ( i / j )<br>    return ans<br></td>
  </tr><tr>
    <th>TILING_WITH_DOMINOES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( n ) :<br>    A = [ 0 ] * ( n + 1 )<br>    B = [ 0 ] * ( n + 1 )<br>    A [ 0 ] = 1<br>    A [ 1 ] = 0<br>    B [ 0 ] = 0<br>    B [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]<br>        B [ i ] = A [ i - 1 ] + B [ i - 2 ]<br>    return A [ n ]<br></td>
    <td>translated code: <br><br> def countWays ( n ) :<br>    A = [ 1 ] * ( n + 1 )<br>    B = [ 0 ] * ( n + 1 )<br>    for i in range ( 2 , n + 1 ) :<br>        A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]<br>        B [ i ] = A [ i - 1 ] + B [ i - 2 ]<br>    return A [ n ]<br></td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDer ( n ) :<br>    if ( n == 1 ) : return 0<br>    if ( n == 0 ) : return 1<br>    if ( n == 2 ) : return 1<br>    return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) )<br></td>
    <td>translated code: <br><br> def count_der ( n ) :<br>    if n == 1 :<br>        return 0<br>    if n == 0 :<br>        return 1<br>    if n == 2 :<br>        return 1<br>    return ( n - 1 ) * ( count_der ( n - 1 ) + count_der ( n - 2 ) )<br></td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFreq ( a , n ) :<br>    hm = dict ( )<br>    for i in range ( n ) :<br>        hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1<br>    cumul = 0<br>    for i in range ( n ) :<br>        cumul += hm [ a [ i ] ]<br>        if ( hm [ a [ i ] ] > 0 ) :<br>            print ( a [ i ] , "->" , cumul )<br>        hm [ a [ i ] ] = 0<br></td>
    <td>translated code: <br><br> def count_freq ( a , n ) :<br>    hm = { }<br>    for i in range ( n ) :<br>        hm [ a [ i ] ] += 1<br>    cumul = 0<br>    for i in range ( n ) :<br>        cumul += hm [ a [ i ] ]<br>        if hm [ a [ i ] ] != 0 :<br>            print ( a [ i ] , "->" , cumul )<br>        hm [ a [ i ] ] = 0<br></td>
  </tr><tr>
    <th>MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minSum ( n ) :<br>    sum = 0 <br>    while ( n > 0 ) :<br>        sum += ( n % 10 ) <br>        n //= 10 <br>    if ( sum == 1 ) :<br>        return 10 <br>    return sum <br></td>
    <td>translated code: <br><br> def minSum ( n ) :<br>    sum = 0<br>    while n > 0 :<br>        sum += ( n % 10 )<br>        n /= 10<br>    if sum == 1 :<br>        return 10<br>    return sum<br></td>
  </tr><tr>
    <th>DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximizecube ( l , b , h ) :<br>    side = gcd ( l , gcd ( b , h ) )<br>    num = int ( l / side )<br>    num = int ( num * b / side )<br>    num = int ( num * h / side )<br>    print ( side , num )<br></td>
    <td>translated code: <br><br> def maximizecube ( l , b , h ) :<br>    side = gcd ( l , gcd ( b , h ) )<br>    num = l / side<br>    num = ( num * b / side )<br>    num = ( num * h / side )<br>    print ( side , num )<br></td>
  </tr><tr>
    <th>CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPowerOfK ( n , k ) :<br>    oneSeen = False<br>    while ( n > 0 ) :<br>        digit = n % k<br>        if ( digit > 1 ) :<br>            return False<br>        if ( digit == 1 ) :<br>            if ( oneSeen ) :<br>                return False<br>            oneSeen = True<br>        n //= k<br>    return True<br></td>
    <td>translated code: <br><br> def is_power_of_k ( n , k ) :<br>    one_seen = False<br>    while n :<br>        digit = n % k<br>        if digit > 1 :<br>            return False<br>        if digit == 1 :<br>            if one_seen :<br>                return False<br>            one_seen = True<br>        n /= k<br>    return True<br></td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def PositionRightmostSetbit ( n ) :<br>    position = 1<br>    m = 1<br>    while ( not ( n & m ) ) :<br>        m = m << 1<br>        position += 1<br>    return position<br></td>
    <td>translated code: <br><br> def PositionRightmostSetbit ( n ) :<br>    position = 1<br>    m = 1<br>    while ( n & m ) == 0 :<br>        m = m << 1<br>        position += 1<br>    return position<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def insertSorted ( arr , n , key , capacity ) :<br>    if ( n >= capacity ) :<br>        return n<br>    i = n - 1<br>    while i >= 0 and arr [ i ] > key :<br>        arr [ i + 1 ] = arr [ i ]<br>        i -= 1<br>    arr [ i + 1 ] = key<br>    return ( n + 1 )<br></td>
    <td>translated code: <br><br> def insert_sorted ( arr , n , key , capacity ) :<br>    if n >= capacity :<br>        return n<br>    i = 0<br>    for ( i , item ) in enumerate ( arr ) :<br>        arr [ i + 1 ] = item<br>    arr [ i + 1 ] = key<br>    return ( n + 1 , arr )<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printMaxOfMin ( arr , n ) :<br>    s = [ ]<br>    left = [ - 1 ] * ( n + 1 )<br>    right = [ n ] * ( n + 1 )<br>    for i in range ( n ) :<br>        while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) :<br>            s.pop ( )<br>        if ( len ( s ) != 0 ) :<br>            left [ i ] = s [ - 1 ]<br>        s.append ( i )<br>    while ( len ( s ) != 0 ) :<br>        s.pop ( )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) :<br>            s.pop ( )<br>        if ( len ( s ) != 0 ) :<br>            right [ i ] = s [ - 1 ]<br>        s.append ( i )<br>    ans = [ 0 ] * ( n + 1 )<br>    for i in range ( n + 1 ) :<br>        ans [ i ] = 0<br>    for i in range ( n ) :<br>        Len = right [ i ] - left [ i ] - 1<br>        ans [ Len ] = max ( ans [ Len ] , arr [ i ] )<br>    for i in range ( n - 1 , 0 , - 1 ) :<br>        ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] )<br>    for i in range ( 1 , n + 1 ) :<br>        print ( ans [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def print_max_of_min ( n ) :<br>    s = Stack ( )<br>    left = [ - 1 ] * n + [ n ]<br>    right = [ n ] * n + [ n ]<br>    for i in range ( n ) :<br>        left [ i ] = - 1<br>        right [ i ] = n<br>    for i in range ( n ) :<br>        while not s.empty ( ) and arr [ s.pop ( ) ] >= arr [ i ] :<br>            s.pop ( )<br>        if not s.empty ( ) :<br>            left [ i ] = s.pop ( )<br>        s.push ( i )<br>    while not s.empty ( ) :<br>        s.pop ( )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        while not s.empty ( ) and arr [ s.pop ( ) ] >= arr [ i ] :<br>            s.pop ( )<br>        if not s.empty ( ) :<br>            right [ i ] = s.pop ( )<br>        s.push ( i )<br>    ans = [ ]<br>    for i in range ( 0 , n + 1 ) :<br>        ans.append ( 0 )<br>    for i in range ( 0 , n + 1 ) :<br>        len = right [ i ] - left [ i ] - 1<br>        ans [ len ] = max ( ans [ len ] , arr [ i ] )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] )<br>    for i in range ( 1 , n + 1 ) :<br>        print ( ans [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MaximumDecimalValue ( mat , n ) :<br>    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]<br>    if ( mat [ 0 ] [ 0 ] == 1 ) :<br>        dp [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , n ) :<br>        if ( mat [ 0 ] [ i ] == 1 ) :<br>            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i<br>        else :<br>            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]<br>    for i in range ( 1 , n ) :<br>        if ( mat [ i ] [ 0 ] == 1 ) :<br>            dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i<br>    else :<br>        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( 1 , n ) :<br>            if ( mat [ i ] [ j ] == 1 ) :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) )<br>            else :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    return dp [ n - 1 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def MaximumDecimalValue ( mat , n ) :<br>    dp = [ 0 ] * n<br>    if mat [ 0 ] [ 0 ] == 1 :<br>        dp [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , n ) :<br>        if mat [ 0 ] [ i ] == 1 :<br>            dp [ 0 ] [ i ] = int ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) )<br>        else :<br>            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]<br>    for i in range ( 1 , n ) :<br>        if mat [ i ] [ 0 ] == 1 :<br>            dp [ i ] [ 0 ] = int ( dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) )<br>        else :<br>            dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( 1 , n ) :<br>            if mat [ i ] [ j ] == 1 :<br>                dp [ i ] [ j ] = int ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) )<br>            else :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    return dp [ n - 1 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printCountRec ( dist ) :<br>    if dist < 0 :<br>        return 0<br>    if dist == 0 :<br>        return 1<br>    return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) )<br></td>
    <td>translated code: <br><br> def print_count_rec ( dist ) :<br>    if dist < 0 :<br>        return 0<br>    if dist == 0 :<br>        return 1<br>    return print_count_rec ( dist - 1 ) + print_count_rec ( dist - 2 ) + print_count_rec ( dist - 3 )<br></td>
  </tr><tr>
    <th>MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def segregateElements ( arr , n ) :<br>    temp = [ 0 for k in range ( n ) ]<br>    j = 0<br>    for i in range ( n ) :<br>        if ( arr [ i ] >= 0 ) :<br>            temp [ j ] = arr [ i ]<br>            j += 1<br>    if ( j == n or j == 0 ) :<br>        return<br>    for i in range ( n ) :<br>        if ( arr [ i ] < 0 ) :<br>            temp [ j ] = arr [ i ]<br>            j += 1<br>    for k in range ( n ) :<br>        arr [ k ] = temp [ k ]<br></td>
    <td>translated code: <br><br> def segregateElements ( arr , n ) :<br>    temp = [ ]<br>    j = 0<br>    for i in range ( n ) :<br>        if arr [ i ] >= 0 :<br>            temp.append ( arr [ i ] )<br>    if j == n or j == 0 :<br>        return<br>    for i in range ( n ) :<br>        if arr [ i ] < 0 :<br>            temp.append ( arr [ i ] )<br>    for i in range ( n ) :<br>        arr [ i ] = temp [ i ]<br></td>
  </tr><tr>
    <th>MINIMUM_PERIMETER_N_BLOCKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minPerimeter ( n ) :<br>    l = math.sqrt ( n )<br>    sq = l * l<br>    if ( sq == n ) :<br>        return l * 4<br>    else :<br>        row = n / l<br>        perimeter = 2 * ( l + row )<br>        if ( n % l != 0 ) :<br>            perimeter += 2<br>        return perimeter<br></td>
    <td>translated code: <br><br> def minPerimeter ( n ) :<br>    l = int ( math.sqrt ( n ) )<br>    sq = l * l<br>    if sq == n :<br>        return l * 4<br>    else :<br>        row = n // l<br>        perimeter = 2 * ( l + row )<br>        if n % l != 0 :<br>            perimeter += 2<br>        return perimeter<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxProd ( n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return 0<br>    max_val = 0<br>    for i in range ( 1 , n - 1 ) :<br>        max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) )<br>    return max_val <br></td>
    <td>translated code: <br><br> def max_prod ( n ) :<br>    if n == 0 or n == 1 :<br>        return 0<br>    max_val = 0<br>    for i in range ( 1 , n ) :<br>        max_val = max ( max_val , max ( i * ( n - i ) , max_prod ( n - i ) ** 2 ) )<br>    return max_val<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LCSubStr ( X , Y ) :<br>    m = len ( X )<br>    n = len ( Y )<br>    result = 0<br>    len_mat = np.zeros ( ( 2 , n ) )<br>    currRow = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if ( i == 0 | j == 0 ) :<br>                len_mat [ currRow ] [ j ] = 0<br>            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :<br>                len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1<br>                result = max ( result , len_mat [ currRow ] [ j ] )<br>            else :<br>                len_mat [ currRow ] [ j ] = 0<br>        currRow = 1 - currRow<br>    return result<br></td>
    <td>translated code: <br><br> def LCSubStr ( X , Y ) :<br>    m = len ( X )<br>    n = len ( Y )<br>    result = 0<br>    len = [ 0 ] * ( n - 1 )<br>    curr_row = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if i == 0 or j == 0 :<br>                len [ curr_row ] [ j ] = 0<br>            elif X [ i - 1 ] == Y [ j - 1 ] :<br>                len [ curr_row ] [ j ] = len [ ( 1 - curr_row ) ] [ ( j - 1 ) ] + 1<br>                result = max ( result , len [ curr_row ] [ j ] )<br>            else :<br>                len [ curr_row ] [ j ] = 0<br>        curr_row = 1 - curr_row<br>    return result<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_ROTATION_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPalindrome ( string ) :<br>    l = 0<br>    h = len ( string ) - 1<br>    while h > l :<br>        l += 1<br>        h -= 1<br>        if string [ l - 1 ] != string [ h + 1 ] :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isPalindrome ( str ) :<br>    l = 0<br>    h = len ( str ) - 1<br>    while h > l :<br>        if str [ l ] != str [ h -- ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSol ( coeff , n , rhs ) :<br>    dp = [ 0 for i in range ( rhs + 1 ) ]<br>    dp [ 0 ] = 1<br>    for i in range ( n ) :<br>        for j in range ( coeff [ i ] , rhs + 1 ) :<br>            dp [ j ] += dp [ j - coeff [ i ] ]<br>    return dp [ rhs ]<br></td>
    <td>translated code: <br><br> def count_sol ( coeff , n , rhs ) :<br>    dp = [ 0 ] * ( rhs + 1 )<br>    dp [ 0 ] = 1<br>    for i in range ( n ) :<br>        for j in range ( coeff [ i ] , rhs + 1 ) :<br>            dp [ j ] += dp [ j - coeff [ i ] ]<br>    return dp [ rhs ]<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLargestSumPair ( arr , n ) :<br>    if arr [ 0 ] > arr [ 1 ] :<br>        first = arr [ 0 ]<br>        second = arr [ 1 ]<br>    else :<br>        first = arr [ 1 ]<br>        second = arr [ 0 ]<br>    for i in range ( 2 , n ) :<br>        if arr [ i ] > first :<br>            second = first<br>            first = arr [ i ]<br>        elif arr [ i ] > second and arr [ i ] != first :<br>            second = arr [ i ]<br>    return ( first + second )<br></td>
    <td>translated code: <br><br> def findLargestSumPair ( ) :<br>    first , second = arr [ 0 ] , arr [ 1 ]<br>    if arr [ 0 ] > arr [ 1 ] :<br>        first , second = arr [ 0 ] , arr [ 1 ]<br>    else :<br>        first , second = arr [ 1 ] , arr [ 0 ]<br>    for i in range ( 2 , len ( arr ) ) :<br>        if arr [ i ] > first :<br>            second , first = first , arr [ i ]<br>        elif arr [ i ] > second and arr [ i ] != first :<br>            second , first = first , second<br>    return ( first , second )<br></td>
  </tr><tr>
    <th>FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binarySearch ( arr , left , right ) :<br>    if ( left <= right ) :<br>        mid = ( left + right ) // 2 <br>        if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) :<br>            return mid <br>        if ( arr [ mid ] < arr [ mid + 1 ] ) :<br>            return binarySearch ( arr , mid + 1 , right ) <br>        else :<br>            return binarySearch ( arr , left , mid - 1 ) <br>    return - 1 <br></td>
    <td>translated code: <br><br> def binary_search ( arr , left , right ) :<br>    if left <= right :<br>        mid = ( left + right ) // 2<br>        if arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] :<br>            return mid<br>        if arr [ mid ] < arr [ mid + 1 ] :<br>            return binary_search ( arr , mid + 1 , right )<br>        else :<br>            return binary_search ( arr , left , mid - 1 )<br>    return - 1<br></td>
  </tr><tr>
    <th>PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printDistinct ( Str ) :<br>    n = len ( Str )<br>    count = [ 0 for i in range ( MAX_CHAR ) ]<br>    index = [ n for i in range ( MAX_CHAR ) ]<br>    for i in range ( n ) :<br>        x = ord ( Str [ i ] )<br>        count [ x ] += 1<br>        if ( count [ x ] == 1 and x != ' ' ) :<br>            index [ x ] = i<br>        if ( count [ x ] == 2 ) :<br>            index [ x ] = n<br>    index = sorted ( index )<br>    for i in range ( MAX_CHAR ) :<br>        if index [ i ] == n :<br>            break<br>        print ( Str [ index [ i ] ] , end = "" )<br></td>
    <td>translated code: <br><br> def printDistinct ( str ) :<br>    n = len ( str )<br>    count = [ 0 ] * MAX_CHAR<br>    index = [ ]<br>    for i in range ( MAX_CHAR ) :<br>        count [ i ] = 0<br>        index.append ( n )<br>    for i in range ( n ) :<br>        x = str [ i ]<br>        yield count [ x ]<br>        if count [ x ] == 1 and x != ' ' :<br>            index.append ( i )<br>        if count [ x ] == 2 :<br>            index.append ( n )<br>    index.sort ( )<br>    for i in range ( MAX_CHAR and index [ i ] != n ) :<br>        print ( str [ index [ i ] ] )<br></td>
  </tr><tr>
    <th>FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printOtherSides ( n ) :<br>    if ( n & 1 ) :<br>        if ( n == 1 ) :<br>            print ( - 1 )<br>        else :<br>            b = ( n * n - 1 ) // 2<br>            c = ( n * n + 1 ) // 2<br>            print ( "b =" , b , ", c =" , c )<br>    else :<br>        if ( n == 2 ) :<br>            print ( - 1 )<br>        else :<br>            b = n * n // 4 - 1<br>            c = n * n // 4 + 1<br>            print ( "b =" , b ", c =" , c )<br></td>
    <td>translated code: <br><br> def print_other_sides ( n ) :<br>    if n % 2 != 0 :<br>        if n == 1 :<br>            print ( "-1" )<br>        else :<br>            b = ( n * n - 1 ) / 2<br>            c = ( n * n + 1 ) / 2<br>            print ( "b = %d, c = %d" % ( b , c ) )<br>    else :<br>        if n == 2 :<br>            print ( "-1" )<br>        else :<br>            b = n * n / 4 - 1<br>            c = n * n / 4 + 1<br>            print ( "b = %d, c = %d" % ( b , c ) )<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def possibleStrings ( n , r , b , g ) :<br>    fact = [ 0 for i in range ( n + 1 ) ]<br>    fact [ 0 ] = 1<br>    for i in range ( 1 , n + 1 , 1 ) :<br>        fact [ i ] = fact [ i - 1 ] * i<br>    left = n - ( r + g + b )<br>    sum = 0<br>    for i in range ( 0 , left + 1 , 1 ) :<br>        for j in range ( 0 , left - i + 1 , 1 ) :<br>            k = left - ( i + j )<br>            sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) )<br>    return sum<br></td>
    <td>translated code: <br><br> def possible_strings ( n , r , b , g ) :<br>    fact = [ 1 ] * n + [ 1 ] * n<br>    for i in range ( 1 , n + 1 ) :<br>        fact [ i ] = fact [ i - 1 ] * i<br>    left = n - ( r + g + b )<br>    sum = 0<br>    for i in range ( 0 , left + 1 ) :<br>        for j in range ( 0 , left - i + 1 ) :<br>            k = left - ( i + j )<br>            sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] )<br>    return sum<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rearrange ( arr , n ) :<br>    max_ele = arr [ n - 1 ]<br>    min_ele = arr [ 0 ]<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            arr [ i ] = max_ele<br>            max_ele -= 1<br>        else :<br>            arr [ i ] = min_ele<br>            min_ele += 1<br></td>
    <td>translated code: <br><br> def rearrange ( arr , n ) :<br>    max_ele = arr [ n - 1 ]<br>    min_ele = arr [ 0 ]<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            arr [ i ] = max_ele<br>            max_ele -= 1<br>        else :<br>            arr [ i ] = min_ele<br>            min_ele += 1<br>    return arr<br></td>
  </tr><tr>
    <th>EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculateSum ( arr , n ) :<br>    if ( n == 0 ) :<br>        return 0<br>    s = arr [ 0 ]<br>    value = int ( s )<br>    sum = value<br>    for i in range ( 2 , n , 2 ) :<br>        s = arr [ i ]<br>        value = int ( s )<br>        operation = arr [ i - 1 ] [ 0 ]<br>        if ( operation == '+' ) :<br>            sum += value<br>        else :<br>            sum -= value<br>    return sum<br></td>
    <td>translated code: <br><br> def calculate_sum ( arr , n ) :<br>    if n == 0 :<br>        return 0<br>    s = arr [ 0 ]<br>    value = int ( s )<br>    sum = value<br>    for i in range ( 2 , n + 1 , 2 ) :<br>        s = arr [ i ]<br>        value = int ( s )<br>        operation = arr [ i - 1 ] [ 0 ]<br>        if operation == '+' :<br>            sum += value<br>        else :<br>            sum -= value<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( n ) :<br>    ans = 0 ; temp = 0 <br>    for i in range ( 1 , n + 1 ) :<br>        if temp < n :<br>            temp = i - 1<br>            num = 1<br>            while temp < n :<br>                if temp + i <= n :<br>                    ans += i * num<br>                else :<br>                    ans += ( n - temp ) * num<br>                temp += i<br>                num += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def findSum ( n ) :<br>    ans , temp , num = 0 , 0 , 0<br>    for i in range ( 1 , n + 1 , 2 ) :<br>        temp = i - 1<br>        num = 1<br>        while temp < n :<br>            if temp + i <= n :<br>                ans += ( i * num )<br>            else :<br>                ans += ( ( n - temp ) * num )<br>            temp += i<br>            num += 1<br>    return ans<br></td>
  </tr><tr>
    <th>SHUFFLE_A_DECK_OF_CARDS_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shuffle ( card , n ) :<br>    for i in range ( n ) :<br>        r = i + ( random.randint ( 0 , 55 ) % ( 52 - i ) )<br>        tmp = card [ i ]<br>        card [ i ] = card [ r ]<br>        card [ r ] = tmp<br></td>
    <td>translated code: <br><br> def shuffle ( card , n ) :<br>    rand = random.Random ( )<br>    for i in range ( n ) :<br>        r = i + rand.randint ( 0 , 52 - i )<br>        temp = card [ r ]<br>        card [ r ] = card [ i ]<br>        card [ i ] = temp<br></td>
  </tr><tr>
    <th>DOOLITTLE_ALGORITHM_LU_DECOMPOSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def luDecomposition ( mat , n ) :<br>    lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] <br>    upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] <br>    for i in range ( n ) :<br>        for k in range ( i , n ) :<br>            sum = 0 <br>            for j in range ( i ) :<br>                sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) <br>            upper [ i ] [ k ] = mat [ i ] [ k ] - sum <br>        for k in range ( i , n ) :<br>            if ( i == k ) :<br>                lower [ i ] [ i ] = 1 <br>            else :<br>                sum = 0 <br>                for j in range ( i ) :<br>                    sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) <br>                lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) <br>    print ( "Lower Triangular\t\tUpper Triangular" ) <br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            print ( lower [ i ] [ j ] , end = "\t" ) <br>        print ( "" , end = "\t" ) <br>        for j in range ( n ) :<br>            print ( upper [ i ] [ j ] , end = "\t" ) <br>        print ( "" ) <br></td>
    <td>translated code: <br><br> def lu_decomposition ( mat , n ) :<br>    lower = [ 0 ] * n<br>    upper = [ 0 ] * n<br>    for i in range ( n ) :<br>        for k in range ( i , n ) :<br>            sum = 0<br>            for j in range ( i ) :<br>                sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] )<br>            upper [ i ] [ k ] = mat [ i ] [ k ] - sum<br>        for k in range ( i , n ) :<br>            if i == k :<br>                lower [ i ] [ i ] = 1<br>            else :<br>                sum = 0<br>                for j in range ( i ) :<br>                    sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] )<br>                lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ]<br>    print ( setw ( 2 ) , "     Lower Triangular" , setw ( 10 ) , "Upper Triangular" )<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            print ( setw ( 4 ) , lower [ i ] [ j ] , "\t" )<br>        print ( "\t" )<br>        for j in range ( n ) :<br>            print ( setw ( 4 ) , upper [ i ] [ j ] , "\t" )<br>        print ( "\n" )<br></td>
  </tr><tr>
    <th>PROGRAM_NTH_CATALAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def catalan ( n ) :<br>    if n <= 1 :<br>        return 1<br>    res = 0<br>    for i in range ( n ) :<br>        res += catalan ( i ) * catalan ( n - i - 1 )<br>    return res<br></td>
    <td>translated code: <br><br> def catalan ( n ) :<br>    res = 0<br>    if n <= 1 :<br>        return 1<br>    for i in range ( n ) :<br>        res += catalan ( i ) * catalan ( n - i - 1 )<br>    return res<br></td>
  </tr><tr>
    <th>NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def divisible ( num ) :<br>    n = len ( num ) <br>    sum = 0 <br>    for i in range ( n ) :<br>        sum += int ( num [ i ] ) <br>    if ( sum % 3 == 0 ) :<br>        return 0 <br>    if ( n == 1 ) :<br>        return - 1 <br>    for i in range ( n ) :<br>        if ( sum % 3 == int ( num [ i ] ) % 3 ) :<br>            return 1 <br>    if ( n == 2 ) :<br>        return - 1 <br>    return 2 <br></td>
    <td>translated code: <br><br> def divisible ( num ) :<br>    n = len ( num )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += int ( num [ i ] )<br>    if sum % 3 == 0 :<br>        return 0<br>    if n == 1 :<br>        return - 1<br>    for i in range ( n ) :<br>        if sum % 3 == ( num [ i ] - '0' ) % 3 :<br>            return 1<br>    if n == 2 :<br>        return - 1<br>    return 2<br></td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPower ( x , y ) :<br>    res1 = math.log ( y ) / math.log ( x ) <br>    res2 = math.log ( y ) / math.log ( x ) <br>    return 1 if ( res1 == res2 ) else 0 <br></td>
    <td>translated code: <br><br> def isPower ( x , y ) :<br>    res1 = int ( math.log ( y , 2 ) ) / int ( math.log ( x , 2 ) )<br>    res2 = math.log ( y , 2 ) / math.log ( x , 2 )<br>    return ( res1 == res2 )<br></td>
  </tr><tr>
    <th>LARGEST_SUBSEQUENCE_GCD_GREATER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def largestGCDSubsequence ( arr , n ) :<br>    ans = 0<br>    maxele = max ( arr )<br>    for i in range ( 2 , maxele + 1 ) :<br>        count = 0<br>        for j in range ( n ) :<br>            if ( arr [ j ] % i == 0 ) :<br>                count += 1<br>        ans = max ( ans , count )<br>    return ans<br></td>
    <td>translated code: <br><br> def largestGCDSubsequence ( arr , n ) :<br>    ans = 0<br>    maxele = sum ( arr )<br>    for i in range ( 2 , maxele + 1 ) :<br>        count = 0<br>        for j in range ( n ) :<br>            if arr [ j ] % i == 0 :<br>                count += 1<br>        ans = max ( ans , count )<br>    return ans<br></td>
  </tr><tr>
    <th>FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findCommon ( mat ) :<br>    column = [ N - 1 ] * M<br>    min_row = 0<br>    while ( column [ min_row ] >= 0 ) :<br>        for i in range ( M ) :<br>            if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) :<br>                min_row = i<br>        eq_count = 0<br>        for i in range ( M ) :<br>            if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) :<br>                if ( column [ i ] == 0 ) :<br>                    return - 1<br>                column [ i ] -= 1<br>            else :<br>                eq_count += 1<br>        if ( eq_count == M ) :<br>            return mat [ min_row ] [ column [ min_row ] ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_common ( mat ) :<br>    column = [ ]<br>    min_row = 0<br>    i = 0<br>    for i in range ( M ) :<br>        column.append ( N - 1 )<br>    min_row = 0<br>    while column [ min_row ] >= 0 :<br>        for i in range ( M ) :<br>            if mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] :<br>                min_row = i<br>        eq_count = 0<br>        for i in range ( M ) :<br>            if mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] :<br>                if column [ i ] == 0 :<br>                    return - 1<br>                column [ i ] -= 1<br>            else :<br>                eq_count += 1<br>        if eq_count == M :<br>            return mat [ min_row ] [ column [ min_row ] ]<br>    return - 1<br></td>
  </tr><tr>
    <th>CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkcircle ( r , R , r1 , x1 , y1 ) :<br>    dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )<br>    return ( dis - r1 >= R and dis + r1 <= r )<br></td>
    <td>translated code: <br><br> def checkcircle ( r , R , r1 , x1 , y1 ) :<br>    dis = int ( math.sqrt ( x1 ** 2 + y1 ** 2 ) )<br>    return ( dis - r1 >= R and dis + r1 <= r )<br></td>
  </tr><tr>
    <th>COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSetBits ( n ) :<br>    i = 0<br>    ans = 0<br>    while ( ( 1 << i ) <= n ) :<br>        k = 0<br>        change = 1 << i<br>        for j in range ( 0 , n + 1 ) :<br>            ans += k<br>            if change == 1 :<br>                k = not k<br>                change = 1 << i<br>            else :<br>                change -= 1<br>        i += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def countSetBits ( n ) :<br>    i = 0<br>    ans = 0<br>    while ( 1 << i ) <= n :<br>        k = False<br>        change = 1 << i<br>        for j in range ( 0 , n ) :<br>            if k == True :<br>                ans += 1<br>            else :<br>                ans += 0<br>            if change == 1 :<br>                k = not k<br>                change = 1 << i<br>            else :<br>                change -= 1<br>        i += 1<br>    return ans<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLongestRepeatingSubSeq ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    return dp [ n ] [ n ]<br></td>
    <td>translated code: <br><br> def find_longest_repetiating_subseq ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n</td>
  </tr><tr>
    <th>FIND_THE_FIRST_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findFirstMissing ( array , start , end ) :<br>    if ( start > end ) :<br>        return end + 1<br>    if ( start != array [ start ] ) :<br>        return start <br>    mid = int ( ( start + end ) / 2 )<br>    if ( array [ mid ] == mid ) :<br>        return findFirstMissing ( array , mid + 1 , end )<br>    return findFirstMissing ( array , start , mid )<br></td>
    <td>translated code: <br><br> def findFirstMissing ( array , start , end ) :<br>    if start > end :<br>        return end + 1<br>    if start != array [ start ] :<br>        return start<br>    mid = ( start + end ) // 2<br>    if array [ mid ] == mid :<br>        return findFirstMissing ( array , mid + 1 , end )<br>    return findFirstMissing ( array , start , mid )<br></td>
  </tr><tr>
    <th>SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortSquares ( arr , n ) :<br>    K = 0<br>    for K in range ( n ) :<br>        if ( arr [ K ] >= 0 ) :<br>            break<br>    i = K - 1<br>    j = K<br>    ind = 0<br>    temp = [ 0 ] * n<br>    while ( i >= 0 and j < n ) :<br>        if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) :<br>            temp [ ind ] = arr [ i ] * arr [ i ]<br>            i -= 1<br>        else :<br>            temp [ ind ] = arr [ j ] * arr [ j ]<br>            j += 1<br>        ind += 1<br>    while ( i >= 0 ) :<br>        temp [ ind ] = arr [ i ] * arr [ i ]<br>        i -= 1<br>        ind += 1<br>    while ( j < n ) :<br>        temp [ ind ] = arr [ j ] * arr [ j ]<br>        j += 1<br>        ind += 1<br>    for i in range ( n ) :<br>        arr [ i ] = temp [ i ]<br></td>
    <td>translated code: <br><br> def sort_squares ( arr ) :<br>    n = len ( arr )<br>    k = 0<br>    for k in range ( n ) :<br>        if arr [ k ] >= 0 :<br>            break<br>    i = k - 1<br>    j = k<br>    ind = 0<br>    temp = [ ]<br>    while i >= 0 and j < n :<br>        if arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] :<br>            temp.append ( arr [ i ] * arr [ i ] )<br>            i -= 1<br>        else :<br>            temp.append ( arr [ j ] * arr [ j ] )<br>            j += 1<br>        ind += 1<br>    while i >= 0 :<br>        temp.append ( arr [ i ] * arr [ i ] )<br>        i -= 1<br>    while j < n :<br>        temp.append ( arr [ j ] * arr [ j ] )<br>        j += 1<br>    for x in range ( n ) :<br>        arr [ x ] = temp [ x ]<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getRemainder ( num , divisor ) :<br>    return ( num - divisor * ( num // divisor ) )<br></td>
    <td>translated code: <br><br> def getRemainder ( num , divisor ) :<br>    return ( num - divisor * ( num / divisor ) )<br></td>
  </tr><tr>
    <th>MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MinimumCost ( cost , n , W ) :<br>    val = list ( )<br>    wt = list ( )<br>    size = 0<br>    for i in range ( n ) :<br>        if ( cost [ i ] != - 1 ) :<br>            val.append ( cost [ i ] )<br>            wt.append ( i + 1 )<br>            size += 1<br>    n = size<br>    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ]<br>    for i in range ( W + 1 ) :<br>        min_cost [ 0 ] [ i ] = INF<br>    for i in range ( 1 , n + 1 ) :<br>        min_cost [ i ] [ 0 ] = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , W + 1 ) :<br>            if ( wt [ i - 1 ] > j ) :<br>                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]<br>            else :<br>                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )<br>    if ( min_cost [ n ] [ W ] == INF ) :<br>        return - 1<br>    else :<br>        return min_cost [ n ] [ W ]<br></td>
    <td>translated code: <br><br> def MinimumCost ( cost , n , W ) :<br>    val = [ ]<br>    wt = [ ]<br>    size = 0<br>    for i in range ( n ) :<br>        if cost [ i ] != - 1 :<br>            val.append ( cost [ i ] )<br>            wt.append ( i + 1 )<br>            size += 1<br>    n = size<br>    min_cost = [ [ ] , [ ] , [ ] ]<br>    for i in range ( 0 , W + 1 ) :<br>        min_cost [ 0 ].append ( int ( i ) )<br>    for i in range ( 1 , n + 1 ) :<br>        min_cost [ i ].append ( 0 )<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , W + 1 ) :<br>            if wt [ i - 1 ] > j :<br>                min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ]<br>            else :<br>                min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] )<br>    return ( min_cost [ n ] [ W ] , min_cost [ n ] [ W ] )<br></td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( str1 ) :<br>    result = 0 <br>    n = len ( str1 )<br>    for i in range ( 0 , n ) :<br>        for j in range ( 1 , MAX_CHAR + 1 ) :<br>            if ( ( i + j ) < n ) :<br>                if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) :<br>                    result += 1 <br>    return result<br></td>
    <td>translated code: <br><br> def countPairs ( str ) :<br>    result = 0<br>    n = len ( str )<br>    for i in range ( n ) :<br>        for j in range ( 1 , n and j <= MAX_CHAR ) :<br>            if ( abs ( str [ i + j ] - str [ i ] ) == j ) :<br>                result += 1<br>    return result<br></td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def productArray ( arr , n ) :<br>    if ( n == 1 ) :<br>        print ( 0 )<br>        return<br>    left = [ 0 ] * n<br>    right = [ 0 ] * n<br>    prod = [ 0 ] * n<br>    left [ 0 ] = 1<br>    right [ n - 1 ] = 1<br>    for i in range ( 1 , n ) :<br>        left [ i ] = arr [ i - 1 ] * left [ i - 1 ]<br>    for j in range ( n - 2 , - 1 , - 1 ) :<br>        right [ j ] = arr [ j + 1 ] * right [ j + 1 ]<br>    for i in range ( n ) :<br>        prod [ i ] = left [ i ] * right [ i ]<br>    for i in range ( n ) :<br>        print ( prod [ i ] , end = ' ' )<br></td>
    <td>translated code: <br><br> def productArray ( arr , n ) :<br>    if n == 1 :<br>        print ( 0 )<br>        return<br>    left = [ ]<br>    right = [ ]<br>    prod = [ ]<br>    i , j = 0 , 0<br>    left.append ( 1 )<br>    right.append ( 1 )<br>    for i in range ( 1 , n ) :<br>        left.append ( arr [ i - 1 ] * left [ i - 1 ] )<br>    for j in range ( n - 2 , - 1 , - 1 ) :<br>        right.append ( arr [ j + 1 ] * right [ j + 1 ] )<br>    for i in range ( n ) :<br>        prod.append ( left [ i ] * right [ i ] )<br>    for i in range ( n ) :<br>        print ( prod [ i ] , end = ' ' )<br>    return<br></td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def mostFrequent ( arr , n ) :<br>    Hash = dict ( )<br>    for i in range ( n ) :<br>        if arr [ i ] in Hash.keys ( ) :<br>            Hash [ arr [ i ] ] += 1<br>        else :<br>            Hash [ arr [ i ] ] = 1<br>    max_count = 0<br>    res = - 1<br>    for i in Hash :<br>        if ( max_count < Hash [ i ] ) :<br>            res = i<br>            max_count = Hash [ i ]<br>    return res<br></td>
    <td>translated code: <br><br> def most_frequent ( arr , n ) :<br>    hp = { }<br>    for i in range ( n ) :<br>        key = arr [ i ]<br>        if hp.has_key ( key ) :<br>            freq = hp [ key ]<br>            freq += 1<br>            hp [ key ] = freq<br>        else :<br>            hp [ key ] = 1<br>    max_count , res = 0 , - 1<br>    for val , count in hp.items ( ) :<br>        if max_count < count :<br>            res = val<br>            max_count = count<br>    return res<br></td>
  </tr><tr>
    <th>PRINT_UNIQUE_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printArray ( matrix ) :<br>    rowCount = len ( matrix )<br>    if rowCount == 0 :<br>        return<br>    columnCount = len ( matrix [ 0 ] )<br>    if columnCount == 0 :<br>        return<br>    row_output_format = " ".join ( [ "%s" ] * columnCount )<br>    printed = { }<br>    for row in matrix :<br>        routput = row_output_format % tuple ( row )<br>        if routput not in printed :<br>            printed [ routput ] = True<br>            print ( routput )<br></td>
    <td>translated code: <br><br> def print_array ( arr , row , col ) :<br>    set = set ( )<br>    for i in range ( row ) :<br>        s = ""<br>        for j in range ( col ) :<br>            s += str ( arr [ i ] [ j ] )<br>        if not set.issubset ( s ) :<br>            set.add ( s )<br>            print ( s )<br></td>
  </tr><tr>
    <th>COUNT_1S_SORTED_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOnes ( arr , low , high ) :<br>    if high >= low :<br>        mid = low + ( high - low ) / 2<br>        if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) :<br>            return mid + 1<br>        if arr [ mid ] == 1 :<br>            return countOnes ( arr , ( mid + 1 ) , high )<br>        return countOnes ( arr , low , mid - 1 )<br>    return 0<br></td>
    <td>translated code: <br><br> def countOnes ( arr , low , high ) :<br>    if high >= low :<br>        mid = low + ( high - low ) // 2<br>        if ( mid == high or arr [ mid + 1 ] == 0 ) :<br>            return mid + 1<br>        if arr [ mid ] == 1 :<br>            return countOnes ( arr , ( mid + 1 ) , high )<br>        return countOnes ( arr , low , ( mid - 1 ) )<br></td>
  </tr><tr>
    <th>POSSIBLE_MOVES_KNIGHT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findPossibleMoves ( mat , p , q ) :<br>    global n , m <br>    X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] <br>    Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] <br>    count = 0 <br>    for i in range ( 8 ) :<br>        x = p + X [ i ] <br>        y = q + Y [ i ] <br>        if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) :<br>            count += 1 <br>    return count <br></td>
    <td>translated code: <br><br> def find_possible_moves ( mat , p , q ) :<br>    X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ]<br>    Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ]<br>    count = 0<br>    for i in range ( 8 ) :<br>        x = p + X [ i ]<br>        y = q + Y [ i ]<br>        if x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>ROTATE_MATRIX_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rotateMatrix ( mat ) :<br>    if not len ( mat ) :<br>        return<br>    top = 0<br>    bottom = len ( mat ) - 1<br>    left = 0<br>    right = len ( mat [ 0 ] ) - 1<br>    while left < right and top < bottom :<br>        prev = mat [ top + 1 ] [ left ]<br>        for i in range ( left , right + 1 ) :<br>            curr = mat [ top ] [ i ]<br>            mat [ top ] [ i ] = prev<br>            prev = curr<br>        top += 1<br>        for i in range ( top , bottom + 1 ) :<br>            curr = mat [ i ] [ right ]<br>            mat [ i ] [ right ] = prev<br>            prev = curr<br>        right -= 1<br>        for i in range ( right , left - 1 , - 1 ) :<br>            curr = mat [ bottom ] [ i ]<br>            mat [ bottom ] [ i ] = prev<br>            prev = curr<br>        bottom -= 1<br>        for i in range ( bottom , top - 1 , - 1 ) :<br>            curr = mat [ i ] [ left ]<br>            mat [ i ] [ left ] = prev<br>            prev = curr<br>        left += 1<br>    return mat<br></td>
    <td>translated code: <br><br> def rotatematrix ( m , n , mat ) :<br>    row , col = 0 , 0<br>    prev , curr = None , None<br>    while row < m and col < n :<br>        if row + 1 == m or col + 1 == n :<br>            break<br>        prev = mat [ row + 1 ] [ col ]<br>        for i in range ( col , n ) :<br>            curr = mat [ row ] [ i ]<br>            mat [ row ] [ i ] = prev<br>            prev = curr<br>        row += 1<br>        for i in range ( row , m ) :<br>            curr = mat [ i ] [ n - 1 ]<br>            mat [ i ] [ n - 1 ] = prev<br>            prev = curr<br>        n -= 1<br>        if row < m :<br>            for i in range ( n - 1 , col + 1 ) :<br>                curr = mat [ m - 1 ] [ i ]<br>                mat [ m - 1 ] [ i ] = prev<br>                prev = curr<br>        m -= 1<br>        if col < n :<br>            for i in range ( m - 1 , row + 1 ) :<br>                curr = mat [ i ] [ col ]<br>                mat [ i ] [ col ] = prev<br>                prev = curr<br>        col += 1<br>    for i in range ( R ) :<br>        for j in range ( C ) :<br>            print ( mat [ i ] [ j ] , end = '' )<br>        print ( '' )<br></td>
  </tr><tr>
    <th>FIND_KTH_CHARACTER_OF_DECRYPTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def encodedChar ( str , k ) :<br>    expand = ""<br>    freq = 0<br>    i = 0<br>    while ( i < len ( str ) ) :<br>        temp = ""<br>        freq = 0<br>        while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( 'a' ) and ord ( str [ i ] ) <= ord ( 'z' ) ) :<br>            temp += str [ i ]<br>            i += 1<br>        while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) :<br>            freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' )<br>            i += 1<br>        for j in range ( 1 , freq + 1 , 1 ) :<br>            expand += temp<br>    if ( freq == 0 ) :<br>        expand += temp<br>    return expand [ k - 1 ]<br></td>
    <td>translated code: <br><br> def encoded_char ( str , k ) :<br>    expand = ""<br>    temp = ""<br>    freq = 0<br>    for i in range ( len ( str ) ) :<br>        temp = ""<br>        freq = 0<br>        while i < len ( str ) and str [ i ] >= 'a' and str [ i ] <= 'z' :<br>            temp += str [ i ]<br>            i += 1<br>        while i < len ( str ) and str [ i ] >= '1' and str [ i ] <= '9' :<br>            freq = freq * 10 + str [ i ] - '0'<br>            i += 1<br>        for j in range ( 1 , freq + 1 ) :<br>            expand += temp<br>    if freq == 0 :<br>        expand += temp<br>    return expand [ k - 1 ]<br></td>
  </tr><tr>
    <th>EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , n , x ) :<br>    i = 0<br>    while ( i <= n - 1 ) :<br>        if ( arr [ i ] == x ) :<br>            return i<br>        i += abs ( arr [ i ] - x )<br>    return - 1<br></td>
    <td>translated code: <br><br> def search ( arr , n , x ) :<br>    i = 0<br>    while i <= n - 1 :<br>        if arr [ i ] == x :<br>            return i<br>        i += abs ( arr [ i ] - x )<br>    return - 1<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def returnMaxSum ( A , B , n ) :<br>    mp = set ( )<br>    result = 0<br>    curr_sum = curr_begin = 0<br>    for i in range ( 0 , n ) :<br>        while A [ i ] in mp :<br>            mp.remove ( A [ curr_begin ] )<br>            curr_sum -= B [ curr_begin ]<br>            curr_begin += 1<br>        mp.add ( A [ i ] )<br>        curr_sum += B [ i ]<br>        result = max ( result , curr_sum )<br>    return result<br></td>
    <td>translated code: <br><br> def returnMaxSum ( A , B , n ) :<br>    mp = set ( )<br>    result = 0<br>    curr_sum , curr_begin = 0 , 0<br>    for i in range ( n ) :<br>        while mp.issubset ( A [ i ] ) :<br>            mp.remove ( A [ curr_begin ] )<br>            curr_sum -= B [ curr_begin ]<br>            curr_begin += 1<br>        mp.add ( A [ i ] )<br>        curr_sum += B [ i ]<br>        result = max ( result , curr_sum )<br>    return result<br></td>
  </tr><tr>
    <th>WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isMultipleOf3 ( n ) :<br>    odd_count = 0<br>    even_count = 0<br>    if ( n < 0 ) :<br>        n = - n<br>    if ( n == 0 ) :<br>        return 1<br>    if ( n == 1 ) :<br>        return 0<br>    while ( n ) :<br>        if ( n & 1 ) :<br>            odd_count += 1<br>        if ( n & 2 ) :<br>            even_count += 1<br>        n = n >> 2<br>    return isMultipleOf3 ( abs ( odd_count - even_count ) )<br></td>
    <td>translated code: <br><br> def is_multiple_of_3 ( n ) :<br>    odd_count = 0<br>    even_count = 0<br>    if n < 0 :<br>        n = - n<br>    if n == 0 :<br>        return 1<br>    if n == 1 :<br>        return 0<br>    while n != 0 :<br>        if ( n & 1 ) :<br>            odd_count += 1<br>        if ( n & 2 ) :<br>            even_count += 1<br>        n = n >> 2<br>    return is_multiple_of_3 ( abs ( odd_count - even_count ) )<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSum ( arr , n ) :<br>    cum_sum = 0<br>    for i in range ( 0 , n ) :<br>        cum_sum += arr [ i ]<br>    curr_val = 0<br>    for i in range ( 0 , n ) :<br>        curr_val += i * arr [ i ]<br>    res = curr_val<br>    for i in range ( 1 , n ) :<br>        next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) )<br>        curr_val = next_val<br>        res = max ( res , next_val )<br>    return res<br></td>
    <td>translated code: <br><br> def max_sum ( arr , n ) :<br>    cum_sum = 0<br>    for i in range ( n ) :<br>        cum_sum += arr [ i ]<br>    curr_val = 0<br>    for i in range ( n ) :<br>        curr_val += i * arr [ i ]<br>    res = curr_val<br>    for i in range ( 1 , n ) :<br>        next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 )<br>        curr_val = next_val<br>        res = max ( res , next_val )<br>    return res<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def carAssembly ( a , t , e , x ) :<br>    NUM_STATION = len ( a [ 0 ] )<br>    T1 = [ 0 for i in range ( NUM_STATION ) ]<br>    T2 = [ 0 for i in range ( NUM_STATION ) ]<br>    T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]<br>    T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]<br>    for i in range ( 1 , NUM_STATION ) :<br>        T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] )<br>        T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] )<br>    return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )<br></td>
    <td>translated code: <br><br> def car_assembly ( a , t , e , x ) :<br>    T1 = [ ]<br>    T2 = [ ]<br>    i = 0<br>    T1.append ( e [ 0 ] + a [ 0 ] [ 0 ] )<br>    T2.append ( e [ 1 ] + a [ 1 ] [ 0 ] )<br>    for i in range ( NUM_STATION ) :<br>        T1.append ( min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) )<br>        T2.append ( min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) )<br>    return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] )<br></td>
  </tr><tr>
    <th>PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSpiral ( mat , r , c ) :<br>    a = 0<br>    b = 2<br>    low_row = 0 if ( 0 > a ) else a<br>    low_column = 0 if ( 0 > b ) else b - 1<br>    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1<br>    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1<br>    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :<br>        i = low_column + 1<br>        while ( i <= high_column and i < c and low_row >= 0 ) :<br>            print ( mat [ low_row ] [ i ] , end = " " )<br>            i += 1<br>        low_row -= 1<br>        i = low_row + 2<br>        while ( i <= high_row and i < r and high_column < c ) :<br>            print ( mat [ i ] [ high_column ] , end = " " )<br>            i += 1<br>        high_column += 1<br>        i = high_column - 2<br>        while ( i >= low_column and i >= 0 and high_row < r ) :<br>            print ( mat [ high_row ] [ i ] , end = " " )<br>            i -= 1<br>        high_row += 1<br>        i = high_row - 2<br>        while ( i > low_row and i >= 0 and low_column >= 0 ) :<br>            print ( mat [ i ] [ low_column ] , end = " " )<br>            i -= 1<br>        low_column -= 1<br>    print ( )<br></td>
    <td>translated code: <br><br> def printSpiral ( mat , r , c ) :<br>    i , a = 0 , 2<br>    low_row = ( 0 > a ) & ( a < r )<br>    low_column = ( 0 > b ) & ( b - 1 )<br>    high_row = ( ( a + 1 ) >= r ) & ( r - 1 )<br>    high_column = ( ( b + 1 ) >= c ) & ( c - 1 )<br>    while ( low_row > 0 - r and low_column > 0 - c ) :<br>        for i in range ( low_column + 1 , high_column , c , low_row >= 0 ) :<br>            print ( mat [ low_row ] [ i ] , end = ' ' )<br>        low_row -= 1<br>        for i in range ( low_row + 2 , high_row , r , high_column < c ) :<br>            print ( mat [ i ] [ high_column ] , end = ' ' )<br>        high_column += 1<br>        for i in range ( high_column - 2 , low_column , 0 , r ) :<br>            print ( mat [ high_row ] [ i ] , end = ' ' )<br>        high_row += 1<br>        for i in range ( high_row - 2 , low_row , 0 , 0 , low_column >= 0 ) :<br>            print ( mat [ i ] [ low_column ] , end = ' ' )<br>        low_column -= 1<br>    print ( )<br></td>
  </tr><tr>
    <th>MID_POINT_CIRCLE_DRAWING_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def midPointCircleDraw ( x_centre , y_centre , r ) :<br>    x = r<br>    y = 0<br>    print ( "(" , x + x_centre , ", " , y + y_centre , ")" , sep = "" , end = "" )<br>    if ( r > 0 ) :<br>        print ( "(" , x + x_centre , ", " , - y + y_centre , ")" , sep = "" , end = "" )<br>        print ( "(" , y + x_centre , ", " , x + y_centre , ")" , sep = "" , end = "" )<br>        print ( "(" , - y + x_centre , ", " , x + y_centre , ")" , sep = "" )<br>    P = 1 - r<br>    while ( x > y ) :<br>        y += 1<br>        if ( P <= 0 ) :<br>            P = P + 2 * y + 1<br>        else :<br>            x -= 1<br>            P = P + 2 * y - 2 * x + 1<br>        if ( x < y ) :<br>            break<br>        print ( "(" , x + x_centre , ", " , y + y_centre , ")" , sep = "" , end = "" )<br>        print ( "(" , - x + x_centre , ", " , y + y_centre , ")" , sep = "" , end = "" )<br>        print ( "(" , x + x_centre , ", " , - y + y_centre , ")" , sep = "" , end = "" )<br>        print ( "(" , - x + x_centre , ", " , - y + y_centre , ")" , sep = "" )<br>        if ( x != y ) :<br>            print ( "(" , y + x_centre , ", " , x + y_centre , ")" , sep = "" , end = "" )<br>            print ( "(" , - y + x_centre , ", " , x + y_centre , ")" , sep = "" , end = "" )<br>            print ( "(" , y + x_centre , ", " , - x + y_centre , ")" , sep = "" , end = "" )<br>            print ( "(" , - y + x_centre , ", " , - x + y_centre , ")" , sep = "" )<br></td>
    <td>translated code: <br><br> def mid_point_circle_draw ( x_centre , y_centre , r ) :<br>    x , y = r<br>    print ( "(%d, %d)" % ( x , y ) )<br>    if r > 0 :<br>        print ( "(%d, %d)" % ( x + x_centre , - y + y_centre ) )<br>        print ( "(%d, %d)" % ( y + x_centre , x + y_centre ) )<br>        print ( "(%d, %d)" % ( - y + x_centre , x + y_centre ) )<br>    P = 1 - r<br>    while x > y :<br>        y += 1<br>        if P <= 0 :<br>            P = P + 2 * y + 1<br>        else :<br>            x -= 1<br>            P = P + 2 * y - 2 * x + 1<br>        if x < y :<br>            break<br>        print ( "(%d, %d)" % ( x + x_centre , y + y_centre ) )<br>        print ( "(%d, %d)" % ( - x + x_centre , y + y_centre ) )<br>        print ( "(%d, %d)" % ( x + x_centre , y + y_centre ) )<br>        print ( "(%d, %d)" % ( - x + x_centre , y + y_centre ) )<br>        print ( "(%d, %d)" % ( - y + x_centre , y + y_centre ) )<br>        print ( "(%d, %d)" % ( - x + x_centre , y + y_centre ) )<br>        if x != y :<br>            print ( "(%d, %d)" % ( y + x_centre , x + y_centre ) )<br>            print ( "(%d, %d)" % ( - y + x_centre , y + y_centre ) )<br></td>
  </tr><tr>
    <th>SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def smallestKFreq ( arr , n , k ) :<br>    mp = defaultdict ( lambda : 0 )<br>    for i in range ( n ) :<br>        mp [ arr [ i ] ] += 1<br>    res = sys.maxsize<br>    res1 = sys.maxsize<br>    for key , values in mp.items ( ) :<br>        if values == k :<br>            res = min ( res , key )<br>    return res if res != res1 else - 1<br></td>
    <td>translated code: <br><br> def smallest_k_freq ( a , n , k ) :<br>    m = { }<br>    for i in range ( n ) :<br>        if m.has_key ( a [ i ] ) :<br>            m [ a [ i ] ] = m [ a [ i ] ] + 1<br>        else :<br>            m [ a [ i ] ] = 1<br>    res = sys.maxsize<br>    s = m.keys ( )<br>    for temp in s :<br>        if m [ temp ] == k :<br>            res = min ( res , temp )<br>    return ( res , - 1 )<br></td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minXOR ( arr , n ) :<br>    arr.sort ( ) <br>    min_xor = 999999<br>    val = 0<br>    for i in range ( 0 , n - 1 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            val = arr [ i ] ^ arr [ j ]<br>            min_xor = min ( min_xor , val )<br>    return min_xor<br></td>
    <td>translated code: <br><br> def minXOR ( arr , n ) :<br>    min_xor = sys.maxint<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] )<br>    return min_xor<br></td>
  </tr><tr>
    <th>MIRROR_CHARACTERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def compute ( st , n ) :<br>    reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba"<br>    l = len ( st )<br>    answer = ""<br>    for i in range ( 0 , n ) :<br>        answer = answer + st [ i ] <br>    for i in range ( n , l ) :<br>        answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( 'a' ) ] ) <br>    return answer <br></td>
    <td>translated code: <br><br> def compute ( str , n ) :<br>    reverse_alphabet = 'zyxwvutsrqponmlkjihgfedcba'<br>    l = len ( str )<br>    answer = ""<br>    for i in range ( n ) :<br>        answer = answer + str [ i ]<br>    for i in range ( n , l ) :<br>        answer = answer + reverse_alphabet [ str [ i ] - 'a' ]<br>    return answer<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_PLUS_PERFECT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkplusperfect ( x ) :<br>    temp = x<br>    n = 0<br>    while ( x != 0 ) :<br>        x = x // 10<br>        n = n + 1<br>    x = temp<br>    sm = 0<br>    while ( x != 0 ) :<br>        sm = sm + ( int ) ( math.pow ( x % 10 , n ) )<br>        x = x // 10<br>    return ( sm == temp )<br></td>
    <td>translated code: <br><br> def checkplusperfect ( x ) :<br>    temp = x<br>    n = 0<br>    while x != 0 :<br>        x /= 10<br>        n += 1<br>    x = temp<br>    sum = 0<br>    while x != 0 :<br>        sum += pow ( x % 10 , n )<br>        x /= 10<br>    return ( sum == temp )<br></td>
  </tr><tr>
    <th>ARC_LENGTH_ANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arcLength ( diameter , angle ) :<br>    if angle >= 360 :<br>        print ( "Angle cannot be formed" )<br>        return 0<br>    else :<br>        arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 )<br>        return arc<br></td>
    <td>translated code: <br><br> def arcLength ( diameter , angle ) :<br>    pi = 22.0 / 7.0<br>    arc = None<br>    if angle >= 360 :<br>        print ( "Angle cannot" + " be formed" )<br>        return None<br>    else :<br>        arc = ( pi * diameter ) * ( angle / 360.0 )<br>        return arc<br></td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLastIndex ( str , x ) :<br>    index = - 1<br>    for i in range ( 0 , len ( str ) ) :<br>        if str [ i ] == x :<br>            index = i<br>    return index<br></td>
    <td>translated code: <br><br> def find_last_index ( str , x ) :<br>    index = - 1<br>    for i in range ( len ( str ) ) :<br>        if str [ i ] == x :<br>            index = i<br>    return index<br></td>
  </tr><tr>
    <th>COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTrailingZeros ( n ) :<br>    count = 0<br>    i = 5<br>    while ( n / i >= 1 ) :<br>        count += int ( n / i )<br>        i *= 5<br>    return int ( count )<br></td>
    <td>translated code: <br><br> def find_trailing_zeros ( n ) :<br>    count = 0<br>    for i in range ( 5 , n // i >= 1 , 1 , 5 ) :<br>        count += n // i<br>    return count<br></td>
  </tr><tr>
    <th>ROTATE_MATRIX_180_DEGREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rotateMatrix ( mat ) :<br>    i = N - 1 <br>    while ( i >= 0 ) :<br>        j = N - 1 <br>        while ( j >= 0 ) :<br>            print ( mat [ i ] [ j ] , end = " " ) <br>            j = j - 1 <br>        print ( ) <br>        i = i - 1 <br></td>
    <td>translated code: <br><br> def rotate_matrix ( mat ) :<br>    for i in range ( N - 1 , - 1 , - 1 ) :<br>        for j in range ( N - 1 , - 1 , - 1 ) :<br>            print ( mat [ i ] [ j ] , end = ' ' )<br>        print ( )<br></td>
  </tr><tr>
    <th>SUM_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculateSum ( n ) :<br>    if ( n <= 0 ) :<br>        return 0<br>    fibo = [ 0 ] * ( n + 1 )<br>    fibo [ 1 ] = 1<br>    sm = fibo [ 0 ] + fibo [ 1 ]<br>    for i in range ( 2 , n + 1 ) :<br>        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]<br>        sm = sm + fibo [ i ]<br>    return sm<br></td>
    <td>translated code: <br><br> def calculate_sum ( n ) :<br>    if n <= 0 :<br>        return 0<br>    fibo = [ 0 ] * ( n + 1 )<br>    sum = fibo [ 0 ] + fibo [ 1 ]<br>    for i in range ( 2 , n + 1 ) :<br>        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]<br>        sum += fibo [ i ]<br>    return sum<br></td>
  </tr><tr>
    <th>LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def KSwapMaximum ( n , k ) :<br>    global arr<br>    for i in range ( 0 , n - 1 ) :<br>        if ( k > 0 ) :<br>            indexPosition = i<br>            for j in range ( i + 1 , n ) :<br>                if ( k <= j - i ) :<br>                    break<br>                if ( arr [ j ] > arr [ indexPosition ] ) :<br>                    indexPosition = j<br>            for j in range ( indexPosition , i , - 1 ) :<br>                t = arr [ j ]<br>                arr [ j ] = arr [ j - 1 ]<br>                arr [ j - 1 ] = t<br>            k = k - indexPosition - i<br></td>
    <td>translated code: <br><br> def KSwapMaximum ( arr , n , k ) :<br>    for i in range ( n - 1 and k > 0 ) :<br>        index_position = i<br>        for j in range ( i + 1 , n ) :<br>            if k <= j - i :<br>                break<br>            if arr [ j ] > arr [ index_position ] :<br>                index_position = j<br>        for j in range ( index_position , i > 0 ) :<br>            SwapInts ( arr , j , j - 1 )<br>        k -= index_position - i<br></td>
  </tr><tr>
    <th>FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( n ) :<br>    return 1162261467 % n == 0<br></td>
    <td>translated code: <br><br> def check ( n ) :<br>    return 1162261467 % n == 0<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRepeating ( arr , size ) :<br>    print ( "Repeating elements are " , end = '' )<br>    for i in range ( 0 , size ) :<br>        for j in range ( i + 1 , size ) :<br>            if arr [ i ] == arr [ j ] :<br>                print ( arr [ i ] , end = ' ' )<br></td>
    <td>translated code: <br><br> def printRepeating ( arr , size ) :<br>    i , j = 0 , 0<br>    print ( "Repeated Elements are :" )<br>    for i in range ( size ) :<br>        for j in range ( i + 1 , size ) :<br>            if arr [ i ] == arr [ j ] :<br>                print ( arr [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findArea ( a , b , c ) :<br>    if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) :<br>        print ( 'Not a valid trianglen' )<br>        return<br>    s = ( a + b + c ) / 2<br>    area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5<br>    print ( 'Area of a traingle is %f' % area )<br></td>
    <td>translated code: <br><br> def findArea ( a , b , c ) :<br>    if a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a :<br>        print ( "Not a valid triangle" )<br>        exit ( 0 )<br>    s = ( a + b + c ) / 2<br>    return float ( math.sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) )<br></td>
  </tr><tr>
    <th>GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubSeqDivisible ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ]<br>    arr = [ 0 for i in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        arr [ i ] = int ( str [ i - 1 ] ) <br>    for i in range ( 1 , n + 1 ) :<br>        dp [ i ] [ arr [ i ] % 8 ] = 1 <br>        for j in range ( 8 ) :<br>            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) :<br>                dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ]<br>            if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j ]<br>    for i in range ( 1 , n + 1 ) :<br>        if ( dp [ i ] [ 0 ] == 1 ) :<br>            return True<br>    return False<br></td>
    <td>translated code: <br><br> def is_subseq_divisible ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0</td>
  </tr><tr>
    <th>DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_SMALLER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def deleteElements ( arr , n , k ) :<br>    st = [ ]<br>    st.append ( arr [ 0 ] )<br>    top = 0<br>    count = 0<br>    for i in range ( 1 , n ) :<br>        while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) :<br>            st.pop ( )<br>            count += 1<br>            top -= 1<br>        st.append ( arr [ i ] )<br>        top += 1<br>    for i in range ( 0 , len ( st ) ) :<br>        print ( st [ i ] , "" , end = "" )<br></td>
    <td>translated code: <br><br> def delete_elements ( arr , n , k ) :<br>    s = Stack ( )<br>    s.push ( arr [ 0 ] )<br>    count = 0<br>    for i in range ( 1 , n ) :<br>        while not s.empty ( ) and s.peek ( ) < arr [ i ] and count < k :<br>            s.pop ( )<br>            count += 1<br>        s.push ( arr [ i ] )<br>    m = len ( s )<br>    v = [ ]<br>    while not s.empty ( ) :<br>        v.append ( s.peek ( ) )<br>        s.pop ( )<br>    for x in v :<br>        print ( x , end = '' ) ;<br>    print ( '' )<br></td>
  </tr><tr>
    <th>MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def smallestSubWithSum ( arr , n , x ) :<br>    curr_sum = 0<br>    min_len = n + 1<br>    start = 0<br>    end = 0<br>    while ( end < n ) :<br>        while ( curr_sum <= x and end < n ) :<br>            curr_sum += arr [ end ]<br>            end += 1<br>        while ( curr_sum > x and start < n ) :<br>            if ( end - start < min_len ) :<br>                min_len = end - start<br>            curr_sum -= arr [ start ]<br>            start += 1<br>    return min_len<br></td>
    <td>translated code: <br><br> def smallest_sub_with_sum ( arr , n , x ) :<br>    curr_sum , min_len = 0 , n + 1<br>    start , end = 0 , 0<br>    while end < n :<br>        while curr_sum <= x and end < n :<br>            curr_sum += arr [ end ]<br>        while curr_sum > x and start < n :<br>            if end - start < min_len :<br>                min_len = end - start<br>            curr_sum -= arr [ start ]<br>    return min_len<br></td>
  </tr><tr>
    <th>FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findPair ( arr , n ) :<br>    s = { i : 1 for i in arr }<br>    found = False<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] + arr [ j ] in s.keys ( ) :<br>                print ( arr [ i ] , arr [ j ] )<br>                found = True<br>    if found == False :<br>        print ( "Not exist" )<br></td>
    <td>translated code: <br><br> def find_pair ( arr , n ) :<br>    s = set ( )<br>    for i in arr :<br>        s.add ( i )<br>    found = False<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            sum = arr [ i ] + arr [ j ]<br>            if s.intersection ( sum ) :<br>                found = True<br>                print ( arr [ i ] , arr [ j ] )<br>    if found == False :<br>        print ( "Not Exist " )<br></td>
  </tr><tr>
    <th>COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numofAP ( a , n ) :<br>    minarr = + 2147483647<br>    maxarr = - 2147483648<br>    for i in range ( n ) :<br>        minarr = min ( minarr , a [ i ] )<br>        maxarr = max ( maxarr , a [ i ] )<br>    dp = [ 0 for i in range ( n + 1 ) ]<br>    ans = n + 1<br>    for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) :<br>        sum = [ 0 for i in range ( MAX + 1 ) ]<br>        for i in range ( n ) :<br>            dp [ i ] = 1<br>            if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) :<br>                dp [ i ] += sum [ a [ i ] - d ]<br>            ans += dp [ i ] - 1<br>            sum [ a [ i ] ] += dp [ i ]<br>    return ans<br></td>
    <td>translated code: <br><br> def numofAP ( a , n ) :<br>    minarr = + 2147483647<br>    maxarr = - 2147483648<br>    for i in range ( n ) :<br>        minarr = min ( minarr , a [ i ] )<br>        maxarr = max ( maxarr , a [ i ] )<br>    dp = [ ]<br>    sum = [ ]<br>    ans = n + 1<br>    for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) :<br>        sum.append ( 0 )<br>        for i in range ( n ) :<br>            dp.append ( 1 )<br>            if a [ i ] - d >= 1 and a [ i ] - d <= 1000000 :<br>                dp [ i ] += sum [ a [ i ] - d ]<br>            ans += dp [ i ] - 1<br>            sum [ a [ i ] ] += dp [ i ]<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_NUMBERS_THAT_DONT_CONTAIN_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count ( n ) :<br>    if n < 3 :<br>        return n<br>    elif n >= 3 and n < 10 :<br>        return n - 1<br>    po = 1<br>    while n / po > 9 :<br>        po = po * 10<br>    msd = n / po<br>    if msd != 3 :<br>        return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po )<br>    else :<br>        return count ( msd * po - 1 )<br></td>
    <td>translated code: <br><br> def count ( n ) :<br>    if n < 3 :<br>        return n<br>    if n >= 3 and n < 10 :<br>        return n - 1<br>    po = 1<br>    while n / po > 9 :<br>        po = po * 10<br>    msd = n / po<br>    if msd != 3 :<br>        return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po )<br>    else :<br>        return count ( msd * po - 1 )<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def transpose ( A ) :<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ]<br></td>
    <td>translated code: <br><br> def transpose ( A ) :<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            temp = A [ i ] [ j ]<br>            A [ i ] [ j ] = A [ j ] [ i ]<br>            A [ j ] [ i ] = temp<br></td>
  </tr><tr>
    <th>SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def spiralDiaSum ( n ) :<br>    if n == 1 :<br>        return 1<br>    return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )<br></td>
    <td>translated code: <br><br> def spiral_dia_sum ( n ) :<br>    if n == 1 :<br>        return 1<br>    return ( 4 * n ** 2 - 6 * n + 6 + spiral_dia_sum ( n - 2 ) )<br></td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getInvCount ( arr ) :<br>    n = len ( arr )<br>    invcount = 0<br>    for i in range ( 0 , n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] > arr [ j ] :<br>                for k in range ( j + 1 , n ) :<br>                    if arr [ j ] > arr [ k ] :<br>                        invcount += 1<br>    return invcount<br></td>
    <td>translated code: <br><br> def getInvCount ( arr , n ) :<br>    invcount = 0<br>    for i in range ( n - 2 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            if arr [ i ] > arr [ j ] :<br>                for k in range ( j + 1 , n ) :<br>                    if arr [ j ] > arr [ k ] :<br>                        invcount += 1<br>    return invcount<br></td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def SumNodes ( l ) :<br>    leafNodeCount = pow ( 2 , l - 1 )<br>    vec = [ [ ] for i in range ( l ) ]<br>    for i in range ( 1 , leafNodeCount + 1 ) :<br>        vec [ l - 1 ].append ( i )<br>    for i in range ( l - 2 , - 1 , - 1 ) :<br>        k = 0<br>        while ( k < len ( vec [ i + 1 ] ) - 1 ) :<br>            vec [ i ].append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] )<br>            k += 2<br>    Sum = 0<br>    for i in range ( l ) :<br>        for j in range ( len ( vec [ i ] ) ) :<br>            Sum += vec [ i ] [ j ]<br>    return Sum<br></td>
    <td>translated code: <br><br> def sumNodes ( l ) :<br>    leafNodeCount = int ( math.pow ( 2 , l - 1 ) )<br>    vec = [ ]<br>    for i in range ( 1 , l + 1 ) :<br>        vec.append ( [ ] )<br>    for i in range ( 1 , leafNodeCount ) :<br>        vec [ - 1 ].append ( i )<br>    for i in range ( l - 2 , - 1 , - 1 ) :<br>        k = 0<br>        while k < len ( vec [ i + 1 ] ) - 1 :<br>            vec [ i ].append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] )<br>            k += 2<br>    sum = 0<br>    for i in range ( l ) :<br>        for j in range ( len ( vec [ i ] ) ) :<br>            sum += vec [ i ] [ j ]<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def divSum ( num ) :<br>    result = 0<br>    i = 2<br>    while i <= ( math.sqrt ( num ) ) :<br>        if ( num % i == 0 ) :<br>            if ( i == ( num / i ) ) :<br>                result = result + i <br>            else :<br>                result = result + ( i + num / i ) <br>        i = i + 1<br>    return ( result + 1 ) <br></td>
    <td>translated code: <br><br> def div_sum ( num ) :<br>    result = 0<br>    for i in range ( 2 , math.sqrt ( num ) ) :<br>        if num % i == 0 :<br>            if i == ( num / i ) :<br>                result += i<br>            else :<br>                result += ( i + num / i )<br>    return ( result + 1 )<br></td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find3Numbers ( A , arr_size , sum ) :<br>    for i in range ( 0 , arr_size - 1 ) :<br>        s = set ( )<br>        curr_sum = sum - A [ i ]<br>        for j in range ( i + 1 , arr_size ) :<br>            if ( curr_sum - A [ j ] ) in s :<br>                print ( "Triplet is" , A [ i ] , ", " , A [ j ] , ", " , curr_sum - A [ j ] )<br>                return True<br>            s.add ( A [ j ] )<br>    return False<br></td>
    <td>translated code: <br><br> def find3Numbers ( A , arr_size , sum ) :<br>    for i in range ( arr_size - 2 ) :<br>        s = set ( )<br>        curr_sum = sum - A [ i ]<br>        for j in range ( i + 1 , arr_size ) :<br>            if s.issubset ( curr_sum - A [ j ] ) and curr_sum - A [ j ] not in ( s.pop ( ) , curr_sum - A [ j ] ) :<br>                print ( "Triplet is %d, %d, %d" % ( A [ i ] , A [ j ] , curr_sum - A [ j ] ) )<br>                return True<br>            s.add ( A [ j ] )<br>    return False<br></td>
  </tr><tr>
    <th>NTH_EVEN_LENGTH_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def evenlength ( n ) :<br>    res = n<br>    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :<br>        res += n [ j ]<br>    return res<br></td>
    <td>translated code: <br><br> def evenlength ( n ) :<br>    res = n<br>    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :<br>        res += n [ j ]<br>    return res<br></td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def PowerOFPINnfactorial ( n , p ) :<br>    ans = 0 <br>    temp = p <br>    while ( temp <= n ) :<br>        ans += n / temp <br>        temp = temp * p <br>    return ans <br></td>
    <td>translated code: <br><br> def PowerOFPINnfactorial ( n , p ) :<br>    ans = 0<br>    for i in range ( 1 , n + 1 ) :<br>        count , temp = 0 , i<br>        while temp % p == 0 :<br>            count += 1<br>            temp = temp // p<br>        ans += count<br>    return ans<br></td>
  </tr><tr>
    <th>MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solve ( X , Y , l , r , k , dp ) :<br>    if k == 0 :<br>        return 0<br>    if l < 0 or r < 0 :<br>        return 1000000000<br>    if dp [ l ] [ r ] [ k ] != - 1 :<br>        return dp [ l ] [ r ] [ k ]<br>    cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [ r ] ) - ord ( 'a' ) ) )<br>    dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] )<br>    return dp [ l ] [ r ] [ k ]<br></td>
    <td>translated code: <br><br> def solve ( X , Y , l , r , k , dp ) :<br>    if k == 0 :<br>        return 0<br>    if l < 0 | r < 0 :<br>        return int ( 1e9 )<br>    if dp [ l ] [ r ] [ k ] != - 1 :<br>        return dp [ l ] [ r ] [ k ]<br>    cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' )<br>    return dp [ l ] [ r ] [ k ] = min ( min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , min ( cost + solve ( X , Y , l , r - 1 , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ) )<br></td>
  </tr><tr>
    <th>PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printString ( str , ch , count ) :<br>    occ , i = 0 , 0<br>    if ( count == 0 ) :<br>        print ( str )<br>    for i in range ( len ( str ) ) :<br>        if ( str [ i ] == ch ) :<br>            occ += 1<br>        if ( occ == count ) :<br>            break<br>    if ( i < len ( str ) - 1 ) :<br>        print ( str [ i + 1 : len ( str ) - i + 2 ] )<br>    else :<br>        print ( "Empty string" )<br></td>
    <td>translated code: <br><br> def printstring ( str , ch , count ) :<br>    occ , i = 0 , 0<br>    if count == 0 :<br>        print ( str )<br>        return<br>    for i in range ( len ( str ) ) :<br>        if str [ i ] == ch :<br>            occ += 1<br>        if occ == count :<br>            break<br>    if i < len ( str ) - 1 :<br>        print ( str [ i + 1 ] )<br>    else :<br>        print ( "Empty string" )<br></td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortedAfterSwap ( A , B , n ) :<br>    for i in range ( 0 , n - 1 ) :<br>        if ( B [ i ] == 1 ) :<br>            j = i<br>            while ( B [ j ] == 1 ) :<br>                j = j + 1<br>            A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ]<br>            i = j<br>    for i in range ( 0 , n ) :<br>        if ( A [ i ] != i + 1 ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def sortedAfterSwap ( A , B , n ) :<br>    i , j = 0 , 0<br>    for i in range ( n - 1 ) :<br>        if B [ i ] :<br>            j = i<br>            while B [ j ] : j += 1<br>            A.sort ( i , j + 1 )<br>            i = j<br>    for i in range ( n ) :<br>        if A [ i ] != i + 1 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>GENERATE_PYTHAGOREAN_TRIPLETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pythagoreanTriplets ( limits ) :<br>    c , m = 0 , 2<br>    while c < limits :<br>        for n in range ( 1 , m ) :<br>            a = m * m - n * n<br>            b = 2 * m * n<br>            c = m * m + n * n<br>            if c > limits :<br>                break<br>            print ( a , b , c )<br>        m = m + 1<br></td>
    <td>translated code: <br><br> def pythagorean_triplets ( limit ) :<br>    a , b , c = 0 , 0 , 0<br>    m = 2<br>    while c < limit :<br>        for n in range ( 1 , m ) :<br>            a , b , c = m * m - n * n , 2 * m * n , m * m + n * n<br>            if c > limit :<br>                break<br>            print ( a , b , c )<br>        m += 1<br></td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSeq ( n , diff ) :<br>    if ( abs ( diff ) > n ) :<br>        return 0<br>    if ( n == 1 and diff == 0 ) :<br>        return 2<br>    if ( n == 1 and abs ( diff ) == 1 ) :<br>        return 1<br>    res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) )<br>    return res<br></td>
    <td>translated code: <br><br> def count_seq ( n , diff ) :<br>    if abs ( diff ) > n :<br>        return 0<br>    if n == 1 and diff == 0 :<br>        return 2<br>    if n == 1 and abs ( diff ) == 1 :<br>        return 1<br>    res = count_seq ( n - 1 , diff + 1 ) + 2 * count_seq ( n - 1 , diff ) + count_seq ( n - 1 , diff - 1 )<br>    return res<br></td>
  </tr><tr>
    <th>POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPossibleTriangle ( arr , N ) :<br>    if N < 3 :<br>        return False<br>    arr.sort ( )<br>    for i in range ( N - 2 ) :<br>        if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :<br>            return True<br></td>
    <td>translated code: <br><br> def isPossibleTriangle ( arr , N ) :<br>    if N < 3 :<br>        return False<br>    arr.sort ( )<br>    for i in range ( N - 2 ) :<br>        if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printInSortedOrder ( arr , n ) :<br>    index = [ 0 ] * n<br>    for i in range ( n ) :<br>        index [ i ] = i<br>    for i in range ( n - 1 ) :<br>        min = i<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) :<br>                min = j<br>        if ( min != i ) :<br>            index [ min ] , index [ i ] = index [ i ] , index [ min ]<br>    for i in range ( n ) :<br>        print ( arr [ index [ i ] ] , end = " " )<br></td>
    <td>translated code: <br><br> def printInSortedOrder ( arr , n ) :<br>    index = [ ]<br>    i , j , min = 0 , 0 , 0<br>    for i in range ( n ) :<br>        index.append ( i )<br>    for i in range ( n - 1 ) :<br>        min = i<br>        for j in range ( i + 1 , n ) :<br>            if arr [ index [ min ] ] > arr [ index [ j ] ] :<br>                min = j<br>        if min != i :<br>            temp = index [ min ]<br>            index [ min ] , index [ i ] = index [ i ] , index [ i ]<br>            index [ i ] = temp<br>    for i in range ( n ) :<br>        print ( arr [ index [ i ] ] , end = ' ' )<br></td>
  </tr><tr>
    <th>GAME_REPLACING_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def playGame ( arr , n ) :<br>    s = set ( )<br>    for i in range ( n ) :<br>        s.add ( arr [ i ] )<br>    return 1 if len ( s ) % 2 == 0 else 2<br></td>
    <td>translated code: <br><br> def play_game ( arr ) :<br>    set = set ( )<br>    for i in arr :<br>        set.add ( i )<br>    return ( len ( set ) % 2 == 0 )<br></td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gcd ( a , b ) :<br>    if a == 0 :<br>        return b<br>    return gcd ( b % a , a )<br></td>
    <td>translated code: <br><br> def gcd ( a , b ) :<br>    if a == 0 :<br>        return b<br>    return gcd ( b % a , a )<br></td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortInWave ( arr , n ) :<br>    for i in range ( 0 , n , 2 ) :<br>        if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) :<br>            arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ]<br>        if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) :<br>            arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]<br></td>
    <td>translated code: <br><br> def sortInWave ( arr , n ) :<br>    for i in range ( 0 , n , 2 ) :<br>        if i > 0 and arr [ i - 1 ] > arr [ i ] :<br>            swap ( arr , i - 1 , i )<br>        if i < n - 1 and arr [ i ] < arr [ i + 1 ] :<br>            swap ( arr , i , i + 1 )<br></td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumSumSubarray ( arr , n ) :<br>    min_prefix_sum = 0<br>    res = - math.inf<br>    prefix_sum = [ ]<br>    prefix_sum.append ( arr [ 0 ] )<br>    for i in range ( 1 , n ) :<br>        prefix_sum.append ( prefix_sum [ i - 1 ] + arr [ i ] )<br>    for i in range ( n ) :<br>        res = max ( res , prefix_sum [ i ] - min_prefix_sum )<br>        min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] )<br>    return res<br></td>
    <td>translated code: <br><br> def maximum_sum_subarray ( arr , n ) :<br>    min_prefix_sum = 0<br>    res = int ( '-1' )<br>    prefix_sum = [ arr [ 0 ] ]<br>    for i in range ( 1 , n ) :<br>        prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]<br>    for i in range ( n ) :<br>        res = max ( res , prefix_sum [ i ] - min_prefix_sum )<br>        min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] )<br>    return res<br></td>
  </tr><tr>
    <th>STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def firstLetterWord ( str ) :<br>    result = ""<br>    v = True<br>    for i in range ( len ( str ) ) :<br>        if ( str [ i ] == ' ' ) :<br>            v = True<br>        elif ( str [ i ] != ' ' and v == True ) :<br>            result += ( str [ i ] )<br>            v = False<br>    return result<br></td>
    <td>translated code: <br><br> def firstLetterWord ( str ) :<br>    result = ""<br>    v = True<br>    for c in str :<br>        if c == " " :<br>            v = True<br>        elif c != " " and v == True :<br>            result += ( c )<br>            v = False<br>    return result<br></td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( n ) :<br>    multiTerms = n * ( n + 1 ) // 2<br>    sm = multiTerms<br>    for i in range ( 2 , n + 1 ) :<br>        multiTerms = multiTerms - ( i - 1 )<br>        sm = sm + multiTerms * i<br>    return sm<br></td>
    <td>translated code: <br><br> def find_sum ( n ) :<br>    multiterms = n * ( n + 1 ) / 2<br>    sum = multiterms<br>    for i in range ( 2 , n + 1 ) :<br>        multiterms = multiterms - ( i - 1 )<br>        sum = sum + multiterms ** i<br>    return sum<br></td>
  </tr><tr>
    <th>CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minCost ( a , n , k ) :<br>    dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] <br>    dp [ 0 ] [ 0 ] = 0 <br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , k + 1 ) :<br>            for m in range ( i - 1 , - 1 , - 1 ) :<br>                dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) <br>    return dp [ n ] [ k ] <br></td>
    <td>translated code: <br><br> def min_cost ( a , n , k ) :<br>    dp = [ [ inf ] * n + [ k + 1 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * n + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k + [ 0 ] * k ]</td>
  </tr><tr>
    <th>LEIBNIZ_HARMONIC_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LeibnizHarmonicTriangle ( n ) :<br>    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] <br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , min ( i , n ) + 1 ) :<br>            if ( j == 0 or j == i ) :<br>                C [ i ] [ j ] = 1 <br>            else :<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) <br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , i + 1 ) :<br>            print ( "1/" , end = "" ) <br>            print ( i * C [ i - 1 ] [ j - 1 ] , end = " " ) <br>        print ( ) <br></td>
    <td>translated code: <br><br> def LeibnizHarmonicTriangle ( n ) :<br>    C = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n ]<br>    </td>
  </tr><tr>
    <th>CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COUNT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def canMakeStr2 ( s1 , s2 ) :<br>    count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) }<br>    for i in range ( len ( s1 ) ) :<br>        count [ s1 [ i ] ] += 1<br>    for i in range ( len ( s2 ) ) :<br>        if count [ s2 [ i ] ] == 0 :<br>            return False<br>        count [ s2 [ i ] ] -= 1<br>    return True<br></td>
    <td>translated code: <br><br> def can_make_str2 ( str1 , str2 ) :<br>    count = [ 0 ] * MAX<br>    str3 = str1.split ( ' ' )<br>    for i in range ( len ( str3 ) ) :<br>        count [ str3 [ i ] ] += 1<br>    str4 = str2.split ( ' ' )<br>    for i in range ( len ( str4 ) ) :<br>        if count [ str4 [ i ] ] == 0 :<br>            return False<br>        count [ str4 [ i ] ] -= 1<br>    return True<br></td>
  </tr><tr>
    <th>SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def SumOfKsubArray ( arr , n , k ) :<br>    Sum = 0<br>    S = deque ( )<br>    G = deque ( )<br>    for i in range ( k ) :<br>        while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) :<br>            S.pop ( )<br>        while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) :<br>            G.pop ( )<br>        G.append ( i )<br>        S.append ( i )<br>    for i in range ( k , n ) :<br>        Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]<br>        while ( len ( S ) > 0 and S [ 0 ] <= i - k ) :<br>            S.popleft ( )<br>        while ( len ( G ) > 0 and G [ 0 ] <= i - k ) :<br>            G.popleft ( )<br>        while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) :<br>            S.pop ( )<br>        while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) :<br>            G.pop ( )<br>        G.append ( i )<br>        S.append ( i )<br>    Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]<br>    return Sum<br></td>
    <td>translated code: <br><br> def SumOfKsubArray ( arr , k ) :<br>    sum = 0<br>    S , G = deque ( ) , deque ( )<br>    i = 0<br>    for i in range ( k ) :<br>        while not S.empty ( ) and arr [ S.popleft ( ) ] >= arr [ i ] :<br>            S.popleft ( )<br>        while not G.empty ( ) and arr [ G.popleft ( ) ] <= arr [ i ] :<br>            G.popleft ( )<br>        G.append ( i )<br>        S.append ( i )<br>    for i in range ( len ( arr ) ) :<br>        sum += arr [ S.popleft ( ) ] + arr [ G.popleft ( ) ]<br>        while not S.empty ( ) and S.popleft ( ) <= i - k :<br>            S.popleft ( )<br>        while not G.empty ( ) and G.popleft ( ) <= i - k :<br>            G.popleft ( )<br>        while not S.empty ( ) and arr [ S.popleft ( ) ] >= arr [ i ] :<br>            S.popleft ( )<br>        while not G.empty ( ) and arr [ G.popleft ( ) ] <= arr [ i ] :<br>            G.popleft ( )<br>        G.append ( i )<br>        S.append ( i )<br>    sum += arr [ S.popleft ( ) ] + arr [ G.popleft ( ) ]<br>    return sum<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcs ( X , Y , m , n ) :<br>    if m == 0 or n == 0 :<br>        return 0 <br>    elif X [ m - 1 ] == Y [ n - 1 ] :<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 ) <br>    else :<br>        return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) <br></td>
    <td>translated code: <br><br> def lcs ( X , Y , m , n ) :<br>    if m == 0 or n == 0 :<br>        return 0<br>    if X [ m - 1 ] == Y [ n - 1 ] :<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 )<br>    else :<br>        return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) )<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMinSum ( a , b , n ) :<br>    a.sort ( )<br>    b.sort ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum = sum + abs ( a [ i ] - b [ i ] )<br>    return sum<br></td>
    <td>translated code: <br><br> def find_min_sum ( a , b , n ) :<br>    a.sort ( )<br>    b.sort ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum = sum + abs ( a [ i ] - b [ i ] )<br>    return sum<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSolutions ( n ) :<br>    res = 0<br>    x = 0<br>    while ( x * x < n ) :<br>        y = 0<br>        while ( x * x + y * y < n ) :<br>            res = res + 1<br>            y = y + 1<br>        x = x + 1<br>    return res<br></td>
    <td>translated code: <br><br> def count_solutions ( n ) :<br>    res = 0<br>    for x in range ( 0 , n * n ) :<br>        for y in range ( 0 , x * x + y * y ) :<br>            res += 1<br>    return res<br></td>
  </tr><tr>
    <th>FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOps ( A , B , m , n ) :<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            A [ i ] [ j ] -= B [ i ] [ j ] <br>    for i in range ( 1 , n ) :<br>        for j in range ( 1 , n ) :<br>            if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) :<br>                return - 1 <br>    result = 0 <br>    for i in range ( n ) :<br>        result += abs ( A [ i ] [ 0 ] ) <br>    for j in range ( m ) :<br>        result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) <br>    return ( result ) <br></td>
    <td>translated code: <br><br> def count_ops ( A , B , m , n ) :<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            A [ i ] [ j ] -= B [ i ] [ j ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( 1 , m ) :<br>            if A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 :<br>                return - 1<br>    result = 0<br>    for i in range ( n ) :<br>        result += abs ( A [ i ] [ 0 ] )<br>    for j in range ( m ) :<br>        result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )<br>    return ( result )<br></td>
  </tr><tr>
    <th>EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def FirstRepeated ( string ) :<br>    checker = 0<br>    pos = 0<br>    for i in string :<br>        val = ord ( i ) - ord ( 'a' ) <br>        if ( ( checker & ( 1 << val ) ) > 0 ) :<br>            return pos<br>        checker |= ( 1 << val )<br>        pos += 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def FirstRepeated ( str ) :<br>    checker = 0<br>    for i in range ( len ( str ) ) :<br>        val = ord ( str [ i ] ) - ord ( 'a' )<br>        if ( checker & ( 1 << val ) ) > 0 :<br>            return i<br>        checker |= ( 1 << val )<br>    return - 1<br></td>
  </tr><tr>
    <th>MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find_max ( A , N , K ) :<br>    Count = dict ( )<br>    for i in range ( K - 1 ) :<br>        Count [ A [ i ] ] = Count.get ( A [ i ] , 0 ) + 1<br>    Myset = dict ( )<br>    for x in Count :<br>        if ( Count [ x ] == 1 ) :<br>            Myset [ x ] = 1<br>    for i in range ( K - 1 , N ) :<br>        Count [ A [ i ] ] = Count.get ( A [ i ] , 0 ) + 1<br>        if ( Count [ A [ i ] ] == 1 ) :<br>            Myset [ A [ i ] ] = 1<br>        else :<br>            del Myset [ A [ i ] ]<br>        if ( len ( Myset ) == 0 ) :<br>            print ( "Nothing" )<br>        else :<br>            maxm = - 10 ** 9<br>            for i in Myset :<br>                maxm = max ( i , maxm )<br>            print ( maxm )<br>        x = A [ i - K + 1 ]<br>        if x in Count.keys ( ) :<br>            Count [ x ] -= 1<br>            if ( Count [ x ] == 1 ) :<br>                Myset [ x ] = 1<br>            if ( Count [ x ] == 0 ) :<br>                del Myset [ x ]<br></td>
    <td>translated code: <br><br> def find_max ( A , N , K ) :<br>    Count = { }<br>    for i in range ( K - 1 ) :<br>        if Count.has_key ( A [ i ] ) :<br>            Count [ A [ i ] ] = 1 + Count [ A [ i ] ]<br>        else :<br>            Count [ A [ i ] ] = 1<br>    Myset = TreeSet ( )<br>    for x in Count.items ( ) :<br>        if int ( str ( x ) ) == 1 :<br>            Myset.add ( int ( str ( x ) ) )<br>    for i in range ( K - 1 , N ) :<br>        if Count.has_key ( A [ i ] ) :<br>            Count [ A [ i ] ] = 1 + Count [ A [ i ] ]<br>        else :<br>            Count [ A [ i ] ] = 1<br>        if int ( str ( Count [ A [ i ] ] ) ) == 1 :<br>            Myset.add ( A [ i ] )<br>        else :<br>            Myset.remove ( A [ i ] )<br>        if len ( Myset ) == 0 :<br>            print ( "Nothing" )<br>        else :<br>            print ( Myset.last ( ) )<br>        x = A [ i - K + 1 ]<br>        Count [ x ] = Count [ x ] - 1<br>        if int ( str ( Count [ x ] ) ) == 1 :<br>            Myset.add ( x )<br>        if int ( str ( Count [ x ] ) ) == 0 :<br>            Myset.remove ( x )<br></td>
  </tr><tr>
    <th>MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculateEnergy ( mat , n ) :<br>    tot_energy = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            q = mat [ i ] [ j ] // n<br>            i_des = q<br>            j_des = mat [ i ] [ j ] - ( n * q )<br>            tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) )<br>    return tot_energy<br></td>
    <td>translated code: <br><br> def calculate_energy ( mat , n ) :<br>    i_des , j_des , q = mat<br>    tot_energy = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            q = mat [ i ] [ j ] / n<br>            i_des = q<br>            j_des = mat [ i ] [ j ] - ( n * q )<br>            tot_energy += abs ( i_des - i ) + abs ( j_des - j )<br>    return tot_energy<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LCSubStr ( X , Y , m , n ) :<br>    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ]<br>    result = 0<br>    for i in range ( m + 1 ) :<br>        for j in range ( n + 1 ) :<br>            if ( i == 0 or j == 0 ) :<br>                LCSuff [ i ] [ j ] = 0<br>            elif ( X [ i - 1 ] == Y [ j - 1 ] ) :<br>                LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1<br>                result = max ( result , LCSuff [ i ] [ j ] )<br>            else :<br>                LCSuff [ i ] [ j ] = 0<br>    return result<br></td>
    <td>translated code: <br><br> def LCSubStr ( X , Y , m , n ) :<br>    LCStuff = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] *</td>
  </tr><tr>
    <th>MAXIMUM_SUM_BITONIC_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSumBitonicSubArr ( arr , n ) :<br>    msis = [ None ] * n<br>    msds = [ None ] * n<br>    max_sum = 0<br>    msis [ 0 ] = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if ( arr [ i ] > arr [ i - 1 ] ) :<br>            msis [ i ] = msis [ i - 1 ] + arr [ i ]<br>        else :<br>            msis [ i ] = arr [ i ]<br>    msds [ n - 1 ] = arr [ n - 1 ]<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if ( arr [ i ] > arr [ i + 1 ] ) :<br>            msds [ i ] = msds [ i + 1 ] + arr [ i ]<br>        else :<br>            msds [ i ] = arr [ i ]<br>    for i in range ( n ) :<br>        if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) :<br>            max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] )<br>    return max_sum<br></td>
    <td>translated code: <br><br> def max_sum_bitonic_sub_arr ( arr , n ) :<br>    msis = [ ]<br>    msds = [ ]<br>    max_sum = int ( "-1" )<br>    msis.append ( arr [ 0 ] )<br>    for i in range ( 1 , n ) :<br>        if arr [ i ] > arr [ i - 1 ] :<br>            msis.append ( msis [ i - 1 ] + arr [ i ] )<br>        else :<br>            msis.append ( arr [ i ] )<br>    msds.append ( arr [ n - 1 ] )<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if arr [ i ] > arr [ i + 1 ] :<br>            msds.append ( msds [ i + 1 ] + arr [ i ] )<br>        else :<br>            msds.append ( arr [ i ] )<br>    for i in range ( n ) :<br>        if max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) :<br>            max_sum = msis [ i ] + msds [ i ] - arr [ i ]<br>    return max_sum<br></td>
  </tr><tr>
    <th>NEWMAN_CONWAY_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sequence ( n ) :<br>    if n == 1 or n == 2 :<br>        return 1<br>    else :<br>        return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) <br></td>
    <td>translated code: <br><br> def sequence ( n ) :<br>    if n == 1 or n == 2 :<br>        return 1<br>    else :<br>        return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) )<br></td>
  </tr><tr>
    <th>PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printAllAPTriplets ( arr , n ) :<br>    s = [ ] <br>    for i in range ( 0 , n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            diff = arr [ j ] - arr [ i ] <br>            if ( ( arr [ i ] - diff ) in arr ) :<br>                print ( "{} {} {}".format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = "\n" ) <br>    s.append ( arr [ i ] ) <br></td>
    <td>translated code: <br><br> def print_all_ap_triplets ( arr , n ) :<br>    s = [ ]<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            diff = arr [ j ] - arr [ i ]<br>            exists = s.count ( arr [ i ] - diff )<br>            if exists :<br>                print ( arr [ i ] - diff , arr [ i ] , arr [ j ] )<br>        s.append ( arr [ i ] )<br></td>
  </tr><tr>
    <th>QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countInRange ( arr , n , x , y ) :<br>    count = 0 <br>    for i in range ( n ) :<br>        if ( arr [ i ] >= x and arr [ i ] <= y ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def countInRange ( arr , n , x , y ) :<br>    count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] >= x and arr [ i ] <= y :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>HIGHWAY_BILLBOARD_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxRevenue ( m , x , revenue , n , t ) :<br>    maxRev = [ 0 ] * ( m + 1 )<br>    nxtbb = 0 <br>    for i in range ( 1 , m + 1 ) :<br>        if ( nxtbb < n ) :<br>            if ( x [ nxtbb ] != i ) :<br>                maxRev [ i ] = maxRev [ i - 1 ]<br>            else :<br>                if ( i <= t ) :<br>                    maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] )<br>                else :<br>                    maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) <br>                nxtbb += 1<br>        else :<br>            maxRev [ i ] = maxRev [ i - 1 ]<br>    return maxRev [ m ]<br></td>
    <td>translated code: <br><br> def max_revenue ( m , x , revenue , n , t ) :<br>    max_rev = [ 0 ] * m + [ 0 ] * m<br>    nxtbb = 0<br>    for i in range ( m + 1 ) :<br>        if nxtbb < n :<br>            if x [ nxtbb ] != i :<br>                max_rev [ i ] = max_rev [ i - 1 ]<br>            else :<br>                if i <= t :<br>                    max_rev [ i ] = max ( max_rev [ i - 1 ] , revenue [ nxtbb ] )<br>                else :<br>                    max_rev [ i ] = max ( max_rev [ i - t - 1 ] + revenue [ nxtbb ] , max_rev [ i - 1 ] )<br>                nxtbb += 1<br>        else :<br>            max_rev [ i ] = max_rev [ i - 1 ]<br>    return max_rev [ m ]<br></td>
  </tr><tr>
    <th>CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printMat ( degseq , n ) :<br>    mat = [ [ 0 ] * n for i in range ( n ) ]<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) :<br>                degseq [ i ] -= 1<br>                degseq [ j ] -= 1<br>                mat [ i ] [ j ] = 1<br>                mat [ j ] [ i ] = 1<br>    print ( "      " , end = "" )<br>    for i in range ( n ) :<br>        print ( "" , "(" , i , ")" , end = "" )<br>    print ( )<br>    print ( )<br>    for i in range ( n ) :<br>        print ( "" , "(" , i , ")" , end = "" )<br>        for j in range ( n ) :<br>            print ( "     " , mat [ i ] [ j ] , end = "" )<br>        print ( )<br></td>
    <td>translated code: <br><br> def printMat ( degseq , n ) :<br>    mat = [ [ 0 ] * n for i in range ( n ) ]<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if degseq [ i ] > 0 and degseq [ j ] > 0 :<br>                degseq [ i ] -= 1<br>                degseq [ j ] -= 1<br>                mat [ i ] [ j ] = 1<br>                mat [ j ] [ i ] = 1<br>    print ( "\n" + setw ( 3 ) + "     " )<br>    for i in range ( n ) :<br>        print ( setw ( 3 ) + "(" + str ( i ) + ")" )<br>    print ( "\n\n" )<br>    for i in range ( n ) :<br>        print ( setw ( 4 ) + "(" + str ( i ) + ")" )<br>        for j in range ( n ) :<br>            print ( setw ( 5 ) + mat [ i ] [ j ] )<br>        print ( "\n" )<br></td>
  </tr><tr>
    <th>DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def oppositeSigns ( x , y ) :<br>    return ( ( x ^ y ) < 0 ) <br></td>
    <td>translated code: <br><br> def oppositeSigns ( x , y ) :<br>    return ( ( x ^ y ) < 0 )<br></td>
  </tr><tr>
    <th>TRIANGULAR_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isTriangular ( num ) :<br>    if ( num < 0 ) :<br>        return False<br>    c = ( - 2 * num )<br>    b , a = 1 , 1<br>    d = ( b * b ) - ( 4 * a * c )<br>    if ( d < 0 ) :<br>        return False<br>    root1 = ( - b + math.sqrt ( d ) ) / ( 2 * a )<br>    root2 = ( - b - math.sqrt ( d ) ) / ( 2 * a )<br>    if ( root1 > 0 and math.floor ( root1 ) == root1 ) :<br>        return True<br>    if ( root2 > 0 and math.floor ( root2 ) == root2 ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def isTriangular ( num ) :<br>    if num < 0 :<br>        return False<br>    c = ( - 2 * num )<br>    b , a = 1 , 1<br>    d = ( b ** 2 ) - ( 4 * a ** 2 )<br>    if d < 0 :<br>        return False<br>    root1 = ( - b + float ( math.sqrt ( d ) ) ) / ( 2 * a )<br>    root2 = ( - b - float ( math.sqrt ( d ) ) ) / ( 2 * a )<br>    if root1 and math.floor ( root1 ) == root1 :<br>        return True<br>    if root2 and math.floor ( root2 ) == root2 :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPowerOfFour ( n ) :<br>    if ( n == 0 ) :<br>        return False<br>    while ( n != 1 ) :<br>        if ( n % 4 != 0 ) :<br>            return False<br>        n = n // 4<br>    return True<br></td>
    <td>translated code: <br><br> def isPowerOfFour ( n ) :<br>    if n == 0 :<br>        return 0<br>    while n != 1 :<br>        if n % 4 != 0 :<br>            return 0<br>        n = n / 4<br>    return 1<br></td>
  </tr><tr>
    <th>LAST_NON_ZERO_DIGIT_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lastNon0Digit ( n ) :<br>    if ( n < 10 ) :<br>        return dig [ n ]<br>    if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) :<br>        return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10<br>    else :<br>        return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10<br>    return 0<br></td>
    <td>translated code: <br><br> def last_non0_digit ( n ) :<br>    if n < 10 :<br>        return dig [ n ]<br>    if ( ( n / 10 ) % 10 ) % 2 == 0 :<br>        return ( 6 * last_non0_digit ( n / 5 ) * dig [ n % 10 ] ) % 10<br>    else :<br>        return ( 4 * last_non0_digit ( n / 5 ) * dig [ n % 10 ] ) % 10<br></td>
  </tr><tr>
    <th>SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortByPattern ( str , pat ) :<br>    global MAX_CHAR<br>    count = [ 0 ] * MAX_CHAR<br>    for i in range ( 0 , len ( str ) ) :<br>        count [ ord ( str [ i ] ) - 97 ] += 1<br>    index = 0 <br>    str = ""<br>    for i in range ( 0 , len ( pat ) ) :<br>        j = 0<br>        while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] ) :<br>            str += pat [ i ]<br>            j = j + 1<br>            index += 1<br>    return str<br></td>
    <td>translated code: <br><br> def sortByPattern ( str , pat ) :<br>    count = [ 0 for i in range ( len ( str ) ) ]<br>    index = 0<br>    for i in range ( len ( pat ) ) :<br>        for j in range ( count [ pat [ i ] - 'a' ] ) :<br>            str [ index ] = pat [ i ]<br>    return str , count<br></td>
  </tr><tr>
    <th>NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minimumBox ( arr , n ) :<br>    q = collections.deque ( [ ] )<br>    arr.sort ( )<br>    q.append ( arr [ 0 ] )<br>    for i in range ( 1 , n ) :<br>        now = q [ 0 ]<br>        if ( arr [ i ] >= 2 * now ) :<br>            q.popleft ( )<br>        q.append ( arr [ i ] )<br>    return len ( q )<br></td>
    <td>translated code: <br><br> def minimumBox ( arr , n ) :<br>    q = Queue ( )<br>    q.put ( arr [ 0 ] )<br>    q.put ( arr [ 1 ] )<br>    for i in range ( 1 , n ) :<br>        now = q.get ( )<br>        if arr [ i ] >= 2 * now :<br>            q.put ( )<br>        q.put ( arr [ i ] )<br>    return q.get ( )<br></td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binarySearch ( arr , low , high , key ) :<br>    if ( high < low ) :<br>        return - 1<br>    mid = ( low + high ) / 2<br>    if ( key == arr [ int ( mid ) ] ) :<br>        return mid<br>    if ( key > arr [ int ( mid ) ] ) :<br>        return binarySearch ( arr , ( mid + 1 ) , high , key )<br>    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) )<br></td>
    <td>translated code: <br><br> def binary_search ( arr , low , high , key ) :<br>    if high < low :<br>        return - 1<br>    mid = ( low + high ) // 2<br>    if key == arr [ mid ] :<br>        return mid<br>    if key > arr [ mid ] :<br>        return binary_search ( arr [ ( mid + 1 ) : ] , high , key )<br>    return binary_search ( arr [ low : ( mid - 1 ) ] , key )<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRepeating ( arr , size ) :<br>    print ( " The repeating elements are" , end = " " )<br>    for i in range ( 0 , size ) :<br>        if ( arr [ abs ( arr [ i ] ) ] > 0 ) :<br>            arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ]<br>        else :<br>            print ( abs ( arr [ i ] ) , end = " " )<br></td>
    <td>translated code: <br><br> def printRepeating ( arr , size ) :<br>    i = 0<br>    print ( "The repeating elements are : " )<br>    for i in range ( size ) :<br>        if arr [ abs ( arr [ i ] ) ] > 0 :<br>            arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]<br>        else :<br>            print ( abs ( arr [ i ] ) , end = ' ' )<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findgroups ( arr , n ) :<br>    c = [ 0 , 0 , 0 ]<br>    res = 0<br>    for i in range ( 0 , n ) :<br>        c [ arr [ i ] % 3 ] += 1<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )<br>    res += c [ 1 ] * c [ 2 ]<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 )<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ]<br>    return res<br></td>
    <td>translated code: <br><br> def findgroups ( arr , n ) :<br>    c = [ 0 , 0 , 0 ]<br>    i = 0<br>    res = 0<br>    for i in range ( n ) :<br>        c [ arr [ i ] % 3 ] += 1<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )<br>    res += c [ 1 ] * c [ 2 ]<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 )<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ]<br>    return res<br></td>
  </tr><tr>
    <th>PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printStringAlternate ( string ) :<br>    occ = { }<br>    for i in range ( 0 , len ( string ) ) :<br>        temp = string [ i ].lower ( )<br>        occ [ temp ] = occ.get ( temp , 0 ) + 1<br>        if occ [ temp ] & 1 :<br>            print ( string [ i ] , end = "" )<br>    print ( )<br></td>
    <td>translated code: <br><br> def print_string_alternate ( str ) :<br>    occ = [ 0 ] * 122<br>    s = str.lower ( )<br>    for i in range ( len ( str ) ) :<br>        temp = s [ i ]<br>        occ [ temp ] += 1<br>        if occ [ temp ] % 2 != 0 :<br>            print ( str [ i ] )<br>    print ( )<br></td>
  </tr><tr>
    <th>NUMBER_DAYS_TANK_WILL_BECOME_EMPTY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minDaysToEmpty ( C , l ) :<br>    if ( l >= C ) : return C<br>    eq_root = ( math.sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2<br>    return math.ceil ( eq_root ) + l<br></td>
    <td>translated code: <br><br> def min_days_to_empty ( C , l ) :<br>    if l >= C :<br>        return C<br>    eq_root = ( math.sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2<br>    return int ( math.ceil ( eq_root ) + l )<br></td>
  </tr><tr>
    <th>REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def reversingString ( str , start , end ) :<br>    while ( start < end ) :<br>        str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) <br>        str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) <br>        str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) <br>        start += 1 <br>        end -= 1 <br>    return str <br></td>
    <td>translated code: <br><br> def reversingString ( str , start , end ) :<br>    while start < end :<br>        str [ start ] ^= str [ end ]<br>        str [ end ] ^= str [ start ]<br>        str [ start ] ^= str [ end ]<br>        start += 1<br>        end -= 1<br>    return str<br></td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFreq ( a , n ) :<br>    hm = { }<br>    for i in range ( 0 , n ) :<br>        hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1<br>    st = set ( )<br>    for x in hm :<br>        st.add ( ( x , hm [ x ] ) )<br>    cumul = 0<br>    for x in sorted ( st ) :<br>        cumul += x [ 1 ]<br>        print ( x [ 0 ] , cumul )<br></td>
    <td>translated code: <br><br> def count_freq ( a , n ) :<br>    hm = { }<br>    for i in range ( n ) :<br>        hm [ a [ i ] ] = hm [ a [ i ] ] if i in hm else 1<br>    st = sorted ( hm.items ( ) , key = lambda x : x [ 1 ] )<br>    cumul = 0<br>    for x in st :<br>        cumul += x [ 1 ]<br>        print ( x [ 0 ] , cumul )<br></td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countRotations ( arr , n ) :<br>    min = arr [ 0 ]<br>    for i in range ( 0 , n ) :<br>        if ( min > arr [ i ] ) :<br>            min = arr [ i ]<br>            min_index = i<br>    return min_index <br></td>
    <td>translated code: <br><br> def count_rotations ( arr , n ) :<br>    min , min_index = arr [ 0 ] , - 1<br>    for i in range ( n ) :<br>        if min > arr [ i ] :<br>            min , min_index = arr [ i ] , i<br>    return min_index<br></td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lis ( arr ) :<br>    n = len ( arr )<br>    lis = [ 1 ] * n<br>    for i in range ( 1 , n ) :<br>        for j in range ( 0 , i ) :<br>            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :<br>                lis [ i ] = lis [ j ] + 1<br>    maximum = 0<br>    for i in range ( n ) :<br>        maximum = max ( maximum , lis [ i ] )<br>    return maximum<br></td>
    <td>translated code: <br><br> def lis ( arr , n ) :<br>    lis = [ 1 ] * n<br>    i , j , max = 0 , 0<br>    for i in range ( n ) :<br>        lis [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 :<br>                lis [ i ] = lis [ j ] + 1<br>    for i in range ( n ) :<br>        if max < lis [ i ] :<br>            max = lis [ i ]<br>    return max<br></td>
  </tr><tr>
    <th>MEDIAN_OF_TWO_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMedian ( ar1 , ar2 , n ) :<br>    i = 0<br>    j = 0<br>    m1 = - 1<br>    m2 = - 1<br>    count = 0<br>    while count < n + 1 :<br>        count += 1<br>        if i == n :<br>            m1 = m2<br>            m2 = ar2 [ 0 ]<br>            break<br>        elif j == n :<br>            m1 = m2<br>            m2 = ar1 [ 0 ]<br>            break<br>        if ar1 [ i ] < ar2 [ j ] :<br>            m1 = m2<br>            m2 = ar1 [ i ]<br>            i += 1<br>        else :<br>            m1 = m2<br>            m2 = ar2 [ j ]<br>            j += 1<br>    return ( m1 + m2 ) / 2<br></td>
    <td>translated code: <br><br> def getMedian ( ar1 , ar2 , n ) :<br>    i = 0<br>    j = 0<br>    count = 0<br>    m1 , m2 = - 1 , - 1<br>    for count in range ( 0 , n ) :<br>        if i == n :<br>            m1 , m2 = m2 , ar2 [ 0 ]<br>            break<br>        elif j == n :<br>            m1 , m2 = m2 , ar1 [ 0 ]<br>            break<br>        if ar1 [ i ] < ar2 [ j ] :<br>            m1 , m2 = m2 , ar1 [ i ]<br>            i += 1<br>        else :<br>            m1 , m2 = m2 , ar2 [ j ]<br>            j += 1<br>    return ( m1 + m2 ) / 2<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minLexRotation ( str_ ) :<br>    n = len ( str_ )<br>    arr = [ 0 ] * n<br>    concat = str_ + str_<br>    for i in range ( n ) :<br>        arr [ i ] = concat [ i : n + i ]<br>    arr.sort ( )<br>    return arr [ 0 ]<br></td>
    <td>translated code: <br><br> def minLexRotation ( str ) :<br>    n = len ( str )<br>    arr = [ ]<br>    concat = str + str<br>    for i in range ( n ) :<br>        arr.append ( concat [ i : i + n ] )<br>    arr.sort ( )<br>    return ''.join ( arr )<br></td>
  </tr><tr>
    <th>INTERPOLATION_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def interpolationSearch ( arr , n , x ) :<br>    lo = 0<br>    hi = ( n - 1 )<br>    while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :<br>        if lo == hi :<br>            if arr [ lo ] == x :<br>                return lo <br>            return - 1 <br>        pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) )<br>        if arr [ pos ] == x :<br>            return pos<br>        if arr [ pos ] < x :<br>            lo = pos + 1 <br>        else :<br>            hi = pos - 1 <br>    return - 1<br></td>
    <td>translated code: <br><br> def interpolationSearch ( x ) :<br>    lo , hi = 0 , ( len ( arr ) - 1 )<br>    while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :<br>        if lo == hi :<br>            if arr [ lo ] == x :<br>                return lo<br>            return - 1<br>        pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) )<br>        if arr [ pos ] == x :<br>            return pos<br>        if arr [ pos ] < x :<br>            lo = pos + 1<br>        else :<br>            hi = pos - 1<br>    return - 1<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( arr1 , arr2 , m , n , x ) :<br>    count , l , r = 0 , 0 , n - 1<br>    while ( l < m and r >= 0 ) :<br>        if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) :<br>            l += 1<br>            r -= 1<br>            count += 1<br>        elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) :<br>            l += 1<br>        else :<br>            r -= 1<br>    return count<br></td>
    <td>translated code: <br><br> def count_pairs ( arr1 , arr2 , m , n , x ) :<br>    count = 0<br>    l , r = 0 , n - 1<br>    while l < m and r >= 0 :<br>        if ( arr1 [ l ] + arr2 [ r ] ) == x :<br>            l += 1<br>            r -= 1<br>            count += 1<br>        elif ( arr1 [ l ] + arr2 [ r ] ) < x :<br>            l += 1<br>        else :<br>            r -= 1<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSubSets ( arr , n ) :<br>    us = set ( )<br>    even_count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] % 2 == 0 :<br>            us.add ( arr [ i ] )<br>    for i in us :<br>        even_count += 1<br>    return pow ( 2 , even_count ) - 1<br></td>
    <td>translated code: <br><br> def count_subsets ( arr , n ) :<br>    us = set ( )<br>    even_count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] % 2 == 0 :<br>            us.add ( arr [ i ] )<br>    even_count = len ( us )<br>    return int ( pow ( 2 , even_count ) - 1 )<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOccurrences ( arr , n , x ) :<br>    res = 0<br>    for i in range ( n ) :<br>        if x == arr [ i ] :<br>            res += 1<br>    return res<br></td>
    <td>translated code: <br><br> def countOccurrences ( arr , n , x ) :<br>    res = 0<br>    for i in range ( n ) :<br>        if x == arr [ i ] :<br>            res += 1<br>    return res<br></td>
  </tr><tr>
    <th>CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Restore_Tree ( S , E ) :<br>    Identity = N * [ 0 ]<br>    for i in range ( N ) :<br>        Identity [ Start [ i ] ] = i<br>    parent = N * [ - 1 ]<br>    curr_parent = Identity [ 0 ]<br>    for j in range ( 1 , N ) :<br>        child = Identity [ j ]<br>        if End [ child ] - j > 1 :<br>            parent [ child ] = curr_parent<br>            curr_parent = child<br>        else :<br>            parent [ child ] = curr_parent<br>            while End [ child ] == End [ parent [ child ] ] :<br>                child = parent [ child ]<br>                curr_parent = parent [ child ]<br>                if curr_parent == Identity [ 0 ] :<br>                    break<br>    for i in range ( N ) :<br>        parent [ i ] += 1<br>    return parent<br></td>
    <td>translated code: <br><br> def Restore_Tree ( S , End ) :<br>    Identity = [ ]<br>    for i in range ( N ) :<br>        Identity.append ( i )<br>    parent = [ ]<br>    del Identity [ 0 ]<br>    curr_parent = Identity [ 0 ]<br>    for j in range ( 1 , N ) :<br>        child = Identity [ j ]<br>        if End [ child ] - j > 1 :<br>            parent.append ( curr_parent )<br>            curr_parent = child<br>        else :<br>            parent.append ( curr_parent )<br>            while parent [ child ] > - 1 and End [ child ] == End [ parent [ child ] ] :<br>                child = parent [ child ]<br>                curr_parent = parent [ child ]<br>                if curr_parent == Identity [ 0 ] :<br>                    break<br>    for i in range ( N ) :<br>        parent [ i ] += 1<br>    return parent<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countOccurrences ( s , K ) :<br>    n = len ( s )<br>    c1 = 0<br>    c2 = 0<br>    C = 0<br>    for i in range ( n ) :<br>        if s [ i ] == 'a' :<br>            c1 += 1<br>        if s [ i ] == 'b' :<br>            c2 += 1<br>            C += c1<br>    return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2<br></td>
    <td>translated code: <br><br> def countOccurrences ( s , K ) :<br>    n = len ( s )<br>    C , c1 , c2 = 0 , 0 , 0<br>    for c in s :<br>        if c == 'a' :<br>            c1 += 1<br>        if c == 'b' :<br>            c2 += 1<br>            C += c1<br>    return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2<br></td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countNonEmptySubstr ( str ) :<br>    n = len ( str ) <br>    return int ( n * ( n + 1 ) / 2 ) <br></td>
    <td>translated code: <br><br> def count_non_empty_substr ( str ) :<br>    n = len ( str )<br>    return n * ( n + 1 ) // 2<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumChars ( str1 ) :<br>    n = len ( str1 )<br>    res = - 1<br>    firstInd = [ - 1 for i in range ( MAX_CHAR ) ]<br>    for i in range ( n ) :<br>        first_ind = firstInd [ ord ( str1 [ i ] ) ]<br>        if ( first_ind == - 1 ) :<br>            firstInd [ ord ( str1 [ i ] ) ] = i<br>        else :<br>            res = max ( res , abs ( i - first_ind - 1 ) )<br>    return res<br></td>
    <td>translated code: <br><br> def maximum_chars ( str ) :<br>    n = len ( str )<br>    res = - 1<br>    first_ind = [ - 1 ] * MAX_CHAR<br>    for i in range ( MAX_CHAR ) :<br>        first_ind [ i ] = - 1<br>    for i in range ( n ) :<br>        first_ind [ str [ i ] ] = i<br>    res = max ( res , abs ( i - first_ind [ - 1 ] ) )<br>    return res<br></td>
  </tr><tr>
    <th>SUM_SQUARES_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumofsquare ( n ) :<br>    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , min ( i , n ) + 1 ) :<br>            if ( j == 0 or j == i ) :<br>                C [ i ] [ j ] = 1<br>            else :<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] )<br>    sum = 0<br>    for i in range ( 0 , n + 1 ) :<br>        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )<br>    return sum<br></td>
    <td>translated code: <br><br> def sumofsquare ( n ) :<br>    C = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n +</td>
  </tr><tr>
    <th>PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSubsequences ( str ) :<br>    n = len ( str )<br>    opsize = int ( pow ( 2 , n - 1 ) )<br>    for counter in range ( opsize ) :<br>        for j in range ( n ) :<br>            print ( str [ j ] , end = "" )<br>            if ( counter & ( 1 << j ) ) :<br>                print ( "" , end = "" )<br>        print ( "\n" , end = "" )<br></td>
    <td>translated code: <br><br> def print_subsequences ( s ) :<br>    s = s.split ( )<br>    n = len ( s )<br>    opsize = int ( math.pow ( 2 , n - 1 ) )<br>    for counter in range ( opsize ) :<br>        for j in range ( n ) :<br>            print ( s [ j ] )<br>            if ( counter & ( 1 << j ) ) > 0 :<br>                print ( " " )<br>        print ( )<br></td>
  </tr><tr>
    <th>NON_REPEATING_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def firstNonRepeating ( arr , n ) :<br>    for i in range ( n ) :<br>        j = 0<br>        while ( j < n ) :<br>            if ( i != j and arr [ i ] == arr [ j ] ) :<br>                break<br>            j += 1<br>        if ( j == n ) :<br>            return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def first_non_repeated ( arr , n ) :<br>    for i in range ( n ) :<br>        j = 0<br>        for j in range ( n ) :<br>            if i != j and arr [ i ] == arr [ j ] :<br>                break<br>        if j == n :<br>            return arr [ i ]<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculateSum ( n ) :<br>    sum = 0<br>    for row in range ( n ) :<br>        sum = sum + ( 1 << row )<br>    return sum<br></td>
    <td>translated code: <br><br> def calculate_sum ( n ) :<br>    sum = 0<br>    for row in range ( n ) :<br>        sum = sum + ( 1 << row )<br>    return sum<br></td>
  </tr><tr>
    <th>CHECK_TWO_STRINGS_K_ANAGRAMS_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def arekAnagrams ( str1 , str2 , k ) :<br>    n = len ( str1 )<br>    if ( len ( str2 ) != n ) :<br>        return False<br>    count1 = [ 0 ] * MAX_CHAR<br>    count2 = [ 0 ] * MAX_CHAR<br>    for i in range ( n ) :<br>        count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1<br>    for i in range ( n ) :<br>        count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1<br>    count = 0<br>    for i in range ( MAX_CHAR ) :<br>        if ( count1 [ i ] > count2 [ i ] ) :<br>            count = count + abs ( count1 [ i ] - count2 [ i ] )<br>    return ( count <= k )<br></td>
    <td>translated code: <br><br> def arek_anagrams ( str1 , str2 , k ) :<br>    n = len ( str1 )<br>    if len ( str2 ) != n :<br>        return False<br>    count1 = [ ]<br>    count2 = [ ]<br>    count = 0<br>    for i in range ( n ) :<br>        count1.append ( str1 [ i ] - 'a' )<br>    for i in range ( n ) :<br>        count2.append ( str2 [ i ] - 'a' )<br>    for i in range ( MAX_CHAR ) :<br>        if count1 [ i ] > count2 [ i ] :<br>            count = count + abs ( count1 [ i ] - count2 [ i ] )<br>    return ( count <= k )<br></td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestCommonSum ( arr1 , arr2 , n ) :<br>    maxLen = 0<br>    for i in range ( 0 , n ) :<br>        sum1 = 0<br>        sum2 = 0<br>        for j in range ( i , n ) :<br>            sum1 += arr1 [ j ]<br>            sum2 += arr2 [ j ]<br>            if ( sum1 == sum2 ) :<br>                len = j - i + 1<br>                if ( len > maxLen ) :<br>                    maxLen = len<br>    return maxLen<br></td>
    <td>translated code: <br><br> def longest_common_sum ( n ) :<br>    max_len = 0<br>    for i in range ( n ) :<br>        sum1 , sum2 = 0 , 0<br>        for j in range ( i , n ) :<br>            sum1 += arr1 [ j ]<br>            sum2 += arr2 [ j ]<br>            if sum1 == sum2 :<br>                len = j - i + 1<br>            else :<br>                len = j - i<br>            if len > max_len :<br>                max_len = len<br>    return max_len<br></td>
  </tr><tr>
    <th>REMAINDER_7_LARGE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def remainderWith7 ( num ) :<br>    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] <br>    series_index = 0 <br>    result = 0 <br>    for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :<br>        digit = ord ( num [ i ] ) - 48 <br>        result += digit * series [ series_index ] <br>        series_index = ( series_index + 1 ) % 6 <br>        result %= 7 <br>    if ( result < 0 ) :<br>        result = ( result + 7 ) % 7 <br>    return result <br></td>
    <td>translated code: <br><br> def remainder_with_7 ( num ) :<br>    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]<br>    series_index = 0<br>    result = 0<br>    for i in range ( len ( num ) - 1 , - 1 , - 1 ) :<br>        digit = num [ i ] - '0'<br>        result += digit * series [ series_index ]<br>        series_index = ( series_index + 1 ) % 6<br>        result %= 7<br>    if result < 0 :<br>        result = ( result + 7 ) % 7<br>    return result<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def prevPermutation ( str ) :<br>    n = len ( str ) - 1<br>    i = n<br>    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :<br>        i -= 1<br>    if ( i <= 0 ) :<br>        return False<br>    j = i - 1<br>    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) :<br>        j += 1<br>    str = list ( str )<br>    temp = str [ i - 1 ]<br>    str [ i - 1 ] = str [ j ]<br>    str [ j ] = temp<br>    str = ''.join ( str )<br>    str [ : : - 1 ]<br>    return True , str<br></td>
    <td>translated code: <br><br> def prevPermutation ( str ) :<br>    n = len ( str ) - 1<br>    i = n<br>    while i > 0 and str [ i - 1 ] <= str [ i ] : i -= 1<br>    if i <= 0 :<br>        return False<br>    j = i - 1<br>    while j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] : j += 1<br>    swap ( str [ i - 1 ] , str [ j ] )<br>    s = [ str [ i - 1 ] ]<br>    s.reverse ( )<br>    str = ''.join ( s )<br>    return True<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSubsequences ( s ) :<br>    aCount = 0<br>    bCount = 0<br>    cCount = 0<br>    for i in range ( len ( s ) ) :<br>        if ( s [ i ] == 'a' ) :<br>            aCount = ( 1 + 2 * aCount )<br>        elif ( s [ i ] == 'b' ) :<br>            bCount = ( aCount + 2 * bCount )<br>        elif ( s [ i ] == 'c' ) :<br>            cCount = ( bCount + 2 * cCount )<br>    return cCount<br></td>
    <td>translated code: <br><br> def countSubsequences ( s ) :<br>    aCount = 0<br>    bCount = 0<br>    cCount = 0<br>    for c in s :<br>        if c == 'a' :<br>            aCount = ( 1 + 2 * aCount )<br>        elif c == 'b' :<br>            bCount = ( aCount + 2 * bCount )<br>        elif c == 'c' :<br>            cCount = ( bCount + 2 * cCount )<br>    return cCount<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isIdentity ( mat , N ) :<br>    for row in range ( N ) :<br>        for col in range ( N ) :<br>            if ( row == col and mat [ row ] [ col ] != 1 ) :<br>                return False <br>            elif ( row != col and mat [ row ] [ col ] != 0 ) :<br>                return False <br>    return True <br></td>
    <td>translated code: <br><br> def isIdentity ( mat , N ) :<br>    for row in range ( N ) :<br>        for col in range ( N ) :<br>            if row == col and mat [ row ] [ col ] != 1 :<br>                return False<br>            elif row != col and mat [ row ] [ col ] != 0 :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDiff ( arr , n ) :<br>    result = 0<br>    arr.sort ( )<br>    for i in range ( n - 1 ) :<br>        if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) :<br>            result += abs ( arr [ i ] )<br>        else :<br>            pass<br>    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :<br>        result += abs ( arr [ n - 1 ] )<br>    return result<br></td>
    <td>translated code: <br><br> def maxDiff ( arr , n ) :<br>    result = 0<br>    arr.sort ( )<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] != arr [ i + 1 ] :<br>            result += abs ( arr [ i ] )<br>        else :<br>            i += 1<br>    if arr [ n - 2 ] != arr [ n - 1 ] :<br>        result += abs ( arr [ n - 1 ] )<br>    return result<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_SUM_GIVEN_NTH_TERM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def summingSeries ( n ) :<br>    S = 0<br>    for i in range ( 1 , n + 1 ) :<br>        S += i * i - ( i - 1 ) * ( i - 1 )<br>    return S<br></td>
    <td>translated code: <br><br> def summing_series ( n ) :<br>    S = 0<br>    for i in range ( 1 , n + 1 ) :<br>        S += i ** 2 - ( i - 1 ) ** 2<br>    return S<br></td>
  </tr><tr>
    <th>PREFIX_SUM_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def prefixSum2D ( a ) :<br>    global C , R<br>    psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ]<br>    psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]<br>    for i in range ( 1 , C ) :<br>        psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] )<br>    for i in range ( 0 , R ) :<br>        psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] )<br>    for i in range ( 1 , R ) :<br>        for j in range ( 1 , C ) :<br>            psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] )<br>    for i in range ( 0 , R ) :<br>        for j in range ( 0 , C ) :<br>            print ( psa [ i ] [ j ] , end = " " )<br>        print ( )<br></td>
    <td>translated code: <br><br> def prefix_sum_2d ( a ) :<br>    R , C = a.shape<br>    psa = np.zeros ( ( R , C ) )<br>    psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]<br>    for i in range ( 1 , C ) :<br>        psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ]<br>    for i in range ( 1 , R ) :<br>        psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ]<br>    for i in range ( 1 , R ) :<br>        for j in range ( 1 , C ) :<br>            psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ]<br>    for i in range ( 0 , R ) :<br>        for j in range ( 0 , C ) :<br>            print ( psa [ i ] [ j ] , end = ' ' )<br>        print ( )<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfSquares ( base ) :<br>    base = ( base - 2 )<br>    base = base / 2<br>    return base * ( base + 1 ) / 2<br></td>
    <td>translated code: <br><br> def number_of_squares ( base ) :<br>    base = ( base - 2 )<br>    base = base / 2<br>    return base * ( base + 1 ) / 2<br></td>
  </tr><tr>
    <th>GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSubStr ( st , n ) :<br>    m = 0<br>    for i in range ( 0 , n ) :<br>        if ( st [ i ] == '1' ) :<br>            m = m + 1<br>    return m * ( m - 1 ) // 2<br></td>
    <td>translated code: <br><br> def countSubStr ( str , n ) :<br>    m = 0<br>    for i in range ( n ) :<br>        if str [ i ] == '1' :<br>            m += 1<br>    return m * ( m - 1 ) / 2<br></td>
  </tr><tr>
    <th>CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isConvertible ( str1 , str2 , k ) :<br>    if ( ( len ( str1 ) + len ( str2 ) ) < k ) :<br>        return True<br>    commonLength = 0<br>    for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) :<br>        if ( str1 [ i ] == str2 [ i ] ) :<br>            commonLength += 1<br>        else :<br>            break<br>    if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def isConvertible ( str1 , str2 , k ) :<br>    if ( len ( str1 ) + len ( str2 ) ) < k :<br>        return True<br>    commonLength = 0<br>    for i in range ( min ( len ( str1 ) , len ( str2 ) ) ) :<br>        if str1 == str2 :<br>            commonLength += 1<br>        else :<br>            break<br>    if ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getOddOccurrence ( arr ) :<br>    res = 0<br>    for element in arr :<br>        res = res ^ element<br>    return res<br></td>
    <td>translated code: <br><br> def getOddOccurrence ( ar , ar_size ) :<br>    i = 0<br>    res = 0<br>    for i in range ( ar_size ) :<br>        res = res ^ ar [ i ]<br>    return res<br></td>
  </tr><tr>
    <th>SUM_MIDDLE_ROW_COLUMN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def middlesum ( mat , n ) :<br>    row_sum = 0<br>    col_sum = 0<br>    for i in range ( n ) :<br>        row_sum += mat [ n // 2 ] [ i ]<br>    print ( "Sum of middle row = " , row_sum )<br>    for i in range ( n ) :<br>        col_sum += mat [ i ] [ n // 2 ]<br>    print ( "Sum of middle column = " , col_sum )<br></td>
    <td>translated code: <br><br> def middlesum ( mat , n ) :<br>    row_sum , col_sum = 0 , 0<br>    for i in range ( n ) :<br>        row_sum += mat [ n // 2 ] [ i ]<br>    print ( "Sum of middle row = " + str ( row_sum ) )<br>    for i in range ( n ) :<br>        col_sum += mat [ i ] [ n // 2 ]<br>    print ( "Sum of middle column = " + str ( col_sum ) )<br></td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printKDistinct ( arr , n , k ) :<br>    dist_count = 0<br>    for i in range ( n ) :<br>        j = 0<br>        while j < n :<br>            if ( i != j and arr [ j ] == arr [ i ] ) :<br>                break<br>            j += 1<br>        if ( j == n ) :<br>            dist_count += 1<br>        if ( dist_count == k ) :<br>            return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def printKDistinct ( arr , n , k ) :<br>    dist_count = 0<br>    for i in range ( n ) :<br>        j = 0<br>        for j in range ( n ) :<br>            if i != j and arr [ j ] == arr [ i ] :<br>                break<br>        if j == n :<br>            dist_count += 1<br>        if dist_count == k :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>MERGING_INTERVALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def mergeIntervals ( arr ) :<br>    arr.sort ( key = lambda x : x [ 0 ] )<br>    m = [ ]<br>    s = - 10000<br>    max = - 100000<br>    for i in range ( len ( arr ) ) :<br>        a = arr [ i ]<br>        if a [ 0 ] > max :<br>            if i != 0 :<br>                m.append ( [ s , max ] )<br>            max = a [ 1 ]<br>            s = a [ 0 ]<br>        else :<br>            if a [ 1 ] >= max :<br>                max = a [ 1 ]<br>    if max != - 100000 and [ s , max ] not in m :<br>        m.append ( [ s , max ] )<br>    print ( "The Merged Intervals are :" , end = " " )<br>    for i in range ( len ( m ) ) :<br>        print ( m [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def merge_intervals ( arr ) :<br>    arr.sort ( key = lambda i1 : i2 [ 0 ] - i1 [ 1 ] )<br>    index = 0<br>    for i in range ( 1 , len ( arr ) ) :<br>        if arr [ index ] [ 'end' ] >= arr [ i ] [ 'start' ] :<br>            arr [ index ] [ 'end' ] = max ( arr [ index ] [ 'end' ] , arr [ i ] [ 'end' ] )<br>            arr [ index ] [ 'start' ] = min ( arr [ index ] [ 'start' ] , arr [ i ] [ 'start' ] )<br>        else :<br>            arr [ index ] = arr [ i ]<br>            index += 1<br>    print ( 'The Merged Intervals are: ' )<br>    for i in range ( 0 , index + 1 ) :<br>        print ( '[%d,%d]' % ( arr [ i ] [ 'start' ] , arr [ i ] [ 'end' ] ) )<br></td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def CountSquares ( a , b ) :<br>    return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( math.sqrt ( a ) ) + 1 )<br></td>
    <td>translated code: <br><br> def count_squares ( a , b ) :<br>    return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( math.sqrt ( a ) ) + 1 )<br></td>
  </tr><tr>
    <th>LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findFibSubset ( arr , n ) :<br>    m = max ( arr )<br>    a = 0<br>    b = 1<br>    hash = [ ]<br>    hash.append ( a )<br>    hash.append ( b )<br>    while ( b < m ) :<br>        c = a + b<br>        a = b<br>        b = c<br>        hash.append ( b )<br>    for i in range ( n ) :<br>        if arr [ i ] in hash :<br>            print ( arr [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def find_fib_subset ( x ) :<br>    max = max ( list ( x ) )<br>    fib = [ ]<br>    result = [ ]<br>    a = 0<br>    b = 1<br>    while b < max :<br>        c = a + b<br>        a = b<br>        b = c<br>        fib.append ( c )<br>    for i in x :<br>        if fib.count ( i ) :<br>            result.append ( i )<br>    print ( result )<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lexicographicSubConcat ( s ) :<br>    n = len ( s ) <br>    sub_count = ( n * ( n + 1 ) ) // 2 <br>    arr = [ 0 ] * sub_count <br>    index = 0 <br>    for i in range ( n ) :<br>        for j in range ( 1 , n - i + 1 ) :<br>            arr [ index ] = s [ i : i + j ] <br>            index += 1 <br>    arr.sort ( ) <br>    res = "" <br>    for i in range ( sub_count ) :<br>        res += arr [ i ] <br>    return res <br></td>
    <td>translated code: <br><br> def lexicographic_sub_concat ( s ) :<br>    n = len ( s )<br>    sub_count = n * ( n + 1 ) // 2<br>    arr = [ ]<br>    index = 0<br>    for i in range ( n ) :<br>        for len in range ( 1 , n - i + 1 ) :<br>            arr.append ( s [ i : i + len ] )<br>    arr.sort ( )<br>    res = ""<br>    for i in range ( sub_count ) :<br>        res += arr [ i ]<br>    return res<br></td>
  </tr><tr>
    <th>COUNT_OPERATIONS_MAKE_STRINGAB_FREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def abFree ( s ) :<br>    b_count = 0<br>    res = 0<br>    for i in range ( len ( s ) ) :<br>        if s [ ~ i ] == 'a' :<br>            res = ( res + b_count )<br>            b_count = ( b_count * 2 )<br>        else :<br>            b_count += 1<br>    return res<br></td>
    <td>translated code: <br><br> def abfree ( s ) :<br>    b_count = 0<br>    res = 0<br>    for c in s :<br>        if c == 'a' :<br>            res = ( res + b_count )<br>            b_count = ( b_count * 2 )<br>        else :<br>            b_count += 1<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MaximumHeight ( a , n ) :<br>    return ( - 1 + int ( math.sqrt ( 1 + ( 8 * n ) ) ) ) // 2<br></td>
    <td>translated code: <br><br> def MaximumHeight ( a , n ) :<br>    return int ( math.floor ( ( - 1 + math.sqrt ( 1 + ( 8 * n ) ) ) ) / 2 )<br></td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxvolume ( s ) :<br>    maxvalue = 0<br>    i = 1<br>    for i in range ( s - 1 ) :<br>        j = 1<br>        for j in range ( s ) :<br>            k = s - i - j<br>            maxvalue = max ( maxvalue , i * j * k )<br>    return maxvalue<br></td>
    <td>translated code: <br><br> def maxvolume ( s ) :<br>    maxvalue = 0<br>    for i in range ( 1 , s - 2 ) :<br>        for j in range ( 1 , s - 1 ) :<br>            k = s - i - j<br>            maxvalue = max ( maxvalue , i * j * k )<br>    return maxvalue<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def decToHexa ( n ) :<br>    hexaDeciNum = [ '0' ] * 100 <br>    i = 0 <br>    while ( n != 0 ) :<br>        temp = 0 <br>        temp = n % 16 <br>        if ( temp < 10 ) :<br>            hexaDeciNum [ i ] = chr ( temp + 48 ) <br>            i = i + 1 <br>        else :<br>            hexaDeciNum [ i ] = chr ( temp + 55 ) <br>            i = i + 1 <br>        n = int ( n / 16 ) <br>    j = i - 1 <br>    while ( j >= 0 ) :<br>        print ( ( hexaDeciNum [ j ] ) , end = "" ) <br>        j = j - 1 <br></td>
    <td>translated code: <br><br> def dec_to_hex ( n ) :<br>    hexaDeciNum = [ ]<br>    i = 0<br>    while n != 0 :<br>        temp = 0<br>        temp = n % 16<br>        if temp < 10 :<br>            hexaDeciNum.append ( chr ( temp + 48 ) )<br>            i += 1<br>        else :<br>            hexaDeciNum.append ( chr ( temp + 55 ) )<br>            i += 1<br>        n = n / 16<br>    for j in range ( i - 1 , - 1 , - 1 ) :<br>        print ( hexaDeciNum [ j ] )<br></td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def smallestSubsegment ( a , n ) :<br>    left = dict ( )<br>    count = dict ( )<br>    mx = 0<br>    mn , strindex = 0 , 0<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        if ( x not in count.keys ( ) ) :<br>            left [ x ] = i<br>            count [ x ] = 1<br>        else :<br>            count [ x ] += 1<br>        if ( count [ x ] > mx ) :<br>            mx = count [ x ]<br>            mn = i - left [ x ] + 1<br>            strindex = left [ x ]<br>        elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) :<br>            mn = i - left [ x ] + 1<br>            strindex = left [ x ]<br>    for i in range ( strindex , strindex + mn ) :<br>        print ( a [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def smallest_subsegment ( a , n ) :<br>    left = { }<br>    count = { }<br>    mx = 0<br>    mn , strindex = - 1 , - 1<br>    for i in range ( n ) :<br>        x = a [ i ]<br>        if count [ x ] == None :<br>            left [ x ] = i<br>            count [ x ] = 1<br>        else :<br>            count [ x ] = count [ x ] + 1<br>        if count [ x ] > mx :<br>            mx = count [ x ]<br>            mn = i - left [ x ] + 1<br>            strindex = left [ x ]<br>        elif ( count [ x ] == mx ) :<br>            mn = i - left [ x ] + 1<br>            strindex = left [ x ]<br>    for i in range ( strindex , strindex + mn ) :<br>        print ( a [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLastIndex ( str , x ) :<br>    for i in range ( len ( str ) - 1 , - 1 , - 1 ) :<br>        if ( str [ i ] == x ) :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_last_index ( str , x ) :<br>    for i in range ( len ( str ) - 1 , - 1 , - 1 ) :<br>        if str [ i ] == x :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>RECAMANS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def recaman ( n ) :<br>    arr = [ 0 ] * n<br>    arr [ 0 ] = 0<br>    print ( arr [ 0 ] , end = ", " )<br>    for i in range ( 1 , n ) :<br>        curr = arr [ i - 1 ] - i<br>        for j in range ( 0 , i ) :<br>            if ( ( arr [ j ] == curr ) or curr < 0 ) :<br>                curr = arr [ i - 1 ] + i<br>                break<br>        arr [ i ] = curr<br>        print ( arr [ i ] , end = ", " )<br></td>
    <td>translated code: <br><br> def recaman ( n ) :<br>    arr = np.arange ( n )<br>    arr [ 0 ] = 0<br>    print ( arr [ 0 ] , " ," )<br>    for i in range ( 1 , n ) :<br>        curr = arr [ i - 1 ] - i<br>        j = 0<br>        for j in range ( i ) :<br>            if ( arr [ j ] == curr ) or curr < 0 :<br>                curr = arr [ i - 1 ] + i<br>                break<br>        arr [ i ] = curr<br>        print ( arr [ i ] , ", " )<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getSecondMostFreq ( str ) :<br>    NO_OF_CHARS = 256<br>    count = [ 0 ] * NO_OF_CHARS<br>    for i in range ( len ( str ) ) :<br>        count [ ord ( str [ i ] ) ] += 1<br>    first , second = 0 , 0<br>    for i in range ( NO_OF_CHARS ) :<br>        if count [ i ] > count [ first ] :<br>            second = first<br>            first = i<br>        elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) :<br>            second = i<br>    return chr ( second )<br></td>
    <td>translated code: <br><br> def getSecondMostFreq ( str ) :<br>    count = [ 0 ] * NO_OF_CHARS<br>    i = 0<br>    for c in str :<br>        ( count [ c ] , count [ c ] ) += 1<br>    first , second = 0 , 0<br>    for c in NO_OF_CHARS :<br>        if count [ c ] > count [ first ] :<br>            second , first = first , c<br>        elif count [ c ] > count [ second ] and count [ c ] != count [ first ] :<br>            second , first = c , first<br>    return chr ( second )<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxLevel ( boxes , n ) :<br>    boxes.sort ( )<br>    ans = 1<br>    prev_width = boxes [ 0 ]<br>    prev_count = 1<br>    curr_count = 0<br>    curr_width = 0<br>    for i in range ( 1 , n ) :<br>        curr_width += boxes [ i ]<br>        curr_count += 1<br>        if ( curr_width > prev_width and curr_count > prev_count ) :<br>            prev_width = curr_width<br>            prev_count = curr_count<br>            curr_count = 0<br>            curr_width = 0<br>            ans += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def maxLevel ( boxes , n ) :<br>    boxes.sort ( )<br>    ans = 1<br>    prev_width = boxes [ 0 ]<br>    prev_count = 1<br>    curr_count = 0<br>    curr_width = 0<br>    for i in range ( 1 , n ) :<br>        curr_width += boxes [ i ]<br>        curr_count += 1<br>        if curr_width > prev_width and curr_count > prev_count :<br>            prev_width = curr_width<br>            prev_count = curr_count<br>            curr_count = 0<br>            curr_width = 0<br>            ans += 1<br>    return ans<br></td>
  </tr><tr>
    <th>COUNTING_INVERSIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getInvCount ( arr , n ) :<br>    inv_count = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ i ] > arr [ j ] ) :<br>                inv_count += 1<br>    return inv_count<br></td>
    <td>translated code: <br><br> def getInvCount ( n ) :<br>    inv_count = 0<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] > arr [ j ] :<br>                inv_count += 1<br>    return inv_count<br></td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def diagonalsquare ( mat , row , column ) :<br>    print ( "Diagonal one : " , end = "" )<br>    for i in range ( 0 , row ) :<br>        for j in range ( 0 , column ) :<br>            if ( i == j ) :<br>                print ( "{} ".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" )<br>    print ( " \n\nDiagonal two : " , end = "" )<br>    for i in range ( 0 , row ) :<br>        for j in range ( 0 , column ) :<br>            if ( i + j == column - 1 ) :<br>                print ( "{} ".format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = "" )<br></td>
    <td>translated code: <br><br> def diagonalsquare ( mat , row , column ) :<br>    print ( "Diagonal one : " )<br>    for i in range ( row ) :<br>        for j in range ( column ) :<br>            if i == j :<br>                print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " )<br>    print ( )<br>    print ( "Diagonal two : " )<br>    for i in range ( row ) :<br>        for j in range ( column ) :<br>            if i + j == column - 1 :<br>                print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " )<br></td>
  </tr><tr>
    <th>ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countCommon ( mat , n ) :<br>    res = 0<br>    for i in range ( n ) :<br>        if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :<br>            res = res + 1<br>    return res<br></td>
    <td>translated code: <br><br> def countCommon ( mat , n ) :<br>    res = 0<br>    for i in range ( n ) :<br>        if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :<br>            res += 1<br>    return res<br></td>
  </tr><tr>
    <th>EULERIAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def eulerian ( n , m ) :<br>    if ( m >= n or n == 0 ) :<br>        return 0 <br>    if ( m == 0 ) :<br>        return 1 <br>    return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) )<br></td>
    <td>translated code: <br><br> def eulerian ( n , m ) :<br>    if m >= n or n == 0 :<br>        return 0<br>    if m == 0 :<br>        return 1<br>    return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m )<br></td>
  </tr><tr>
    <th>EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def squareRootExists ( n , p ) :<br>    n = n % p<br>    for x in range ( 2 , p , 1 ) :<br>        if ( ( x * x ) % p == n ) :<br>            return True<br>    return False<br></td>
    <td>translated code: <br><br> def square_root_exists ( n , p ) :<br>    n = n % p<br>    for x in range ( 2 , p ) :<br>        if ( x ** 2 ) % p == n :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfPaths ( m , n ) :<br>    for i in range ( n , ( m + n - 1 ) ) :<br>        path *= i <br>        path //= ( i - n + 1 ) <br>    return path <br></td>
    <td>translated code: <br><br> def number_of_paths ( m , n ) :<br>    path = 1<br>    for i in range ( n , ( m + n - 1 ) ) :<br>        path *= i<br>        path /= ( i - n + 1 )<br>    return path<br></td>
  </tr><tr>
    <th>MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maximumDifferenceSum ( arr , N ) :<br>    dp = [ [ 0 , 0 ] for i in range ( N ) ]<br>    for i in range ( N ) :<br>        dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0<br>    for i in range ( N - 1 ) :<br>        dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) )<br>        dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) )<br>    return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )<br></td>
    <td>translated code: <br><br> def maximumDifferenceSum ( arr , N ) :<br>    dp = [ 0 ] * ( N )<br>    for i in range ( N ) :<br>        dp [ i ] = dp [ i ] + 1<br>    for i in range ( ( N - 1 ) ) :<br>        dp [ i + 1 ] = max ( dp [ i ] , dp [ i ] + abs ( 1 - arr [ i ] ) )<br>        dp [ i + 1 ] = max ( dp [ i ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] + abs ( arr [ i + 1 ] - arr [ i ] ) )<br>    return max ( dp [ N - 1 ] , dp [ N - 1 ] + 1 )<br></td>
  </tr><tr>
    <th>STERN_BROCOT_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def SternSequenceFunc ( BrocotSequence , n ) :<br>    for i in range ( 1 , n ) :<br>        considered_element = BrocotSequence [ i ]<br>        precedent = BrocotSequence [ i - 1 ]<br>        BrocotSequence.append ( considered_element + precedent )<br>        BrocotSequence.append ( considered_element )<br>    for i in range ( 0 , 15 ) :<br>        print ( BrocotSequence [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def SternSequenceFunc ( BrocotSequence , n ) :<br>    for i in range ( 1 , n ) :<br>        considered_element = BrocotSequence [ i ]<br>        precedent = BrocotSequence [ i - 1 ]<br>        BrocotSequence.append ( considered_element + precedent )<br>        BrocotSequence.append ( considered_element )<br>    for i in range ( 15 ) :<br>        print ( BrocotSequence [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDivisibleSubseq ( str , n ) :<br>    l = len ( str )<br>    dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ]<br>    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1<br>    for i in range ( 1 , l ) :<br>        dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1<br>        for j in range ( n ) :<br>            dp [ i ] [ j ] += dp [ i - 1 ] [ j ]<br>            dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ]<br>    return dp [ l - 1 ] [ 0 ]<br></td>
    <td>translated code: <br><br> def count_divisible_subseq ( str , n ) :<br>    len ( str )<br>    dp = [ 0 ] * len ( str )<br>    dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] += 1<br>    for i in range ( 1 , len ( str ) ) :<br>        dp [ i ] [ ( str [ i ] - '0' ) % n ] += 1<br>        for j in range ( n ) :<br>            dp [ i ] [ j ] += dp [ i - 1 ] [ j ]<br>            dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ]<br>    return dp [ len ( str ) - 1 ] [ 0 ]<br></td>
  </tr><tr>
    <th>HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , x ) :<br>    n = len ( arr )<br>    for j in range ( 0 , n ) :<br>        if ( x == arr [ j ] ) :<br>            return j<br>    return - 1<br></td>
    <td>translated code: <br><br> def search ( arr , n , x ) :<br>    for i in range ( n ) :<br>        if arr [ i ] == x :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getPairsCount ( arr , n , sum ) :<br>    m = [ 0 ] * 1000<br>    for i in range ( 0 , n ) :<br>        m [ arr [ i ] ]<br>        m [ arr [ i ] ] += 1<br>    twice_count = 0<br>    for i in range ( 0 , n ) :<br>        twice_count += m [ sum - arr [ i ] ]<br>        if ( sum - arr [ i ] == arr [ i ] ) :<br>            twice_count -= 1<br>    return int ( twice_count / 2 )<br></td>
    <td>translated code: <br><br> def getPairsCount ( n , sum ) :<br>    hm = { }<br>    for i in range ( n ) :<br>        if not hm.has_key ( arr [ i ] ) :<br>            hm [ arr [ i ] ] = 0<br>        hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1<br>    twice_count = 0<br>    for i in range ( n ) :<br>        if hm.has_key ( sum - arr [ i ] ) :<br>            twice_count += hm [ sum - arr [ i ] ]<br>        if sum - arr [ i ] == arr [ i ] :<br>            twice_count -= 1<br>    return twice_count / 2<br></td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minDist ( arr , n , x , y ) :<br>    min_dist = 99999999<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :<br>                min_dist = abs ( i - j )<br>        return min_dist<br></td>
    <td>translated code: <br><br> def minDist ( arr , n , x , y ) :<br>    i , j = 0 , 0<br>    min_dist = sys.maxint<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) :<br>                min_dist = abs ( i - j )<br>    return min_dist<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRepeating ( arr , n ) :<br>    res = 0<br>    for i in range ( 0 , n - 1 ) :<br>        res = res ^ ( i + 1 ) ^ arr [ i ]<br>    res = res ^ arr [ n - 1 ]<br>    return res<br></td>
    <td>translated code: <br><br> def find_repeated ( arr , n ) :<br>    res = 0<br>    for i in range ( n - 1 ) :<br>        res = res ^ ( i + 1 ) ^ arr [ i ]<br>    res = res ^ arr [ n - 1 ]<br>    return res<br></td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shortestPath ( graph , u , v , k ) :<br>    global V , INF<br>    sp = [ [ None ] * V for i in range ( V ) ]<br>    for i in range ( V ) :<br>        for j in range ( V ) :<br>            sp [ i ] [ j ] = [ None ] * ( k + 1 )<br>    for e in range ( k + 1 ) :<br>        for i in range ( V ) :<br>            for j in range ( V ) :<br>                sp [ i ] [ j ] [ e ] = INF<br>                if ( e == 0 and i == j ) :<br>                    sp [ i ] [ j ] [ e ] = 0<br>                if ( e == 1 and graph [ i ] [ j ] != INF ) :<br>                    sp [ i ] [ j ] [ e ] = graph [ i ] [ j ]<br>                if ( e > 1 ) :<br>                    for a in range ( V ) :<br>                        if ( graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF ) :<br>                            sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] )<br>    return sp [ u ] [ v ] [ k ]<br></td>
    <td>translated code: <br><br> def shortestPath ( graph , u , v , k ) :<br>    sp = [ [ INF ] * V [ V ] [ k + 1 ] for e in range ( 0 , k + 1 ) ]<br>    for i in range ( V ) :<br>        for j in range ( V ) :<br>            sp [ i ] [ j ] [ e ] = INF<br>            if e == 0 and i == j :<br>                sp [ i ] [ j ] [ e ] = 0<br>            if e == 1 and graph [ i ] [ j ] != INF :<br>                sp [ i ] [ j ] [ e ] = graph [ i ] [ j ]<br>            if e > 1 :<br>                for a in range ( V ) :<br>                    if graph [ i ] [ a ] != INF and i != a and j != a and sp [ a ] [ j ] [ e - 1 ] != INF :<br>                        sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] )<br>    return sp [ u ] [ v ] [ k ]<br></td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longest ( a , n , k ) :<br>    freq = [ 0 ] * n<br>    start = 0<br>    end = 0<br>    now = 0<br>    l = 0<br>    for i in range ( n ) :<br>        freq [ a [ i ] ] += 1<br>        if ( freq [ a [ i ] ] == 1 ) :<br>            now += 1<br>        while ( now > k ) :<br>            freq [ a [ l ] ] -= 1<br>            if ( freq [ a [ l ] ] == 0 ) :<br>                now -= 1<br>            l += 1<br>        if ( i - l + 1 >= end - start + 1 ) :<br>            end = i<br>            start = l<br>    for i in range ( start , end + 1 ) :<br>        print ( a [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def longest ( a , n , k ) :<br>    freq = [ 0 ] * 7<br>    start , end , now , l = 0 , 0 , 0 , 0<br>    for i in range ( n ) :<br>        freq [ a [ i ] ] += 1<br>        if freq [ a [ i ] ] == 1 :<br>            now += 1<br>        while now > k :<br>            freq [ a [ l ] ] -= 1<br>            if freq [ a [ l ] ] == 0 :<br>                now -= 1<br>            l += 1<br>        if i - l + 1 >= end - start + 1 :<br>            end = i<br>            start = l<br>    for i in range ( start , end + 1 ) :<br>        print ( a [ i ] , end )<br></td>
  </tr><tr>
    <th>MAXIMUM_XOR_VALUE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxXOR ( mat , N ) :<br>    max_xor = 0<br>    for i in range ( N ) :<br>        r_xor = 0<br>        c_xor = 0<br>        for j in range ( N ) :<br>            r_xor = r_xor ^ mat [ i ] [ j ]<br>            c_xor = c_xor ^ mat [ j ] [ i ]<br>        if ( max_xor < max ( r_xor , c_xor ) ) :<br>            max_xor = max ( r_xor , c_xor )<br>    return max_xor<br></td>
    <td>translated code: <br><br> def maxXOR ( mat , N ) :<br>    r_xor , c_xor = 0 , 0<br>    max_xor = 0<br>    for i in range ( N ) :<br>        r_xor = 0<br>        c_xor = 0<br>        for j in range ( N ) :<br>            r_xor = r_xor ^ mat [ i ] [ j ]<br>            c_xor = c_xor ^ mat [ j ] [ i ]<br>        if max_xor < max ( r_xor , c_xor ) :<br>            max_xor = max ( r_xor , c_xor )<br>    return max_xor<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestNull ( S ) :<br>    arr = [ ]<br>    arr.append ( [ '@' , - 1 ] )<br>    maxlen = 0<br>    for i in range ( len ( S ) ) :<br>        arr.append ( [ S [ i ] , i ] )<br>        while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) :<br>            arr.pop ( )<br>            arr.pop ( )<br>            arr.pop ( )<br>        tmp = arr [ - 1 ]<br>        maxlen = max ( maxlen , i - tmp [ 1 ] )<br>    return maxlen<br></td>
    <td>translated code: <br><br> def longest_null ( str ) :<br>    arr = [ ( '@' , - 1 ) ]<br>    maxlen = 0<br>    for i in range ( len ( str ) ) :<br>        arr.append ( ( str [ i ] , i ) )<br>        while len ( arr ) >= 3 and arr [ - 3 ] [ 0 ] == '1' and arr [ - 2 ] [ 0 ] == '0' and arr [ - 1 ] [ 0 ] == '0' :<br>            arr.pop ( - 3 )<br>            arr.pop ( - 2 )<br>            arr.pop ( - 1 )<br>        tmp = arr [ - 1 ] [ 1 ]<br>        maxlen = max ( maxlen , i - tmp )<br>    return maxlen<br></td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def alternateSubarray ( arr , n ) :<br>    len = [ ]<br>    for i in range ( n + 1 ) :<br>        len.append ( 0 )<br>    len [ n - 1 ] = 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if ( arr [ i ] ^ arr [ i + 1 ] == True ) :<br>            len [ i ] = len [ i + 1 ] + 1<br>        else :<br>            len [ i ] = 1<br>    for i in range ( n ) :<br>        print ( len [ i ] , "" , end = "" )<br></td>
    <td>translated code: <br><br> def alternate_subarray ( arr , n ) :<br>    len = [ 1 ] * n<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if arr [ i ] ^ arr [ i + 1 ] == True :<br>            len [ i ] = len [ i + 1 ] + 1<br>        else :<br>            len [ i ] = 1<br>    for i in range ( n ) :<br>        print ( len [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>WILDCARD_CHARACTER_MATCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def match ( first , second ) :<br>    if len ( first ) == 0 and len ( second ) == 0 :<br>        return True<br>    if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 :<br>        return False<br>    if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and len ( second ) != 0 and first [ 0 ] == second [ 0 ] ) :<br>        return match ( first [ 1 : ] , second [ 1 : ] ) <br>    if len ( first ) != 0 and first [ 0 ] == '*' :<br>        return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] )<br>    return False<br></td>
    <td>translated code: <br><br> def match ( first , second ) :<br>    if len ( first ) == 0 and len ( second ) == 0 :<br>        return True<br>    if len ( first ) > 1 and first [ 0 ] == '*' and len ( second ) == 0 :<br>        return False<br>    if ( len ( first ) > 1 and first [ 0 ] == '?' ) or ( len ( first ) != 0 and second != '?' and first [ 0 ] == second [ 0 ] ) :<br>        return match ( first [ 1 : ] , second [ 1 : ] )<br>    if len ( first ) > 0 and first [ 0 ] == '*' :<br>        return match ( first [ 1 : ] , second ) or match ( first , second [ 1 : ] )<br>    return False<br></td>
  </tr><tr>
    <th>FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printFactorialNums ( n ) :<br>    fact = 1<br>    x = 2<br>    while fact <= n :<br>        print ( fact , end = " " )<br>        fact = fact * x<br>        x += 1<br></td>
    <td>translated code: <br><br> def print_factorial ( n ) :<br>    fact = 1<br>    x = 2<br>    while fact <= n :<br>        print ( fact , end = ' ' )<br>        fact = fact * x<br>        x += 1<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFriendsPairings ( n ) :<br>    a , b , c = 1 , 2 , 0 <br>    if ( n <= 2 ) :<br>        return n <br>    for i in range ( 3 , n + 1 ) :<br>        c = b + ( i - 1 ) * a <br>        a = b <br>        b = c <br>    return c <br></td>
    <td>translated code: <br><br> def countFriendsPairings ( n ) :<br>    a , b , c = 1 , 2 , 0<br>    if n <= 2 :<br>        return n<br>    for i in range ( 3 , n + 1 ) :<br>        c = b + ( i - 1 ) * a<br>        a , b , c = b , c , c<br>    return c<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxArea ( mat ) :<br>    hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ]<br>    for i in range ( 0 , C , 1 ) :<br>        hist [ 0 ] [ i ] = mat [ 0 ] [ i ]<br>        for j in range ( 1 , R , 1 ) :<br>            if ( ( mat [ j ] [ i ] == 0 ) ) :<br>                hist [ j ] [ i ] = 0<br>            else :<br>                hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1<br>    for i in range ( 0 , R , 1 ) :<br>        count = [ 0 for i in range ( R + 1 ) ]<br>        for j in range ( 0 , C , 1 ) :<br>            count [ hist [ i ] [ j ] ] += 1<br>        col_no = 0<br>        j = R<br>        while ( j >= 0 ) :<br>            if ( count [ j ] > 0 ) :<br>                for k in range ( 0 , count [ j ] , 1 ) :<br>                    hist [ i ] [ col_no ] = j<br>                    col_no += 1<br>            j -= 1<br>    max_area = 0<br>    for i in range ( 0 , R , 1 ) :<br>        for j in range ( 0 , C , 1 ) :<br>            curr_area = ( j + 1 ) * hist [ i ] [ j ]<br>            if ( curr_area > max_area ) :<br>                max_area = curr_area<br>    return max_area<br></td>
    <td>translated code: <br><br> def maxArea ( mat ) :<br>    hist = [ 0 ] * ( R + 1 )<br>    for i in range ( C ) :<br>        hist [ 0 ] [ i ] = mat [ 0 ] [ i ]<br>        for j in range ( 1 , R ) :<br>            hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 )<br>    for i in range ( R ) :<br>        count = [ 0 ] * ( R + 1 )<br>        for j in range ( C ) :<br>            count [ hist [ i ] [ j ] ] += 1<br>        col_no = 0<br>        for j in range ( R , - 1 , - 1 ) :<br>            if count [ j ] > 0 :<br>                for k in count [ j ] :<br>                    hist [ i ] [ col_no ] = j<br>                    col_no += 1<br>    curr_area , max_area = 0 , 0<br>    for i in range ( R ) :<br>        for j in range ( C ) :<br>            curr_area = ( j + 1 ) * hist [ i ] [ j ]<br>            if curr_area > max_area :<br>                max_area = curr_area<br>    return max_area<br></td>
  </tr><tr>
    <th>SUM_SEQUENCE_2_22_222</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumOfSeries ( n ) :<br>    return 0.0246 * ( math.pow ( 10 , n ) - 1 - ( 9 * n ) )<br></td>
    <td>translated code: <br><br> def sum_of_series ( n ) :<br>    return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) )<br></td>
  </tr><tr>
    <th>PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def firstFit ( blockSize , m , processSize , n ) :<br>    allocation = [ - 1 ] * n<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if blockSize [ j ] >= processSize [ i ] :<br>                allocation [ i ] = j<br>                blockSize [ j ] -= processSize [ i ]<br>                break<br>    print ( " Process No.Process Size      Block no." )<br>    for i in range ( n ) :<br>        print ( " " , i + 1 , "         " , processSize [ i ] , "         " , end = " " )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br></td>
    <td>translated code: <br><br> def first_fit ( block_size , m , process_size , n ) :<br>    allocation = [ - 1 ] * n<br>    for i in range ( n ) :<br>        allocation [ i ] = - 1<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if block_size [ j ] >= process_size [ i ] :<br>                allocation [ i ] = j<br>                block_size [ j ] -= process_size [ i ]<br>                break<br>    print ( "\nProcess No.\tProcess Size\tBlock no." )<br>    for i in range ( n ) :<br>        print ( " " * ( i + 1 ) + "\t\t" + str ( process_size [ i ] ) + "\t\t" )<br>        if allocation [ i ] != - 1 :<br>            print ( allocation [ i ] + 1 )<br>        else :<br>            print ( "Not Allocated" )<br>        print ( )<br></td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPower ( x , y ) :<br>    if ( x == 1 ) :<br>        return ( y == 1 )<br>    pow = 1<br>    while ( pow < y ) :<br>        pow = pow * x<br>    return ( pow == y )<br></td>
    <td>translated code: <br><br> def isPower ( x , y ) :<br>    if x == 1 :<br>        return ( y == 1 )<br>    pow = 1<br>    while pow < y :<br>        pow = pow * x<br>    return ( pow == y )<br></td>
  </tr><tr>
    <th>DIVIDE_LARGE_NUMBER_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longDivision ( number , divisor ) :<br>    ans = "" <br>    idx = 0 <br>    temp = ord ( number [ idx ] ) - ord ( '0' ) <br>    while ( temp < divisor ) :<br>        temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) <br>        idx += 1 <br>    idx += 1 <br>    while ( ( len ( number ) ) > idx ) :<br>        ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) ) <br>        temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) <br>        idx += 1 <br>    ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) ) <br>    if ( len ( ans ) == 0 ) :<br>        return "0" <br>    return ans <br></td>
    <td>translated code: <br><br> def longDivision ( number , divisor ) :<br>    ans = ""<br>    idx = 0<br>    num = number.split ( )<br>    temp = num [ idx ] - '0'<br>    while temp < divisor :<br>        temp = temp * 10 + ( num [ ++ idx ] - '0' )<br>    idx += 1<br>    while len ( num ) > idx :<br>        ans += ( temp / divisor )<br>        temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0'<br>    if len ( ans ) == 0 :<br>        return "0"<br>    return ans<br></td>
  </tr><tr>
    <th>FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMax ( arr ) :<br>    row = 0<br>    j = N - 1<br>    for i in range ( 0 , N ) :<br>        while ( arr [ i ] [ j ] == 1 and j >= 0 ) :<br>            row = i<br>            j -= 1<br>    print ( "Row number = " , row + 1 , ", MaxCount = " , N - 1 - j )<br></td>
    <td>translated code: <br><br> def findMax ( arr ) :<br>    row , i , j = 0 , N - 1 , N - 1<br>    for i , j in enumerate ( arr ) :<br>        while j >= 0 and arr [ i ] [ j ] == 1 :<br>            row = i<br>            j -= 1<br>    print ( "Row number = " + str ( row + 1 ) )<br>    print ( ", MaxCount = " + str ( N - 1 - j ) )<br></td>
  </tr><tr>
    <th>MINIMUM_ROTATIONS_REQUIRED_GET_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRotations ( str ) :<br>    tmp = str + str<br>    n = len ( str )<br>    for i in range ( 1 , n + 1 ) :<br>        substring = tmp [ i : n ]<br>        if ( str == substring ) :<br>            return i<br>    return n<br></td>
    <td>translated code: <br><br> def find_rotations ( str ) :<br>    tmp = str + str<br>    n = len ( str )<br>    for i in range ( 1 , n + 1 ) :<br>        substring = tmp [ i : i + len ( str ) ]<br>        if str == substring :<br>            return i<br>    return n<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfPaths ( m , n ) :<br>    if ( m == 1 or n == 1 ) :<br>        return 1<br>    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )<br></td>
    <td>translated code: <br><br> def number_of_paths ( m , n ) :<br>    if m == 1 or n == 1 :<br>        return 1<br>    return number_of_paths ( m - 1 , n ) + number_of_paths ( m , n - 1 )<br></td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findNth ( n ) :<br>    count = 0 <br>    curr = 19 <br>    while ( True ) :<br>        sum = 0 <br>        x = curr <br>        while ( x > 0 ) :<br>            sum = sum + x % 10 <br>            x = int ( x / 10 ) <br>        if ( sum == 10 ) :<br>            count += 1 <br>        if ( count == n ) :<br>            return curr <br>        curr += 9 <br>    return - 1 <br></td>
    <td>translated code: <br><br> def find_nth ( n ) :<br>    count = 0<br>    for curr in range ( 19 , 0 , 9 ) :<br>        sum = 0<br>        for x in range ( curr , 0 , 10 ) :<br>            sum = sum + x % 10<br>        if sum == 10 :<br>            count += 1<br>        if count == n :<br>            return curr<br></td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumAtKthLevel ( tree , k , i , level ) :<br>    if ( tree [ i [ 0 ] ] == '(' ) :<br>        i [ 0 ] += 1<br>        if ( tree [ i [ 0 ] ] == ')' ) :<br>            return 0<br>        sum = 0<br>        if ( level == k ) :<br>            sum = int ( tree [ i [ 0 ] ] )<br>        i [ 0 ] += 1<br>        leftsum = sumAtKthLevel ( tree , k , i , level + 1 )<br>        i [ 0 ] += 1<br>        rightsum = sumAtKthLevel ( tree , k , i , level + 1 )<br>        i [ 0 ] += 1<br>        return sum + leftsum + rightsum<br></td>
    <td>translated code: <br><br> def sum_at_kth_level ( tree , k , level ) :<br>    if tree [ i ] == '(' :<br>        if tree [ i ] == ')' :<br>            return 0<br>        sum = 0<br>        if level == k :<br>            sum = tree [ i ] - '0'<br>        i += 1<br>        leftsum = sum_at_kth_level ( tree , k , level + 1 )<br>        i += 1<br>        rightsum = sum_at_kth_level ( tree , k , level + 1 )<br>        i += 1<br>        return sum + leftsum + rightsum<br>    return int ( tree [ i ] )<br></td>
  </tr><tr>
    <th>COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( n ) :<br>    DP = [ 0 for i in range ( 0 , n + 1 ) ]<br>    DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1<br>    DP [ 3 ] = 2<br>    for i in range ( 4 , n + 1 ) :<br>        DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ]<br>    return DP [ n ]<br></td>
    <td>translated code: <br><br> def countWays ( n ) :<br>    DP = [ 0 ] * ( n + 1 )<br>    for i in range ( 4 , n + 1 ) :<br>        DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ]<br>    return DP [ n ]<br></td>
  </tr><tr>
    <th>MAXIMUM_EQULIBRIUM_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxSum ( arr , n ) :<br>    res = - sys.maxsize - 1<br>    for i in range ( n ) :<br>        prefix_sum = arr [ i ]<br>        for j in range ( i ) :<br>            prefix_sum += arr [ j ]<br>        suffix_sum = arr [ i ]<br>        j = n - 1<br>        while ( j > i ) :<br>            suffix_sum += arr [ j ]<br>            j -= 1<br>        if ( prefix_sum == suffix_sum ) :<br>            res = max ( res , prefix_sum )<br>    return res<br></td>
    <td>translated code: <br><br> def find_max_sum ( arr , n ) :<br>    res = int ( '' )<br>    for i in range ( n ) :<br>        prefix_sum = arr [ i ]<br>        for j in range ( i ) :<br>            prefix_sum += arr [ j ]<br>        suffix_sum = arr [ i ]<br>        for j in range ( n - 1 , i , - 1 ) :<br>            suffix_sum += arr [ j ]<br>        if prefix_sum == suffix_sum :<br>            res = max ( res , prefix_sum )<br>    return res<br></td>
  </tr><tr>
    <th>STEINS_ALGORITHM_FOR_FINDING_GCD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gcd ( a , b ) :<br>    if ( a == b ) :<br>        return a<br>    if ( a == 0 ) :<br>        return b<br>    if ( b == 0 ) :<br>        return a<br>    if ( ( ~ a & 1 ) == 1 ) :<br>        if ( ( b & 1 ) == 1 ) :<br>            return gcd ( a >> 1 , b )<br>        else :<br>            return ( gcd ( a >> 1 , b >> 1 ) << 1 )<br>    if ( ( ~ b & 1 ) == 1 ) :<br>        return gcd ( a , b >> 1 )<br>    if ( a > b ) :<br>        return gcd ( ( a - b ) >> 1 , b )<br>    return gcd ( ( b - a ) >> 1 , a )<br></td>
    <td>translated code: <br><br> def gcd ( a , b ) :<br>    if a == b : return a<br>    if a == 0 : return b<br>    if b == 0 : return a<br>    if ( ~ a & 1 ) == 1 :<br>        if ( b & 1 ) == 1 : return gcd ( a >> 1 , b )<br>        else : return gcd ( a >> 1 , b >> 1 ) << 1<br>    if ( ~ b & 1 ) == 1 : return gcd ( a , b >> 1 )<br>    if a > b : return gcd ( ( a - b ) >> 1 , b )<br>    return gcd ( ( b - a ) >> 1 , a )<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findVolume ( l , b , h ) :<br>    return ( ( l * b * h ) / 2 )<br></td>
    <td>translated code: <br><br> def find_volume ( l , b , h ) :<br>    volume = ( l * b * h ) / 2<br>    return volume<br></td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isRectangle ( m ) :<br>    rows = len ( m )<br>    if ( rows == 0 ) :<br>        return False<br>    columns = len ( m [ 0 ] )<br>    for y1 in range ( rows ) :<br>        for x1 in range ( columns ) :<br>            if ( m [ y1 ] [ x1 ] == 1 ) :<br>                for y2 in range ( y1 + 1 , rows ) :<br>                    for x2 in range ( x1 + 1 , columns ) :<br>                        if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) :<br>                            return True<br>    return False<br></td>
    <td>translated code: <br><br> def isRectangle ( m ) :<br>    rows = m.shape [ 0 ]<br>    if rows == 0 : return False<br>    columns = m.shape [ 1 ]<br>    for y1 in range ( rows ) :<br>        for x1 in range ( columns ) :<br>            if m [ y1 , x1 ] == 1 :<br>                for y2 in range ( y1 + 1 , rows ) :<br>                    for x2 in range ( x1 + 1 , columns ) :<br>                        if m [ y1 , x2 ] == 1 and m [ y2 , x1 ] == 1 and m [ y2 , x2 ] == 1 :<br>                            return True<br>    return False<br></td>
  </tr><tr>
    <th>CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPossible ( str , n ) :<br>    l = len ( str )<br>    if ( l >= n ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def is_possible ( str , n ) :<br>    len = len ( str )<br>    if len >= n :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>CHECK_STAR_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkStar ( mat ) :<br>    global size<br>    vertexD1 = 0<br>    vertexDn_1 = 0<br>    if ( size == 1 ) :<br>        return ( mat [ 0 ] [ 0 ] == 0 )<br>    if ( size == 2 ) :<br>        return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 )<br>    for i in range ( 0 , size ) :<br>        degreeI = 0<br>        for j in range ( 0 , size ) :<br>            if ( mat [ i ] [ j ] ) :<br>                degreeI = degreeI + 1<br>        if ( degreeI == 1 ) :<br>            vertexD1 = vertexD1 + 1<br>        elif ( degreeI == size - 1 ) :<br>            vertexDn_1 = vertexDn_1 + 1<br>    return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 )<br></td>
    <td>translated code: <br><br> def checkStar ( mat ) :<br>    vertexD1 , vertexDn_1 = 0 , 0<br>    if size == 1 :<br>        return ( mat [ 0 ] [ 0 ] , mat [ 0 ] [ 1 ] , mat [ 1 ] [ 0 ] , mat [ 1 ] [ 1 ] , mat [ 0 ] [ 2 ] , mat [ 1 ] [ 2 ] , mat [ 0 ] [ 3 ] , mat [ 1 ] [ 3 ] , mat [ 0 ] [ 4 ] , mat [ 1 ] [ 4 ] , mat [ 1 ] [ 4 ] , mat [ 0 ] [ 5 ] , mat [ 1 ] [ 5 ] , mat [ 0 ] [ 6 ] , mat [ 1 ] [ 6 ] , mat [ 0 ] [ 7 ] , mat [ 1 ] [ 7 ] , mat [ 0 ] [ 8 ] , mat [ 1 ] [ 8 ] , mat [ 0 ] [ 9 ] , mat [ 1 ] [ 9 ] , mat [ 0 ] [ 10 ] , mat [ 1 ] [ 10 ] , mat [ 0 ] [ 11 ] , mat [ 1 ] [ 11 ] , mat [ 0 ] [ 12 ] , mat [ 1 ] [ 12 ] , mat [ 0 ] [ 13 ] , mat [ 1 ] [ 13 ] , mat [ 0 ] [ 14 ] , mat [ 1 ] [ 14 ] , mat [ 0 ] [ 15 ] , mat [ 1 ] [ 15 ] , mat [ 0 ] [ 16 ] , mat [ 1 ] [ 16 ] , mat [ 0 ] [ 17 ] , mat [ 1 ] [ 17 ] , mat [ 0 ] [ 18 ] , mat [ 1 ] [ 18 ] , mat [ 0 ] [ 19 ] , mat [ 1 ] [ 19 ] , mat [ 0 ] [ 20 ] , mat [ 1 ] [ 20 ] , mat [ 0 ] [ 21 ] , mat [ 1 ] [ 21 ] , mat [ 0 ] [ 22 ] , mat [ 1 ] [ 22 ] , mat [ 0 ] [ 23 ] , mat [ 1 ] [ 23 ] , mat [ 0 ] [ 24 ] , mat [ 1 ] [ 24 ] , mat [ 0 ] [ 25 ] , mat [ 1 ] [ 25 ] , mat [ 0 ] [ 26 ] , mat [ 1 ] [ 26 ] , mat [ 0 ] [ 27 ] , mat [ 1 ] [ 27 ] , mat [ 0 ] [ 28 ] , mat [ 1 ] [ 28 ] , mat [ 0 ] [ 29 ] ,</td>
  </tr><tr>
    <th>ROOTS_OF_UNITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRoots ( n ) :<br>    theta = math.pi * 2 / n<br>    for k in range ( 0 , n ) :<br>        real = math.cos ( k * theta )<br>        img = math.sin ( k * theta )<br>        print ( real , end = " " )<br>        if ( img >= 0 ) :<br>            print ( " + i " , end = " " )<br>        else :<br>            print ( " - i " , end = " " )<br>        print ( abs ( img ) )<br></td>
    <td>translated code: <br><br> def print_roots ( n ) :<br>    theta = 3.14 * 2 / n<br>    for k in range ( n ) :<br>        real = cos ( k * theta )<br>        img = sin ( k * theta )<br>        print ( real )<br>        if img >= 0 :<br>            print ( " + i " )<br>        else :<br>            print ( " - i " )<br>        print ( abs ( img ) )<br></td>
  </tr><tr>
    <th>FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLargestd ( S , n ) :<br>    found = False<br>    S.sort ( )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        for j in range ( 0 , n ) :<br>            if ( i == j ) :<br>                continue<br>            for k in range ( j + 1 , n ) :<br>                if ( i == k ) :<br>                    continue<br>                for l in range ( k + 1 , n ) :<br>                    if ( i == l ) :<br>                        continue<br>                    if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) :<br>                        found = True<br>                        return S [ i ]<br>    if ( found == False ) :<br>        return - 1<br></td>
    <td>translated code: <br><br> def find_largestd ( S , n ) :<br>    found = False<br>    S.sort ( )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        for j in range ( n ) :<br>            if i == j :<br>                continue<br>            for k in range ( j + 1 , n ) :<br>                if i == k :<br>                    continue<br>                for l in range ( k + 1 , n ) :<br>                    if i == l :<br>                        continue<br>                    if S [ i ] == S [ j ] + S [ k ] + S [ l ] :<br>                        found = True<br>                        return S [ i ]<br>    if found == False :<br>        return int ( S [ 0 ] )<br></td>
  </tr><tr>
    <th>GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count9s ( number ) :<br>    n = len ( number )<br>    d = [ 0 for i in range ( 9 ) ]<br>    d [ 0 ] = 1<br>    result = 0<br>    mod_sum = 0<br>    continuous_zero = 0<br>    for i in range ( n ) :<br>        if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) :<br>            continuous_zero += 1<br>        else :<br>            continuous_zero = 0<br>        mod_sum += ord ( number [ i ] ) - ord ( '0' )<br>        mod_sum %= 9<br>        result += d [ mod_sum ]<br>        d [ mod_sum ] += 1<br>        result -= continuous_zero<br>    return result<br></td>
    <td>translated code: <br><br> def count9s ( number ) :<br>    n = len ( number )<br>    d = [ 1 ] * 9<br>    result = 0<br>    mod_sum , continuous_zero = 0 , 0<br>    for i in range ( n ) :<br>        if ( number [ i ] - '0' ) == 0 :<br>            continuous_zero += 1<br>        else :<br>            continuous_zero = 0<br>        mod_sum += ( number [ i ] - '0' )<br>        mod_sum %= 9<br>        result += d [ mod_sum ]<br>        d [ mod_sum ] += 1<br>        result -= continuous_zero<br>    return result<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LexicographicalMaxString ( str ) :<br>    mx = ""<br>    for i in range ( len ( str ) ) :<br>        mx = max ( mx , str [ i : ] )<br>    return mx<br></td>
    <td>translated code: <br><br> def LexicographicalMaxString ( * args ) :<br>    mx = ""<br>    for arg in args :<br>        if mx <= arg : mx = arg<br>    return mx<br></td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def areDisjoint ( set1 , set2 , m , n ) :<br>    set1.sort ( )<br>    set2.sort ( )<br>    i = 0 ; j = 0<br>    while ( i < m and j < n ) :<br>        if ( set1 [ i ] < set2 [ j ] ) :<br>            i += 1<br>        elif ( set2 [ j ] < set1 [ i ] ) :<br>            j += 1<br>        else :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def aredisjoint ( set1 , set2 ) :<br>    i , j = 0 , 0<br>    set1.sort ( )<br>    set2.sort ( )<br>    while i < len ( set1 ) and j < len ( set2 ) :<br>        if set1 [ i ] < set2 [ j ] :<br>            i += 1<br>        elif set1 [ i ] > set2 [ j ] :<br>            j += 1<br>        else :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>EQUILIBRIUM_INDEX_OF_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def equilibrium ( arr ) :<br>    total_sum = sum ( arr )<br>    leftsum = 0<br>    for i , num in enumerate ( arr ) :<br>        total_sum -= num<br>        if leftsum == total_sum :<br>            return i<br>        leftsum += num<br>    return - 1<br></td>
    <td>translated code: <br><br> def equilibrium ( arr , n ) :<br>    sum = 0<br>    leftsum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    for i in range ( n ) :<br>        sum -= arr [ i ]<br>        if leftsum == sum :<br>            return i<br>        leftsum += arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>AREA_CIRCUMSCRIBED_CIRCLE_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def areacircumscribed ( a ) :<br>    return ( a * a * ( PI / 2 ) )<br></td>
    <td>translated code: <br><br> def areacircumscribed ( a ) :<br>    PI = 3.14159265f<br>    return ( a * a * ( PI / 2 ) )<br></td>
  </tr><tr>
    <th>LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestRepeatedSubstring ( str ) :<br>    n = len ( str )<br>    LCSRe = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]<br>    res = ""<br>    res_length = 0<br>    index = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i + 1 , n + 1 ) :<br>            if ( str [ i - 1 ] == str [ j - 1 ] and LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) :<br>                LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1<br>                if ( LCSRe [ i ] [ j ] > res_length ) :<br>                    res_length = LCSRe [ i ] [ j ]<br>                    index = max ( i , index )<br>            else :<br>                LCSRe [ i ] [ j ] = 0<br>    if ( res_length > 0 ) :<br>        for i in range ( index - res_length + 1 , index + 1 ) :<br>            res = res + str [ i - 1 ]<br>    return res<br></td>
    <td>translated code: <br><br> def longestRepeatedSubstring ( str ) :<br>    n = len ( str )<br>    LCSRe = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n ]</td>
  </tr><tr>
    <th>HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def mulmod ( a , b , mod ) :<br>    res = 0 <br>    a = a % mod <br>    while ( b > 0 ) :<br>        if ( b % 2 == 1 ) :<br>            res = ( res + a ) % mod <br>        a = ( a * 2 ) % mod <br>        b //= 2 <br>    return res % mod <br></td>
    <td>translated code: <br><br> def mulmod ( a , b , mod ) :<br>    res = 0<br>    a = a % mod<br>    while b :<br>        if b % 2 == 1 :<br>            res = ( res + a ) % mod<br>        a = ( a * 2 ) % mod<br>        b //= 2<br>    return res % mod<br></td>
  </tr><tr>
    <th>PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isProduct ( arr , n , x ) :<br>    if n < 2 :<br>        return False<br>    s = set ( )<br>    for i in range ( 0 , n ) :<br>        if arr [ i ] == 0 :<br>            if x == 0 :<br>                return True<br>            else :<br>                continue<br>        if x % arr [ i ] == 0 :<br>            if x // arr [ i ] in s :<br>                return True<br>            s.add ( arr [ i ] )<br>    return False<br></td>
    <td>translated code: <br><br> def isProduct ( arr , n , x ) :<br>    hset = set ( )<br>    if n < 2 :<br>        return False<br>    for i in range ( n ) :<br>        if arr [ i ] == 0 :<br>            if x == 0 :<br>                return True<br>            else :<br>                continue<br>        if x % arr [ i ] == 0 :<br>            if hset.intersection ( x / arr [ i ] ) :<br>                return True<br>            hset.add ( arr [ i ] )<br>    return False<br></td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def kthgroupsum ( k ) :<br>    cur = int ( ( k * ( k - 1 ) ) + 1 )<br>    sum = 0<br>    while k :<br>        sum += cur<br>        cur += 2<br>        k = k - 1<br>    return sum<br></td>
    <td>translated code: <br><br> def kthgroupsum ( k ) :<br>    cur = ( k * ( k - 1 ) ) + 1<br>    sum = 0<br>    while k :<br>        sum += cur<br>        cur += 2<br>    return sum<br></td>
  </tr><tr>
    <th>FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findElements ( arr , n ) :<br>    arr.sort ( )<br>    for i in range ( 0 , n - 2 ) :<br>        print ( arr [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def find_elements ( arr , n ) :<br>    arr.sort ( )<br>    for i in range ( n - 2 ) :<br>        print ( arr [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minStepToDeleteString ( str ) :<br>    N = len ( str )<br>    dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ]<br>    for l in range ( 1 , N + 1 ) :<br>        i = 0<br>        j = l - 1<br>        while j < N :<br>            if ( l == 1 ) :<br>                dp [ i ] [ j ] = 1<br>            else :<br>                dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ]<br>                if ( str [ i ] == str [ i + 1 ] ) :<br>                    dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] )<br>                for K in range ( i + 2 , j + 1 ) :<br>                    if ( str [ i ] == str [ K ] ) :<br>                        dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] )<br>            i += 1<br>            j += 1<br>    return dp [ 0 ] [ N - 1 ]<br></td>
    <td>translated code: <br><br> def min_step_to_delete_string ( str ) :<br>    N = len ( str )<br>    dp = [ [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0 ] * N + [ 0</td>
  </tr><tr>
    <th>CALCULATE_AREA_TETRAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def vol_tetra ( side ) :<br>    volume = ( side ** 3 / ( 6 * math.sqrt ( 2 ) ) )<br>    return round ( volume , 2 )<br></td>
    <td>translated code: <br><br> def vol_tetra ( side ) :<br>    volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) )<br>    return volume<br></td>
  </tr><tr>
    <th>SIEVE_OF_ATKIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def SieveOfAtkin ( limit ) :<br>    if ( limit > 2 ) :<br>        print ( 2 , end = " " )<br>    if ( limit > 3 ) :<br>        print ( 3 , end = " " )<br>    sieve = [ False ] * limit<br>    for i in range ( 0 , limit ) :<br>        sieve [ i ] = False<br>    x = 1<br>    while ( x * x < limit ) :<br>        y = 1<br>        while ( y * y < limit ) :<br>            n = ( 4 * x * x ) + ( y * y )<br>            if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) :<br>                sieve [ n ] ^= True<br>            n = ( 3 * x * x ) + ( y * y )<br>            if ( n <= limit and n % 12 == 7 ) :<br>                sieve [ n ] ^= True<br>            n = ( 3 * x * x ) - ( y * y )<br>            if ( x > y and n <= limit and n % 12 == 11 ) :<br>                sieve [ n ] ^= True<br>            y += 1<br>        x += 1<br>    r = 5<br>    while ( r * r < limit ) :<br>        if ( sieve [ r ] ) :<br>            for i in range ( r * r , limit , r * r ) :<br>                sieve [ i ] = False<br>    for a in range ( 5 , limit ) :<br>        if ( sieve [ a ] ) :<br>            print ( a , end = " " )<br></td>
    <td>translated code: <br><br> def SieveOfAtkin ( limit ) :<br>    if limit > 2 :<br>        print ( 2 , end = ' ' )<br>    if limit > 3 :<br>        print ( 3 , end = ' ' )<br>    sieve = [ False for i in range ( limit ) ]<br>    for x in range ( 1 , limit * 2 ) :<br>        for y in range ( 1 , limit * 2 ) :<br>            n = ( 4 * x * x ) + ( y * y )<br>            if n <= limit and ( n % 12 == 1 or n % 12 == 5 ) :<br>                sieve [ n ] ^= True<br>            n = ( 3 * x * x ) + ( y * y )<br>            if n <= limit and n % 12 == 7 :<br>                sieve [ n ] ^= True<br>            n = ( 3 * x * x ) - ( y * y )<br>            if x > y and n <= limit and n % 12 == 11 :<br>                sieve [ n ] ^= True<br>    for r in range ( 5 , limit * 2 ) :<br>        if sieve [ r ] :<br>            for i in range ( r * r , limit , r * r ) :<br>                sieve [ i ] = False<br>    for a in range ( 5 , limit ) :<br>        if sieve [ a ] :<br>            print ( a , end = ' ' )<br>    return 0<br></td>
  </tr><tr>
    <th>LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lenghtOfLongestAP ( set , n ) :<br>    if ( n <= 2 ) :<br>        return n<br>    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]<br>    llap = 2<br>    for i in range ( n ) :<br>        L [ i ] [ n - 1 ] = 2<br>    for j in range ( n - 2 , 0 , - 1 ) :<br>        i = j - 1<br>        k = j + 1<br>        while ( i >= 0 and k <= n - 1 ) :<br>            if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :<br>                k += 1<br>            elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :<br>                L [ i ] [ j ] = 2<br>                i -= 1<br>            else :<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1<br>                llap = max ( llap , L [ i ] [ j ] )<br>                i -= 1<br>                k += 1<br>                while ( i >= 0 ) :<br>                    L [ i ] [ j ] = 2<br>                    i -= 1<br>    return llap<br></td>
    <td>translated code: <br><br> def lenghtOfLongestAP ( set , n ) :<br>    if n <= 2 :<br>        return n<br>    L = [ [ ] for i in range ( n ) ]<br>    llap = 2<br>    for i in range ( n ) :<br>        L [ i ] [ n - 1 ] = 2<br>    for j in range ( n - 2 , - 1 , - 1 ) :<br>        i , k = j - 1 , j + 1<br>        while i >= 0 and k <= n - 1 :<br>            if set [ i ] + set [ k ] < 2 * set [ j ] :<br>                k += 1<br>            elif set [ i ] + set [ k ] > 2 * set [ j ] :<br>                L [ i ] [ j ] = 2<br>                i -= 1<br>            else :<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1<br>                llap = max ( llap , L [ i ] [ j ] )<br>                i -= 1<br>                k += 1<br>        while i >= 0 :<br>            L [ i ] [ j ] = 2<br>            i -= 1<br>    return llap<br></td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countGroups ( position , previous_sum , length , num ) :<br>    if ( position == length ) :<br>        return 1<br>    if ( dp [ position ] [ previous_sum ] != - 1 ) :<br>        return dp [ position ] [ previous_sum ]<br>    dp [ position ] [ previous_sum ] = 0<br>    res = 0<br>    sum = 0<br>    for i in range ( position , length ) :<br>        sum += ( ord ( num [ i ] ) - ord ( '0' ) )<br>        if ( sum >= previous_sum ) :<br>            res += countGroups ( i + 1 , sum , length , num )<br>    dp [ position ] [ previous_sum ] = res<br>    return res<br></td>
    <td>translated code: <br><br> def count_groups ( position , previous_sum , length , num ) :<br>    if position == length :<br>        return 1<br>    if dp [ position ] [ previous_sum ] != - 1 :<br>        return dp [ position ] [ previous_sum ]<br>    dp [ position ] [ previous_sum ] = 0<br>    res = 0<br>    sum = 0<br>    for i in range ( position , length ) :<br>        sum += ( num [ i ] - '0' )<br>        if sum >= previous_sum :<br>            res += count_groups ( i + 1 , sum , length , num )<br>    dp [ position ] [ previous_sum ] = res<br>    return res<br></td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestCommonSum ( arr1 , arr2 , n ) :<br>    maxLen = 0<br>    presum1 = presum2 = 0<br>    diff = { }<br>    for i in range ( n ) :<br>        presum1 += arr1 [ i ]<br>        presum2 += arr2 [ i ]<br>        curr_diff = presum1 - presum2<br>        if curr_diff == 0 :<br>            maxLen = i + 1<br>        elif curr_diff not in diff :<br>            diff [ curr_diff ] = i<br>        else :<br>            length = i - diff [ curr_diff ]<br>            maxLen = max ( maxLen , length )<br>    return maxLen<br></td>
    <td>translated code: <br><br> def longest_common_sum ( n ) :<br>    max_len = 0<br>    pre_sum1 , pre_sum2 = 0 , 0<br>    diff = [ - 1 ] * ( 2 * n + 1 )<br>    for i in range ( len ( diff ) ) :<br>        pre_sum1 += arr1 [ i ]<br>        pre_sum2 += arr2 [ i ]<br>        curr_diff = pre_sum1 - pre_sum2<br>        diff_index = n + curr_diff<br>        if curr_diff == 0 :<br>            max_len = i + 1<br>        elif diff [ diff_index ] == - 1 :<br>            diff [ diff_index ] = i<br>        else :<br>            len = i - diff [ diff_index ]<br>            if len > max_len :<br>                max_len = len<br>    return max_len<br></td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printFibonacciNumbers ( n ) :<br>    f1 = 0<br>    f2 = 1<br>    if ( n < 1 ) :<br>        return<br>    for x in range ( 0 , n ) :<br>        print ( f2 , end = " " )<br>        next = f1 + f2<br>        f1 = f2<br>        f2 = next<br></td>
    <td>translated code: <br><br> def print_fibonacci_numbers ( n ) :<br>    f1 , f2 , i = 0 , 1 , i<br>    if n < 1 :<br>        return<br>    for i in range ( 1 , n + 1 ) :<br>        print ( f2 , end = ' ' )<br>        next = f1 + f2<br>        f1 , f2 = f2 , next<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubArraySum ( a , size ) :<br>    max_so_far = - maxsize - 1<br>    max_ending_here = 0<br>    start = 0<br>    end = 0<br>    s = 0<br>    for i in range ( 0 , size ) :<br>        max_ending_here += a [ i ]<br>        if max_so_far < max_ending_here :<br>            max_so_far = max_ending_here<br>            start = s<br>            end = i<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>            s = i + 1<br>    print ( "Maximum contiguous sum is %d" % ( max_so_far ) )<br>    print ( "Starting Index %d" % ( start ) )<br>    print ( "Ending Index %d" % ( end ) )<br></td>
    <td>translated code: <br><br> def max_subarray_sum ( a , size ) :<br>    max_so_far , max_ending_here , start , end , s = int ( a [ : size ] ) , 0 , 0 , 0 , 0<br>    for i in range ( size ) :<br>        max_ending_here += a [ i ]<br>        if max_so_far < max_ending_here :<br>            max_so_far = max_ending_here<br>            start = s<br>            end = i<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>            s = i + 1<br>    print ( "Maximum contiguous sum is %d" % max_so_far )<br>    print ( "Starting index %d" % start )<br>    print ( "Ending index %d" % end )<br></td>
  </tr><tr>
    <th>FIND_EQUAL_POINT_STRING_BRACKETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findIndex ( str ) :<br>    l = len ( str )<br>    open = [ None ] * ( l + 1 )<br>    close = [ None ] * ( l + 1 )<br>    index = - 1<br>    open [ 0 ] = 0<br>    close [ l ] = 0<br>    if ( str [ 0 ] == '(' ) :<br>        open [ 1 ] = 1<br>    if ( str [ l - 1 ] == ')' ) :<br>        close [ l - 1 ] = 1<br>    for i in range ( 1 , l ) :<br>        if ( str [ i ] == '(' ) :<br>            open [ i + 1 ] = open [ i ] + 1<br>        else :<br>            open [ i + 1 ] = open [ i ]<br>    for i in range ( l - 2 , - 1 , - 1 ) :<br>        if ( str [ i ] == ')' ) :<br>            close [ i ] = close [ i + 1 ] + 1<br>        else :<br>            close [ i ] = close [ i + 1 ]<br>    if ( open [ l ] == 0 ) :<br>        return len<br>    if ( close [ 0 ] == 0 ) :<br>        return 0<br>    for i in range ( l + 1 ) :<br>        if ( open [ i ] == close [ i ] ) :<br>            index = i<br>    return index<br></td>
    <td>translated code: <br><br> def findIndex ( str ) :<br>    len ( str )<br>    open = [ ]<br>    close = [ ]<br>    index = - 1<br>    open.append ( 0 )<br>    close.append ( 0 )<br>    if str [ 0 ] == '(' :<br>        open.append ( 1 )<br>    if str [ len - 1 ] == ')' :<br>        close.append ( 1 )<br>    for i in range ( 1 , len ( str ) ) :<br>        if str [ i ] == '(' :<br>            open.append ( open [ i ] + 1 )<br>        else :<br>            open.append ( open [ i ] )<br>    for i in range ( len - 2 , - 1 , - 1 ) :<br>        if str [ i ] == ')' :<br>            close.append ( close [ i + 1 ] + 1 )<br>        else :<br>            close.append ( close [ i + 1 ] )<br>    if open [ len ] == 0 :<br>        return len<br>    if close [ 0 ] == 0 :<br>        return 0<br>    for i in range ( 0 , len ( open ) ) :<br>        if open [ i ] == close [ i ] :<br>            index = i<br>    return index<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countP ( n , k ) :<br>    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        dp [ i ] [ 0 ] = 0<br>    for i in range ( k + 1 ) :<br>        dp [ 0 ] [ k ] = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , k + 1 ) :<br>            if ( j == 1 or i == j ) :<br>                dp [ i ] [ j ] = 1<br>            else :<br>                dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] )<br>    return dp [ n ] [ k ]<br></td>
    <td>translated code: <br><br> def count_p ( n , k ) :<br>    dp = [ [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n + [ k + 1 ] * k + [ 0 ] * n +</td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lis ( arr ) :<br>    global maximum<br>    n = len ( arr )<br>    maximum = 1<br>    _lis ( arr , n )<br>    return maximum<br></td>
    <td>translated code: <br><br> def lis ( arr , n ) :<br>    global max_ref<br>    _lis ( arr , n )<br>    return max_ref<br></td>
  </tr><tr>
    <th>FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRepeatFirstN2 ( s ) :<br>    p = - 1<br>    for i in range ( len ( s ) ) :<br>        for j in range ( i + 1 , len ( s ) ) :<br>            if ( s [ i ] == s [ j ] ) :<br>                p = i<br>                break<br>        if ( p != - 1 ) :<br>            break<br>    return p<br></td>
    <td>translated code: <br><br> def findRepeatFirstN2 ( s ) :<br>    p , i , j = - 1 , 0 , 0<br>    for i in range ( len ( s ) ) :<br>        for j in range ( i + 1 , len ( s ) ) :<br>            if s [ i ] == s [ j ] :<br>                p = i<br>                break<br>        if p != - 1 :<br>            break<br>    return p<br></td>
  </tr><tr>
    <th>K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def ksmallest ( arr , n , k ) :<br>    b = [ 0 ] * MAX <br>    for i in range ( n ) :<br>        b [ arr [ i ] ] = 1 <br>    for j in range ( 1 , MAX ) :<br>        if ( b [ j ] != 1 ) :<br>            k -= 1 <br>        if ( k is not 1 ) :<br>            return j <br></td>
    <td>translated code: <br><br> def ksmallest ( arr , n , k ) :<br>    b = [ 1 for i in range ( n ) ]<br>    for i in range ( MAX ) :<br>        b [ arr [ i ] ] = 1<br>    for j in range ( 1 , MAX ) :<br>        if b [ j ] != 1 :<br>            k -= 1<br>        if k != 1 :<br>            return j<br>    return int ( '-1' )<br></td>
  </tr><tr>
    <th>CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pairWiseConsecutive ( s ) :<br>    aux = [ ]<br>    while ( len ( s ) != 0 ) :<br>        aux.append ( s [ - 1 ] )<br>        s.pop ( )<br>    result = True<br>    while ( len ( aux ) > 1 ) :<br>        x = aux [ - 1 ]<br>        aux.pop ( )<br>        y = aux [ - 1 ]<br>        aux.pop ( )<br>        if ( abs ( x - y ) != 1 ) :<br>            result = False<br>        s.append ( x )<br>        s.append ( y )<br>    if ( len ( aux ) == 1 ) :<br>        s.append ( aux [ - 1 ] )<br>    return result<br></td>
    <td>translated code: <br><br> def pairWiseConsecutive ( s ) :<br>    aux = [ ]<br>    while not s.empty ( ) :<br>        aux.append ( s.pop ( ) )<br>        s.pop ( )<br>    result = True<br>    while aux.size ( ) > 1 :<br>        x = aux.pop ( )<br>        aux.pop ( )<br>        y = aux.pop ( )<br>        aux.pop ( )<br>        if abs ( x - y ) != 1 :<br>            result = False<br>        s.append ( x )<br>        s.append ( y )<br>    if len ( aux ) == 1 :<br>        s.append ( aux.pop ( ) )<br>    return result<br></td>
  </tr><tr>
    <th>BINARY_SEARCH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binarySearch ( arr , l , r , x ) :<br>    while l <= r :<br>        mid = l + ( r - l ) // 2 <br>        if arr [ mid ] == x :<br>            return mid<br>        elif arr [ mid ] < x :<br>            l = mid + 1<br>        else :<br>            r = mid - 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def binary_search ( arr , x ) :<br>    l , r = 0 , len ( arr ) - 1<br>    while l <= r :<br>        m = l + ( r - l ) // 2<br>        if arr [ m ] == x :<br>            return m<br>        if arr [ m ] < x :<br>            l = m + 1<br>        else :<br>            r = m - 1<br>    return - 1<br></td>
  </tr><tr>
    <th>COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSubsequenceCount ( S , T ) :<br>    m = len ( T )<br>    n = len ( S )<br>    if m > n :<br>        return 0<br>    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ]<br>    for i in range ( 1 , m + 1 ) :<br>        mat [ i ] [ 0 ] = 0<br>    for j in range ( n + 1 ) :<br>        mat [ 0 ] [ j ] = 1<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            if T [ i - 1 ] != S [ j - 1 ] :<br>                mat [ i ] [ j ] = mat [ i ] [ j - 1 ]<br>            else :<br>                mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] )<br>    return mat [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def findSubsequenceCount ( S , T ) :<br>    m = len ( T )<br>    n = len ( S )<br>    if m > n :<br>        return 0<br>    mat = [ [ 0 ] * m + [ n + 1 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m</td>
  </tr><tr>
    <th>SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def swap ( xp , yp ) :<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br>    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br></td>
    <td>translated code: <br><br> def swap ( xp , yp ) :<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br>    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]<br></td>
  </tr><tr>
    <th>POLICEMEN_CATCH_THIEVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def policeThief ( arr , n , k ) :<br>    i = 0<br>    l = 0<br>    r = 0<br>    res = 0<br>    thi = [ ]<br>    pol = [ ]<br>    while i < n :<br>        if arr [ i ] == 'P' :<br>            pol.append ( i )<br>        elif arr [ i ] == 'T' :<br>            thi.append ( i )<br>        i += 1<br>    while l < len ( thi ) and r < len ( pol ) :<br>        if ( abs ( thi [ l ] - pol [ r ] ) <= k ) :<br>            res += 1<br>            l += 1<br>            r += 1<br>        elif thi [ l ] < pol [ r ] :<br>            l += 1<br>        else :<br>            r += 1<br>    return res<br></td>
    <td>translated code: <br><br> def police_thief ( arr , n , k ) :<br>    res = 0<br>    thi = [ ]<br>    pol = [ ]<br>    for i in range ( n ) :<br>        if arr [ i ] == 'P' :<br>            pol.append ( i )<br>        elif arr [ i ] == 'T' :<br>            thi.append ( i )<br>    l , r = 0 , 0<br>    while l < len ( thi ) and r < len ( pol ) :<br>        if abs ( thi [ l ] - pol [ r ] ) <= k :<br>            res += 1<br>            l += 1<br>            r += 1<br>        elif thi [ l ] < pol [ r ] :<br>            l += 1<br>        else :<br>            r += 1<br>    return res<br></td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxLen ( arr , n ) :<br>    hash_map = { } <br>    curr_sum = 0 <br>    max_len = 0 <br>    ending_index = - 1 <br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] == 0 ) :<br>            arr [ i ] = - 1 <br>        else :<br>            arr [ i ] = 1 <br>    for i in range ( 0 , n ) :<br>        curr_sum = curr_sum + arr [ i ] <br>        if ( curr_sum == 0 ) :<br>            max_len = i + 1 <br>            ending_index = i <br>        if ( curr_sum + n ) in hash_map :<br>            max_len = max ( max_len , i - hash_map [ curr_sum + n ] )<br>        else :<br>            hash_map [ curr_sum ] = i <br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] == - 1 ) :<br>            arr [ i ] = 0 <br>        else :<br>            arr [ i ] = 1 <br>    print ( ending_index - max_len + 1 , end = " " ) <br>    print ( "to" , end = " " ) <br>    print ( ending_index ) <br>    return max_len <br></td>
    <td>translated code: <br><br> def max_len ( arr , n ) :<br>    hM = { }<br>    sum = 0<br>    max_len = 0<br>    ending_index = - 1<br>    start_index = 0<br>    for i in range ( n ) :<br>        arr [ i ] = ( arr [ i ] == 0 )<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>        if sum == 0 :<br>            max_len = i + 1<br>            ending_index = i<br>        if hM.has_key ( sum + n ) :<br>            if max_len < i - hM [ sum + n ] :<br>                max_len = i - hM [ sum + n ]<br>                ending_index = i<br>        else :<br>            hM [ sum + n ] = i<br>    for i in range ( n ) :<br>        arr [ i ] = ( arr [ i ] == - 1 )<br>    end = ending_index - max_len + 1<br>    print ( end , ending_index )<br>    return max_len<br></td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLength ( string , n ) :<br>    current_sum = 0<br>    max_sum = 0<br>    for i in range ( n ) :<br>        current_sum += ( 1 if string [ i ] == '0' else - 1 )<br>        if current_sum < 0 :<br>            current_sum = 0<br>        max_sum = max ( current_sum , max_sum )<br>    return max_sum if max_sum else 0<br></td>
    <td>translated code: <br><br> def find_length ( str , n ) :<br>    current_sum = 0<br>    max_sum = 0<br>    for i in range ( n ) :<br>        current_sum += ( str [ i ] == '0' )<br>        if current_sum < 0 :<br>            current_sum = 0<br>        max_sum = max ( current_sum , max_sum )<br>    return max_sum if max_sum > 0 else - 1<br></td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findLongestConseqSubseq ( arr , n ) :<br>    S = set ( ) <br>    for i in range ( n ) :<br>        S.add ( arr [ i ] ) <br>    ans = 0 <br>    for i in range ( n ) :<br>        if S.__contains__ ( arr [ i ] ) :<br>            j = arr [ i ] <br>            while ( S.__contains__ ( j ) ) :<br>                j += 1 <br>            ans = max ( ans , j - arr [ i ] ) <br>    return ans <br></td>
    <td>translated code: <br><br> def findLongestConseqSubseq ( arr , n ) :<br>    S = set ( )<br>    for i in range ( n ) :<br>        S.add ( arr [ i ] )<br>    ans = 0<br>    for i in range ( n ) :<br>        if S.intersection ( arr [ i ] ) :<br>            j = arr [ i ]<br>            while S.intersection ( j ) :<br>                j += 1<br>            ans = max ( ans , j - arr [ i ] )<br>    return ans<br></td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_NEXT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextWord ( s ) :<br>    if ( s == " " ) :<br>        return "a"<br>    i = len ( s ) - 1<br>    while ( s [ i ] == 'z' and i >= 0 ) :<br>        i -= 1<br>    if ( i == - 1 ) :<br>        s = s + 'a'<br>    else :<br>        s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 )<br>    return s<br></td>
    <td>translated code: <br><br> def next_word ( str ) :<br>    if str == "" :<br>        return "a"<br>    i = len ( str ) - 1<br>    while str [ i ] == "z" and i >= 0 :<br>        i -= 1<br>    if i == - 1 :<br>        str = str + 'a'<br>    else :<br>        str = str [ : i ] + chr ( ord ( str [ i ] ) + 1 ) + str [ i + 1 : ]<br>    return str<br></td>
  </tr><tr>
    <th>SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solve ( a , b , n ) :<br>    s = 0<br>    for i in range ( 0 , n ) :<br>        s += a [ i ] + b [ i ]<br>    if n == 1 :<br>        return a [ 0 ] + b [ 0 ]<br>    if s % n != 0 :<br>        return - 1<br>    x = s // n<br>    for i in range ( 0 , n ) :<br>        if a [ i ] > x :<br>            return - 1<br>        if i > 0 :<br>            a [ i ] += b [ i - 1 ]<br>            b [ i - 1 ] = 0<br>        if a [ i ] == x :<br>            continue<br>        y = a [ i ] + b [ i ]<br>        if i + 1 < n :<br>            y += b [ i + 1 ]<br>        if y == x :<br>            a [ i ] = y<br>            b [ i ] = 0<br>            if i + 1 < n : b [ i + 1 ] = 0<br>            continue<br>        if a [ i ] + b [ i ] == x :<br>            a [ i ] += b [ i ]<br>            b [ i ] = 0<br>            continue<br>        if i + 1 < n and a [ i ] + b [ i + 1 ] == x :<br>            a [ i ] += b [ i + 1 ]<br>            b [ i + 1 ] = 0<br>            continue<br>        return - 1<br>    for i in range ( 0 , n ) :<br>        if b [ i ] != 0 :<br>            return - 1<br>    return x<br></td>
    <td>translated code: <br><br> def solve ( a , b , n ) :<br>    i = 0<br>    s = 0<br>    for i in range ( n ) :<br>        s += ( a [ i ] + b [ i ] )<br>    if n == 1 :<br>        return a [ 0 ] + b [ 0 ]<br>    if s % n != 0 :<br>        return - 1<br>    x = s / n<br>    for i in range ( n ) :<br>        if a [ i ] > x :<br>            return - 1<br>        if i > 0 :<br>            a [ i ] += b [ i - 1 ]<br>            b [ i - 1 ] = 0<br>        if a [ i ] == x :<br>            continue<br>        y = a [ i ] + b [ i ]<br>        if i + 1 < n :<br>            y += b [ i + 1 ]<br>        if y == x :<br>            a [ i ] = y<br>            b [ i ] = 0<br>            continue<br>        if a [ i ] + b [ i ] == x :<br>            a [ i ] += b [ i ]<br>            b [ i ] = 0<br>            continue<br>        if i + 1 < n and a [ i ] + b [ i + 1 ] == x :<br>            a [ i ] += b [ i + 1 ]<br>            b [ i + 1 ] = 0<br>            continue<br>        return - 1<br>    for i in range ( n ) :<br>        if b [ i ] != 0 :<br>            return - 1<br>    return x<br></td>
  </tr><tr>
    <th>FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMinNumberForPattern ( seq ) :<br>    n = len ( seq )<br>    if ( n >= 9 ) :<br>        return "-1"<br>    result = [ None ] * ( n + 1 )<br>    count = 1<br>    for i in range ( n + 1 ) :<br>        if ( i == n or seq [ i ] == 'I' ) :<br>            for j in range ( i - 1 , - 2 , - 1 ) :<br>                result [ j + 1 ] = int ( '0' + str ( count ) )<br>                count += 1<br>                if ( j >= 0 and seq [ j ] == 'I' ) :<br>                    break<br>    return result<br></td>
    <td>translated code: <br><br> def getMinNumberForPattern ( seq ) :<br>    n = len ( seq )<br>    if n >= 9 :<br>        return "-1"<br>    result = [ ]<br>    count = 1<br>    for i in range ( 0 , n ) :<br>        if i == n or seq [ i ] == 'I' :<br>            for j in range ( i - 1 , - 1 , - 1 ) :<br>                result.append ( chr ( int ( '0' + count , 16 ) ) )<br>                if j >= 0 and seq [ j ] == 'I' :<br>                    break<br>    return ''.join ( result )<br></td>
  </tr><tr>
    <th>SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shuffleArray ( a , n ) :<br>    i , q , k = 0 , 1 , n<br>    while ( i < n ) :<br>        j = k<br>        while ( j > i + q ) :<br>            a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ]<br>            j -= 1<br>        i += 1<br>        k += 1<br>        q += 1<br></td>
    <td>translated code: <br><br> def shuffleArray ( a , n ) :<br>    for i , q , k in enumerate ( a ) :<br>        for j in range ( k , i + q , - 1 ) :<br>            temp = a [ j - 1 ]<br>            a [ j - 1 ] = a [ j ]<br>            a [ j ] = temp<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRepeating ( arr , n ) :<br>    s = set ( )<br>    for i in range ( n ) :<br>        if arr [ i ] in s :<br>            return arr [ i ]<br>        s.add ( arr [ i ] )<br>    rteurn - 1<br></td>
    <td>translated code: <br><br> def find_repeated ( arr , n ) :<br>    s = set ( )<br>    for i in range ( n ) :<br>        if s.issubset ( arr [ i ] ) :<br>            return arr [ i ]<br>        s.add ( arr [ i ] )<br>    return - 1<br></td>
  </tr><tr>
    <th>C_PROGRAM_SUBTRACTION_MATICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def multiply ( A , B , C ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]<br></td>
    <td>translated code: <br><br> def multiply ( A , B , C ) :<br>    i , j = 0 , 0<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]<br></td>
  </tr><tr>
    <th>FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printFirstNegativeInteger ( arr , n , k ) :<br>    for i in range ( 0 , ( n - k + 1 ) ) :<br>        flag = False<br>        for j in range ( 0 , k ) :<br>            if ( arr [ i + j ] < 0 ) :<br>                print ( arr [ i + j ] , end = " " )<br>                flag = True<br>                break<br>        if ( not ( flag ) ) :<br>            print ( "0" , end = " " )<br></td>
    <td>translated code: <br><br> def printFirstNegativeInteger ( arr , n , k ) :<br>    flag = False<br>    for i in range ( ( n - k + 1 ) ) :<br>        flag = False<br>        for j in range ( k ) :<br>            if arr [ i + j ] < 0 :<br>                print ( ( arr [ i + j ] , arr [ i + j ] ) )<br>                flag = True<br>                break<br>        if not flag :<br>            print ( "0" , end = ' ' )<br></td>
  </tr><tr>
    <th>NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numoffbt ( arr , n ) :<br>    maxvalue = - 2147483647<br>    minvalue = 2147483647<br>    for i in range ( n ) :<br>        maxvalue = max ( maxvalue , arr [ i ] )<br>        minvalue = min ( minvalue , arr [ i ] )<br>    mark = [ 0 for i in range ( maxvalue + 2 ) ]<br>    value = [ 0 for i in range ( maxvalue + 2 ) ]<br>    for i in range ( n ) :<br>        mark [ arr [ i ] ] = 1<br>        value [ arr [ i ] ] = 1<br>    ans = 0<br>    for i in range ( minvalue , maxvalue + 1 ) :<br>        if ( mark [ i ] != 0 ) :<br>            j = i + i<br>            while ( j <= maxvalue and j // i <= i ) :<br>                if ( mark [ j ] == 0 ) :<br>                    continue<br>                value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] )<br>                if ( i != j // i ) :<br>                    value [ j ] = value [ j ] + ( value [ i ] * value [ j // i ] )<br>                j += i<br>        ans += value [ i ]<br>    return ans<br></td>
    <td>translated code: <br><br> def numoffbt ( arr , n ) :<br>    maxvalue = - 2147483647<br>    minvalue = 2147483647<br>    for i in range ( n ) :<br>        maxvalue = max ( maxvalue , arr [ i ] )<br>        minvalue = min ( minvalue , arr [ i ] )<br>    mark = [ 0 ] * ( maxvalue + 2 )<br>    value = [ 0 ] * ( maxvalue + 2 )<br>    del mark [ 0 ]<br>    del value [ 0 ]<br>    for i in range ( n ) :<br>        mark [ arr [ i ] ] = 1<br>        value [ arr [ i ] ] = 1<br>    ans = 0<br>    for i in range ( minvalue , maxvalue + 1 ) :<br>        if mark [ i ] != 0 :<br>            for j in range ( i + i , maxvalue + 1 , i ) :<br>                if mark [ j ] == 0 :<br>                    continue<br>                value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] )<br>                if i != j / i :<br>                    value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] )<br>        ans += value [ i ]<br>    return ans<br></td>
  </tr><tr>
    <th>TRIANGULAR_MATCHSTICK_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberOfSticks ( x ) :<br>    return ( 3 * x * ( x + 1 ) ) / 2<br></td>
    <td>translated code: <br><br> def number_of_ticks ( x ) :<br>    return ( 3 * x * ( x + 1 ) ) / 2<br></td>
  </tr><tr>
    <th>K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def KMaxCombinations ( A , B , N , K ) :<br>    pq = PriorityQueue ( )<br>    for i in range ( 0 , N ) :<br>        for j in range ( 0 , N ) :<br>            a = A [ i ] + B [ j ]<br>            pq.put ( ( - a , a ) )<br>    count = 0<br>    while ( count < K ) :<br>        print ( pq.get ( ) [ 1 ] )<br>        count = count + 1<br></td>
    <td>translated code: <br><br> def KMaxCombinations ( A , B , N , K ) :<br>    pq = PriorityQueue ( sorted ( A ) )<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            pq.add ( A [ i ] + B [ j ] )<br>    count = 0<br>    while count < K :<br>        print ( pq.get ( ) )<br>        pq.pop ( )<br>        count += 1<br></td>
  </tr><tr>
    <th>CONSTRUCT_ARRAY_PAIR_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def constructArr ( arr , pair , n ) :<br>    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2<br>    for i in range ( 1 , n ) :<br>        arr [ i ] = pair [ i - 1 ] - arr [ 0 ]<br></td>
    <td>translated code: <br><br> def construct_arr ( arr , pair , n ) :<br>    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2<br>    for i in range ( 1 , n ) :<br>        arr [ i ] = pair [ i - 1 ] - arr [ 0 ]<br></td>
  </tr><tr>
    <th>CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkCorrectOrNot ( s ) :<br>    global MAX_CHAR<br>    count1 = [ 0 ] * MAX_CHAR<br>    count2 = [ 0 ] * MAX_CHAR<br>    n = len ( s )<br>    if n == 1 :<br>        return true<br>    i = 0 ; j = n - 1<br>    while ( i < j ) :<br>        count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1<br>        count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1<br>        i += 1 ; j -= 1<br>    for i in range ( MAX_CHAR ) :<br>        if count1 [ i ] != count2 [ i ] :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def check_correct_or_not ( s ) :<br>    count1 = [ ]<br>    count2 = [ ]<br>    n = len ( s )<br>    if n == 1 :<br>        return True<br>    for i , c in enumerate ( s ) :<br>        count1.append ( ord ( c ) - ord ( 'a' ) )<br>        count2.append ( ord ( c ) - ord ( 'a' ) )<br>    for i in range ( MAX_CHAR ) :<br>        if count1 [ i ] != count2 [ i ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMinDiff ( arr , n , k ) :<br>    if ( n == 1 ) :<br>        return 0<br>    arr.sort ( )<br>    ans = arr [ n - 1 ] - arr [ 0 ]<br>    small = arr [ 0 ] + k<br>    big = arr [ n - 1 ] - k<br>    if ( small > big ) :<br>        small , big = big , small<br>    for i in range ( 1 , n - 1 ) :<br>        subtract = arr [ i ] - k<br>        add = arr [ i ] + k<br>        if ( subtract >= small or add <= big ) :<br>            continue<br>        if ( big - subtract <= add - small ) :<br>            small = subtract<br>        else :<br>            big = add<br>    return min ( ans , big - small )<br></td>
    <td>translated code: <br><br> def getMinDiff ( arr , n , k ) :<br>    if n == 1 :<br>        return 0<br>    arr.sort ( )<br>    ans = arr [ n - 1 ] - arr [ 0 ]<br>    small = arr [ 0 ] + k<br>    big = arr [ n - 1 ] - k<br>    temp = 0<br>    if small > big :<br>        temp = small<br>        small = big<br>        big = temp<br>    for i in range ( 1 , n - 1 ) :<br>        subtract = arr [ i ] - k<br>        add = arr [ i ] + k<br>        if subtract >= small or add <= big :<br>            continue<br>        if big - subtract <= add - small :<br>            small = subtract<br>        else :<br>            big = add<br>    return min ( ans , big - small )<br></td>
  </tr><tr>
    <th>MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pairs ( arr , n , k ) :<br>    smallest = 999999999999<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if abs ( arr [ i ] + arr [ j ] - k ) < smallest :<br>                smallest = abs ( arr [ i ] + arr [ j ] - k )<br>                count = 1<br>            elif abs ( arr [ i ] + arr [ j ] - k ) == smallest :<br>                count += 1<br>    print ( "Minimal Value = " , smallest )<br>    print ( "Total Pairs = " , count )<br></td>
    <td>translated code: <br><br> def pairs ( arr , n , k ) :<br>    smallest = int ( '-inf' )<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if abs ( arr [ i ] + arr [ j ] - k ) < smallest :<br>                smallest = abs ( arr [ i ] + arr [ j ] - k )<br>                count = 1<br>            elif abs ( arr [ i ] + arr [ j ] - k ) == smallest :<br>                count += 1<br>    print ( 'Minimal Value = %d' % smallest )<br>    print ( 'Total Pairs = %d' % count )<br></td>
  </tr><tr>
    <th>SIZE_SUBARRAY_MAXIMUM_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubArraySum ( a , size ) :<br>    max_so_far = - maxsize - 1<br>    max_ending_here = 0<br>    start = 0<br>    end = 0<br>    s = 0<br>    for i in range ( 0 , size ) :<br>        max_ending_here += a [ i ]<br>        if max_so_far < max_ending_here :<br>            max_so_far = max_ending_here<br>            start = s<br>            end = i<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>            s = i + 1<br>    return ( end - start + 1 )<br></td>
    <td>translated code: <br><br> def max_subarray_sum ( a , size ) :<br>    max_so_far , max_ending_here , start , end , s = int ( a [ : size ] ) , 0 , 0 , 0 , 0<br>    for i in range ( size ) :<br>        max_ending_here += a [ i ]<br>        if max_so_far < max_ending_here :<br>            max_so_far = max_ending_here<br>            start = s<br>            end = i<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>            s = i + 1<br>    return ( end - start + 1 )<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMinSquares ( n ) :<br>    dp = [ 0 , 1 , 2 , 3 ]<br>    for i in range ( 4 , n + 1 ) :<br>        dp.append ( i )<br>        for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) :<br>            temp = x * x <br>            if temp > i :<br>                break<br>            else :<br>                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def get_min_squares ( n ) :<br>    if n <= 3 :<br>        return n<br>    dp = [ 0 ] * ( n + 1 )<br>    for i in range ( 4 , n + 1 ) :<br>        dp [ i ] = i<br>        for x in range ( 1 , math.ceil ( math.sqrt ( i ) ) ) :<br>            temp = x ** 2<br>            if temp > i :<br>                break<br>            else :<br>                dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )<br>    res = dp [ n ]<br>    return res<br></td>
  </tr><tr>
    <th>DIVISIBILITY_BY_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isDivisibleBy7 ( num ) :<br>    if num < 0 :<br>        return isDivisibleBy7 ( - num )<br>    if ( num == 0 or num == 7 ) :<br>        return True<br>    if ( num < 10 ) :<br>        return False<br>    return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) )<br></td>
    <td>translated code: <br><br> def is_divisibleBy7 ( num ) :<br>    if num < 0 :<br>        return is_divisibleBy7 ( - num )<br>    if num == 0 or num == 7 :<br>        return True<br>    if num < 10 :<br>        return False<br>    return is_divisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) )<br></td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def Right_most_setbit ( num ) :<br>    pos = 1<br>    for i in range ( INT_SIZE ) :<br>        if not ( num & ( 1 << i ) ) :<br>            pos += 1<br>        else :<br>            break<br>    return pos<br></td>
    <td>translated code: <br><br> def Right_most_setbit ( num ) :<br>    pos = 1<br>    for i in range ( INT_SIZE ) :<br>        if ( num & ( 1 << i ) ) == 0 :<br>            pos += 1<br>        else :<br>            break<br>    return pos<br></td>
  </tr><tr>
    <th>EFFICIENT_WAY_TO_MULTIPLY_WITH_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def multiplyBySeven ( n ) :<br>    return ( ( n << 3 ) - n )<br></td>
    <td>translated code: <br><br> def multiplyBySeven ( n ) :<br>    return ( ( n << 3 ) - n )<br></td>
  </tr><tr>
    <th>NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def snoob ( x ) :<br>    next = 0<br>    if ( x ) :<br>        rightOne = x & - ( x )<br>        nextHigherOneBit = x + int ( rightOne )<br>        rightOnesPattern = x ^ int ( nextHigherOneBit )<br>        rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) )<br>        rightOnesPattern = int ( rightOnesPattern ) >> 2<br>        next = nextHigherOneBit | rightOnesPattern<br>    return next<br></td>
    <td>translated code: <br><br> def snoob ( x ) :<br>    right_one , next_higher_one_bit , right_ones_pattern , next = x<br>    if next_higher_one_bit :<br>        right_one = x & - x<br>        next_higher_one_bit = x + right_one<br>        right_ones_pattern = x ^ next_higher_one_bit<br>        right_ones_pattern = ( right_ones_pattern ) // right_one<br>        right_ones_pattern >>= 2<br>        next = next_higher_one_bit | right_ones_pattern<br>    return next<br></td>
  </tr><tr>
    <th>CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def makePermutation ( a , n ) :<br>    count = dict ( )<br>    for i in range ( n ) :<br>        if count.get ( a [ i ] ) :<br>            count [ a [ i ] ] += 1<br>        else :<br>            count [ a [ i ] ] = 1 <br>    next_missing = 1<br>    for i in range ( n ) :<br>        if count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 :<br>            count [ a [ i ] ] -= 1<br>            while count.get ( next_missing ) :<br>                next_missing += 1<br>            a [ i ] = next_missing<br>            count [ next_missing ] = 1<br></td>
    <td>translated code: <br><br> def makePermutation ( a , n ) :<br>    count = { }<br>    for i in range ( n ) :<br>        if count.has_key ( a [ i ] ) :<br>            count [ a [ i ] ] = count [ a [ i ] ] + 1<br>        else :<br>            count [ a [ i ] ] = 1<br>    next_missing = 1<br>    for i in range ( n ) :<br>        if count.has_key ( a [ i ] ) and count [ a [ i ] ] != 1 or a [ i ] > n or a [ i ] < 1 :<br>            count [ a [ i ] ] = count [ a [ i ] ] - 1<br>            while count.has_key ( next_missing ) :<br>                next_missing += 1<br>            a [ i ] = next_missing<br>            count [ next_missing ] = 1<br></td>
  </tr><tr>
    <th>MAXIMUM_AREA_QUADRILATERAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxArea ( a , b , c , d ) :<br>    semiperimeter = ( a + b + c + d ) / 2<br>    return math.sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )<br></td>
    <td>translated code: <br><br> def max_area ( a , b , c , d ) :<br>    semiperimeter = ( a + b + c + d ) / 2<br>    return math.sqrt ( ( semiperimeter - a ) ** 2 + ( semiperimeter - b ) ** 2 + ( semiperimeter - c ) ** 2 + ( semiperimeter - d ) ** 2 )<br></td>
  </tr><tr>
    <th>REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def translate ( st ) :<br>    l = len ( st )<br>    if ( l < 2 ) :<br>        return<br>    i = 0<br>    j = 0<br>    while ( j < l - 1 ) :<br>        if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) :<br>            j += 2<br>            st [ i ] = 'C'<br>            i += 1<br>            continue<br>        st [ i ] = st [ j ]<br>        i += 1<br>        j += 1<br>    if ( j == l - 1 ) :<br>        st [ i ] = st [ j ]<br>        i += 1<br>    st [ i ] = ' '<br>    st [ l - 1 ] = ' '<br></td>
    <td>translated code: <br><br> def translate ( s ) :<br>    """translate(s) -> string<br><br> Return a copy of the string s with all occurrences of substring<br> s[i:j], where i <= len(s) and j >= len(s).<br><br> """<br>    return s [ : 0 ].translate ( string.maketrans ( s , '' ) )<br>    # Capitalize a string, e.g."aBc dEf" -> "Abc def".<br>    # This means that "Abc def" -> "Abc Def".<br>    # If there is no '%' prefix, then split on a newline.<br>    # Otherwise, we look for "%n" in s.replace("\n", "\n").<br></td>
  </tr><tr>
    <th>FIND_POWER_POWER_MOD_PRIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def calculate ( A , B , C , M ) :<br>    res = pow ( B , C , M - 1 )<br>    ans = pow ( A , res , M )<br>    return ans<br></td>
    <td>translated code: <br><br> def Calculate ( A , B , C , M ) :<br>    res , ans = power ( B , C , M - 1 )<br>    ans = power ( A , res , M )<br>    return ans<br></td>
  </tr><tr>
    <th>CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkPair ( arr , n ) :<br>    s = set ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    if sum % 2 != 0 :<br>        return False<br>    sum = sum / 2<br>    for i in range ( n ) :<br>        val = sum - arr [ i ]<br>        if arr [ i ] not in s :<br>            s.add ( arr [ i ] )<br>        if val in s :<br>            print ( "Pair elements are" , arr [ i ] , "and" , int ( val ) )<br></td>
    <td>translated code: <br><br> def check_pair ( arr , n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    if sum % 2 != 0 :<br>        return False<br>    sum = sum / 2<br>    s = set ( )<br>    for i in range ( n ) :<br>        val = sum - arr [ i ]<br>        if s.issuperset ( val ) and val in ( s.union ( val ) ) :<br>            print ( "Pair elements are %d and %d" % ( arr [ i ] , val ) )<br>            return True<br>        s.add ( arr [ i ] )<br>    return False<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def surface_area_octahedron ( side ) :<br>    return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )<br></td>
    <td>translated code: <br><br> def surface_area_octahedron ( side ) :<br>    return ( 2 * ( np.sqrt ( 3 ) ) * ( side ** 2 ) )<br></td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxValue ( mat ) :<br>    maxValue = 0<br>    for a in range ( N - 1 ) :<br>        for b in range ( N - 1 ) :<br>            for d in range ( a + 1 , N ) :<br>                for e in range ( b + 1 , N ) :<br>                    if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) :<br>                        maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) <br>    return maxValue <br></td>
    <td>translated code: <br><br> def findMaxValue ( N , mat ) :<br>    maxValue = int ( "" )<br>    for a in range ( N - 1 ) :<br>        for b in range ( N - 1 ) :<br>            for d in range ( a + 1 , N ) :<br>                for e in range ( b + 1 , N ) :<br>                    if maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) :<br>                        maxValue = mat [ d ] [ e ] - mat [ a ] [ b ]<br>    return maxValue<br></td>
  </tr><tr>
    <th>MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def multiply ( x , y ) :<br>    if ( y == 0 ) :<br>        return 0<br>    if ( y > 0 ) :<br>        return ( x + multiply ( x , y - 1 ) )<br>    if ( y < 0 ) :<br>        return - multiply ( x , - y )<br></td>
    <td>translated code: <br><br> def multiply ( x , y ) :<br>    if y == 0 :<br>        return 0<br>    if y > 0 :<br>        return ( x + multiply ( x , y - 1 ) )<br>    if y < 0 :<br>        return - multiply ( x , - y )<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTriplets ( arr , n ) :<br>    found = False<br>    for i in range ( n - 1 ) :<br>        s = set ( )<br>        for j in range ( i + 1 , n ) :<br>            x = - ( arr [ i ] + arr [ j ] )<br>            if x in s :<br>                print ( x , arr [ i ] , arr [ j ] )<br>                found = True<br>            else :<br>                s.add ( arr [ j ] )<br>    if found == False :<br>        print ( "No Triplet Found" )<br></td>
    <td>translated code: <br><br> def find_triplets ( arr , n ) :<br>    found = False<br>    for i in range ( n - 1 ) :<br>        s = set ( )<br>        for j in range ( i + 1 , n ) :<br>            x = - ( arr [ i ] + arr [ j ] )<br>            if s.intersection ( x ) :<br>                print ( x , arr [ i ] , arr [ j ] )<br>                found = True<br>            else :<br>                s.add ( arr [ j ] )<br>    if found == False :<br>        print ( " No Triplet Found" )<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSum ( arr ) :<br>    arrSum = 0<br>    currVal = 0<br>    n = len ( arr )<br>    for i in range ( 0 , n ) :<br>        arrSum = arrSum + arr [ i ]<br>        currVal = currVal + ( i * arr [ i ] )<br>    maxVal = currVal<br>    for j in range ( 1 , n ) :<br>        currVal = currVal + arrSum - n * arr [ n - j ]<br>        if currVal > maxVal :<br>            maxVal = currVal<br>    return maxVal<br></td>
    <td>translated code: <br><br> def maxSum ( ) :<br>    arrSum = 0<br>    currVal = 0<br>    for i in range ( len ( arr ) ) :<br>        arrSum = arrSum + arr [ i ]<br>        currVal = currVal + ( i * arr [ i ] )<br>    maxVal = currVal<br>    for j in range ( 1 , len ( arr ) ) :<br>        currVal = currVal + arrSum - len ( arr ) * arr [ len ( arr ) - j ]<br>        if currVal > maxVal :<br>            maxVal = currVal<br>    return maxVal<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def scalarProductMat ( mat , k ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            mat [ i ] [ j ] = mat [ i ] [ j ] * k<br></td>
    <td>translated code: <br><br> def scalar_product_mat ( mat , k ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            mat [ i , j ] = mat [ i , j ] * k<br></td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSquares ( n ) :<br>    square = 0<br>    odd = 1<br>    for x in range ( 0 , n ) :<br>        print ( square , end = " " )<br>        square = square + odd<br>        odd = odd + 2<br></td>
    <td>translated code: <br><br> def print_squares ( n ) :<br>    square , odd = 0 , 1<br>    for x in range ( n ) :<br>        print ( square , end = ' ' )<br>        square , odd = square + odd , odd + 2<br></td>
  </tr><tr>
    <th>NTH_PENTAGONAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pentagonalNum ( n ) :<br>    return ( 3 * n * n - n ) / 2<br></td>
    <td>translated code: <br><br> def pentagonalNum ( n ) :<br>    return ( 3 * n ** 2 - n ) / 2<br></td>
  </tr><tr>
    <th>COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numofArray ( n , m ) :<br>    dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ]<br>    di = [ [ ] for i in range ( MAX ) ]<br>    mu = [ [ ] for i in range ( MAX ) ]<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 2 * i , m + 1 , i ) :<br>            di [ j ].append ( i )<br>            mu [ i ].append ( j )<br>        di [ i ].append ( i )<br>    for i in range ( 1 , m + 1 ) :<br>        dp [ 1 ] [ i ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 1 , m + 1 ) :<br>            dp [ i ] [ j ] = 0<br>            for x in di [ j ] :<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]<br>            for x in mu [ j ] :<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]<br>    ans = 0<br>    for i in range ( 1 , m + 1 ) :<br>        ans += dp [ n ] [ i ]<br>        di [ i ].clear ( )<br>        mu [ i ].clear ( )<br>    return ans<br></td>
    <td>translated code: <br><br> def numof_array ( n , m ) :<br>    dp = [ ]<br>    di = [ ]<br>    mu = [ ]<br>    for i in range ( MAX ) :<br>        for j in range ( MAX ) :<br>            dp [ i ] [ j ] = 0<br>    for i in range ( MAX ) :<br>        di.append ( [ ] )<br>        mu.append ( [ ] )<br>    for i in range ( 1 , m ) :<br>        for j in range ( 2 * i , m , i += 1 ) :<br>            di [ j ].append ( i )<br>            mu [ i ].append ( j )<br>        di [ i ].append ( i )<br>    for i in range ( 1 , m ) :<br>        dp [ 1 ] [ i ] = 1<br>    for i in range ( 2 , n ) :<br>        for j in range ( 1 , m ) :<br>            dp [ i ] [ j ] = 0<br>            for x in di [ j ] :<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]<br>            for x in mu [ j ] :<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ]<br>    ans = 0<br>    for i in range ( 1 , m ) :<br>        ans += dp [ n ] [ i ]<br>        di.reverse ( )<br>        mu.reverse ( )<br>    return ans<br></td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def knapSack ( W , wt , val , n ) :<br>    if n == 0 or W == 0 :<br>        return 0<br>    if ( wt [ n - 1 ] > W ) :<br>        return knapSack ( W , wt , val , n - 1 )<br>    else :<br>        return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )<br></td>
    <td>translated code: <br><br> def knapSack ( W , wt , val , n ) :<br>    if n == 0 or W == 0 :<br>        return 0<br>    if wt [ - 1 ] > W :<br>        return knapSack ( W , wt , val , n - 1 )<br>    else :<br>        return max ( val [ - 1 ] + knapSack ( W - wt [ - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) )<br></td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTriplets ( arr , n ) :<br>    found = True<br>    for i in range ( 0 , n - 2 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) :<br>                    print ( arr [ i ] , arr [ j ] , arr [ k ] )<br>                    found = True<br>    if ( found == False ) :<br>        print ( " not exist " )<br></td>
    <td>translated code: <br><br> def find_triplets ( arr , n ) :<br>    found = True<br>    for i in range ( n - 2 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                if arr [ i ] + arr [ j ] + arr [ k ] == 0 :<br>                    print ( arr [ i ] , end = ' ' )<br>                    print ( arr [ j ] , end = ' ' )<br>                    print ( arr [ k ] , end = ' ' )<br>                    print ( arr [ i ] , end = ' ' )<br>                    print ( arr [ j ] , end = ' ' )<br>                    print ( arr [ k ] , end = ' ' )<br>                    print ( arr [ i ] , end = ' ' )<br>                    found = True<br>    if found == False :<br>        print ( ' not exist ' )<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def count ( n ) :<br>    table = [ 0 for i in range ( n + 1 ) ]<br>    table [ 0 ] = 1<br>    for i in range ( 3 , n + 1 ) :<br>        table [ i ] += table [ i - 3 ]<br>    for i in range ( 5 , n + 1 ) :<br>        table [ i ] += table [ i - 5 ]<br>    for i in range ( 10 , n + 1 ) :<br>        table [ i ] += table [ i - 10 ]<br>    return table [ n ]<br></td>
    <td>translated code: <br><br> def count ( n ) :<br>    table , i = [ 0 ] * ( n + 1 ) , 0<br>    table [ 0 ] = 1<br>    for i in range ( 3 , n + 1 ) :<br>        table [ i ] += table [ i - 3 ]<br>    for i in range ( 5 , n + 1 ) :<br>        table [ i ] += table [ i - 5 ]<br>    for i in range ( 10 , n + 1 ) :<br>        table [ i ] += table [ i - 10 ]<br>    return table [ n ]<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MaxSumDifference ( a , n ) :<br>    np.sort ( a ) <br>    j = 0<br>    finalSequence = [ 0 for x in range ( n ) ]<br>    for i in range ( 0 , int ( n / 2 ) ) :<br>        finalSequence [ j ] = a [ i ]<br>        finalSequence [ j + 1 ] = a [ n - i - 1 ]<br>        j = j + 2<br>    MaximumSum = 0<br>    for i in range ( 0 , n - 1 ) :<br>        MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) )<br>    MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) <br>    print ( MaximumSum )<br></td>
    <td>translated code: <br><br> def MaxSumDifference ( a , n ) :<br>    final_sequence = [ ]<br>    final_sequence.sort ( )<br>    for i in range ( n // 2 ) :<br>        final_sequence.append ( a [ i ] )<br>        final_sequence.append ( a [ n - i - 1 ] )<br>    MaximumSum = 0<br>    for i in range ( n - 1 ) :<br>        MaximumSum = MaximumSum + abs ( final_sequence [ i ] - final_sequence [ i + 1 ] )<br>    MaximumSum = MaximumSum + abs ( final_sequence [ n - 1 ] - final_sequence [ 0 ] )<br>    return MaximumSum<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_MID_POINT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def midpoint ( x1 , x2 , y1 , y2 ) :<br>    print ( ( x1 + x2 ) // 2 , " , " , ( y1 + y2 ) // 2 )<br></td>
    <td>translated code: <br><br> def midpoint ( x1 , x2 , y1 , y2 ) :<br>    print ( ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 )<br></td>
  </tr><tr>
    <th>ALTERNATIVE_SORTING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def alternateSort ( arr , n ) :<br>    arr.sort ( )<br>    i = 0<br>    j = n - 1<br>    while ( i < j ) :<br>        print ( arr [ j ] , end = " " )<br>        j -= 1<br>        print ( arr [ i ] , end = " " )<br>        i += 1<br>    if ( n % 2 != 0 ) :<br>        print ( arr [ i ] )<br></td>
    <td>translated code: <br><br> def alternate_sort ( arr , n ) :<br>    arr.sort ( )<br>    i , j = 0 , n - 1<br>    while i < j :<br>        print ( arr [ j ] , end = ' ' )<br>        print ( arr [ i ] , end = ' ' )<br>    if n % 2 != 0 :<br>        print ( arr [ i ] )<br></td>
  </tr><tr>
    <th>NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSubarraySum ( arr , n , Sum ) :<br>    prevSum = defaultdict ( lambda : 0 )<br>    res = 0<br>    currsum = 0<br>    for i in range ( 0 , n ) :<br>        currsum += arr [ i ]<br>        if currsum == Sum :<br>            res += 1<br>        if ( currsum - Sum ) in prevSum :<br>            res += prevSum [ currsum - Sum ]<br>        prevSum [ currsum ] += 1<br>    return res<br></td>
    <td>translated code: <br><br> def findSubarraySum ( arr , n , sum ) :<br>    prevSum = { }<br>    res = 0<br>    currsum = 0<br>    for i in range ( n ) :<br>        currsum += arr [ i ]<br>        if currsum == sum :<br>            res += 1<br>        if prevSum.has_key ( currsum - sum ) :<br>            res += prevSum [ currsum - sum ]<br>        count = prevSum.get ( currsum )<br>        if count == None :<br>            prevSum [ currsum ] = 1<br>        else :<br>            prevSum [ currsum ] = count + 1<br>    return res<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , low , high ) :<br>    if low > high :<br>        return None<br>    if low == high :<br>        return arr [ low ]<br>    mid = low + ( high - low ) / 2<br>    if mid % 2 == 0 :<br>        if arr [ mid ] == arr [ mid + 1 ] :<br>            return search ( arr , mid + 2 , high )<br>        else :<br>            return search ( arr , low , mid )<br>    else :<br>        if arr [ mid ] == arr [ mid - 1 ] :<br>            return search ( arr , mid + 1 , high )<br>        else :<br>            return search ( arr , low , mid - 1 )<br></td>
    <td>translated code: <br><br> def search ( arr , low , high ) :<br>    if low > high :<br>        return<br>    if low == high :<br>        print ( "The required element is " + str ( arr [ low ] ) )<br>        return<br>    mid = ( low + high ) // 2<br>    if mid % 2 == 0 :<br>        if arr [ mid ] == arr [ mid + 1 ] :<br>            search ( arr , mid + 2 , high )<br>        else :<br>            search ( arr , low , mid )<br>    elif mid % 2 == 1 :<br>        if arr [ mid ] == arr [ mid - 1 ] :<br>            search ( arr , mid + 1 , high )<br>        else :<br>            search ( arr , low , mid - 1 )<br></td>
  </tr><tr>
    <th>FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def smallestNumber ( num ) :<br>    num = list ( num )<br>    n = len ( num )<br>    rightMin = [ 0 ] * n<br>    right = 0<br>    rightMin [ n - 1 ] = - 1 <br>    right = n - 1 <br>    for i in range ( n - 2 , 0 , - 1 ) :<br>        if num [ i ] > num [ right ] :<br>            rightMin [ i ] = right<br>        else :<br>            rightMin [ i ] = - 1<br>            right = i<br>    small = - 1<br>    for i in range ( 1 , n ) :<br>        if num [ i ] != '0' :<br>            if small == - 1 :<br>                if num [ i ] < num [ 0 ] :<br>                    small = i<br>            elif num [ i ] < num [ small ] :<br>                small = i<br>    if small != - 1 :<br>        num [ 0 ] , num [ small ] = num [ small ] , num [ 0 ]<br>    else :<br>        for i in range ( 1 , n ) :<br>            if rightMin [ i ] != - 1 :<br>                num [ i ] , num [ rightMin [ i ] ] = num [ rightMin [ i ] ] , num [ i ]<br>                break<br>    return ''.join ( num )<br></td>
    <td>translated code: <br><br> def smallest_number ( str ) :<br>    num = str.split ( '.' )<br>    n = len ( str )<br>    right_min = [ - 1 ] * n<br>    right = n - 1<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if num [ i ] > num [ right ] :<br>            right_min [ i ] = right<br>        else :<br>            right_min [ i ] = - 1<br>            right = i<br>    small = - 1<br>    for i in range ( 1 , n ) :<br>        if num [ i ] != '0' :<br>            if small == - 1 :<br>                if num [ i ] < num [ 0 ] :<br>                    small = i<br>            elif num [ i ] < num [ small ] :<br>                small = i<br>        if small != - 1 :<br>            temp = num [ 0 ]<br>            num [ 0 ] = num [ small ]<br>            num [ small ] = temp<br>        else :<br>            for i in range ( 1 , n ) :<br>                if right_min [ i ] != - 1 :<br>                    temp = num [ i ]<br>                    num [ i ] = num [ right_min [ i ] ]<br>                    num [ right_min [ i ] ] = temp<br>                    break<br>    return ( [ num [ i ] for i in range ( 1 , n ) ] )<br></td>
  </tr><tr>
    <th>PROGRAM_AREA_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def areaSquare ( side ) :<br>    area = side * side<br>    return area<br></td>
    <td>translated code: <br><br> def area_square ( side ) :<br>    area = side * side<br>    return area<br></td>
  </tr><tr>
    <th>FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def dayofweek ( d , m , y ) :<br>    t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ]<br>    y -= m < 3<br>    return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 )<br></td>
    <td>translated code: <br><br> def dayofweek ( d , m , y ) :<br>    t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ]<br>    y -= ( m < 3 )<br>    return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7<br></td>
  </tr><tr>
    <th>CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkSorted ( n , q ) :<br>    st = [ ]<br>    expected = 1<br>    fnt = None<br>    while ( not q.empty ( ) ) :<br>        fnt = q.queue [ 0 ]<br>        q.get ( )<br>        if ( fnt == expected ) :<br>            expected += 1<br>        else :<br>            if ( len ( st ) == 0 ) :<br>                st.append ( fnt )<br>            elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) :<br>                return False<br>            else :<br>                st.append ( fnt )<br>        while ( len ( st ) != 0 and st [ - 1 ] == expected ) :<br>            st.pop ( )<br>            expected += 1<br>    if ( expected - 1 == n and len ( st ) == 0 ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def check_sorted ( n ) :<br>    st = [ ]<br>    expected = 1<br>    fnt = None<br>    while q.size != 0 :<br>        fnt = q.pop ( )<br>        q.extend ( [ fnt ] )<br>        if fnt == expected :<br>            expected += 1<br>        else :<br>            if len ( st ) == 0 :<br>                st.append ( fnt )<br>            elif len ( st ) != 0 and st [ - 1 ] < fnt :<br>                return False<br>            else :<br>                st.append ( fnt )<br>        while len ( st ) != 0 and st [ - 1 ] == expected :<br>            st.pop ( )<br>            expected += 1<br>    if expected - 1 == n and len ( st ) == 0 :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>SORT_ARRAY_CONTAIN_1_N_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortit ( arr , n ) :<br>    for i in range ( n ) :<br>        arr [ i ] = i + 1<br></td>
    <td>translated code: <br><br> def sortit ( arr , n ) :<br>    for i in range ( n ) :<br>        arr [ i ] = i + 1<br></td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcsOf3 ( i , j , k ) :<br>    if ( i == - 1 or j == - 1 or k == - 1 ) :<br>        return 0<br>    if ( dp [ i ] [ j ] [ k ] != - 1 ) :<br>        return dp [ i ] [ j ] [ k ]<br>    if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) :<br>        dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 )<br>        return dp [ i ] [ j ] [ k ]<br>    else :<br>        dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) )<br>        return dp [ i ] [ j ] [ k ]<br></td>
    <td>translated code: <br><br> def lcsOf3 ( i , j , k ) :<br>    if i == - 1 or j == - 1 or k == - 1 :<br>        return 0<br>    if dp [ i ] [ j ] [ k ] != - 1 :<br>        return dp [ i ] [ j ] [ k ]<br>    if X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] :<br>        return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 )<br>    else :<br>        return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) )<br></td>
  </tr><tr>
    <th>LOWER_INSERTION_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def LowerInsertionPoint ( arr , n , X ) :<br>    if ( X < arr [ 0 ] ) :<br>        return 0 <br>    elif ( X > arr [ n - 1 ] ) :<br>        return n<br>    lowerPnt = 0<br>    i = 1<br>    while ( i < n and arr [ i ] < X ) :<br>        lowerPnt = i<br>        i = i * 2<br>    while ( lowerPnt < n and arr [ lowerPnt ] < X ) :<br>        lowerPnt += 1<br>    return lowerPnt<br></td>
    <td>translated code: <br><br> def LowerInsertionPoint ( arr , n , X ) :<br>    if X < arr [ 0 ] :<br>        return 0<br>    elif X > arr [ n - 1 ] :<br>        return n<br>    lower_pnt = 0<br>    i = 1<br>    while i < n and arr [ i ] < X :<br>        lower_pnt = i<br>        i = i * 2<br>    while lower_pnt < n and arr [ lower_pnt ] < X :<br>        lower_pnt += 1<br>    return lower_pnt<br></td>
  </tr><tr>
    <th>CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def constructPalin ( string , l ) :<br>    string = list ( string )<br>    i = - 1<br>    j = l<br>    while i < j :<br>        i += 1<br>        j -= 1<br>        if ( string [ i ] == string [ j ] and string [ i ] != '*' ) :<br>            continue<br>        elif ( string [ i ] == string [ j ] and string [ i ] == '*' ) :<br>            string [ i ] = 'a'<br>            string [ j ] = 'a'<br>            continue<br>        elif string [ i ] == '*' :<br>            string [ i ] = string [ j ]<br>            continue<br>        elif string [ j ] == '*' :<br>            string [ j ] = string [ i ]<br>            continue<br>        print ( "Not Possible" )<br>        return ""<br>    return ''.join ( string )<br></td>
    <td>translated code: <br><br> def constructPalin ( str , len ) :<br>    i , j = 0 , len - 1<br>    for i in range ( j ) :<br>        if str [ i ] == str [ j ] and str [ i ] != '*' :<br>            continue<br>        elif str [ i ] == str [ j ] and str [ i ] == '*' :<br>            str [ i ] = 'a'<br>            str [ j ] = 'a'<br>            continue<br>        elif str [ i ] == '*' :<br>            str [ i ] = str [ j ]<br>            continue<br>        elif str [ j ] == '*' :<br>            str [ j ] = str [ i ]<br>            continue<br>        print ( "Not Possible" )<br>        return ""<br>    return str<br></td>
  </tr><tr>
    <th>SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def section ( x1 , x2 , y1 , y2 , m , n ) :<br>    x = ( float ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n )<br>    y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n )<br>    print ( x , y )<br></td>
    <td>translated code: <br><br> def section ( x1 , x2 , y1 , y2 , m , n ) :<br>    x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n )<br>    y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n )<br>    print ( "(%f, %f)" % ( x , y ) )<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_NUMBER_USING_LOG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def squareRoot ( n ) :<br>    return pow ( 2 , 0.5 * math.log2 ( n ) )<br></td>
    <td>translated code: <br><br> def squared_root ( n ) :<br>    return math.pow ( 2 , 0.5 * ( math.log ( n ) / math.log ( 2 ) ) )<br></td>
  </tr><tr>
    <th>MAXIMIZE_SUM_ARRII</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSum ( arr , n ) :<br>    arr.sort ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ] * i<br>    return sum<br></td>
    <td>translated code: <br><br> def max_sum ( arr , n ) :<br>    arr.sort ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += ( arr [ i ] * i )<br>    return sum<br></td>
  </tr><tr>
    <th>STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findString ( n , k ) :<br>    res = ""<br>    for i in range ( k ) :<br>        res = res + chr ( ord ( 'a' ) + i )<br>    count = 0<br>    for i in range ( n - k ) :<br>        res = res + chr ( ord ( 'a' ) + count )<br>        count += 1<br>        if ( count == k ) :<br>            count = 0 <br>    return res<br></td>
    <td>translated code: <br><br> def findString ( n , k ) :<br>    res = ""<br>    for i in range ( k ) :<br>        res = res + chr ( ord ( 'a' ) + i )<br>    count = 0<br>    for i in range ( n - k ) :<br>        res = res + chr ( ord ( 'a' ) + count )<br>        count += 1<br>        if count == k :<br>            count = 0<br>    return res<br></td>
  </tr><tr>
    <th>COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWords ( str , l ) :<br>    count = 1 <br>    if ( l == 1 ) :<br>        return count<br>    if ( str [ 0 ] == str [ 1 ] ) :<br>        count *= 1<br>    else :<br>        count *= 2<br>    for j in range ( 1 , l - 1 ) :<br>        if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) :<br>            count *= 1<br>        elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) :<br>            count *= 2<br>        else :<br>            count *= 3<br>    if ( str [ l - 1 ] == str [ l - 2 ] ) :<br>        count *= 1<br>    else :<br>        count *= 2<br>    return count<br></td>
    <td>translated code: <br><br> def count_words ( str , len ) :<br>    count = 1<br>    if len == 1 :<br>        return count<br>    if str [ 0 ] == str [ 1 ] :<br>        count *= 1<br>    else :<br>        count *= 2<br>    for j in range ( 1 , len - 1 ) :<br>        if str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] :<br>            count *= 1<br>        elif str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] :<br>            count *= 2<br>        else :<br>            count *= 3<br>    if str [ len - 1 ] == str [ len - 2 ] :<br>        count *= 1<br>    else :<br>        count *= 2<br>    return count<br></td>
  </tr><tr>
    <th>NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minJumps ( a , b , d ) :<br>    temp = a<br>    a = min ( a , b )<br>    b = max ( temp , b )<br>    if ( d >= b ) :<br>        return ( d + b - 1 ) / b<br>    if ( d == 0 ) :<br>        return 0<br>    if ( d == a ) :<br>        return 1<br>    return 2<br></td>
    <td>translated code: <br><br> def minJumps ( a , b , d ) :<br>    temp = a<br>    a = min ( a , b )<br>    b = max ( temp , b )<br>    if d >= b :<br>        return ( d + b - 1 ) // b<br>    if d == 0 :<br>        return 0<br>    if d == a :<br>        return 1<br>    return 2<br></td>
  </tr><tr>
    <th>SUM_FACTORS_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumofFactors ( n ) :<br>    res = 1<br>    for i in range ( 2 , int ( m.sqrt ( n ) + 1 ) ) :<br>        curr_sum = 1<br>        curr_term = 1<br>        while n % i == 0 :<br>            n = n / i <br>            curr_term = curr_term * i <br>            curr_sum += curr_term <br>        res = res * curr_sum<br>    if n > 2 :<br>        res = res * ( 1 + n )<br>    return res <br></td>
    <td>translated code: <br><br> def sumof_factors ( n ) :<br>    res = 1<br>    for i in range ( 2 , math.sqrt ( n ) ) :<br>        curr_sum = 1<br>        curr_term = 1<br>        while n % i == 0 :<br>            n = n // i<br>            curr_term *= i<br>            curr_sum += curr_term<br>        res *= curr_sum<br>    if n > 2 :<br>        res *= ( 1 + n )<br>    return res<br></td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def removeConsecutiveSame ( v ) :<br>    n = len ( v )<br>    i = 0<br>    while ( i < n - 1 ) :<br>        if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) :<br>            v = v [ : i ]<br>            v = v [ : i ]<br>            if ( i > 0 ) :<br>                i -= 1<br>            n = n - 2<br>        else :<br>            i += 1<br>    return len ( v [ : i - 1 ] )<br></td>
    <td>translated code: <br><br> def removeConsecutiveSame ( v ) :<br>    n = len ( v )<br>    for i in range ( n - 1 ) :<br>        if v [ i ] == v [ i + 1 ] :<br>            v.pop ( i )<br>            v.pop ( i )<br>            if i > 0 :<br>                i -= 1<br>            n = n - 2<br>        else :<br>            i += 1<br>    return len ( v )<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countStrings ( n ) :<br>    a = [ 0 for i in range ( n ) ]<br>    b = [ 0 for i in range ( n ) ]<br>    a [ 0 ] = b [ 0 ] = 1<br>    for i in range ( 1 , n ) :<br>        a [ i ] = a [ i - 1 ] + b [ i - 1 ]<br>        b [ i ] = a [ i - 1 ]<br>    return a [ n - 1 ] + b [ n - 1 ]<br></td>
    <td>translated code: <br><br> def countStrings ( n ) :<br>    a = [ ]<br>    b = [ ]<br>    a.append ( b.append = 1 )<br>    for i in range ( 1 , n ) :<br>        a.append ( a [ i - 1 ] + b [ i - 1 ] )<br>        b.append ( a [ i - 1 ] )<br>    return a.append ( b )<br></td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMissingNo ( A ) :<br>    n = len ( A )<br>    total = ( n + 1 ) * ( n + 2 ) / 2<br>    sum_of_A = sum ( A )<br>    return total - sum_of_A<br></td>
    <td>translated code: <br><br> def getMissingNo ( a , n ) :<br>    i , total = ( n + 1 ) * ( n + 2 ) / 2<br>    for i in range ( n ) :<br>        total -= a [ i ]<br>    return total<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def squareRoot ( n ) :<br>    x = n<br>    y = 1<br>    e = 0.000001<br>    while ( x - y > e ) :<br>        x = ( x + y ) / 2<br>        y = n / x<br>    return x<br></td>
    <td>translated code: <br><br> def squareRoot ( n ) :<br>    x = n<br>    y = 1<br>    e = 0.000001<br>    while x - y > e :<br>        x = ( x + y ) / 2<br>        y = n / x<br>    return x<br></td>
  </tr><tr>
    <th>SUBSET_SUM_PROBLEM_OSUM_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubsetSum ( arr , n , sum ) :<br>    subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ]<br>    for i in range ( n + 1 ) :<br>        for j in range ( sum + 1 ) :<br>            if ( j == 0 ) :<br>                subset [ i % 2 ] [ j ] = True<br>            elif ( i == 0 ) :<br>                subset [ i % 2 ] [ j ] = False<br>            elif ( arr [ i - 1 ] <= j ) :<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ]<br>            else :<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]<br>    return subset [ n % 2 ] [ sum ]<br></td>
    <td>translated code: <br><br> def isSubsetSum ( arr , n , sum ) :<br>    subset = [ [ ] for i in range ( 0 , n + 1 ) ]<br>    for i in range ( 0 , sum + 1 ) :<br>        for j in range ( 0 , sum + 1 ) :<br>            if j == 0 :<br>                subset [ i % 2 ] [ j ] = True<br>            elif i == 0 :<br>                subset [ i % 2 ] [ j ] = False<br>            elif arr [ i - 1 ] <= j :<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ]<br>            else :<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ]<br>    return subset [ n % 2 ] [ sum ]<br></td>
  </tr><tr>
    <th>MULTIPLICATIVE_INVERSE_UNDER_MODULO_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def modInverse ( a , m ) :<br>    a = a % m <br>    for x in range ( 1 , m ) :<br>        if ( ( a * x ) % m == 1 ) :<br>            return x<br>    return 1<br></td>
    <td>translated code: <br><br> def mod_inverse ( a , m ) :<br>    a = a % m<br>    for x in range ( 1 , m ) :<br>        if ( a * x ) % m == 1 :<br>            return x<br>    return 1<br></td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def compute_average ( a , b ) :<br>    return floor ( ( a + b ) / 2 )<br></td>
    <td>translated code: <br><br> def compute_average ( a , b ) :<br>    return ( a + b ) / 2<br></td>
  </tr><tr>
    <th>REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bestApproximate ( x , y , n ) :<br>    sum_x = 0<br>    sum_y = 0<br>    sum_xy = 0<br>    sum_x2 = 0<br>    for i in range ( 0 , n ) :<br>        sum_x += x [ i ]<br>        sum_y += y [ i ]<br>        sum_xy += x [ i ] * y [ i ]<br>        sum_x2 += pow ( x [ i ] , 2 )<br>    m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) <br>    c = ( float ) ( sum_y - m * sum_x ) / n <br>    print ( "m = " , m ) <br>    print ( "c = " , c ) <br></td>
    <td>translated code: <br><br> def best_approximate ( x , y ) :<br>    n = len ( x )<br>    m , c , sum_x , sum_y , sum_xy , sum_x2 = 0 , 0 , 0 , 0 , 0<br>    for i in range ( n ) :<br>        sum_x += x [ i ]<br>        sum_y += y [ i ]<br>        sum_xy += x [ i ] * y [ i ]<br>        sum_x2 += pow ( x [ i ] , 2 )<br>    m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) )<br>    c = ( sum_y - m * sum_x ) / n<br>    print ( 'm = %f' % m )<br>    print ( 'c = %f' % c )<br></td>
  </tr><tr>
    <th>SPLIT_ARRAY_ADD_FIRST_PART_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def splitArr ( arr , n , k ) :<br>    for i in range ( 0 , k ) :<br>        x = arr [ 0 ]<br>        for j in range ( 0 , n - 1 ) :<br>            arr [ j ] = arr [ j + 1 ]<br>        arr [ n - 1 ] = x<br></td>
    <td>translated code: <br><br> def split_arr ( arr , n , k ) :<br>    for i in range ( k ) :<br>        x = arr [ 0 ]<br>        for j in range ( n - 1 ) :<br>            arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ]<br>        arr [ n - 1 ] , arr [ n - 1 ] = x , arr [ n - 1 ]<br></td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDiff ( arr , n ) :<br>    SubsetSum_1 = 0<br>    SubsetSum_2 = 0<br>    for i in range ( 0 , n ) :<br>        isSingleOccurance = True<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ i ] == arr [ j ] ) :<br>                isSingleOccurance = False<br>                arr [ i ] = arr [ j ] = 0<br>                break<br>        if ( isSingleOccurance == True ) :<br>            if ( arr [ i ] > 0 ) :<br>                SubsetSum_1 += arr [ i ]<br>            else :<br>                SubsetSum_2 += arr [ i ]<br>    return abs ( SubsetSum_1 - SubsetSum_2 )<br></td>
    <td>translated code: <br><br> def maxDiff ( arr , n ) :<br>    SubsetSum_1 , SubsetSum_2 = 0 , 0<br>    for i in range ( 0 , n - 1 ) :<br>        is_single_occurrence = True<br>        for j in range ( i + 1 , n - 1 ) :<br>            if arr [ i ] == arr [ j ] :<br>                is_single_occurrence = False<br>                arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ]<br>                break<br>        if is_single_occurrence :<br>            if arr [ i ] > 0 :<br>                SubsetSum_1 += arr [ i ]<br>            else :<br>                SubsetSum_2 += arr [ i ]<br>    return abs ( SubsetSum_1 - SubsetSum_2 )<br></td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longLenSub ( arr , n ) :<br>    um = defaultdict ( lambda : 0 )<br>    longLen = 0<br>    for i in range ( n ) :<br>        len1 = 0<br>        if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) :<br>            len1 = um [ arr [ i ] - 1 ]<br>        if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) :<br>            len1 = um [ arr [ i ] + 1 ]<br>        um [ arr [ i ] ] = len1 + 1<br>        if longLen < um [ arr [ i ] ] :<br>            longLen = um [ arr [ i ] ]<br>    return longLen<br></td>
    <td>translated code: <br><br> def longLenSub ( arr , n ) :<br>    um = { }<br>    longLen = 0<br>    for i in range ( n ) :<br>        len = 0<br>        if um.has_key ( arr [ i ] - 1 ) and len < um [ arr [ i ] - 1 ] :<br>            len = um [ arr [ i ] - 1 ]<br>        if um.has_key ( arr [ i ] + 1 ) and len < um [ arr [ i ] + 1 ] :<br>            len = um [ arr [ i ] + 1 ]<br>        um [ arr [ i ] ] = len + 1<br>        if longLen < um [ arr [ i ] ] :<br>            longLen = um [ arr [ i ] ]<br>    return longLen<br></td>
  </tr><tr>
    <th>LONGEST_REPEATED_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestRepeatedSubSeq ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) :<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    res = ''<br>    i = n<br>    j = n<br>    while ( i > 0 and j > 0 ) :<br>        if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) :<br>            res += str [ i - 1 ]<br>            i -= 1<br>            j -= 1<br>        elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :<br>            i -= 1<br>        else :<br>            j -= 1<br>    res = ''.join ( reversed ( res ) )<br>    return res<br></td>
    <td>translated code: <br><br> def longest_repeated_subseq ( str ) :<br>    n = len ( str )<br>    dp = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0</td>
  </tr><tr>
    <th>FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRandomIndexOfMax ( arr , n ) :<br>    mp = dict ( )<br>    for i in range ( n ) :<br>        if ( arr [ i ] in mp ) :<br>            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1<br>        else :<br>            mp [ arr [ i ] ] = 1<br>    max_element = - 323567<br>    max_so_far = - 323567<br>    for p in mp :<br>        if ( mp [ p ] > max_so_far ) :<br>            max_so_far = mp [ p ]<br>            max_element = p<br>    r = int ( ( ( random.randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) )<br>    i = 0<br>    count = 0<br>    while ( i < n ) :<br>        if ( arr [ i ] == max_element ) :<br>            count = count + 1<br>        if ( count == r ) :<br>            print ( "Element with maximum frequency present at index " , i )<br>            break<br>        i = i + 1<br></td>
    <td>translated code: <br><br> def find_random_index_of_max ( arr , n ) :<br>    mp = { }<br>    for i in range ( n ) :<br>        if mp.has_key ( arr [ i ] ) :<br>            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1<br>        else :<br>            mp [ arr [ i ] ] = 1<br>    max_element = int ( '-1' )<br>    max_so_far = int ( '-1' )<br>    for p , q in mp.items ( ) :<br>        if q > max_so_far :<br>            max_so_far = q<br>            max_element = p<br>    r = int ( ( random.random ( ) * max_so_far ) + 1 )<br>    for i , count in enumerate ( arr ) :<br>        if arr [ i ] == max_element :<br>            count += 1<br>        if count == r :<br>            print ( 'Element with maximum frequency present ' 'at index %d' % i )<br>            break<br></td>
  </tr><tr>
    <th>CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPerfectSquare ( n ) :<br>    i = 1<br>    the_sum = 0<br>    while the_sum < n :<br>        the_sum += i<br>        if the_sum == n :<br>            return True<br>        i += 2<br>    return False<br></td>
    <td>translated code: <br><br> def is_perfect_square ( n ) :<br>    for sum , i in itertools.combinations ( range ( 1 , n + 1 ) , 2 ) :<br>        sum += i<br>        if sum == n :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>N_BONACCI_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bonacciseries ( n , m ) :<br>    a = [ 0 for i in range ( m ) ]<br>    a [ n - 1 ] = 1<br>    a [ n ] = 1<br>    for i in range ( n + 1 , m ) :<br>        a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]<br>    for i in range ( 0 , m ) :<br>        print ( a [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def bonacci_series ( n , m ) :<br>    a = [ 0 ] * m<br>    a [ n - 1 ] = 1<br>    a [ n ] = 1<br>    for i in range ( n + 1 , m ) :<br>        a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]<br>    for i in range ( m ) :<br>        print ( a [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPairs ( arr , n ) :<br>    mp = dict ( )<br>    for i in range ( n ) :<br>        if arr [ i ] in mp.keys ( ) :<br>            mp [ arr [ i ] ] += 1<br>        else :<br>            mp [ arr [ i ] ] = 1<br>    ans = 0<br>    for it in mp :<br>        count = mp [ it ]<br>        ans += ( count * ( count - 1 ) ) // 2<br>    return ans<br></td>
    <td>translated code: <br><br> def count_pairs ( arr , n ) :<br>    hm = { }<br>    for i in range ( n ) :<br>        if hm.has_key ( arr [ i ] ) :<br>            hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1<br>        else :<br>            hm [ arr [ i ] ] = 1<br>    ans = 0<br>    for key , count in hm.items ( ) :<br>        ans += ( count * ( count - 1 ) ) / 2<br>    return ans<br></td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def bitonicGenerator ( arr , n ) :<br>    evenArr = [ ]<br>    oddArr = [ ]<br>    for i in range ( n ) :<br>        if ( ( i % 2 ) == 0 ) :<br>            evenArr.append ( arr [ i ] )<br>        else :<br>            oddArr.append ( arr [ i ] )<br>    evenArr = sorted ( evenArr )<br>    oddArr = sorted ( oddArr )<br>    oddArr = oddArr [ : : - 1 ]<br>    i = 0<br>    for j in range ( len ( evenArr ) ) :<br>        arr [ i ] = evenArr [ j ]<br>        i += 1<br>    for j in range ( len ( oddArr ) ) :<br>        arr [ i ] = oddArr [ j ]<br>        i += 1<br></td>
    <td>translated code: <br><br> def bitonic_generator ( arr , n ) :<br>    evenArr = [ ]<br>    oddArr = [ ]<br>    for i in range ( n ) :<br>        if i % 2 != 1 :<br>            evenArr.append ( arr [ i ] )<br>        else :<br>            oddArr.append ( arr [ i ] )<br>    evenArr.sort ( )<br>    oddArr.sort ( )<br>    i = 0<br>    for j in evenArr :<br>        arr [ i ] = evenArr [ j ]<br>    for j in oddArr :<br>        arr [ i ] = oddArr [ j ]<br>    return arr<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def binomialCoeff ( n , k ) :<br>    if k == 0 or k == n :<br>        return 1<br>    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k )<br></td>
    <td>translated code: <br><br> def binomial_coeff ( n , k ) :<br>    if k == 0 or k == n :<br>        return 1<br>    return binomial_coeff ( n - 1 , k - 1 ) + binomial_coeff ( n - 1 , k )<br></td>
  </tr><tr>
    <th>WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getParity ( n ) :<br>    parity = 0<br>    while n :<br>        parity = ~ parity<br>        n = n & ( n - 1 )<br>    return parity<br></td>
    <td>translated code: <br><br> def getParity ( n ) :<br>    parity = False<br>    while n != 0 :<br>        parity = not parity<br>        n = n & ( n - 1 )<br>    return parity<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isdivisible7 ( num ) :<br>    n = len ( num )<br>    if ( n == 0 and num [ 0 ] == '\n' ) :<br>        return 1<br>    if ( n % 3 == 1 ) :<br>        num = str ( num ) + "00"<br>        n += 2<br>    elif ( n % 3 == 2 ) :<br>        num = str ( num ) + "0"<br>        n += 1<br>    GSum = 0<br>    p = 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        group = 0<br>        group += ord ( num [ i ] ) - ord ( '0' )<br>        i -= 1<br>        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10<br>        i -= 1<br>        group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100<br>        GSum = GSum + group * p<br>        p *= ( - 1 )<br>    return ( GSum % 7 == 0 )<br></td>
    <td>translated code: <br><br> def isDivisible7 ( num ) :<br>    n = len ( num )<br>    if n == 0 and num [ 0 ] == '0' :<br>        return True<br>    if n % 3 == 1 :<br>        num = '00' + num<br>    if n % 3 == 2 :<br>        num = '0' + num<br>    n = len ( num )<br>    gSum , p = 0 , 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        group = 0<br>        group += num [ i ] - '0'<br>        group += ( num [ i ] - '0' ) * 10<br>        group += ( num [ i ] - '0' ) * 100<br>        gSum = gSum + group * p<br>        p = p * - 1<br>    return ( gSum % 7 == 0 )<br></td>
  </tr><tr>
    <th>PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def productAtKthLevel ( tree , k ) :<br>    level = - 1<br>    product = 1<br>    n = len ( tree )<br>    for i in range ( 0 , n ) :<br>        if ( tree [ i ] == '(' ) :<br>            level += 1<br>        elif ( tree [ i ] == ')' ) :<br>            level -= 1<br>        else :<br>            if ( level == k ) :<br>                product *= ( int ( tree [ i ] ) - int ( '0' ) )<br>    return product<br></td>
    <td>translated code: <br><br> def product_at_kth_level ( tree , k ) :<br>    level = - 1<br>    product = 1<br>    n = len ( tree )<br>    for i in range ( n ) :<br>        if tree [ i ] == '(' :<br>            level += 1<br>        elif tree [ i ] == ')' :<br>            level -= 1<br>        else :<br>            if level == k :<br>                product *= ( tree [ i ] - '0' )<br>    return product<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isEven ( n ) :<br>    return ( n % 2 == 0 )<br></td>
    <td>translated code: <br><br> def is_even ( n ) :<br>    return ( n % 2 == 0 )<br></td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countGroups ( position , previous_sum , length , num ) :<br>    if ( position == length ) :<br>        return 1<br>    res = 0<br>    sum = 0<br>    for i in range ( position , length ) :<br>        sum = sum + int ( num [ i ] )<br>        if ( sum >= previous_sum ) :<br>            res = res + countGroups ( i + 1 , sum , length , num )<br>    return res<br></td>
    <td>translated code: <br><br> def countGroups ( position , previous_sum , length , num ) :<br>    if position == length :<br>        return 1<br>    res = 0<br>    sum = 0<br>    for i in range ( position , length ) :<br>        sum += ( num [ i ] - '0' )<br>        if sum >= previous_sum :<br>            res += countGroups ( i + 1 , sum , length , num )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( arr , low , high ) :<br>    if low > high :<br>        return None<br>    if low == high :<br>        return arr [ low ]<br>    mid = ( low + high ) / 2 <br>    if mid % 2 == 0 :<br>        if arr [ mid ] == arr [ mid + 1 ] :<br>            return search ( arr , mid + 2 , high )<br>        else :<br>            return search ( arr , low , mid )<br>    else :<br>        if arr [ mid ] == arr [ mid - 1 ] :<br>            return search ( arr , mid + 1 , high )<br>        else :<br>            return search ( arr , low , mid - 1 )<br></td>
    <td>translated code: <br><br> def search ( arr , low , high ) :<br>    if low > high :<br>        return<br>    if low == high :<br>        print ( "The required element is " + str ( arr [ low ] ) + " " )<br>        return<br>    mid = ( low + high ) // 2<br>    if mid % 2 == 0 :<br>        if arr [ mid ] == arr [ mid + 1 ] :<br>            search ( arr , mid + 2 , high )<br>        else :<br>            search ( arr , low , mid )<br>    else :<br>        if arr [ mid ] == arr [ mid - 1 ] :<br>            search ( arr , mid + 1 , high )<br>        else :<br>            search ( arr , low , mid - 1 )<br></td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def removeConsecutiveSame ( v ) :<br>    st = [ ]<br>    for i in range ( len ( v ) ) :<br>        if ( len ( st ) == 0 ) :<br>            st.append ( v [ i ] )<br>        else :<br>            Str = st [ - 1 ]<br>            if ( Str == v [ i ] ) :<br>                st.pop ( )<br>            else :<br>                st.append ( v [ i ] )<br>    return len ( st )<br></td>
    <td>translated code: <br><br> def removeConsecutiveSame ( v ) :<br>    st = [ ]<br>    for i in range ( len ( v ) ) :<br>        if st == [ ] :<br>            st.append ( v [ i ] )<br>        else :<br>            str = st.pop ( )<br>            if str == v [ i ] :<br>                st.pop ( )<br>            else :<br>                st.append ( v [ i ] )<br>    return len ( st )<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minJumps ( arr , n ) :<br>    jumps = [ 0 for i in range ( n ) ]<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if ( arr [ i ] == 0 ) :<br>            jumps [ i ] = float ( 'inf' )<br>        elif ( arr [ i ] >= n - i - 1 ) :<br>            jumps [ i ] = 1<br>        else :<br>            min = float ( 'inf' )<br>            for j in range ( i + 1 , n ) :<br>                if ( j <= arr [ i ] + i ) :<br>                    if ( min > jumps [ j ] ) :<br>                        min = jumps [ j ]<br>            if ( min != float ( 'inf' ) ) :<br>                jumps [ i ] = min + 1<br>            else :<br>                jumps [ i ] = min<br>    return jumps [ 0 ]<br></td>
    <td>translated code: <br><br> def minJumps ( arr , n ) :<br>    jumps = [ ]<br>    min = None<br>    jumps.append ( 0 )<br>    for i in range ( n - 2 , - 1 , - 1 ) :<br>        if arr [ i ] == 0 :<br>            jumps.append ( int ( arr [ i ] ) )<br>        elif arr [ i ] >= n - i - 1 :<br>            jumps.append ( 1 )<br>        else :<br>            min = int ( arr [ i ] )<br>            for j in range ( i + 1 , n and j <= arr [ i ] + i ) :<br>                if min > jumps [ j ] :<br>                    min = jumps [ j ]<br>            if min != int ( arr [ i ] ) :<br>                jumps.append ( min + 1 )<br>            else :<br>                jumps.append ( min )<br>    return jumps [ 0 ]<br></td>
  </tr><tr>
    <th>PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gcd ( a , b ) :<br>    if ( a < b ) :<br>        return gcd ( b , a )<br>    if ( abs ( b ) < 0.001 ) :<br>        return a<br>    else :<br>        return ( gcd ( b , a - math.floor ( a / b ) * b ) )<br></td>
    <td>translated code: <br><br> def gcd ( a , b ) :<br>    if a < b :<br>        return gcd ( b , a )<br>    if abs ( b ) < 0.001 :<br>        return a<br>    else :<br>        return ( gcd ( b , a - floor ( a / b ) * b ) )<br></td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxProfit ( price , n ) :<br>    profit = [ 0 ] * n<br>    max_price = price [ n - 1 ]<br>    for i in range ( n - 2 , 0 , - 1 ) :<br>        if price [ i ] > max_price :<br>            max_price = price [ i ]<br>        profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] )<br>    min_price = price [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if price [ i ] < min_price :<br>            min_price = price [ i ]<br>        profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) )<br>    result = profit [ n - 1 ]<br>    return result<br></td>
    <td>translated code: <br><br> def max_profit ( price , n ) :<br>    profit = [ 0 ] * n<br>    max_price = price [ n - 1 ]<br>    for i in range ( n - 1 ) :<br>        if price [ i ] > max_price :<br>            max_price = price [ i ]<br>        profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] )<br>    min_price = price [ 0 ]<br>    for i in range ( 1 , n ) :<br>        if price [ i ] < min_price :<br>            min_price = price [ i ]<br>        profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) )<br>    result = profit [ n - 1 ]<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSetBits ( n ) :<br>    if ( n == 0 ) :<br>        return 0<br>    else :<br>        return ( n & 1 ) + countSetBits ( n >> 1 )<br></td>
    <td>translated code: <br><br> def count_set_bits ( n ) :<br>    if n == 0 :<br>        return 0<br>    else :<br>        return ( n & 1 ) + count_set_bits ( n >> 1 )<br></td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def reorder ( arr , index , n ) :<br>    temp = [ 0 ] * n <br>    for i in range ( 0 , n ) :<br>        temp [ index [ i ] ] = arr [ i ]<br>    for i in range ( 0 , n ) :<br>        arr [ i ] = temp [ i ]<br>        index [ i ] = i<br></td>
    <td>translated code: <br><br> def reorder ( ) :<br>    temp = [ ]<br>    for i in range ( len ( arr ) ) :<br>        temp.append ( index [ i ] )<br>    for i in range ( len ( arr ) ) :<br>        arr [ i ] = temp [ i ]<br>        index [ i ] = i<br></td>
  </tr><tr>
    <th>CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def canRepresentBST ( pre ) :<br>    s = [ ]<br>    root = INT_MIN<br>    for value in pre :<br>        if value < root :<br>            return False<br>        while ( len ( s ) > 0 and s [ - 1 ] < value ) :<br>            root = s.pop ( )<br>        s.append ( value )<br>    return True<br></td>
    <td>translated code: <br><br> def can_representBST ( pre , n ) :<br>    s = Stack ( )<br>    root = int ( '-1' )<br>    for i in range ( n ) :<br>        if pre [ i ] < root :<br>            return False<br>        while not s.empty ( ) and s.peek ( ) < pre [ i ] :<br>            root = s.pop ( )<br>            s.pop ( )<br>        s.push ( pre [ i ] )<br>    return True<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRepeating ( arr , n ) :<br>    missingElement = 0<br>    for i in range ( 0 , n ) :<br>        element = arr [ abs ( arr [ i ] ) ]<br>        if ( element < 0 ) :<br>            missingElement = arr [ i ]<br>            break<br>        arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]<br>    return abs ( missingElement )<br></td>
    <td>translated code: <br><br> def find_repeated ( arr , n ) :<br>    missing_element = 0<br>    for i in range ( n ) :<br>        element = arr [ abs ( arr [ i ] ) ]<br>        if element < 0 :<br>            missing_element = arr [ i ]<br>            break<br>        arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ]<br>    return abs ( missing_element )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MatrixChainOrder ( p , n ) :<br>    m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]<br>    for i in range ( 1 , n ) :<br>        m [ i ] [ i ] = 0<br>    for L in range ( 2 , n ) :<br>        for i in range ( 1 , n - L + 1 ) :<br>            j = i + L - 1<br>            m [ i ] [ j ] = sys.maxint<br>            for k in range ( i , j ) :<br>                q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ]<br>                if q < m [ i ] [ j ] :<br>                    m [ i ] [ j ] = q<br>    return m [ 1 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def MatrixChainOrder ( p , n ) :<br>    m = [ [ ] for i in range ( n ) ]<br>    i , j , k , L , q = 0 , 0 , 0 , 0<br>    for i in range ( 1 , n ) :<br>        m [ i ] [ i ] = 0<br>    for L in range ( 2 , n ) :<br>        for i in range ( 1 , n - L + 1 ) :<br>            j = i + L - 1<br>            if j == n :<br>                continue<br>            m [ i ] [ j ] = int ( m [ i ] [ j ] )<br>            for k in range ( i , j - 1 ) :<br>                q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ]<br>                if q < m [ i ] [ j ] :<br>                    m [ i ] [ j ] = q<br>    return m [ 1 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countIslands ( mat ) :<br>    count = 0 <br>    for i in range ( 0 , M ) :<br>        for j in range ( 0 , N ) :<br>            if ( mat [ i ] [ j ] == 'X' ) :<br>                if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) and ( j == 0 or mat [ i ] [ j - 1 ] == 'O' ) ) :<br>                    count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def countIslands ( mat , m , n ) :<br>    count = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if mat [ i ] [ j ] == 'X' :<br>                if ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) :<br>                    count += 1<br>    return count<br></td>
  </tr><tr>
    <th>MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solve ( A , B , C ) :<br>    i = len ( A ) - 1<br>    j = len ( B ) - 1<br>    k = len ( C ) - 1<br>    min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) )<br>    while i != - 1 and j != - 1 and k != - 1 :<br>        current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) )<br>        if current_diff < min_diff :<br>            min_diff = current_diff<br>        max_term = max ( A [ i ] , B [ j ] , C [ k ] )<br>        if A [ i ] == max_term :<br>            i -= 1<br>        elif B [ j ] == max_term :<br>            j -= 1<br>        else :<br>            k -= 1<br>    return min_diff<br></td>
    <td>translated code: <br><br> def solve ( A , B , C ) :<br>    i , j , k = A.shape<br>    min_diff , current_diff , max_term = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) )<br>    while i != - 1 and j != - 1 and k != - 1 :<br>        current_diff , current_term = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) )<br>        if current_diff < min_diff :<br>            min_diff = current_diff<br>        max_term , current_term = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) )<br>        if A [ i ] == max_term :<br>            i -= 1<br>        elif B [ j ] == max_term :<br>            j -= 1<br>        else :<br>            k -= 1<br>    return min_diff , current_diff , max_term<br></td>
  </tr><tr>
    <th>ROOTS_QUADRATIC_EQUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findRoots ( a , b , c ) :<br>    if a == 0 :<br>        print ( "Invalid" )<br>        return - 1<br>    d = b * b - 4 * a * c<br>    sqrt_val = math.sqrt ( abs ( d ) )<br>    if d > 0 :<br>        print ( "Roots are real and different " )<br>        print ( ( - b + sqrt_val ) / ( 2 * a ) )<br>        print ( ( - b - sqrt_val ) / ( 2 * a ) )<br>    elif d == 0 :<br>        print ( "Roots are real and same" )<br>        print ( - b / ( 2 * a ) )<br>    else :<br>        print ( "Roots are complex" )<br>        print ( - b / ( 2 * a ) , " + i" , sqrt_val )<br>        print ( - b / ( 2 * a ) , " - i" , sqrt_val )<br></td>
    <td>translated code: <br><br> def findRoots ( a , b , c ) :<br>    if a == 0 :<br>        print ( "Invalid" )<br>        return<br>    d = b ** 2 - 4 * a * c<br>    sqrt_val = sqrt ( abs ( d ) )<br>    if d > 0 :<br>        print ( "Roots are real and different \n" )<br>        print ( float ( - b + sqrt_val ) / ( 2 * a ) + "\n" + float ( - b - sqrt_val ) / ( 2 * a ) )<br>    else :<br>        print ( "Roots are complex \n" )<br>        print ( - float ( b / ( 2 * a ) ) + " + i" + sqrt_val + "\n" + - float ( b / ( 2 * a ) ) + " - i" + sqrt_val )<br></td>
  </tr><tr>
    <th>GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isMinHeap ( level , n ) :<br>    for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) :<br>        if level [ i ] > level [ 2 * i + 1 ] :<br>            return False<br>        if 2 * i + 2 < n :<br>            if level [ i ] > level [ 2 * i + 2 ] :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def isMinHeap ( level ) :<br>    n = len ( level ) - 1<br>    for i in range ( ( n // 2 - 1 ) , - 1 , - 1 ) :<br>        if level [ i ] > level [ 2 * i + 1 ] :<br>            return False<br>        if 2 * i + 2 < n :<br>            if level [ i ] > level [ 2 * i + 2 ] :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMin ( arr , low , high ) :<br>    if high < low :<br>        return arr [ 0 ]<br>    if high == low :<br>        return arr [ low ]<br>    mid = int ( ( low + high ) / 2 )<br>    if mid < high and arr [ mid + 1 ] < arr [ mid ] :<br>        return arr [ mid + 1 ]<br>    if mid > low and arr [ mid ] < arr [ mid - 1 ] :<br>        return arr [ mid ]<br>    if arr [ high ] > arr [ mid ] :<br>        return findMin ( arr , low , mid - 1 )<br>    return findMin ( arr , mid + 1 , high )<br></td>
    <td>translated code: <br><br> def findMin ( arr , low , high ) :<br>    if high < low :<br>        return arr [ 0 ]<br>    if high == low :<br>        return arr [ low ]<br>    mid = low + ( high - low ) // 2<br>    if mid < high and arr [ mid + 1 ] < arr [ mid ] :<br>        return arr [ mid + 1 ]<br>    if mid > low and arr [ mid ] < arr [ mid - 1 ] :<br>        return arr [ mid ]<br>    if arr [ high ] > arr [ mid ] :<br>        return findMin ( arr , low , mid - 1 )<br>    return findMin ( arr , mid + 1 , high )<br></td>
  </tr><tr>
    <th>SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTINCT_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def stringReduction ( str ) :<br>    n = len ( str )<br>    count = [ 0 ] * 3<br>    for i in range ( n ) :<br>        count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1<br>    if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) :<br>        return n<br>    if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) :<br>        return 2<br>    return 1<br></td>
    <td>translated code: <br><br> def stringReduction ( str ) :<br>    n = len ( str )<br>    count = [ 0 ] * 3<br>    for i in range ( n ) :<br>        count [ str [ i ] - 'a' ] += 1<br>    if count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n :<br>        return n<br>    if ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) :<br>        return 2<br>    return 1<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( num ) :<br>    digitSum = 0<br>    while num > 0 :<br>        rem = num % 10<br>        digitSum = digitSum + rem<br>        num = num / 10<br>    return ( digitSum % 3 == 0 )<br></td>
    <td>translated code: <br><br> def check ( str ) :<br>    n = len ( str )<br>    digitSum = 0<br>    for i in range ( n ) :<br>        digitSum += ( str [ i ] - '0' )<br>    return ( digitSum % 3 == 0 )<br></td>
  </tr><tr>
    <th>COMPUTE_N_UNDER_MODULO_P</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def modFact ( n , p ) :<br>    if n >= p :<br>        return 0<br>    result = 1<br>    for i in range ( 1 , n + 1 ) :<br>        result = ( result * i ) % p<br>    return result<br></td>
    <td>translated code: <br><br> def mod_fact ( n , p ) :<br>    if n >= p :<br>        return 0<br>    result = 1<br>    for i in range ( 1 , n + 1 ) :<br>        result = ( result * i ) % p<br>    return result<br></td>
  </tr><tr>
    <th>POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPresent ( s , q ) :<br>    freq = [ 0 ] * MAX_CHAR<br>    for i in range ( 0 , len ( s ) ) :<br>        freq [ ord ( s [ i ] ) ] += 1<br>    for i in range ( 0 , len ( q ) ) :<br>        freq [ ord ( q [ i ] ) ] -= 1<br>        if ( freq [ ord ( q [ i ] ) ] < 0 ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isPresent ( s , q ) :<br>    freq = [ 0 ] * MAX_CHAR<br>    for c in s :<br>        freq [ c ] += 1<br>    for c in q :<br>        freq [ c ] -= 1<br>        if freq [ c ] < 0 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextPowerOf2 ( n ) :<br>    p = 1<br>    if ( n and not ( n & ( n - 1 ) ) ) :<br>        return n<br>    while ( p < n ) :<br>        p <<= 1<br>    return p <br></td>
    <td>translated code: <br><br> def next_power_of_2 ( n ) :<br>    p = 1<br>    if n and ( n & ( n - 1 ) ) == 0 :<br>        return n<br>    while p < n :<br>        p <<= 1<br>    return p<br></td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def reorder ( arr , index , n ) :<br>    for i in range ( 0 , n ) :<br>        while ( index [ i ] != i ) :<br>            oldTargetI = index [ index [ i ] ]<br>            oldTargetE = arr [ index [ i ] ]<br>            arr [ index [ i ] ] = arr [ i ]<br>            index [ index [ i ] ] = index [ i ]<br>            index [ i ] = oldTargetI<br>            arr [ i ] = oldTargetE<br></td>
    <td>translated code: <br><br> def reorder ( ) :<br>    for i in range ( len ( arr ) ) :<br>        while index [ i ] != i :<br>            old_target_i = index [ index [ i ] ]<br>            old_target_e = ord ( arr [ index [ i ] ] )<br>            arr [ index [ i ] ] = arr [ i ]<br>            index [ index [ i ] ] = index [ i ]<br>            index [ i ] = old_target_i<br>            arr [ i ] = old_target_e<br></td>
  </tr><tr>
    <th>UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def unboundedKnapsack ( W , n , val , wt ) :<br>    dp = [ 0 for i in range ( W + 1 ) ]<br>    ans = 0<br>    for i in range ( W + 1 ) :<br>        for j in range ( n ) :<br>            if ( wt [ j ] <= i ) :<br>                dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] )<br>    return dp [ W ]<br></td>
    <td>translated code: <br><br> def _unboundedKnapsack ( W , n , val , wt ) :<br>    dp = [ 0 ] * ( W + 1 )<br>    for i in range ( 0 , W + 1 ) :<br>        for j in range ( 0 , n ) :<br>            if wt [ j ] <= i :<br>                dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] )<br>    return dp [ W ]<br></td>
  </tr><tr>
    <th>PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isDiagonalMatrix ( mat ) :<br>    for i in range ( 0 , N ) :<br>        for j in range ( 0 , N ) :<br>            if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def isDiagonalMatrix ( mat ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            if ( i != j ) :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxRemoval ( arr , n ) :<br>    count = 0<br>    cummulative_sum = 0<br>    arr.sort ( )<br>    for i in range ( n ) :<br>        if arr [ i ] >= cummulative_sum :<br>            count += 1<br>            cummulative_sum += arr [ i ]<br>    return count<br></td>
    <td>translated code: <br><br> def max_removal ( arr , n ) :<br>    count = 0<br>    cummulative_sum = 0<br>    arr.sort ( )<br>    for i in range ( n ) :<br>        if arr [ i ] >= cummulative_sum :<br>            count += 1<br>            cummulative_sum += arr [ i ]<br>    return count<br></td>
  </tr><tr>
    <th>PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def censor ( text , word ) :<br>    word_list = text.split ( )<br>    result = ''<br>    stars = '*' * len ( word )<br>    count = 0<br>    index = 0 <br>    for i in word_list :<br>        if i == word :<br>            word_list [ index ] = stars<br>        index += 1<br>    result = ' '.join ( word_list )<br>    return result<br></td>
    <td>translated code: <br><br> def censor ( text , word ) :<br>    word_list = text.split ( )<br>    result = ""<br>    stars = ""<br>    for i in word :<br>        stars += '*'<br>    index = 0<br>    for i in word_list :<br>        if i == word :<br>            word_list [ index ] = stars<br>        index += 1<br>    for i in word_list :<br>        result += i + ' '<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_WITH_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countStrings ( n ) :<br>    a = [ 0 ] * n<br>    b = [ 0 ] * n<br>    a [ 0 ] = b [ 0 ] = 1<br>    for i in range ( 1 , n ) :<br>        a [ i ] = a [ i - 1 ] + b [ i - 1 ]<br>        b [ i ] = a [ i - 1 ]<br>    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]<br></td>
    <td>translated code: <br><br> def count_strings ( n ) :<br>    a , b = [ 0 ] , [ 1 ]<br>    for i in range ( 1 , n ) :<br>        a [ i ] = a [ i - 1 ] + b [ i - 1 ]<br>        b [ i ] = a [ i - 1 ]<br>    from 2 ** n<br>    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_BALANCED_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxLength ( s , n ) :<br>    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]<br>    for i in range ( n - 1 ) :<br>        if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :<br>            dp [ i ] [ i + 1 ] = 2<br>    for l in range ( 2 , n ) :<br>        i = - 1<br>        for j in range ( l , n ) :<br>            i += 1<br>            if ( s [ i ] == '(' and s [ j ] == ')' ) :<br>                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]<br>            for k in range ( i , j ) :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )<br>    return dp [ 0 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def max_length ( s , n ) :<br>    dp = [ [ ] for i in range ( n ) ]<br>    for i in range ( n - 1 ) :<br>        if s [ i ] == '(' and s [ i + 1 ] == ')' :<br>            dp [ i ] [ i + 1 ] = 2<br>    for l in range ( 2 , n ) :<br>        for i , j in enumerate ( l ) :<br>            if s [ i ] == '(' and s [ j ] == ')' :<br>                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]<br>            for k in range ( i , j ) :<br>                dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] )<br>    return dp [ 0 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxGuests ( arrl , exit , n ) :<br>    arrl.sort ( ) <br>    exit.sort ( ) <br>    guests_in = 1 <br>    max_guests = 1 <br>    time = arrl [ 0 ] <br>    i = 1 <br>    j = 0 <br>    while ( i < n and j < n ) :<br>        if ( arrl [ i ] <= exit [ j ] ) :<br>            guests_in = guests_in + 1 <br>            if ( guests_in > max_guests ) :<br>                max_guests = guests_in <br>                time = arrl [ i ] <br>            i = i + 1 <br>        else :<br>            guests_in = guests_in - 1 <br>            j = j + 1 <br>    print ( "Maximum Number of Guests =" , max_guests , "at time" , time )<br></td>
    <td>translated code: <br><br> def find_max_guests ( arrl , exit , n ) :<br>    arrl.sort ( )<br>    exit.sort ( )<br>    guests_in , max_guests , time = arrl [ 0 ] , arrl [ 1 ] , arrl [ 2 ]<br>    i , j = 1 , 0<br>    while i < n and j < n :<br>        if arrl [ i ] <= exit [ j ] :<br>            guests_in += 1<br>            if guests_in > max_guests :<br>                max_guests = guests_in<br>                time = arrl [ i ]<br>            i += 1<br>        else :<br>            guests_in -= 1<br>            j += 1<br>    print ( "Maximum Number of Guests = " + str ( max_guests ) + " at time " + str ( time ) )<br></td>
  </tr><tr>
    <th>EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isMultipleOf10 ( n ) :<br>    return ( n % 15 == 0 )<br></td>
    <td>translated code: <br><br> def is_multiple_of_10 ( n ) :<br>    if n % 15 == 0 :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :<br>    arr.sort ( )<br>    dp = [ 0 ] * N<br>    dp [ 0 ] = 0<br>    for i in range ( 1 , N ) :<br>        dp [ i ] = dp [ i - 1 ]<br>        if ( arr [ i ] - arr [ i - 1 ] < K ) :<br>            if ( i >= 2 ) :<br>                dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) <br>            else :<br>                dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) <br>    return dp [ N - 1 ]<br></td>
    <td>translated code: <br><br> def max_sum_pair_with_difference_less_k ( arr , N , K ) :<br>    arr.sort ( )<br>    dp = [ 0 ] * N<br>    for i in range ( 1 , N ) :<br>        dp [ i ] = dp [ i - 1 ]<br>        if arr [ i ] - arr [ i - 1 ] < K :<br>            if i >= 2 :<br>                dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] )<br>            else :<br>                dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] )<br>    return dp [ N - 1 ]<br></td>
  </tr><tr>
    <th>FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) :<br>    if ( k > n1 * n2 ) :<br>        print ( "k pairs don't exist" )<br>        return<br>    index2 = [ 0 for i in range ( n1 ) ]<br>    while ( k > 0 ) :<br>        min_sum = sys.maxsize<br>        min_index = 0<br>        for i1 in range ( 0 , n1 , 1 ) :<br>            if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) :<br>                min_index = i1<br>                min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ]<br>        print ( "(" , arr1 [ min_index ] , "," , arr2 [ index2 [ min_index ] ] , ")" , end = " " )<br>        index2 [ min_index ] += 1<br>        k -= 1<br></td>
    <td>translated code: <br><br> def k_smallest_pair ( arr1 , n1 , arr2 , n2 , k ) :<br>    if k > n1 * n2 :<br>        print ( "k pairs don't exist" )<br>        return<br>    index2 = range ( n1 )<br>    while k > 0 :<br>        min_sum = sys.maxint<br>        min_index = 0<br>        for i1 in range ( n1 ) :<br>            if index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum :<br>                min_index = i1<br>                min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ]<br>        print ( "(" + str ( arr1 [ min_index ] ) + ", " + str ( arr2 [ index2 [ min_index ] ] ) + ") " )<br>        index2 [ min_index ] += 1<br>        k -= 1<br></td>
  </tr><tr>
    <th>FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def first ( str , i ) :<br>    if ( str [ i ] == '\0' ) :<br>        return 0<br>    if ( str [ i ].isupper ( ) ) :<br>        return str [ i ]<br>    return first ( str , i + 1 )<br></td>
    <td>translated code: <br><br> def first ( str , i ) :<br>    if str [ i ] == '\0' :<br>        return 0<br>    if ord ( str [ i ] ) < 128 :<br>        return str [ i ]<br>    return first ( str , i + 1 )<br></td>
  </tr><tr>
    <th>FIND_PAIRS_B_ARRAY_B_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printPairs ( arr , n , k ) :<br>    isPairFound = True<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , n ) :<br>            if ( i != j and arr [ i ] % arr [ j ] == k ) :<br>                print ( "(" , arr [ i ] , ", " , arr [ j ] , ")" , sep = "" , end = " " )<br>                isPairFound = True<br>    return isPairFound<br></td>
    <td>translated code: <br><br> def printPairs ( arr , n , k ) :<br>    isPairFound = True<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if i != j and arr [ i ] % arr [ j ] == k :<br>                print ( "(" + str ( arr [ i ] ) + ", " + str ( arr [ j ] ) + ")" + " " )<br>                isPairFound = True<br>    return isPairFound<br></td>
  </tr><tr>
    <th>FIND_ARRANGEMENT_QUEUE_GIVEN_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def solve ( n , t , p ) :<br>    s = list ( p )<br>    for i in range ( 0 , t ) :<br>        for j in range ( 0 , n - 1 ) :<br>            if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) :<br>                temp = s [ j ] <br>                s [ j ] = s [ j + 1 ] <br>                s [ j + 1 ] = temp <br>                j = j + 1<br>    print ( ''.join ( s ) )<br></td>
    <td>translated code: <br><br> def solve ( n , t , s ) :<br>    for i in range ( t ) :<br>        for j in range ( n - 1 ) :<br>            if s [ j ] == 'B' and s [ j + 1 ] == 'G' :<br>                temp = s [ j ]<br>                s [ j ] = s [ j + 1 ]<br>                s [ j + 1 ] = temp<br>                j += 1<br>        print ( s )<br></td>
  </tr><tr>
    <th>SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printSuperSeq ( a , b ) :<br>    m = len ( a )<br>    n = len ( b )<br>    dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]<br>    for i in range ( 0 , m + 1 ) :<br>        for j in range ( 0 , n + 1 ) :<br>            if not i :<br>                dp [ i ] [ j ] = j <br>            elif not j :<br>                dp [ i ] [ j ] = i <br>            elif ( a [ i - 1 ] == b [ j - 1 ] ) :<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] <br>            else :<br>                dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) <br>    index = dp [ m ] [ n ] <br>    res = [ "" ] * ( index )<br>    i = m<br>    j = n <br>    while ( i > 0 and j > 0 ) :<br>        if ( a [ i - 1 ] == b [ j - 1 ] ) :<br>            res [ index - 1 ] = a [ i - 1 ] <br>            i -= 1<br>            j -= 1<br>            index -= 1<br>        elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) :<br>            res [ index - 1 ] = a [ i - 1 ]<br>            i -= 1<br>            index -= 1<br>        else :<br>            res [ index - 1 ] = b [ j - 1 ]<br>            j -= 1<br>            index -= 1<br>    while ( i > 0 ) :<br>        res [ index - 1 ] = a [ i - 1 ]<br>        i -= 1<br>        index -= 1<br>    while ( j > 0 ) :<br>        res [ index - 1 ] = b [ j - 1 ]<br>        j -= 1<br>        index -= 1<br>    print ( "".join ( res ) )<br></td>
    <td>translated code: <br><br> def print_superseq ( a , b ) :<br>    m , n = len ( a ) , len ( b )<br>    dp = [ [ 0 ] * m + [ 0 ] * n + [ 0 ] * n for i in range ( 0 , m ) ]<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , m ) :<br>            if i == 0 :<br>                dp [ i ] [ j ] = j<br>            elif j == 0 :<br>                dp [ i ] [ j ] = i<br>            elif a [ i - 1 ] == b [ j - 1 ] :<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] )<br>    res = ""<br>    i , j = m , n<br>    while i > 0 and j > 0 :<br>        if a [ i - 1 ] == b [ j - 1 ] :<br>            res = a [ i - 1 ] + res<br>            i -= 1<br>            j -= 1<br>        elif dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] :<br>            res = a [ i - 1 ] + res<br>            i -= 1<br>        else :<br>            res = b [ j - 1 ] + res<br>            j -= 1<br>    while i > 0 :<br>        res = a [ i - 1 ] + res<br>        i -= 1<br>    while j > 0 :<br>        res = b [ j - 1 ] + res<br>        j -= 1<br>    print ( res )<br></td>
  </tr><tr>
    <th>COUNT_ROTATIONS_DIVISIBLE_8</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countRotationsDivBy8 ( n ) :<br>    l = len ( n )<br>    count = 0<br>    if ( l == 1 ) :<br>        oneDigit = int ( n [ 0 ] )<br>        if ( oneDigit % 8 == 0 ) :<br>            return 1<br>        return 0<br>    if ( l == 2 ) :<br>        first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )<br>        second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )<br>        if ( first % 8 == 0 ) :<br>            count += 1<br>        if ( second % 8 == 0 ) :<br>            count += 1<br>        return count<br>    threeDigit = 0<br>    for i in range ( 0 , ( l - 2 ) ) :<br>        threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) )<br>        if ( threeDigit % 8 == 0 ) :<br>            count += 1<br>    threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) )<br>    if ( threeDigit % 8 == 0 ) :<br>        count += 1<br>    threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) )<br>    if ( threeDigit % 8 == 0 ) :<br>        count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def countRotationsDivBy8 ( n ) :<br>    n = n.split ( )<br>    count = 0<br>    if len ( n ) == 1 :<br>        oneDigit = n [ 0 ] - '0'<br>        if oneDigit % 8 == 0 :<br>            return 1<br>        return 0<br>    if len ( n ) == 2 :<br>        first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' )<br>        second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' )<br>        if first % 8 == 0 :<br>            count += 1<br>        if second % 8 == 0 :<br>            count += 1<br>        return count<br>    threeDigit = 0<br>    for i in range ( ( len ( n ) - 2 ) ) :<br>        threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' )<br>        if threeDigit % 8 == 0 :<br>            count += 1<br>    threeDigit = ( n [ len ( n ) - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' )<br>    if threeDigit % 8 == 0 :<br>        count += 1<br>    threeDigit = ( n [ len ( n ) - 2 ] - '0' ) * 100 + ( n [ len ( n ) - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' )<br>    if threeDigit % 8 == 0 :<br>        count += 1<br>    return count<br></td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcs ( dp , arr1 , n , arr2 , m , k ) :<br>    if k < 0 :<br>        return - ( 10 ** 7 )<br>    if n < 0 or m < 0 :<br>        return 0<br>    ans = dp [ n ] [ m ] [ k ]<br>    if ans != - 1 :<br>        return ans<br>    ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) )<br>    if arr1 [ n - 1 ] == arr2 [ m - 1 ] :<br>        ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) )<br>    ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) )<br>    return ans<br></td>
    <td>translated code: <br><br> def lcs ( dp , arr1 , n , arr2 , m , k ) :<br>    if k < 0 :<br>        return - 10000000<br>    if n < 0 or m < 0 :<br>        return 0<br>    ans = dp [ n ] [ m ] [ k ]<br>    if ans != - 1 :<br>        return ans<br>    try :<br>        ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) )<br>        if arr1 [ n - 1 ] == arr2 [ m - 1 ] :<br>            ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) )<br>        ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) )<br>    except :<br>        pass<br>    return ans<br></td>
  </tr><tr>
    <th>CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkCollision ( a , b , c , x , y , radius ) :<br>    dist = ( ( abs ( a * x + b * y + c ) ) / math.sqrt ( a * a + b * b ) )<br>    if ( radius == dist ) :<br>        print ( "Touch" )<br>    elif ( radius > dist ) :<br>        print ( "Intersect" )<br>    else :<br>        print ( "Outside" )<br></td>
    <td>translated code: <br><br> def checkCollision ( a , b , c , x , y , radius ) :<br>    dist = ( abs ( a * x + b * y + c ) ) / math.sqrt ( a ** 2 + b ** 2 )<br>    if radius == dist :<br>        print ( "Touch" )<br>    elif radius > dist :<br>        print ( "Intersect" )<br>    else :<br>        print ( "Outside" )<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubarrayXOR ( arr , n ) :<br>    ans = - 2147483648<br>    for i in range ( n ) :<br>        curr_xor = 0<br>        for j in range ( i , n ) :<br>            curr_xor = curr_xor ^ arr [ j ]<br>            ans = max ( ans , curr_xor )<br>    return ans<br></td>
    <td>translated code: <br><br> def max_subarray_XOR ( arr , n ) :<br>    ans = int ( 0 )<br>    for i in range ( n ) :<br>        curr_xor = 0<br>        for j in range ( i , n ) :<br>            curr_xor = curr_xor ^ arr [ j ]<br>            ans = max ( ans , curr_xor )<br>    return ans<br></td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shortestPath ( graph , u , v , k ) :<br>    V = 4<br>    INF = 999999999999<br>    if k == 0 and u == v :<br>        return 0<br>    if k == 1 and graph [ u ] [ v ] != INF :<br>        return graph [ u ] [ v ]<br>    if k <= 0 :<br>        return INF<br>    res = INF<br>    for i in range ( V ) :<br>        if graph [ u ] [ i ] != INF and u != i and v != i :<br>            rec_res = shortestPath ( graph , i , v , k - 1 )<br>            if rec_res != INF :<br>                res = min ( res , graph [ u ] [ i ] + rec_res )<br>    return res<br></td>
    <td>translated code: <br><br> def shortestPath ( graph , u , v , k ) :<br>    if k == 0 and u == v :<br>        return 0<br>    if k == 1 and graph [ u ] [ v ] != INF :<br>        return graph [ u ] [ v ]<br>    if k <= 0 :<br>        return INF<br>    res = INF<br>    for i in range ( V ) :<br>        if graph [ u ] [ i ] != INF and u != i and v != i :<br>            rec_res = shortestPath ( graph , i , v , k - 1 )<br>            if rec_res != INF :<br>                res = min ( res , graph [ u ] [ i ] + rec_res )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def subArraySum ( arr , n , sum ) :<br>    for i in range ( n ) :<br>        curr_sum = arr [ i ]<br>        j = i + 1<br>        while j <= n :<br>            if curr_sum == sum :<br>                print ( "Sum found between" )<br>                print ( "indexes %d and %d" % ( i , j - 1 ) )<br>                return 1<br>            if curr_sum > sum or j == n :<br>                break<br>            curr_sum = curr_sum + arr [ j ]<br>            j += 1<br>    print ( "No subarray found" )<br>    return 0<br></td>
    <td>translated code: <br><br> def subArraySum ( arr , n , sum ) :<br>    curr_sum , i , j = 0 , 0 , 0<br>    for i in range ( n ) :<br>        curr_sum = arr [ i ]<br>        for j in range ( i + 1 , n + 1 ) :<br>            if curr_sum == sum :<br>                p = j - 1<br>                print ( "Sum found between indexes " + str ( i ) + " and " + str ( p ) )<br>                return 1<br>            if curr_sum > sum or j == n :<br>                break<br>            curr_sum = curr_sum + arr [ j ]<br>    print ( "No subarray found" )<br>    return 0<br></td>
  </tr><tr>
    <th>K_TH_PRIME_FACTOR_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def kPrimeFactor ( n , k ) :<br>    while ( n % 2 == 0 ) :<br>        k = k - 1<br>        n = n / 2<br>        if ( k == 0 ) :<br>            return 2<br>    i = 3<br>    while i <= math.sqrt ( n ) :<br>        while ( n % i == 0 ) :<br>            if ( k == 1 ) :<br>                return i<br>            k = k - 1<br>            n = n / i<br>        i = i + 2<br>    if ( n > 2 and k == 1 ) :<br>        return n<br>    return - 1<br></td>
    <td>translated code: <br><br> def k_prime_factor ( n , k ) :<br>    while n % 2 == 0 :<br>        k -= 1<br>        n = n // 2<br>        if k == 0 :<br>            return 2<br>    for i in range ( 3 , math.sqrt ( n ) , 2 ) :<br>        while n % i == 0 :<br>            if k == 1 :<br>                return i<br>            k -= 1<br>            n = n // i<br>    if n > 2 and k == 1 :<br>        return n<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countRotations ( arr , low , high ) :<br>    if ( high < low ) :<br>        return 0<br>    if ( high == low ) :<br>        return low<br>    mid = low + ( high - low ) / 2 <br>    mid = int ( mid )<br>    if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :<br>        return ( mid + 1 )<br>    if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :<br>        return mid<br>    if ( arr [ high ] > arr [ mid ] ) :<br>        return countRotations ( arr , low , mid - 1 ) <br>    return countRotations ( arr , mid + 1 , high )<br></td>
    <td>translated code: <br><br> def countRotations ( arr , low , high ) :<br>    if high < low :<br>        return 0<br>    if high == low :<br>        return low<br>    mid = low + ( high - low ) // 2<br>    if mid < high and arr [ mid + 1 ] < arr [ mid ] :<br>        return ( mid + 1 )<br>    if mid > low and arr [ mid ] < arr [ mid - 1 ] :<br>        return mid<br>    if arr [ high ] > arr [ mid ] :<br>        return countRotations ( arr , low , mid - 1 )<br>    return countRotations ( arr , mid + 1 , high )<br></td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def compute_average ( a , b ) :<br>    return ( a // 2 ) + ( b // 2 ) + ( ( a % 2 + b % 2 ) // 2 )<br></td>
    <td>translated code: <br><br> def compute_average ( a , b ) :<br>    return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 )<br></td>
  </tr><tr>
    <th>SORTING_USING_TRIVIAL_HASH_FUNCTION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortUsingHash ( a , n ) :<br>    Max = max ( a )<br>    Min = abs ( min ( a ) )<br>    hashpos = [ 0 ] * ( Max + 1 )<br>    hashneg = [ 0 ] * ( Min + 1 )<br>    for i in range ( 0 , n ) :<br>        if a [ i ] >= 0 :<br>            hashpos [ a [ i ] ] += 1<br>        else :<br>            hashneg [ abs ( a [ i ] ) ] += 1<br>    for i in range ( Min , 0 , - 1 ) :<br>        if hashneg [ i ] != 0 :<br>            for j in range ( 0 , hashneg [ i ] ) :<br>                print ( ( - 1 ) * i , end = " " )<br>    for i in range ( 0 , Max + 1 ) :<br>        if hashpos [ i ] != 0 :<br>            for j in range ( 0 , hashpos [ i ] ) :<br>                print ( i , end = " " )<br></td>
    <td>translated code: <br><br> def sort_using_hash ( a , n ) :<br>    max = sum ( a )<br>    min = abs ( sum ( a ) )<br>    hashpos = [ ]<br>    hashneg = [ ]<br>    for i in range ( n ) :<br>        if a [ i ] >= 0 :<br>            hashpos.append ( a [ i ] )<br>        else :<br>            hashneg.append ( abs ( a [ i ] ) )<br>    for i in range ( min , 0 , - 1 ) :<br>        if hashneg [ i ] > 0 :<br>            for j in range ( hashneg [ i ] ) :<br>                print ( ( - 1 ) * i , end = ' ' )<br>    for i in range ( 0 , max ) :<br>        if hashpos [ i ] > 0 :<br>            for j in range ( hashpos [ i ] ) :<br>                print ( i , end = ' ' )<br></td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printRepeating ( arr , size ) :<br>    count = [ 0 ] * size<br>    print ( " Repeating elements are " , end = "" )<br>    for i in range ( 0 , size ) :<br>        if ( count [ arr [ i ] ] == 1 ) :<br>            print ( arr [ i ] , end = " " )<br>        else :<br>            count [ arr [ i ] ] = count [ arr [ i ] ] + 1<br></td>
    <td>translated code: <br><br> def printRepeating ( arr , size ) :<br>    count = [ 0 ] * size<br>    i = 0<br>    print ( "Repeated elements are : " )<br>    for i in range ( size ) :<br>        if count [ arr [ i ] ] == 1 :<br>            print ( arr [ i ] + " " )<br>        else :<br>            count [ arr [ i ] ] += 1<br></td>
  </tr><tr>
    <th>MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getMinSteps ( n ) :<br>    table = [ 0 ] * ( n + 1 )<br>    for i in range ( n + 1 ) :<br>        table [ i ] = n - i<br>    for i in range ( n , 0 , - 1 ) :<br>        if ( not ( i % 2 ) ) :<br>            table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] )<br>        if ( not ( i % 3 ) ) :<br>            table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] )<br>    return table [ 1 ]<br>    </td>
    <td>translated code: <br><br> def getMinSteps ( n ) :<br>    table = [ n + 1 ] * ( n + 1 )<br>    for i in range ( 0 , n + 1 ) :<br>        table [ i ] = n - i<br>    for i in range ( n , - 1 , - 1 ) :<br>        if not ( i % 2 > 0 ) :<br>            table [ i / 2 ] = min ( table [ i ] + 1 , table [ i / 2 ] )<br>        if not ( i % 3 > 0 ) :<br>            table [ i / 3 ] = min ( table [ i ] + 1 , table [ i / 3 ] )<br>    return table [ 1 ]<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDecodingDP ( digits , n ) :<br>    count = [ 0 ] * ( n + 1 ) <br>    count [ 0 ] = 1 <br>    count [ 1 ] = 1 <br>    for i in range ( 2 , n + 1 ) :<br>        count [ i ] = 0 <br>        if ( digits [ i - 1 ] > '0' ) :<br>            count [ i ] = count [ i - 1 ] <br>        if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) :<br>            count [ i ] += count [ i - 2 ] <br>    return count [ n ] <br></td>
    <td>translated code: <br><br> def count_decoding_dp ( digits , n ) :<br>    count = [ 1 ] * ( n + 1 )<br>    if digits [ 0 ] == '0' :<br>        return 0<br>    for i in range ( 2 , n + 1 ) :<br>        count [ i ] = 0<br>        if digits [ i - 1 ] > '0' :<br>            count [ i ] = count [ i - 1 ]<br>        if digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) :<br>            count [ i ] += count [ i - 2 ]<br>    return count [ n ]<br></td>
  </tr><tr>
    <th>EULERS_FOUR_SQUARE_IDENTITY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def checkEulerFourSquareIdentity ( a , b ) :<br>    ab = a * b<br>    flag = False<br>    i = 0<br>    while i * i <= ab :<br>        j = i<br>        while i * i + j * j <= ab :<br>            k = j<br>            while i * i + j * j + k * k <= ab :<br>                l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 )<br>                if l == int ( l ) and l >= k :<br>                    flag = True<br>                    print ( "i = " , i )<br>                    print ( "j = " , j )<br>                    print ( "k = " , k )<br>                    print ( "l = " , l )<br>                    print ( "Product of" , a , "and" , b , "can be written as sum of squares of i, j, k, l" )<br>                    print ( ab , " = " , i , "*" , i , "+" , j , "*" , j , "+" , k , "*" , k , "+" , l , "*" , l )<br>                k += 1<br>            j += 1<br>        i += 1<br>    if flag == False :<br>        print ( "Solution doesn't exist!" )<br>        return<br></td>
    <td>translated code: <br><br> def check_euler ( a , b ) :<br>    ab = a * b<br>    flag = False<br>    i = 0<br>    while i * i <= ab :<br>        j = i<br>        while i * i + j * j <= ab :<br>            k = j<br>            while i * i + j * j + k * k <= ab :<br>                l = math.sqrt ( ab - ( i * i + j * j + k * k ) )<br>                if math.floor ( l ) == math.ceil ( l ) and l >= k :<br>                    flag = True<br>                    print ( "i = %d\n" % i )<br>                    print ( "j = %d\n" % j )<br>                    print ( "k = %d\n" % k )<br>                    print ( "l = %d\n" % int ( l ) )<br>                    print ( "Product of %d and %d can be written as sum of squares" " of i, j, k, l \n" % ( a , b ) )<br>                    print ( "%d = %d*%d + %d*%d + %d*%d + %d*%d + %d*%d\n" % ( ab , i , i , j , j , k , k , int ( l ) , int ( l ) ) )<br>                k += 1<br>            j += 1<br>        i += 1<br>    if flag == False :<br>        print ( "Solution doesn't exist!" )<br>        return<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numOfIncSubseqOfSizeK ( arr , n , k ) :<br>    dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]<br>    for i in range ( n ) :<br>        dp [ 0 ] [ i ] = 1<br>    for l in range ( 1 , k ) :<br>        for i in range ( l , n ) :<br>            dp [ l ] [ i ] = 0<br>            for j in range ( l - 1 , i ) :<br>                if ( arr [ j ] < arr [ i ] ) :<br>                    dp [ l ] [ i ] += dp [ l - 1 ] [ j ]<br>    Sum = 0<br>    for i in range ( k - 1 , n ) :<br>        Sum += dp [ k - 1 ] [ i ]<br>    return Sum<br></td>
    <td>translated code: <br><br> def numOfIncSubseqOfSizeK ( arr , n , k ) :<br>    dp , sum = [ 0 ] , 0<br>    for i in range ( n ) :<br>        dp [ 0 ] [ i ] = 1<br>    for l in range ( 1 , k ) :<br>        for i in range ( l , n ) :<br>            dp [ l ] [ i ] = 0<br>            for j in range ( l - 1 , i ) :<br>                if arr [ j ] < arr [ i ] :<br>                    dp [ l ] [ i ] += dp [ l - 1 ] [ j ]<br>    for i in range ( k - 1 , n ) :<br>        sum += dp [ k - 1 ] [ i ]<br>    return sum<br></td>
  </tr><tr>
    <th>KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def knapSack ( W , wt , val , n ) :<br>    K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        for w in range ( W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
    <td>translated code: <br><br> def knapSack ( W , wt , val , n ) :<br>    i , w = 0 , 0<br>    K = [ 0 ] * ( n + 1 ) * ( W + 1 )<br>    for i in range ( 0 , n + 1 ) :<br>        for w in range ( 0 , W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def drawPattern ( N ) :<br>    n = N <br>    row = 1 <br>    nst = 1 <br>    nsp1 = n - 1 <br>    nsp2 = - 1 <br>    val1 = row <br>    val2 = 1 <br>    while ( row <= n ) :<br>        csp1 = 1 <br>        while ( csp1 <= nsp1 ) :<br>            print ( " " , end = " " ) <br>            csp1 = csp1 + 1 <br>        cst1 = 1 <br>        while ( cst1 <= nst ) :<br>            print ( val1 , end = " " ) <br>            val1 = val1 - 1 <br>            cst1 = cst1 + 1 <br>        csp2 = 1 <br>        while ( csp2 <= nsp2 ) :<br>            print ( " " , end = " " ) <br>            csp2 = csp2 + 1 <br>        if ( row != 1 and row != n ) :<br>            cst2 = 1 <br>            while ( cst2 <= nst ) :<br>                print ( val2 , end = " " ) <br>                val2 = val2 + 1 <br>                cst2 = cst2 + 1 <br>        print ( )<br>        if ( row <= n // 2 ) :<br>            nst = nst + 1 <br>            nsp1 = nsp1 - 2 <br>            nsp2 = nsp2 + 2 <br>            val1 = row + 1 <br>            val2 = 1 <br>        else :<br>            nst = nst - 1 <br>            nsp1 = nsp1 + 2 <br>            nsp2 = nsp2 - 2 <br>            val1 = n - row <br>            val2 = 1 <br>        row = row + 1 <br></td>
    <td>translated code: <br><br> def draw_pattern ( N ) :<br>    n = N<br>    row = 1<br>    nst = 1<br>    nsp1 = n - 1<br>    nsp2 = - 1<br>    val1 = row<br>    val2 = 1<br>    while row <= n :<br>        csp1 = 1<br>        while csp1 <= nsp1 :<br>            print ( "  " , end = ' ' )<br>            csp1 = csp1 + 1<br>        cst1 = 1<br>        while cst1 <= nst :<br>            print ( val1 , end = ' ' )<br>            val1 = val1 - 1<br>            cst1 = cst1 + 1<br>        csp2 = 1<br>        while csp2 <= nsp2 :<br>            print ( "  " , end = ' ' )<br>            csp2 = csp2 + 1<br>        if row != 1 and row != n :<br>            cst2 = 1<br>            while cst2 <= nst :<br>                print ( val2 , end = ' ' )<br>                val2 = val2 + 1<br>                cst2 = cst2 + 1<br>        print ( )<br>        if row <= n / 2 :<br>            nst = nst + 1<br>            nsp1 = nsp1 - 2<br>            nsp2 = nsp2 + 2<br>            val1 = row + 1<br>            val2 = 1<br>        else :<br>            nst = nst - 1<br>            nsp1 = nsp1 + 2<br>            nsp2 = nsp2 - 2<br>            val1 = n - row<br>            val2 = 1<br>        row = row + 1<br></td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findInteger ( arr , n ) :<br>    hash = dict ( )<br>    maximum = 0<br>    for i in arr :<br>        if ( i < 0 ) :<br>            if abs ( i ) not in hash.keys ( ) :<br>                hash [ abs ( i ) ] = - 1<br>            else :<br>                hash [ abs ( i ) ] -= 1<br>        else :<br>            hash [ i ] = hash.get ( i , 0 ) + 1<br>    for i in arr :<br>        if i in hash.keys ( ) and hash [ i ] > 0 :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def find_integer ( arr , n ) :<br>    hash = { }<br>    maximum = 0<br>    for i in range ( n ) :<br>        if arr [ i ] < 0 :<br>            hash [ abs ( arr [ i ] ) ] = ( hash [ abs ( arr [ i ] ) ] if i in hash else 0 ) - 1<br>        else :<br>            hash [ abs ( arr [ i ] ) ] = ( hash [ abs ( arr [ i ] ) ] if i in hash else 0 ) + 1<br>    for i in range ( n ) :<br>        if hash [ i ] > 0 :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_SOLUTION_LCS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lcs ( X , Y ) :<br>    m = len ( X )<br>    n = len ( Y )<br>    L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ]<br>    bi = bool<br>    for i in range ( m ) :<br>        bi = i & 1<br>        for j in range ( n + 1 ) :<br>            if ( i == 0 or j == 0 ) :<br>                L [ bi ] [ j ] = 0<br>            elif ( X [ i ] == Y [ j - 1 ] ) :<br>                L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1<br>            else :<br>                L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] )<br>    return L [ bi ] [ n ]<br></td>
    <td>translated code: <br><br> def lcs ( X , Y ) :<br>    m , n = len ( X ) , len ( Y )<br>    L = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0</td>
  </tr><tr>
    <th>REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def psuedoBinary ( n ) :<br>    while ( n > 0 ) :<br>        temp = n <br>        m = 0 <br>        p = 1 <br>        while ( temp ) :<br>            rem = temp % 10 <br>            temp = int ( temp / 10 ) <br>            if ( rem != 0 ) :<br>                m += p <br>            p *= 10 <br>        print ( m , end = " " ) <br>        n = n - m <br></td>
    <td>translated code: <br><br> def psuedo_binary ( n ) :<br>    while n != 0 :<br>        temp , m , p = n , 0 , 1<br>        while temp != 0 :<br>            rem = temp % 10<br>            temp , m , p = temp , m , p<br>            if rem != 0 :<br>                m += p<br>            p *= 10<br>        print ( m , end = ' ' )<br>        n = n - m<br>    print ( ' ' )<br></td>
  </tr><tr>
    <th>FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countCurrency ( amount ) :<br>    notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ]<br>    noteCounter = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]<br>    print ( "Currency Count -> " )<br>    for i , j in zip ( notes , noteCounter ) :<br>        if amount >= i :<br>            j = amount // i<br>            amount = amount - j * i<br>            print ( i , " : " , j )<br></td>
    <td>translated code: <br><br> def count_currency ( amount ) :<br>    notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ]<br>    note_counter = [ ]<br>    for i in range ( 9 ) :<br>        if amount >= notes [ i ] :<br>            note_counter.append ( amount / notes [ i ] )<br>            amount = amount - note_counter [ i ] * notes [ i ]<br>    print ( "Currency Count ->" )<br>    for i in range ( 9 ) :<br>        if note_counter [ i ] != 0 :<br>            print ( notes [ i ] , " : " , note_counter [ i ] )<br></td>
  </tr><tr>
    <th>POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rearrange ( a , size ) :<br>    positive = 0<br>    negative = 1<br>    while ( True ) :<br>        while ( positive < size and a [ positive ] >= 0 ) :<br>            positive = positive + 2<br>        while ( negative < size and a [ negative ] <= 0 ) :<br>            negative = negative + 2<br>        if ( positive < size and negative < size ) :<br>            temp = a [ positive ]<br>            a [ positive ] = a [ negative ]<br>            a [ negative ] = temp<br>        else :<br>            break<br></td>
    <td>translated code: <br><br> def rearrange ( a , size ) :<br>    positive , negative = 0 , 1 , 0<br>    temp = 0<br>    while True :<br>        while positive < size and a [ positive ] >= 0 :<br>            positive += 2<br>        while negative < size and a [ negative ] <= 0 :<br>            negative += 2<br>        if positive < size and negative < size :<br>            temp = a [ positive ]<br>            a [ positive ] , a [ negative ] = a [ negative ] , temp<br>        else :<br>            break<br></td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSubset ( arr1 , arr2 , m , n ) :<br>    i = 0<br>    j = 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if ( arr2 [ i ] == arr1 [ j ] ) :<br>                break<br>        if ( j == m ) :<br>            return 0<br>    return 1<br></td>
    <td>translated code: <br><br> def issubset ( arr1 , arr2 , m , n ) :<br>    i = 0<br>    j = 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if arr2 [ i ] == arr1 [ j ] :<br>                break<br>        if j == m :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def pairInSortedRotated ( arr , n , x ) :<br>    for i in range ( 0 , n - 1 ) :<br>        if ( arr [ i ] > arr [ i + 1 ] ) :<br>            break <br>    l = ( i + 1 ) % n<br>    r = i<br>    while ( l != r ) :<br>        if ( arr [ l ] + arr [ r ] == x ) :<br>            return True <br>        if ( arr [ l ] + arr [ r ] < x ) :<br>            l = ( l + 1 ) % n <br>        else :<br>            r = ( n + r - 1 ) % n <br>    return False <br></td>
    <td>translated code: <br><br> def pairInSortedRotated ( arr , n , x ) :<br>    i = 0<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] > arr [ i + 1 ] :<br>            break<br>    l = ( i + 1 ) % n<br>    r = i<br>    while l != r :<br>        if arr [ l ] + arr [ r ] == x :<br>            return True<br>        if arr [ l ] + arr [ r ] < x :<br>            l = ( l + 1 ) % n<br>        else :<br>            r = ( n + r - 1 ) % n<br>    return False<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getRemainder ( num , divisor ) :<br>    if ( divisor == 0 ) :<br>        return False<br>    if ( divisor < 0 ) :<br>        divisor = - divisor<br>    if ( num < 0 ) :<br>        num = - num<br>    i = 1<br>    product = 0<br>    while ( product <= num ) :<br>        product = divisor * i<br>        i += 1<br>    return num - ( product - divisor )<br></td>
    <td>translated code: <br><br> def getRemainder ( num , divisor ) :<br>    if divisor == 0 :<br>        print ( "Error: divisor " + "can't be zero \n" )<br>        return - 1<br>    if divisor < 0 :<br>        divisor = - divisor<br>    if num < 0 :<br>        num = - num<br>    i = 1<br>    product = 0<br>    while product <= num :<br>        product = divisor * i<br>        i += 1<br>    return num - ( product - divisor )<br></td>
  </tr><tr>
    <th>GNOME_SORT_A_STUPID_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def gnomeSort ( arr , n ) :<br>    index = 0<br>    while index < n :<br>        if index == 0 :<br>            index = index + 1<br>        if arr [ index ] >= arr [ index - 1 ] :<br>            index = index + 1<br>        else :<br>            arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ]<br>            index = index - 1<br>    return arr<br></td>
    <td>translated code: <br><br> def gnome_sort ( arr , n ) :<br>    index = 0<br>    while index < n :<br>        if index == 0 :<br>            index += 1<br>        if arr [ index ] >= arr [ index - 1 ] :<br>            index += 1<br>        else :<br>            temp = 0<br>            temp = arr [ index ]<br>            arr [ index ] = arr [ index - 1 ]<br>            arr [ index - 1 ] = temp<br>            index -= 1<br>    return<br></td>
  </tr><tr>
    <th>NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numberofways ( A , B , N , M ) :<br>    pos = [ [ ] for _ in range ( MAX ) ]<br>    for i in range ( M ) :<br>        pos [ ord ( B [ i ] ) ].append ( i + 1 )<br>    dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( 1 , M + 1 ) :<br>            if A [ i - 1 ] == B [ j - 1 ] :<br>                dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1<br>            else :<br>                dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] )<br>    LCS = dpl [ N ] [ M ]<br>    dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]<br>    for i in range ( N , 0 , - 1 ) :<br>        for j in range ( M , 0 , - 1 ) :<br>            if A [ i - 1 ] == B [ j - 1 ] :<br>                dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1<br>            else :<br>                dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] )<br>    ans = 0<br>    for i in range ( N + 1 ) :<br>        for j in range ( MAX ) :<br>            for x in pos [ j ] :<br>                if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS :<br>                    ans += 1<br>                    break<br>    return ans<br></td>
    <td>translated code: <br><br> def numberofways ( A , B , N , M ) :<br>    pos = [ ]<br>    for i in range ( MAX ) :<br>        pos.append ( [ ] )<br>    for i in range ( M ) :<br>        pos [ B [ i ] ].append ( i + 1 )<br>    dpl = [ [ ] for i in range ( N + 2 ) ]<br>    dpr = [ [ ] for i in range ( N + 2 ) ]<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( 1 , M + 1 ) :<br>            if A [ i - 1 ] == B [ j - 1 ] :<br>                dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1<br>            else :<br>                dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] )<br>    LCS = dpl [ N ] [ M ]<br>    dpr = [ [ ] for i in range ( N + 2 ) ]<br>    for i in range ( N , 1 , - 1 ) :<br>        for j in range ( M , - 1 , - 1 ) :<br>            if A [ i - 1 ] == B [ j - 1 ] :<br>                dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1<br>            else :<br>                dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] )<br>    ans = 0<br>    for i in range ( 0 , N + 1 ) :<br>        for j in range ( 0 , MAX ) :<br>            for x in pos [ j ] :<br>                if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS :<br>                    ans += 1<br>                    break<br>    return ans<br></td>
  </tr><tr>
    <th>MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minProduct ( arr , n , k ) :<br>    heapq.heapify ( arr )<br>    count = 0<br>    ans = 1<br>    while ( arr ) and count < k :<br>        x = heapq.heappop ( arr )<br>        ans = ans * x<br>        count = count + 1<br>    return ans <br></td>
    <td>translated code: <br><br> def min_product ( arr , n , k ) :<br>    pq = PriorityQueue ( )<br>    for i in range ( n ) :<br>        pq.add ( arr [ i ] )<br>    count , ans = 0 , 1<br>    while pq.empty ( ) == False and count < k :<br>        ans = ans * pq.element ( )<br>        pq.pop ( )<br>        count += 1<br>    return ans<br></td>
  </tr><tr>
    <th>FIND_UNIQUE_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def unique ( mat , n , m ) :<br>    maximum = 0 ; flag = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , m ) :<br>            if ( maximum < mat [ i ] [ j ] ) :<br>                maximum = mat [ i ] [ j ] <br>    uniqueElementDict = [ 0 ] * ( maximum + 1 )<br>    for i in range ( 0 , n ) :<br>        for j in range ( 0 , m ) :<br>            uniqueElementDict [ mat [ i ] [ j ] ] += 1<br>    for key in range ( maximum + 1 ) :<br>        if uniqueElementDict [ key ] == 1 :<br>            print ( key , end = " " )<br>            flag = 1<br>    if ( flag == 0 ) :<br>        print ( "No unique element in the matrix" )<br></td>
    <td>translated code: <br><br> def unique ( mat , n , m ) :<br>    maximum , flag = 0 , 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if maximum < mat [ i ] [ j ] :<br>                maximum = mat [ i ] [ j ]<br>        b = [ 0 ] * ( maximum + 1 )<br>        for i in range ( n ) :<br>            for j in range ( m ) :<br>                b [ mat [ i ] [ j ] ] += 1<br>        for i in range ( 1 , maximum + 1 ) :<br>            if b [ i ] == 1 :<br>                print ( i , end = ' ' )<br>        flag = 1<br>        if flag == 0 :<br>            print ( 'No unique element ' + 'in the matrix' )<br>    </td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longestSubseqWithDiffOne ( arr , n ) :<br>    dp = [ 1 for i in range ( n ) ]<br>    for i in range ( n ) :<br>        for j in range ( i ) :<br>            if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) :<br>                dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )<br>    result = 1<br>    for i in range ( n ) :<br>        if ( result < dp [ i ] ) :<br>            result = dp [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def longestSubseqWithDiffOne ( arr , n ) :<br>    dp = [ 1 ] * n<br>    for i in range ( n ) :<br>        dp [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] == arr [ j ] + 1 ) :<br>                dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )<br>    result = 1<br>    for i in range ( n ) :<br>        if result < dp [ i ] :<br>            result = dp [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def repeat ( s , n ) :<br>    s1 = s<br>    for i in range ( 1 , n ) :<br>        s += s1<br>    return s<br></td>
    <td>translated code: <br><br> def repeat ( s , n ) :<br>    s1 = s<br>    for i in range ( 1 , n ) :<br>        s += s1<br>    return s<br></td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def search ( pat , txt ) :<br>    M = len ( pat )<br>    N = len ( txt )<br>    for i in range ( N - M + 1 ) :<br>        j = 0<br>        while ( j < M ) :<br>            if ( txt [ i + j ] != pat [ j ] ) :<br>                break<br>            j += 1<br>        if ( j == M ) :<br>            print ( "Pattern found at index " , i )<br></td>
    <td>translated code: <br><br> def search ( txt , pat ) :<br>    M = len ( pat )<br>    N = len ( txt )<br>    for i in range ( 0 , N - M + 1 ) :<br>        j = 0<br>        for j in range ( M ) :<br>            if txt [ i + j ] != pat [ j ] :<br>                break<br>        if j == M :<br>            print ( "Pattern found at index " + str ( i ) )<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countwalks ( graph , u , v , k ) :<br>    if ( k == 0 and u == v ) :<br>        return 1<br>    if ( k == 1 and graph [ u ] [ v ] ) :<br>        return 1<br>    if ( k <= 0 ) :<br>        return 0<br>    count = 0<br>    for i in range ( 0 , V ) :<br>        if ( graph [ u ] [ i ] == 1 ) :<br>            count += countwalks ( graph , i , v , k - 1 )<br>    return count<br></td>
    <td>translated code: <br><br> def countwalks ( graph , u , v , k ) :<br>    if k == 0 and u == v :<br>        return 1<br>    if k == 1 and graph [ u ] [ v ] == 1 :<br>        return 1<br>    if k <= 0 :<br>        return 0<br>    count = 0<br>    for i in range ( V ) :<br>        if graph [ u ] [ i ] == 1 :<br>            count += countwalks ( graph , i , v , k - 1 )<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_DIVISIBLE_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDivisibles ( arr , n ) :<br>    res = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) :<br>                res += 1<br>    return res<br></td>
    <td>translated code: <br><br> def count_divisibles ( arr , n ) :<br>    res = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 :<br>                res += 1<br>    return res<br></td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isSymmetric ( mat , N ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def isSymmetric ( mat , N ) :<br>    for i in range ( N ) :<br>        for j in range ( N ) :<br>            if mat [ i ] [ j ] != mat [ j ] [ i ] :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>COUNT_PALINDROME_SUB_STRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def CountPS ( str , n ) :<br>    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]<br>    P = [ [ False for x in range ( n ) ] for y in range ( n ) ]<br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True<br>    for i in range ( n - 1 ) :<br>        if ( str [ i ] == str [ i + 1 ] ) :<br>            P [ i ] [ i + 1 ] = True<br>            dp [ i ] [ i + 1 ] = 1<br>    for gap in range ( 2 , n ) :<br>        for i in range ( n - gap ) :<br>            j = gap + i <br>            if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) :<br>                P [ i ] [ j ] = True<br>            if ( P [ i ] [ j ] == True ) :<br>                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] )<br>            else :<br>                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] )<br>    return dp [ 0 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def CountPS ( str , n ) :<br>    dp = [ [ ] for i in range ( n ) ]<br>    P = [ [ ] for i in range ( n ) ]<br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True<br>    for i in range ( n - 1 ) :<br>        if str [ i ] == str [ i + 1 ] :<br>            P [ i ] [ i + 1 ] = True<br>            dp [ i ] [ i + 1 ] = 1<br>    for gap in range ( 2 , n ) :<br>        for i in range ( n - gap ) :<br>            j = gap + i<br>            if str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] :<br>                P [ i ] [ j ] = True<br>            if P [ i ] [ j ] == True :<br>                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ]<br>    return dp [ 0 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countWays ( arr , m , N ) :<br>    count = [ 0 for i in range ( N + 1 ) ]<br>    count [ 0 ] = 1<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( m ) :<br>            if ( i >= arr [ j ] ) :<br>                count [ i ] += count [ i - arr [ j ] ]<br>    return count [ N ]<br></td>
    <td>translated code: <br><br> def countWays ( N ) :<br>    count = [ 0 ] * ( N + 1 )<br>    count [ 0 ] = 1<br>    for i in range ( 1 , N + 1 ) :<br>        for j in range ( len ( arr ) ) :<br>            if i >= arr [ j ] :<br>                count [ i ] += count [ i - arr [ j ] ]<br>    return count [ N ]<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minOperations ( str , n ) :<br>    lastUpper = - 1<br>    firstLower = - 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if ( str [ i ].isupper ( ) ) :<br>            lastUpper = i<br>            break<br>    for i in range ( n ) :<br>        if ( str [ i ].islower ( ) ) :<br>            firstLower = i<br>            break<br>    if ( lastUpper == - 1 or firstLower == - 1 ) :<br>        return 0<br>    countUpper = 0<br>    for i in range ( firstLower , n ) :<br>        if ( str [ i ].isupper ( ) ) :<br>            countUpper += 1<br>    countLower = 0<br>    for i in range ( lastUpper ) :<br>        if ( str [ i ].islower ( ) ) :<br>            countLower += 1<br>    return min ( countLower , countUpper )<br></td>
    <td>translated code: <br><br> def min_operations ( str , n ) :<br>    i , last_upper = - 1 , - 1<br>    first_lower = - 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if re.search ( r '[\W_]' , str [ i ] ) :<br>            last_upper = i<br>            break<br>    for i in range ( n ) :<br>        if re.search ( r '[\W_]' , str [ i ] ) :<br>            first_lower = i<br>            break<br>    if last_upper == - 1 or first_lower == - 1 :<br>        return 0<br>    count_upper = 0<br>    for i in range ( first_lower , n ) :<br>        if re.search ( r '[\W_]' , str [ i ] ) :<br>            count_upper += 1<br>    count_lower = 0<br>    for i in range ( last_upper ) :<br>        if re.search ( r '[\W_]' , str [ i ] ) :<br>            count_lower += 1<br>    return min ( count_lower , count_upper )<br></td>
  </tr><tr>
    <th>PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def spiralPrint ( m , n , a ) :<br>    k = 0 ; l = 0<br>    while ( k < m and l < n ) :<br>        for i in range ( l , n ) :<br>            print ( a [ k ] [ i ] , end = " " )<br>        k += 1<br>        for i in range ( k , m ) :<br>            print ( a [ i ] [ n - 1 ] , end = " " )<br>        n -= 1<br>        if ( k < m ) :<br>            for i in range ( n - 1 , ( l - 1 ) , - 1 ) :<br>                print ( a [ m - 1 ] [ i ] , end = " " )<br>            m -= 1<br>        if ( l < n ) :<br>            for i in range ( m - 1 , k - 1 , - 1 ) :<br>                print ( a [ i ] [ l ] , end = " " )<br>            l += 1<br></td>
    <td>translated code: <br><br> def spiral_print ( m , n , a ) :<br>    i , k , l = 0 , 0 , 0<br>    while k < m and l < n :<br>        for i in range ( l , n ) :<br>            print ( a [ k ] [ i ] , end = ' ' )<br>        k += 1<br>        for i in range ( k , m ) :<br>            print ( a [ i ] [ n - 1 ] , end = ' ' )<br>        n -= 1<br>        if k < m :<br>            for i in range ( n - 1 , i >= l ) :<br>                print ( a [ m - 1 ] [ i ] , end = ' ' )<br>            m -= 1<br>        if l < n :<br>            for i in range ( m - 1 , i >= k ) :<br>                print ( a [ i ] [ l ] , end = ' ' )<br>            l += 1<br></td>
  </tr><tr>
    <th>FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findTriplets ( x ) :<br>    fact = [ ] <br>    factors = set ( ) <br>    for i in range ( 2 , int ( sqrt ( x ) ) ) :<br>        if ( x % i == 0 ) :<br>            fact.append ( i ) <br>            if ( x / i != i ) :<br>                fact.append ( x // i ) <br>            factors.add ( i ) <br>            factors.add ( x // i ) <br>    found = False <br>    k = len ( fact ) <br>    for i in range ( k ) :<br>        a = fact [ i ] <br>        for j in range ( k ) :<br>            b = fact [ j ] <br>            if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) :<br>                print ( a , b , x // ( a * b ) ) <br>                found = True <br>                break <br>        if ( found ) :<br>            break <br>    if ( not found ) :<br>        print ( "-1" ) <br></td>
    <td>translated code: <br><br> def find_triplets ( x ) :<br>    fact = [ ]<br>    factors = set ( )<br>    for i in range ( 2 , math.sqrt ( x ) + 1 ) :<br>        if x % i == 0 :<br>            fact.append ( i )<br>            if x / i != i :<br>                fact.append ( x / i )<br>            factors.add ( i )<br>            factors.add ( x / i )<br>    found = False<br>    k = len ( fact )<br>    for i in range ( k ) :<br>        a = fact [ i ]<br>        for j in range ( k ) :<br>            b = fact [ j ]<br>            if ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) :<br>                print ( a , b , ( x / ( a * b ) ) )<br>                found = True<br>                break<br>        if found :<br>            break<br>    if not found :<br>        print ( '-1' )<br></td>
  </tr><tr>
    <th>SUM_TWO_LARGE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( str1 , str2 ) :<br>    if len ( str1 ) > len ( str2 ) :<br>        temp = str1<br>        str1 = str2<br>        str2 = temp<br>    str3 = ""<br>    n1 = len ( str1 )<br>    n2 = len ( str2 )<br>    diff = n2 - n1<br>    carry = 0<br>    for i in range ( n1 - 1 , - 1 , - 1 ) :<br>        sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry )<br>        str3 = str3 + str ( sum % 10 )<br>        carry = sum // 10<br>    for i in range ( n2 - n1 - 1 , - 1 , - 1 ) :<br>        sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry )<br>        str3 = str3 + str ( sum % 10 )<br>        carry = sum // 10<br>    if ( carry ) :<br>        str3 + str ( carry + '0' )<br>    str3 = str3 [ : : - 1 ]<br>    return str3<br></td>
    <td>translated code: <br><br> def find_sum ( str1 , str2 ) :<br>    if len ( str1 ) > len ( str2 ) :<br>        t = str1<br>        str1 = str2<br>        str2 = t<br>    str = ""<br>    n1 , n2 = len ( str1 ) , len ( str2 )<br>    diff = n2 - n1<br>    carry = 0<br>    for i in range ( n1 - 1 , - 1 , - 1 ) :<br>        sum = ( int ( str1 [ i ] - '0' ) + int ( str2 [ i + diff ] - '0' ) + carry )<br>        str += chr ( sum % 10 + '0' )<br>        carry = sum / 10<br>    for i in range ( n2 - n1 - 1 , - 1 , - 1 ) :<br>        sum = ( int ( str2 [ i ] - '0' ) + carry )<br>        str += chr ( sum % 10 + '0' )<br>        carry = sum / 10<br>    if carry :<br>        str += chr ( carry + '0' )<br>    return [ str ].reverse ( ) [ : : - 1 ]<br></td>
  </tr><tr>
    <th>COCKTAIL_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def cocktailSort ( a ) :<br>    n = len ( a )<br>    swapped = True<br>    start = 0<br>    end = n - 1<br>    while ( swapped == True ) :<br>        swapped = False<br>        for i in range ( start , end ) :<br>            if ( a [ i ] > a [ i + 1 ] ) :<br>                a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ]<br>                swapped = True<br>        if ( swapped == False ) :<br>            break<br>        swapped = False<br>        end = end - 1<br>        for i in range ( end - 1 , start - 1 , - 1 ) :<br>            if ( a [ i ] > a [ i + 1 ] ) :<br>                a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ]<br>                swapped = True<br>        start = start + 1<br></td>
    <td>translated code: <br><br> def cocktail_sort ( a ) :<br>    swapped = True<br>    start = 0<br>    end = len ( a )<br>    while swapped == True :<br>        swapped = False<br>        for i in range ( start , end - 1 ) :<br>            if a [ i ] > a [ i + 1 ] :<br>                temp = a [ i ]<br>                a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i + 1 ]<br>                a [ i + 1 ] = temp<br>                swapped = True<br>        if swapped == False :<br>            break<br>        swapped = False<br>        end = end - 1<br>        for i in range ( end - 1 , - start , - 1 ) :<br>            if a [ i ] > a [ i + 1 ] :<br>                temp = a [ i ]<br>                a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i + 1 ]<br>                a [ i + 1 ] = temp<br>                swapped = True<br>        start = start + 1<br>    return a<br></td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countDer ( n ) :<br>    der = [ 0 for i in range ( n + 1 ) ]<br>    der [ 0 ] = 1<br>    der [ 1 ] = 0<br>    der [ 2 ] = 1<br>    for i in range ( 3 , n + 1 ) :<br>        der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] )<br>    return der [ n ]<br></td>
    <td>translated code: <br><br> def count_der ( n ) :<br>    der = [ 1 ] * ( n + 1 )<br>    der [ 0 ] = 1<br>    der [ 1 ] = 0<br>    der [ 2 ] = 1<br>    for i in range ( 3 , n + 1 ) :<br>        der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] )<br>    return der [ n ]<br></td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findMaxProduct ( arr , n ) :<br>    ans = - float ( 'inf' )<br>    maxval = 1<br>    minval = 1<br>    for i in range ( 0 , n ) :<br>        if arr [ i ] > 0 :<br>            maxval = maxval * arr [ i ]<br>            minval = min ( 1 , minval * arr [ i ] )<br>        elif arr [ i ] == 0 :<br>            minval = 1<br>            maxval = 0<br>        elif arr [ i ] < 0 :<br>            prevMax = maxval<br>            maxval = minval * arr [ i ]<br>            minval = prevMax * arr [ i ]<br>        ans = max ( ans , maxval )<br>        if maxval <= 0 :<br>            maxval = 1<br>    return ans<br></td>
    <td>translated code: <br><br> def find_max_product ( arr , n ) :<br>    i = 0<br>    ans = int ( 0 )<br>    maxval = 1<br>    minval = 1<br>    prev_max = 0<br>    for i in range ( n ) :<br>        if arr [ i ] > 0 :<br>            maxval = maxval * arr [ i ]<br>            minval = min ( 1 , minval * arr [ i ] )<br>        elif arr [ i ] == 0 :<br>            minval = 1<br>            maxval = 0<br>        elif arr [ i ] < 0 :<br>            prev_max = maxval<br>            maxval = minval * arr [ i ]<br>            minval = prev_max * arr [ i ]<br>        ans = max ( ans , maxval )<br>        if maxval <= 0 :<br>            maxval = 1<br>    return ans<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def assign ( a , n ) :<br>    a.sort ( )<br>    ans = [ 0 ] * n<br>    p = 0<br>    q = n - 1<br>    for i in range ( n ) :<br>        if ( i + 1 ) % 2 == 0 :<br>            ans [ i ] = a [ q ]<br>            q = q - 1<br>        else :<br>            ans [ i ] = a [ p ]<br>            p = p + 1<br>    for i in range ( n ) :<br>        print ( ans [ i ] , end = " " )<br></td>
    <td>translated code: <br><br> def assign ( a , n ) :<br>    a.sort ( )<br>    ans = [ ]<br>    p , q = 0 , n - 1<br>    for i in range ( n ) :<br>        if ( i + 1 ) % 2 == 0 :<br>            ans.append ( a [ q -- ] )<br>        else :<br>            ans.append ( a [ p ++ ] )<br>    for i in range ( n ) :<br>        print ( ans [ i ] , end = ' ' )<br></td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFriendsPairings ( n ) :<br>    dp = [ 0 for i in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        if ( i <= 2 ) :<br>            dp [ i ] = i<br>        else :<br>            dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def count_friend_pairings ( n ) :<br>    dp = [ ]<br>    for i in range ( 0 , n + 1 ) :<br>        if i <= 2 :<br>            dp.append ( i )<br>        else :<br>            dp.append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] )<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>PRIME_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPrime ( n ) :<br>    if ( n <= 1 ) :<br>        return False<br>    for i in range ( 2 , n ) :<br>        if ( n % i == 0 ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def isPrime ( n ) :<br>    if n <= 1 :<br>        return False<br>    for i in range ( 2 , n ) :<br>        if n % i == 0 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>PROBABILITY_REACHING_POINT_2_3_STEPS_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def find_prob ( N , P ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    dp [ 0 ] = 1<br>    dp [ 1 ] = 0<br>    dp [ 2 ] = P<br>    dp [ 3 ] = 1 - P<br>    for i in range ( 4 , N + 1 ) :<br>        dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ]<br>    return dp [ N ]<br></td>
    <td>translated code: <br><br> def find_prob ( N , P ) :<br>    dp = np.zeros ( ( N + 1 , N + 1 ) )<br>    dp [ 0 ] = 1<br>    dp [ 1 ] = 0<br>    dp [ 2 ] = P<br>    dp [ 3 ] = 1 - P<br>    for i in range ( 4 , N + 1 ) :<br>        dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ]<br>    return ( float ( dp [ N ] ) , float ( dp [ N + 1 ] ) )<br></td>
  </tr><tr>
    <th>SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def smallest ( x , y , z ) :<br>    if ( not ( y / x ) ) :<br>        return y if ( not ( y / z ) ) else z<br>    return x if ( not ( x / z ) ) else z<br></td>
    <td>translated code: <br><br> def smallest ( x , y , z ) :<br>    if ( y / x ) != 1 :<br>        return ( ( y / z ) != 1 )<br>    return ( ( x / z ) != 1 )<br></td>
  </tr><tr>
    <th>COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def printCommonElements ( mat ) :<br>    mp = dict ( )<br>    for j in range ( N ) :<br>        mp [ mat [ 0 ] [ j ] ] = 1<br>    for i in range ( 1 , M ) :<br>        for j in range ( N ) :<br>            if ( mat [ i ] [ j ] in mp.keys ( ) and mp [ mat [ i ] [ j ] ] == i ) :<br>                mp [ mat [ i ] [ j ] ] = i + 1<br>                if i == M - 1 :<br>                    print ( mat [ i ] [ j ] , end = " " )<br></td>
    <td>translated code: <br><br> def printCommonElements ( mat ) :<br>    mp = { }<br>    for j in range ( N ) :<br>        mp [ mat [ 0 ] [ j ] ] = 1<br>    for i in range ( 1 , M ) :<br>        for j in range ( N ) :<br>            if mp [ mat [ i ] [ j ] ] != 0 and mp [ mat [ i ] [ j ] ] == i :<br>                mp [ mat [ i ] [ j ] ] = i + 1<br>                if i == M - 1 :<br>                    print ( mat [ i ] [ j ] , end = ' ' )<br></td>
  </tr><tr>
    <th>DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def negCyclefloydWarshall ( graph ) :<br>    dist = [ [ 0 for i in range ( V + 1 ) ] for j in range ( V + 1 ) ]<br>    for i in range ( V ) :<br>        for j in range ( V ) :<br>            dist [ i ] [ j ] = graph [ i ] [ j ]<br>    for k in range ( V ) :<br>        for i in range ( V ) :<br>            for j in range ( V ) :<br>                if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) :<br>                    dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ]<br>    for i in range ( V ) :<br>        if ( dist [ i ] [ i ] < 0 ) :<br>            return True<br>    return False<br></td>
    <td>translated code: <br><br> def neg_cyclefloyd_warshall ( graph ) :<br>    dist , i , j , k = [ ] , [ ] , [ ] , [ ]<br>    for i in range ( V ) :<br>        for j in range ( V ) :<br>            dist.append ( graph [ i , j ] )<br>    for k in range ( V ) :<br>        for i in range ( V ) :<br>            for j in range ( V ) :<br>                if dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] :<br>                    dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ]<br>    for i in range ( V ) :<br>        if dist [ i ] [ i ] < 0 :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>PROGRAM_SORT_STRING_DESCENDING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sortString ( str ) :<br>    charCount = [ 0 ] * MAX_CHAR <br>    for i in range ( len ( str ) ) :<br>        charCount [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 <br>    for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) :<br>        for j in range ( charCount [ i ] ) :<br>            print ( chr ( 97 + i ) , end = "" ) <br></td>
    <td>translated code: <br><br> def sortString ( str ) :<br>    charCount = [ 0 ] * MAX_CHAR<br>    for i in range ( len ( str ) ) :<br>        charCount [ str [ i ] - 'a' ] += 1<br>    for i in range ( MAX_CHAR - 1 , - 1 , - 1 ) :<br>        for j in range ( charCount [ i ] ) :<br>            print ( chr ( 'a' + str [ j ] ) )<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getPairsCount ( arr , n , sum ) :<br>    count = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] + arr [ j ] == sum :<br>                count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def get_paired_count ( arr , sum ) :<br>    count = 0<br>    for i in range ( len ( arr ) ) :<br>        for j in range ( i + 1 , len ( arr ) ) :<br>            if ( arr [ i ] + arr [ j ] ) == sum :<br>                count += 1<br>    print ( "Count of pairs is " + str ( count ) )<br></td>
  </tr><tr>
    <th>SUM_SERIES_12_32_52_2N_12_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumOfSeries ( n ) :<br>    return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 )<br></td>
    <td>translated code: <br><br> def sum_of_series ( n ) :<br>    return ( n * ( 2 * n - 1 ) ** ( 2 * n + 1 ) ) / 3<br></td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxdiff ( arr , n ) :<br>    freq = defaultdict ( lambda : 0 )<br>    for i in range ( n ) :<br>        freq [ arr [ i ] ] += 1<br>    ans = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] :<br>                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )<br>            elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :<br>                ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )<br>    return ans<br></td>
    <td>translated code: <br><br> def maxdiff ( arr , n ) :<br>    freq = { }<br>    for i in range ( n ) :<br>        freq [ arr [ i ] ] = freq [ arr [ i ] ] if i in freq else 1<br>    ans = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] :<br>                ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] )<br>            elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] :<br>                ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] )<br>    return ans<br></td>
  </tr><tr>
    <th>SHIFT_MATRIX_ELEMENTS_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def shiftMatrixByK ( mat , k ) :<br>    if ( k > N ) :<br>        print ( "shifting is"" not possible" )<br>        return<br>    j = 0<br>    while ( j < N ) :<br>        for i in range ( k , N ) :<br>            print ( "{} ".format ( mat [ j ] [ i ] ) , end = "" )<br>        for i in range ( 0 , k ) :<br>            print ( "{} ".format ( mat [ j ] [ i ] ) , end = "" )<br>        print ( "" )<br>        j = j + 1<br></td>
    <td>translated code: <br><br> def shift_matrix_by_k ( mat , k ) :<br>    if k > N :<br>        print ( "Shifting is" , " not possible" )<br>        return<br>    j = 0<br>    while j < N :<br>        for i in range ( k , N ) :<br>            print ( mat [ j ] [ i ] , end = ' ' )<br>        for i in range ( k ) :<br>            print ( mat [ j ] [ i ] , end = ' ' )<br>        print ( )<br>        j += 1<br></td>
  </tr><tr>
    <th>MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def MAXMIN ( arr , n ) :<br>    MIN = 10 ** 9<br>    MAX = - 10 ** 9<br>    for i in range ( n ) :<br>        for j in range ( n // 2 + 1 ) :<br>            if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) :<br>                if ( MIN > arr [ i ] [ n - j - 1 ] ) :<br>                    MIN = arr [ i ] [ n - j - 1 ]<br>                if ( MAX < arr [ i ] [ j ] ) :<br>                    MAX = arr [ i ] [ j ]<br>            else :<br>                if ( MIN > arr [ i ] [ j ] ) :<br>                    MIN = arr [ i ] [ j ]<br>                if ( MAX < arr [ i ] [ n - j - 1 ] ) :<br>                    MAX = arr [ i ] [ n - j - 1 ]<br>    print ( "MAXimum =" , MAX , ", MINimum =" , MIN )<br></td>
    <td>translated code: <br><br> def maxMin ( arr , n ) :<br>    min = + 2147483647<br>    max = - 2147483648<br>    for i in range ( n ) :<br>        for j in range ( 0 , n // 2 ) :<br>            if arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] :<br>                if min > arr [ i ] [ n - j - 1 ] :<br>                    min = arr [ i ] [ n - j - 1 ]<br>                if max < arr [ i ] [ j ] :<br>                    max = arr [ i ] [ j ]<br>            else :<br>                if min > arr [ i ] [ j ] :<br>                    min = arr [ i ] [ j ]<br>                if max < arr [ i ] [ n - j - 1 ] :<br>                    max = arr [ i ] [ n - j - 1 ]<br>    print ( "Maximum = " + str ( max ) + ", Minimum = " + str ( min ) )<br></td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findGreatest ( arr , n ) :<br>    m = dict ( )<br>    for i in arr :<br>        m [ i ] = m.get ( i , 0 ) + 1<br>    arr = sorted ( arr )<br>    for i in range ( n - 1 , 0 , - 1 ) :<br>        j = 0<br>        while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) :<br>            if ( arr [ i ] % arr [ j ] == 0 ) :<br>                result = arr [ i ] // arr [ j ]<br>                if ( result != arr [ j ] and ( result in m.keys ( ) ) and m [ result ] > 0 ) :<br>                    return arr [ i ]<br>                elif ( result == arr [ j ] and ( result in m.keys ( ) ) and m [ result ] > 1 ) :<br>                    return arr [ i ]<br>            j += 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def findGreatest ( arr , n ) :<br>    m = { }<br>    for i in range ( n ) :<br>        if m.has_key ( arr [ i ] ) :<br>            m [ arr [ i ] ] = m [ arr [ i ] ] + 1<br>        else :<br>            m [ arr [ i ] ] = m [ arr [ i ] ]<br>    arr.sort ( )<br>    for i in range ( n - 1 , 1 , - 1 ) :<br>        for j in range ( i , j + 1 , - 1 ) :<br>            if arr [ i ] % arr [ j ] == 0 :<br>                result = arr [ i ] / arr [ j ]<br>                if result != arr [ j ] and m [ result ] == 0 or m [ result ] > 0 :<br>                    return arr [ i ]<br>                elif result == arr [ j ] and m [ result ] > 1 :<br>                    return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def knapSack ( W , wt , val , n ) :<br>    K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        for w in range ( W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
    <td>translated code: <br><br> def knapSack ( W , wt , val , n ) :<br>    i , w = 0 , 0<br>    K = [ 0 ] * ( n + 1 ) * ( W + 1 )<br>    for i in range ( 0 , n + 1 ) :<br>        for w in range ( 0 , W + 1 ) :<br>            if i == 0 or w == 0 :<br>                K [ i ] [ w ] = 0<br>            elif wt [ i - 1 ] <= w :<br>                K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] )<br>            else :<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ]<br>    return K [ n ] [ W ]<br></td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_OCTAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def decToOctal ( n ) :<br>    octalNum = [ 0 ] * 100 <br>    i = 0 <br>    while ( n != 0 ) :<br>        octalNum [ i ] = n % 8 <br>        n = int ( n / 8 ) <br>        i += 1 <br>    for j in range ( i - 1 , - 1 , - 1 ) :<br>        print ( octalNum [ j ] , end = "" ) <br></td>
    <td>translated code: <br><br> def dec_to_oct ( n ) :<br>    octal_num = [ ]<br>    i = 0<br>    while n != 0 :<br>        octal_num.append ( n % 8 )<br>        n = n // 8<br>        i += 1<br>    for j in range ( i - 1 , - 1 , - 1 ) :<br>        print ( octal_num [ j ] )<br></td>
  </tr><tr>
    <th>SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countSubSeq ( A , N , M ) :<br>    ans = 0<br>    h = [ 0 ] * M<br>    for i in range ( 0 , N ) :<br>        A [ i ] = A [ i ] % M<br>        h [ A [ i ] ] = h [ A [ i ] ] + 1<br>    for i in range ( 0 , M ) :<br>        for j in range ( i , M ) :<br>            rem = ( M - ( i + j ) % M ) % M<br>            if ( rem < j ) :<br>                continue<br>            if ( i == j and rem == j ) :<br>                ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6<br>            elif ( i == j ) :<br>                ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 )<br>            elif ( i == rem ) :<br>                ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2<br>            elif ( rem == j ) :<br>                ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2<br>            else :<br>                ans = ans + h [ i ] * h [ j ] * h [ rem ]<br>        return ans<br></td>
    <td>translated code: <br><br> def count_subseq ( A , N , M ) :<br>    ans = 0<br>    h = [ 0 ] * M<br>    h [ A [ i ] % M ] += 1<br>    for i in range ( N ) :<br>        A [ i ] = A [ i ] % M<br>        h [ A [ i ] ] += 1<br>    for i in range ( M ) :<br>        for j in range ( i , M ) :<br>            rem = ( M - ( i + j ) % M ) % M<br>            if rem < j :<br>                continue<br>            if i == j and rem == j :<br>                ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6<br>            elif i == j :<br>                ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2<br>            elif i == rem :<br>                ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2<br>            elif rem == j :<br>                ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2<br>            else :<br>                ans = ans + h [ i ] * h [ j ] * h [ rem ]<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countFibs ( low , high ) :<br>    f1 , f2 , f3 = 0 , 1 , 1<br>    result = 0<br>    while ( f1 <= high ) :<br>        if ( f1 >= low ) :<br>            result += 1<br>        f1 = f2<br>        f2 = f3<br>        f3 = f1 + f2<br>    return result<br></td>
    <td>translated code: <br><br> def count_fibs ( low , high ) :<br>    f1 , f2 , f3 = 0 , 1 , 1<br>    result = 0<br>    while f1 <= high :<br>        if f1 >= low :<br>            result += 1<br>        f1 , f2 , f3 = f2 , f3 , f1 + f2<br>    return result<br></td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isPowerOfFour ( n ) :<br>    count = 0<br>    if ( n and ( not ( n & ( n - 1 ) ) ) ) :<br>        while ( n > 1 ) :<br>            n >>= 1<br>            count += 1<br>        if ( count % 2 == 0 ) :<br>            return True<br>        else :<br>            return False<br></td>
    <td>translated code: <br><br> def isPowerOfFour ( n ) :<br>    count = 0<br>    x = n & ( n - 1 )<br>    if n and x == 0 :<br>        while n > 1 :<br>            n >>= 1<br>            count += 1<br>        return ( count % 2 == 0 )<br></td>
  </tr><tr>
    <th>FIND_SUM_EVEN_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def sumofFactors ( n ) :<br>    if ( n % 2 != 0 ) :<br>        return 0<br>    res = 1<br>    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :<br>        count = 0<br>        curr_sum = 1<br>        curr_term = 1<br>        while ( n % i == 0 ) :<br>            count = count + 1<br>            n = n // i<br>            if ( i == 2 and count == 1 ) :<br>                curr_sum = 0<br>            curr_term = curr_term * i<br>            curr_sum = curr_sum + curr_term<br>        res = res * curr_sum<br>    if ( n >= 2 ) :<br>        res = res * ( 1 + n )<br>    return res<br></td>
    <td>translated code: <br><br> def sumof_factors ( n ) :<br>    if n % 2 != 0 :<br>        return 0<br>    res = 1<br>    for i in range ( 2 , math.sqrt ( n ) ) :<br>        count , curr_sum = 0 , 1<br>        curr_term = 1<br>        while n % i == 0 :<br>            count += 1<br>            n = n // i<br>            if i == 2 and count == 1 :<br>                curr_sum = 0<br>            curr_term *= i<br>            curr_sum += curr_term<br>        res *= curr_sum<br>    if n >= 2 :<br>        res *= ( 1 + n )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findSum ( arr , n ) :<br>    s = set ( )<br>    sum = 0<br>    for i in range ( n ) :<br>        if arr [ i ] not in s :<br>            s.add ( arr [ i ] )<br>    for i in s :<br>        sum = sum + i<br>    return sum<br></td>
    <td>translated code: <br><br> def find_sum ( arr , n ) :<br>    sum = 0<br>    s = set ( )<br>    for i in range ( n ) :<br>        if not s.issubset ( arr [ i ] ) :<br>            sum += arr [ i ]<br>            s.add ( arr [ i ] )<br>    return sum<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minPalPartion ( str1 ) :<br>    n = len ( str1 ) <br>    C = [ 0 ] * ( n + 1 ) <br>    P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] <br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True <br>    for L in range ( 2 , n + 1 ) :<br>        for i in range ( n - L + 1 ) :<br>            j = i + L - 1 <br>            if ( L == 2 ) :<br>                P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) <br>            else :<br>                P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) <br>    for i in range ( n ) :<br>        if ( P [ 0 ] [ i ] == True ) :<br>            C [ i ] = 0 <br>        else :<br>            C [ i ] = sys.maxsize <br>            for j in range ( i ) :<br>                if ( P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] ) :<br>                    C [ i ] = 1 + C [ j ] <br>    return C [ n - 1 ] <br></td>
    <td>translated code: <br><br> def minPalPartion ( str ) :<br>    n = len ( str )<br>    C = [ [ ] for i in range ( n ) ]<br>    P = [ [ ] for i in range ( n ) ]<br>    i , j , k , L = 0 , 0 , 0 , 0<br>    for i in range ( n ) :<br>        P [ i ] [ i ] = True<br>    for L in range ( 2 , n + 1 ) :<br>        for i in range ( n - L + 1 ) :<br>            j = i + L - 1<br>            if L == 2 :<br>                P [ i ] [ j ] = ( str [ i ] == str [ j ] )<br>            else :<br>                P [ i ] [ j ] = ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ]<br>    for i in range ( n ) :<br>        if P [ 0 ] [ i ] == True :<br>            C [ i ] = 0<br>        else :<br>            C [ i ] = int ( P [ i ] [ j ] )<br>            for j in range ( i ) :<br>                if P [ j + 1 ] [ i ] == True and 1 + C [ j ] < C [ i ] :<br>                    C [ i ] = 1 + C [ j ]<br>    return C [ n - 1 ]<br></td>
  </tr><tr>
    <th>MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minInitialPoints ( points ) :<br>    dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ]<br>    m , n = R , C<br>    if points [ m - 1 ] [ n - 1 ] > 0 :<br>        dp [ m - 1 ] [ n - 1 ] = 1<br>    else :<br>        dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1<br>    for i in range ( m - 2 , - 1 , - 1 ) :<br>        dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 )<br>    for i in range ( 2 , - 1 , - 1 ) :<br>        dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 )<br>    for i in range ( m - 2 , - 1 , - 1 ) :<br>        for j in range ( n - 2 , - 1 , - 1 ) :<br>            min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] )<br>            dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 )<br>    return dp [ 0 ] [ 0 ]<br></td>
    <td>translated code: <br><br> def min_initial_points ( points , R , C ) :<br>    dp = [ 0 ] * R<br>    m , n = R , C<br>    dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0<br>    for i in range ( m - 2 , - 1 , - 1 ) :<br>        dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 )<br>    for j in range ( n - 2 , - 1 , - 1 ) :<br>        dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 )<br>    for i in range ( m - 2 , - 1 , - 1 ) :<br>        for j in range ( n - 2 , - 1 , - 1 ) :<br>            min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] )<br>            dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 )<br>    return dp [ 0 ] [ 0 ]<br></td>
  </tr><tr>
    <th>COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def countPair ( a , b ) :<br>    s = str ( b )<br>    i = 0<br>    while i < ( len ( s ) ) :<br>        if ( s [ i ] != '9' ) :<br>            break<br>        i += 1<br>    result = 0<br>    if ( i == len ( s ) ) :<br>        result = a * len ( s )<br>    else :<br>        result = a * ( len ( s ) - 1 )<br>    return result<br></td>
    <td>translated code: <br><br> def count_pair ( a , b ) :<br>    s = str ( b )<br>    i = 0<br>    for c in s :<br>        if c != '9' :<br>            break<br>    result = 0<br>    if i == len ( s ) :<br>        result = a * len ( s )<br>    else :<br>        result = a * ( len ( s ) - 1 )<br>    return result<br></td>
  </tr><tr>
    <th>SURVIVAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def survival ( S , N , M ) :<br>    if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) :<br>        print ( "No" )<br>    else :<br>        days = ( M * S ) / N<br>        if ( ( ( M * S ) % N ) != 0 ) :<br>            days += 1<br>        print ( "Yes " ) ,<br>        print ( days )<br></td>
    <td>translated code: <br><br> def survival ( S , N , M ) :<br>    if ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N :<br>        print ( "No" )<br>    else :<br>        days = ( M * S ) / N<br>        if ( ( M * S ) % N ) != 0 :<br>            days += 1<br>        print ( "Yes " + str ( days ) )<br></td>
  </tr><tr>
    <th>INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def interLeaveQueue ( q ) :<br>    if ( q.qsize ( ) % 2 != 0 ) :<br>        print ( "Input even number of integers." )<br>    s = [ ]<br>    halfSize = int ( q.qsize ( ) / 2 )<br>    for i in range ( halfSize ) :<br>        s.append ( q.queue [ 0 ] )<br>        q.get ( )<br>    while len ( s ) != 0 :<br>        q.put ( s [ - 1 ] )<br>        s.pop ( )<br>    for i in range ( halfSize ) :<br>        q.put ( q.queue [ 0 ] )<br>        q.get ( )<br>    for i in range ( halfSize ) :<br>        s.append ( q.queue [ 0 ] )<br>        q.get ( )<br>    while len ( s ) != 0 :<br>        q.put ( s [ - 1 ] )<br>        s.pop ( )<br>        q.put ( q.queue [ 0 ] )<br>        q.get ( )<br></td>
    <td>translated code: <br><br> def interleave_queue ( q ) :<br>    if len ( q ) % 2 != 0 :<br>        print ( "Input even number of integers." )<br>    s = Stack ( )<br>    half_size = len ( q ) // 2<br>    for i in range ( half_size ) :<br>        s.push ( q.pop ( ) )<br>        q.pop ( )<br>    while not s.empty ( ) :<br>        q.push ( s.pop ( ) )<br>        s.pop ( )<br>    for i in range ( half_size ) :<br>        q.push ( q.pop ( ) )<br>        q.pop ( )<br>    for i in range ( half_size ) :<br>        s.push ( q.pop ( ) )<br>        q.pop ( )<br>    while not s.empty ( ) :<br>        q.push ( s.pop ( ) )<br>        s.pop ( )<br>        q.push ( q.pop ( ) )<br>        q.pop ( )<br></td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def findInteger ( arr , n ) :<br>    neg = 0<br>    pos = 0<br>    sum = 0<br>    for i in range ( 0 , n ) :<br>        sum += arr [ i ]<br>        if ( arr [ i ] < 0 ) :<br>            neg += 1<br>        else :<br>            pos += 1<br>    return ( sum / abs ( neg - pos ) )<br></td>
    <td>translated code: <br><br> def find_integer ( arr , n ) :<br>    neg , pos = 0 , 0<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>        if arr [ i ] < 0 :<br>            neg += 1<br>        else :<br>            pos += 1<br>    return ( sum / abs ( neg - pos ) )<br></td>
  </tr><tr>
    <th>FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def evenSum ( n ) :<br>    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , min ( i , n + 1 ) ) :<br>            if j == 0 or j == i :<br>                C [ i ] [ j ] = 1<br>            else :<br>                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]<br>    sum = 0 <br>    for i in range ( 0 , n + 1 ) :<br>        if n % 2 == 0 :<br>            sum = sum + C [ n ] [ i ]<br>    return sum<br></td>
    <td>translated code: <br><br> def evenSum ( n ) :<br>    C = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n</td>
  </tr><tr>
    <th>DELANNOY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def dealnnoy ( n , m ) :<br>    if ( m == 0 or n == 0 ) :<br>        return 1<br>    return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )<br></td>
    <td>translated code: <br><br> def dealnnoy ( n , m ) :<br>    if m == 0 or n == 0 :<br>        return 1<br>    return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 )<br></td>
  </tr><tr>
    <th>FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxLen ( arr ) :<br>    max_len = 0<br>    for i in range ( len ( arr ) ) :<br>        curr_sum = 0<br>        for j in range ( i , len ( arr ) ) :<br>            curr_sum += arr [ j ]<br>            if curr_sum == 0 :<br>                max_len = max ( max_len , j - i + 1 )<br>    return max_len<br></td>
    <td>translated code: <br><br> def max_len ( arr , n ) :<br>    max_len = 0<br>    for i in range ( n ) :<br>        curr_sum = 0<br>        for j in range ( i , n ) :<br>            curr_sum += arr [ j ]<br>            if curr_sum == 0 :<br>                max_len = max ( max_len , j - i + 1 )<br>    return max_len<br></td>
  </tr><tr>
    <th>NEXT_POWER_OF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextPowerOf2 ( n ) :<br>    count = 0 <br>    if ( n and not ( n & ( n - 1 ) ) ) :<br>        return n<br>    while ( n != 0 ) :<br>        n >>= 1<br>        count += 1<br>    return 1 << count <br></td>
    <td>translated code: <br><br> def next_power_of_2 ( n ) :<br>    count = 0<br>    if n and ( n & ( n - 1 ) ) == 0 :<br>        return n<br>    while n != 0 :<br>        n >>= 1<br>        count += 1<br>    return 1 << count<br></td>
  </tr><tr>
    <th>LONGEST_GEOMETRIC_PROGRESSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def lenOfLongestGP ( sett , n ) :<br>    if n < 2 :<br>        return n<br>    if n == 2 :<br>        return ( sett [ 1 ] % sett [ 0 ] == 0 )<br>    sett.sort ( )<br>    L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]<br>    llgp = 1<br>    for i in range ( 0 , n ) :<br>        if sett [ n - 1 ] % sett [ i ] == 0 :<br>            L [ i ] [ n - 1 ] = 2<br>        else :<br>            L [ i ] [ n - 1 ] = 1<br>    for j in range ( n - 2 , 0 , - 1 ) :<br>        i = j - 1<br>        k = j + 1<br>        while i >= 0 and k <= n - 1 :<br>            if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] :<br>                k += 1<br>            elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] :<br>                if sett [ j ] % sett [ i ] == 0 :<br>                    L [ i ] [ j ] = 2<br>                else :<br>                    L [ i ] [ j ] = 1<br>                i -= 1<br>            else :<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1<br>                if L [ i ] [ j ] > llgp :<br>                    llgp = L [ i ] [ j ]<br>                i -= 1<br>                k + 1<br>        while i >= 0 :<br>            if sett [ j ] % sett [ i ] == 0 :<br>                L [ i ] [ j ] = 2<br>            else :<br>                L [ i ] [ j ] = 1<br>            i -= 1<br>    return llgp<br></td>
    <td>translated code: <br><br> def lenOfLongestGP ( set , n ) :<br>    if n < 2 :<br>        return n<br>    if n == 2 :<br>        return ( set [ 1 ] % set [ 0 ] == 0 )<br>    set.sort ( )<br>    L = [ [ 0 ] * n for i in range ( n ) ]<br>    llgp = 1<br>    for i in range ( n ) :<br>        if set [ n - 1 ] % set [ i ] == 0 :<br>            L [ i ] [ n - 1 ] = 2<br>        else :<br>            L [ i ] [ n - 1 ] = 1<br>    for j in range ( n - 2 , - 1 , - 1 ) :<br>        i = j - 1 , j + 1<br>        while i >= 0 and k <= n - 1 :<br>            if set [ i ] * set [ k ] < set [ j ] * set [ j ] :<br>                k += 1<br>            elif set [ i ] * set [ k ] > set [ j ] * set [ j ] :<br>                if set [ j ] % set [ i ] == 0 :<br>                    L [ i ] [ j ] = 2<br>                else :<br>                    L [ i ] [ j ] = 1<br>                del L [ i ] [ j ]<br>            else :<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1<br>                if L [ i ] [ j ] > llgp :<br>                    llgp = L [ i ] [ j ]<br>                del L [ i ] [ j ]<br>                del L [ i ] [ k ]<br>        while i >= 0 :<br>            if set [ j ] % set [ i ] == 0 :<br>                L [ i ] [ j ] = 2<br>            else :<br>                L [ i ] [ j ] = 1<br>            del L [ i ] [ j ]<br>    return llgp<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def minCost ( cost , m , n ) :<br>    tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ]<br>    tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]<br>    for i in range ( 1 , m + 1 ) :<br>        tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ]<br>    for j in range ( 1 , n + 1 ) :<br>        tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ]<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ]<br>    return tc [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def _min_cost ( cost , m , n ) :<br>    i , j = 0 , 0<br>    tc = [ [ 0 ] * m + [ n + 1 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m ]<br>    return tc</td>
  </tr><tr>
    <th>PROGRAM_DISTANCE_TWO_POINTS_EARTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def distance ( lat1 , lat2 , lon1 , lon2 ) :<br>    lon1 = radians ( lon1 )<br>    lon2 = radians ( lon2 )<br>    lat1 = radians ( lat1 )<br>    lat2 = radians ( lat2 )<br>    dlon = lon2 - lon1<br>    dlat = lat2 - lat1<br>    a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2<br>    c = 2 * asin ( sqrt ( a ) )<br>    r = 6371<br>    return ( c * r )<br></td>
    <td>translated code: <br><br> def distance ( lat1 , lat2 , lon1 , lon2 ) :<br>    lon1 = math.radians ( lon1 )<br>    lon2 = math.radians ( lon2 )<br>    lat1 = math.radians ( lat1 )<br>    lat2 = math.radians ( lat2 )<br>    dlon = lon2 - lon1<br>    dlat = lat2 - lat1<br>    a = math.pow ( math.sin ( dlat / 2 ) , 2 ) + math.cos ( lat1 ) * math.cos ( lat2 ) * math.pow ( math.sin ( dlon / 2 ) , 2 )<br>    c = 2 * math.asin ( math.sqrt ( a ) )<br>    r = 6371<br>    return ( c * r )<br></td>
  </tr><tr>
    <th>BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def nextfit ( weight , c ) :<br>    res = 0<br>    rem = c<br>    for _ in range ( len ( weight ) ) :<br>        if rem >= weight [ _ ] :<br>            rem = rem - weight [ _ ]<br>        else :<br>            res += 1<br>            rem = c - weight [ _ ]<br>    return res<br></td>
    <td>translated code: <br><br> def next_fit ( weight , n , c ) :<br>    res , bin_rem = 0 , c<br>    for i in range ( n ) :<br>        if weight [ i ] > bin_rem :<br>            res += 1<br>            bin_rem = c - weight [ i ]<br>        else :<br>            bin_rem -= weight [ i ]<br>    return res , bin_rem<br></td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def subArraySum ( arr , n , sum ) :<br>    curr_sum = arr [ 0 ]<br>    start = 0<br>    i = 1<br>    while i <= n :<br>        while curr_sum > sum and start < i - 1 :<br>            curr_sum = curr_sum - arr [ start ]<br>            start += 1<br>        if curr_sum == sum :<br>            print ( "Sum found between indexes" )<br>            print ( "%d and %d" % ( start , i - 1 ) )<br>            return 1<br>        if i < n :<br>            curr_sum = curr_sum + arr [ i ]<br>        i += 1<br>    print ( "No subarray found" )<br>    return 0<br></td>
    <td>translated code: <br><br> def subArraySum ( arr , n , sum ) :<br>    curr_sum , start = arr [ 0 ] , 0 , 0<br>    for i in range ( 1 , n + 1 ) :<br>        while curr_sum > sum and start < i - 1 :<br>            curr_sum = curr_sum - arr [ start ]<br>            start += 1<br>        if curr_sum == sum :<br>            p = i - 1<br>            print ( "Sum found between indexes " + str ( start ) + " and " + str ( p ) )<br>            return 1<br>        if i < n :<br>            curr_sum = curr_sum + arr [ i ]<br>    print ( "No subarray found" )<br>    return 0<br></td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def KnapSack ( val , wt , n , W ) :<br>    dp = [ 0 ] * ( W + 1 ) <br>    for i in range ( n ) :<br>        for j in range ( W , wt [ i ] , - 1 ) :<br>            dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) <br>    return dp [ W ] <br></td>
    <td>translated code: <br><br> def KnapSack ( val , wt , n , W ) :<br>    dp = np.zeros ( ( W + 1 , ) )<br>    dp [ 0 ] = 0<br>    for i in range ( n ) :<br>        for j in range ( W , j >= wt [ i ] ) :<br>            dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] )<br>    return dp [ W ]<br></td>
  </tr><tr>
    <th>FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def yMod ( y , x ) :<br>    return ( y % pow ( 2 , x ) )<br></td>
    <td>translated code: <br><br> def yMod ( y , x ) :<br>    if ( math.log ( y ) / math.log ( 2 ) ) < x : return y<br>    if x > 63 : return y<br>    return ( y % ( 1 << int ( x ) ) )<br></td>
  </tr><tr>
    <th>SUM_SERIES_23_45_67_89_UPTO_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def seriesSum ( n ) :<br>    i = 1 <br>    res = 0.0 <br>    sign = True <br>    while ( n > 0 ) :<br>        n = n - 1 <br>        if ( sign ) :<br>            sign = False <br>            res = res + ( i + 1 ) / ( i + 2 ) <br>            i = i + 2 <br>        else :<br>            sign = True <br>            res = res - ( i + 1 ) / ( i + 2 ) <br>            i = i + 2 <br>    return res <br></td>
    <td>translated code: <br><br> def series_sum ( n ) :<br>    i = 1<br>    res = 0.0<br>    sign = True<br>    while n > 0 :<br>        n -= 1<br>        if sign :<br>            sign = not sign<br>            res = res + float ( yield i ) / yield i<br>        else :<br>            sign = not sign<br>            res = res - float ( yield i ) / yield i<br>    return res<br></td>
  </tr><tr>
    <th>LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def longLenStrictBitonicSub ( arr , n ) :<br>    inc , dcr = dict ( ) , dict ( )<br>    len_inc , len_dcr = [ 0 ] * n , [ 0 ] * n<br>    longLen = 0<br>    for i in range ( n ) :<br>        len = 0<br>        if inc.get ( arr [ i ] - 1 ) in inc.values ( ) :<br>            len = inc.get ( arr [ i ] - 1 )<br>        inc [ arr [ i ] ] = len_inc [ i ] = len + 1<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        len = 0<br>        if dcr.get ( arr [ i ] - 1 ) in dcr.values ( ) :<br>            len = dcr.get ( arr [ i ] - 1 )<br>        dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1<br>    for i in range ( n ) :<br>        if longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) :<br>            longLen = len_inc [ i ] + len_dcr [ i ] - 1<br>    return longLen<br></td>
    <td>translated code: <br><br> def long_len_strict_bitonic_sub ( arr , n ) :<br>    inc = { }<br>    dcr = { }<br>    len_inc = [ ]<br>    len_dcr = [ ]<br>    long_len = 0<br>    for i in range ( n ) :<br>        len = 0<br>        if inc.has_key ( arr [ i ] - 1 ) :<br>            len = inc [ arr [ i ] - 1 ]<br>        len_inc.append ( len + 1 )<br>        inc [ arr [ i ] ] = len_inc [ i ]<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        len = 0<br>        if dcr.has_key ( arr [ i ] - 1 ) :<br>            len = dcr [ arr [ i ] - 1 ]<br>        len_dcr.append ( len + 1 )<br>        dcr [ arr [ i ] ] = len_dcr [ i ]<br>    for i in range ( n ) :<br>        if long_len < ( len_inc + len_dcr [ i ] - 1 ) :<br>            long_len = len_inc [ i ] + len_dcr [ i ] - 1<br>    return long_len<br></td>
  </tr><tr>
    <th>MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxDistance ( arr , n ) :<br>    mp = { }<br>    maxDict = 0<br>    for i in range ( n ) :<br>        if arr [ i ] not in mp.keys ( ) :<br>            mp [ arr [ i ] ] = i<br>        else :<br>            maxDict = max ( maxDict , i - mp [ arr [ i ] ] )<br>    return maxDict<br></td>
    <td>translated code: <br><br> def max_distance ( arr , n ) :<br>    d = { }<br>    max_dist = 0<br>    for i in range ( n ) :<br>        if not d.has_key ( arr [ i ] ) :<br>            d [ arr [ i ] ] = i<br>        else :<br>            max_dist = max ( max_dist , i - d [ arr [ i ] ] )<br>    return max_dist<br></td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def isRectangle ( matrix ) :<br>    rows = len ( matrix )<br>    if ( rows == 0 ) :<br>        return False<br>    columns = len ( matrix [ 0 ] )<br>    table = { }<br>    for i in range ( rows ) :<br>        for j in range ( columns - 1 ) :<br>            for k in range ( j + 1 , columns ) :<br>                if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) :<br>                    if ( j in table and k in table [ j ] ) :<br>                        return True<br>                    if ( k in table and j in table [ k ] ) :<br>                        return True<br>                    if j not in table :<br>                        table [ j ] = set ( )<br>                    if k not in table :<br>                        table [ k ] = set ( )<br>                    table [ j ].add ( k )<br>                    table [ k ].add ( j )<br>    return False<br></td>
    <td>translated code: <br><br> def isRectangle ( matrix ) :<br>    rows = len ( matrix )<br>    if rows == 0 :<br>        return False<br>    columns = len ( matrix [ 0 ] )<br>    table = { }<br>    for i in range ( rows ) :<br>        for j in range ( columns - 1 ) :<br>            for k in range ( j + 1 , columns ) :<br>                if matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 :<br>                    if table.has_key ( j ) and table [ j ].has_key ( k ) :<br>                        return True<br>                    if table.has_key ( k ) and table [ k ].has_key ( j ) :<br>                        return True<br>                    if not table.has_key ( j ) :<br>                        x = set ( [ k ] )<br>                        table [ j ].add ( x )<br>                    else :<br>                        table [ j ].add ( k )<br>                    if not table.has_key ( k ) :<br>                        x = set ( [ j ] )<br>                        table [ k ].add ( x )<br>                    else :<br>                        table [ k ].add ( j )<br>    return False<br></td>
  </tr><tr>
    <th>COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def numofsubset ( arr , n ) :<br>    x = sorted ( arr )<br>    count = 1<br>    for i in range ( 0 , n - 1 ) :<br>        if ( x [ i ] + 1 != x [ i + 1 ] ) :<br>            count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def numofsubset ( arr , n ) :<br>    arr.sort ( )<br>    count = 1<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] + 1 != arr [ i + 1 ] :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def maxSubArraySum ( a , size ) :<br>    max_so_far = - maxint - 1<br>    max_ending_here = 0<br>    for i in range ( 0 , size ) :<br>        max_ending_here = max_ending_here + a [ i ]<br>        if ( max_so_far < max_ending_here ) :<br>            max_so_far = max_ending_here<br>        if max_ending_here < 0 :<br>            max_ending_here = 0<br>    return max_so_far<br></td>
    <td>translated code: <br><br> def max_subarray_sum ( a ) :<br>    size = len ( a )<br>    max_so_far , max_ending_here = int ( a [ 0 ] ) , 0<br>    for i in range ( size ) :<br>        max_ending_here = max_ending_here + a [ i ]<br>        if max_so_far < max_ending_here :<br>            max_so_far , max_ending_here = max_ending_here , max_ending_here<br>        if max_ending_here < 0 :<br>            max_ending_here , max_ending_here = 0 , 0<br>    return max_so_far , max_ending_here<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getRemainder ( num , divisor ) :<br>    while ( num >= divisor ) :<br>        num -= divisor <br>    return num <br></td>
    <td>translated code: <br><br> def getRemainder ( num , divisor ) :<br>    while num >= divisor :<br>        num -= divisor<br>    return num<br></td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def check ( st ) :<br>    n = len ( st )<br>    if ( n == 0 ) :<br>        return False<br>    if ( n == 1 ) :<br>        return ( ( st [ 0 ] - '0' ) % 4 == 0 )<br>    last = ( int ) ( st [ n - 1 ] )<br>    second_last = ( int ) ( st [ n - 2 ] )<br>    return ( ( second_last * 10 + last ) % 4 == 0 )<br></td>
    <td>translated code: <br><br> def check ( str ) :<br>    n = len ( str )<br>    if n == 0 :<br>        return False<br>    if n == 1 :<br>        return ( ( str [ 0 ] - '0' ) % 4 == 0 )<br>    last = str [ n - 1 ] - '0'<br>    second_last = str [ n - 2 ] - '0'<br>    return ( ( second_last * 10 + last ) % 4 == 0 )<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def getSingle ( arr , n ) :<br>    result = 0<br>    for i in range ( 0 , INT_SIZE ) :<br>        sm = 0<br>        x = ( 1 << i )<br>        for j in range ( 0 , n ) :<br>            if ( arr [ j ] & x ) :<br>                sm = sm + 1<br>        if ( sm % 3 ) :<br>            result = result | x<br>    return result<br></td>
    <td>translated code: <br><br> def getSingle ( arr , n ) :<br>    result = 0<br>    x , sum = 0 , 0<br>    for i in range ( INT_SIZE ) :<br>        sum = 0<br>        x = ( 1 << i )<br>        for j in range ( n ) :<br>            if ( arr [ j ] & x ) == 0 :<br>                sum += 1<br>        if ( sum % 3 ) == 0 :<br>            result |= x<br>    return result<br></td>
  </tr><tr>
    <th>NUMBER_RECTANGLES_NM_GRID</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def rectCount ( n , m ) :<br>    return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4<br></td>
    <td>translated code: <br><br> def rectCount ( n , m ) :<br>    return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4<br></td>
  </tr><tr>
    <th>MAXIMUM_POINTS_INTERSECTION_N_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def intersection ( n ) :<br>    return n * ( n - 1 ) <br></td>
    <td>translated code: <br><br> def intersection ( n ) :<br>    return n * ( n - 1 )<br></td>
  </tr><tr>
    <th>ADD_1_TO_A_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x ) :<br>    m = 1 <br>    while ( x & m ) :<br>        x = x ^ m<br>        m <<= 1<br>    x = x ^ m<br>    return x<br></td>
    <td>translated code: <br><br> def f_gold ( x ) :<br>    m = 1<br>    while int ( x & m ) >= 1 :<br>        x = x ^ m<br>        m <<= 1<br>    x = x ^ m<br>    return x<br></td>
  </tr><tr>
    <th>ADD_TWO_NUMBERS_WITHOUT_USING_ARITHMETIC_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x , y ) :<br>    while ( y != 0 ) :<br>        carry = x & y<br>        x = x ^ y<br>        y = carry << 1<br>    return x<br></td>
    <td>translated code: <br><br> def f_gold ( x , y ) :<br>    while y != 0 :<br>        carry = x & y<br>        x = x ^ y<br>        y = carry << 1<br>    return x<br></td>
  </tr><tr>
    <th>AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a ) :<br>    area = ( math.pi * a * a ) / 4<br>    return area<br></td>
    <td>translated code: <br><br> def f_gold ( a ) :<br>    area = float ( math.pi * a ** 2 ) / 4<br>    return area<br></td>
  </tr><tr>
    <th>ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( start , end , arr ) :<br>    frequency = dict ( )<br>    for i in range ( start , end + 1 ) :<br>        if arr [ i ] in frequency.keys ( ) :<br>            frequency [ arr [ i ] ] += 1<br>        else :<br>            frequency [ arr [ i ] ] = 1<br>    count = 0<br>    for x in frequency :<br>        if x == frequency [ x ] :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( start , end , arr ) :<br>    mp = { }<br>    for i in range ( start , end + 1 ) :<br>        mp [ arr [ i ] ] = mp [ arr [ i ] ] if i in mp else 1<br>    count = 0<br>    for key , value in mp.items ( ) :<br>        if key == arr [ i ] :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>BELL_NUMBERS_NUMBER_OF_WAYS_TO_PARTITION_A_SET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ]<br>    bell [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ]<br>        for j in range ( 1 , i + 1 ) :<br>            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ]<br>    return bell [ n ] [ 0 ]<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    bell = [ 1 for i in range ( n + 1 ) ]<br>    bell [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ]<br>        for j in range ( 1 , i + 1 ) :<br>            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ]<br>    return bell [ n ] [ 0 ]<br></td>
  </tr><tr>
    <th>BINARY_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , l , r , x ) :<br>    if r >= l :<br>        mid = l + ( r - l ) // 2<br>        if arr [ mid ] == x :<br>            return mid<br>        elif arr [ mid ] > x :<br>            return f_gold ( arr , l , mid - 1 , x )<br>        else :<br>            return f_gold ( arr , mid + 1 , r , x )<br>    else :<br>        return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , l , r , x ) :<br>    if r >= l :<br>        mid = l + ( r - l ) // 2<br>        if arr [ mid ] == x :<br>            return mid<br>        if arr [ mid ] > x :<br>            return f_gold ( arr , l , mid - 1 , x )<br>        return f_gold ( arr , mid + 1 , r , x )<br></td>
  </tr><tr>
    <th>BREAK_NUMBER_THREE_PARTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    count = 0<br>    count = ( n + 1 ) * ( n + 2 ) // 2<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    count = 0<br>    count = ( n + 1 ) * ( n + 2 ) / 2<br>    return count<br></td>
  </tr><tr>
    <th>CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( h , m ) :<br>    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :<br>        print ( 'Wrong input' )<br>    if ( h == 12 ) :<br>        h = 0<br>    if ( m == 60 ) :<br>        m = 0<br>    hour_angle = 0.5 * ( h * 60 + m )<br>    minute_angle = 6 * m<br>    angle = abs ( hour_angle - minute_angle )<br>    angle = min ( 360 - angle , angle )<br>    return angle<br></td>
    <td>translated code: <br><br> def f_gold ( h , m ) :<br>    if h < 0 or m < 0 or h > 12 or m > 60 :<br>        print ( "Wrong input" )<br>    if h == 12 :<br>        h = 0<br>    if m == 60 :<br>        m = 0<br>    hour_angle = int ( 0.5 * ( h * 60 + m ) )<br>    minute_angle = int ( 6 * m )<br>    angle = abs ( hour_angle - minute_angle )<br>    angle = min ( 360 - angle , angle )<br>    return angle<br></td>
  </tr><tr>
    <th>CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    res = ord ( str [ 0 ] ) - 48<br>    for i in range ( 1 , len ( str ) ) :<br>        if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) :<br>            res += ord ( str [ i ] ) - 48<br>        else :<br>            res *= ord ( str [ i ] ) - 48<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    res = str [ 0 ] - '0'<br>    for c in str [ 1 : ] :<br>        if c == '0' or c == '1' or res < 2 :<br>            res += ( c - '0' )<br>        else :<br>            res *= ( c - '0' )<br>    return res<br></td>
  </tr><tr>
    <th>CALCULATE_VOLUME_DODECAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( side ) :<br>    return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( math.pow ( side , 3 ) ) )<br></td>
    <td>translated code: <br><br> def f_gold ( side ) :<br>    return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) ** ( math.pow ( side , 3 ) ) )<br></td>
  </tr><tr>
    <th>CEILING_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , low , high , x ) :<br>    if x <= arr [ low ] :<br>        return low<br>    i = low<br>    for i in range ( high ) :<br>        if arr [ i ] == x :<br>            return i<br>        if arr [ i ] < x and arr [ i + 1 ] >= x :<br>            return i + 1<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , low , high , x ) :<br>    i = 0<br>    if x <= arr [ low ] :<br>        return low<br>    for i in range ( low , high ) :<br>        if arr [ i ] == x :<br>            return i<br>        if arr [ i ] < x and arr [ i + 1 ] >= x :<br>            return i + 1<br>    return - 1<br></td>
  </tr><tr>
    <th>CEILING_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , low , high , x ) :<br>    if x <= arr [ low ] :<br>        return low<br>    if x > arr [ high ] :<br>        return - 1<br>    mid = ( low + high ) / 2 <br>    if arr [ mid ] == x :<br>        return mid<br>    elif arr [ mid ] < x :<br>        if mid + 1 <= high and x <= arr [ mid + 1 ] :<br>            return mid + 1<br>        else :<br>            return f_gold ( arr , mid + 1 , high , x )<br>    else :<br>        if mid - 1 >= low and x > arr [ mid - 1 ] :<br>            return mid<br>        else :<br>            return f_gold ( arr , low , mid - 1 , x )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , low , high , x ) :<br>    mid = 0<br>    if x <= arr [ low ] :<br>        return low<br>    if x > arr [ high ] :<br>        return - 1<br>    mid = ( low + high ) // 2<br>    if arr [ mid ] == x :<br>        return mid<br>    elif arr [ mid ] < x :<br>        if mid + 1 <= high and x <= arr [ mid + 1 ] :<br>            return mid + 1<br>        else :<br>            return f_gold ( arr , mid + 1 , high , x )<br>    else :<br>        if mid - 1 >= low and x > arr [ mid - 1 ] :<br>            return mid<br>        else :<br>            return f_gold ( arr , low , mid - 1 , x )<br></td>
  </tr><tr>
    <th>CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , n ) :<br>    diag1_left = 0<br>    diag1_right = 0<br>    diag2_left = 0<br>    diag2_right = 0<br>    i = 0<br>    j = n - 1<br>    while i < n :<br>        if ( i < n // 2 ) :<br>            diag1_left += mat [ i ] [ i ]<br>            diag2_left += mat [ j ] [ i ]<br>        elif ( i > n // 2 ) :<br>            diag1_right += mat [ i ] [ i ]<br>            diag2_right += mat [ j ] [ i ]<br>        i += 1<br>        j -= 1<br>    return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] )<br></td>
    <td>translated code: <br><br> def f_gold ( mat , n ) :<br>    diag1_left , diag1_right = 0 , 0<br>    diag2_left , diag2_right = 0 , 0<br>    for i , j in enumerate ( n - 1 ) :<br>        if i < n / 2 :<br>            diag1_left += mat [ i ] [ i ]<br>            diag2_left += mat [ j ] [ i ]<br>        elif i > n / 2 :<br>            diag1_right += mat [ i ] [ i ]<br>            diag2_right += mat [ j ] [ i ]<br>    return ( diag1_left , diag2_right , diag2_left , diag1_right , diag2_left , diag2_right , mat [ n / 2 ] [ n / 2 ] )<br></td>
  </tr><tr>
    <th>CHANGE_BITS_CAN_MADE_ONE_FLIP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    zeros = 0<br>    ones = 0<br>    for i in range ( 0 , len ( str ) ) :<br>        ch = str [ i ] <br>        if ( ch == '0' ) :<br>            zeros = zeros + 1<br>        else :<br>            ones = ones + 1<br>    return ( zeros == 1 or ones == 1 ) <br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    zeros , ones = 0 , 0<br>    for ch in str :<br>        if ch == '0' :<br>            zeros += 1<br>        else :<br>            ones += 1<br>    return ( zeros == 1 or ones == 1 )<br></td>
  </tr><tr>
    <th>CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    max1 = max ( arr )<br>    min1 = min ( arr )<br>    m = max1 - min1 + 1<br>    if ( m > n ) :<br>        return False<br>    visited = [ 0 ] * m<br>    for i in range ( 0 , n ) :<br>        visited [ arr [ i ] - min1 ] = True<br>    for i in range ( 0 , m ) :<br>        if ( visited [ i ] == False ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    max = int ( arr [ 0 ] )<br>    min = int ( arr [ 1 ] )<br>    for i in range ( n ) :<br>        max = max ( max , arr [ i ] )<br>        min = min ( min , arr [ i ] )<br>    m = max - min + 1<br>    if m > n :<br>        return False<br>    visited = [ ]<br>    for i in range ( n ) :<br>        visited.append ( arr [ i ] - min )<br>    for i in range ( m ) :<br>        if visited [ i ] == False :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    count_odd = 0 ; count_even = 0 <br>    for i in range ( n ) :<br>        if ( a [ i ] & 1 ) :<br>            count_odd += 1 <br>        else :<br>            count_even += 1 <br>    if ( count_odd % 2 and count_even % 2 ) :<br>        return False <br>    else :<br>        return True <br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    count_odd , count_even = 0 , 0<br>    for i in range ( n ) :<br>        if ( a [ i ] & 1 ) == 1 :<br>            count_odd += 1<br>        else :<br>            count_even += 1<br>    if count_odd % 2 == 1 and count_even % 2 == 1 :<br>        return False<br>    else :<br>        return True<br></td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_JUMBLED_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( num ) :<br>    if ( num // 10 == 0 ) :<br>        return True<br>    while ( num != 0 ) :<br>        if ( num // 10 == 0 ) :<br>            return True<br>        digit1 = num % 10<br>        digit2 = ( num // 10 ) % 10<br>        if ( abs ( digit2 - digit1 ) > 1 ) :<br>            return False<br>        num = num // 10<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( num ) :<br>    if num / 10 == 0 :<br>        return True<br>    while num != 0 :<br>        if num / 10 == 0 :<br>            return True<br>        digit1 = num % 10<br>        digit2 = ( num / 10 ) % 10<br>        if abs ( digit2 - digit1 ) > 1 :<br>            return False<br>        num = num / 10<br>    return True<br></td>
  </tr><tr>
    <th>CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( notes , n ) :<br>    fiveCount = 0<br>    tenCount = 0<br>    for i in range ( n ) :<br>        if ( notes [ i ] == 5 ) :<br>            fiveCount += 1<br>        elif ( notes [ i ] == 10 ) :<br>            if ( fiveCount > 0 ) :<br>                fiveCount -= 1<br>                tenCount += 1<br>            else :<br>                return 0<br>        else :<br>            if ( fiveCount > 0 and tenCount > 0 ) :<br>                fiveCount -= 1<br>                tenCount -= 1<br>            elif ( fiveCount >= 3 ) :<br>                fiveCount -= 3<br>            else :<br>                return 0<br>    return 1<br></td>
    <td>translated code: <br><br> def f_gold ( notes , n ) :<br>    five_count = 0<br>    ten_count = 0<br>    for i in range ( n ) :<br>        if notes [ i ] == 5 :<br>            five_count += 1<br>        elif notes [ i ] == 10 :<br>            if five_count > 0 :<br>                five_count -= 1<br>                ten_count += 1<br>            else :<br>                return 0<br>        else :<br>            if five_count > 0 and ten_count > 0 :<br>                five_count -= 1<br>                ten_count -= 1<br>            elif five_count >= 3 :<br>                five_count -= 3<br>            else :<br>                return 0<br>    return 1<br></td>
  </tr><tr>
    <th>CHECK_INTEGER_OVERFLOW_MULTIPLICATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b ) :<br>    if ( a == 0 or b == 0 ) :<br>        return False<br>    result = a * b<br>    if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) :<br>        result = 0<br>    if ( a == ( result // b ) ) :<br>        print ( result // b )<br>        return False<br>    else :<br>        return True<br></td>
    <td>translated code: <br><br> def f_gold ( a , b ) :<br>    if a == 0 or b == 0 :<br>        return False<br>    result = a * b<br>    if a == result / b :<br>        return False<br>    else :<br>        return True<br></td>
  </tr><tr>
    <th>CHECK_LINE_PASSES_ORIGIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x1 , y1 , x2 , y2 ) :<br>    return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( x1 , y1 , x2 , y2 ) :<br>    return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) )<br></td>
  </tr><tr>
    <th>CHECK_POSSIBLE_SORT_ARRAY_CONDITIONAL_SWAPPING_ADJACENT_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( 0 , n - 1 ) :<br>        if ( arr [ i ] > arr [ i + 1 ] ) :<br>            if ( arr [ i ] - arr [ i + 1 ] == 1 ) :<br>                arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ]<br>            else :<br>                return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( n - 1 ) :<br>        if arr [ i ] > arr [ i + 1 ] :<br>            if arr [ i ] - arr [ i + 1 ] == 1 :<br>                temp = arr [ i ]<br>                arr [ i ] = arr [ i + 1 ]<br>                arr [ i + 1 ] = temp<br>            else :<br>                return False<br>    return True<br></td>
  </tr><tr>
    <th>CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s1 , s2 ) :<br>    n = len ( s1 )<br>    m = len ( s2 )<br>    dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] )<br>    dp [ 0 ] [ 0 ] = True<br>    for i in range ( len ( s1 ) ) :<br>        for j in range ( len ( s2 ) + 1 ) :<br>            if ( dp [ i ] [ j ] ) :<br>                if ( ( j < len ( s2 ) and ( s1 [ i ].upper ( ) == s2 [ j ] ) ) ) :<br>                    dp [ i + 1 ] [ j + 1 ] = True<br>                if ( s1 [ i ].isupper ( ) == False ) :<br>                    dp [ i + 1 ] [ j ] = True<br>    return ( dp [ n ] [ m ] )<br></td>
    <td>translated code: <br><br> def f_gold ( s1 , s2 ) :<br>    n = len ( s1 )<br>    m = len ( s2 )<br>    dp = [ False for i in range ( n + 1 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , m + 1 ) :<br>            dp [ i ] [ j ] = False<br>    dp [ 0 ] [ 0 ] = True<br>    for i in range ( 0 , len ( s1 ) ) :<br>        for j in range ( 0 , len ( s2 ) ) :<br>            if dp [ i ] [ j ] :<br>                if j < len ( s2 ) and ( ord ( s1 [ i ] ) == ord ( s2 [ j ] ) ) :<br>                    dp [ i + 1 ] [ j + 1 ] = True<br>                if not ord ( s1 [ i ] ) :<br>                    dp [ i + 1 ] [ j ] = True<br>    return ( dp [ n ] [ m ] )<br></td>
  </tr><tr>
    <th>CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    temp = [ 0 ] * n<br>    for i in range ( n ) :<br>        temp [ i ] = arr [ i ]<br>    temp.sort ( )<br>    for front in range ( n ) :<br>        if temp [ front ] != arr [ front ] :<br>            break<br>    for back in range ( n - 1 , - 1 , - 1 ) :<br>        if temp [ back ] != arr [ back ] :<br>            break<br>    if front >= back :<br>        return True<br>    while front != back :<br>        front += 1<br>        if arr [ front - 1 ] < arr [ front ] :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    temp = [ arr [ i ] for i in range ( n ) ]<br>    temp.sort ( )<br>    front = 0<br>    for front in temp :<br>        if temp [ front ] != arr [ front ] :<br>            break<br>    back = 0<br>    for back in temp :<br>        if temp [ back ] != arr [ back ] :<br>            break<br>    if front >= back :<br>        return True<br>    do :<br>        front += 1<br>        if arr [ front - 1 ] < arr [ front ] :<br>            return False<br>    while front != back :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    if ( n == 1 ) :<br>        return True<br>    i = 1<br>    for i in range ( 1 , n ) :<br>        if arr [ i - 1 ] < arr [ i ] :<br>            if ( i == n ) :<br>                return True<br>    j = i<br>    while ( arr [ j ] < arr [ j - 1 ] ) :<br>        if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :<br>            return False<br>        j += 1<br>    if ( j == n ) :<br>        return True<br>    k = j<br>    if ( arr [ k ] < arr [ i - 1 ] ) :<br>        return False<br>    while ( k > 1 and k < n ) :<br>        if ( arr [ k ] < arr [ k - 1 ] ) :<br>            return False<br>        k += 1<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    if n == 1 :<br>        return True<br>    i = 0<br>    for i in range ( 1 , arr [ i - 1 ] < arr [ i ] , i ) :<br>        pass<br>    if i == n :<br>        return True<br>    j = i += 1<br>    while arr [ j ] < arr [ j - 1 ] :<br>        if i > 1 and arr [ j ] < arr [ i - 2 ] :<br>            return False<br>        j += 1<br>    if j == n :<br>        return True<br>    k = j<br>    if arr [ k ] < arr [ i - 1 ] :<br>        return False<br>    while k > 1 and k < n :<br>        if arr [ k ] < arr [ k - 1 ] :<br>            return False<br>        k += 1<br>    return True<br></td>
  </tr><tr>
    <th>CHECK_VALID_SEQUENCE_DIVISIBLE_M_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , index , modulo , M , arr , dp ) :<br>    modulo = ( ( modulo % M ) + M ) % M<br>    if ( index == n ) :<br>        if ( modulo == 0 ) :<br>            return 1<br>        return 0<br>    if ( dp [ index ] [ modulo ] != - 1 ) :<br>        return dp [ index ] [ modulo ]<br>    placeAdd = f_gold ( n , index + 1 , modulo + arr [ index ] , M , arr , dp )<br>    placeMinus = f_gold ( n , index + 1 , modulo - arr [ index ] , M , arr , dp )<br>    res = bool ( placeAdd or placeMinus )<br>    dp [ index ] [ modulo ] = res<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( n , index , modulo , M , arr , dp ) :<br>    modulo = ( ( modulo % M ) + M ) % M<br>    if index == n :<br>        if modulo == 0 :<br>            return 1<br>        return 0<br>    if dp [ index ] [ modulo ] != - 1 :<br>        return dp [ index ] [ modulo ]<br>    place_add = f_gold ( n , index + 1 , modulo + arr [ index ] , M , arr , dp )<br>    place_minus = f_gold ( n , index + 1 , modulo - arr [ index ] , M , arr , dp )<br>    res = place_add<br>    dp [ index ] [ modulo ] = res<br>    return res<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( not ( n & 1 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if ( n & 1 ) == 0 :<br>        return True<br>    else :<br>        return False<br></td>
  </tr><tr>
    <th>CHECK_WHETHER_TWO_STRINGS_ARE_ANAGRAM_OF_EACH_OTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str1 , str2 ) :<br>    n1 = len ( str1 )<br>    n2 = len ( str2 )<br>    if n1 != n2 :<br>        return 0<br>    str1 = sorted ( str1 )<br>    str2 = sorted ( str2 )<br>    for i in range ( 0 , n1 ) :<br>        if str1 [ i ] != str2 [ i ] :<br>            return 0<br>    return 1<br></td>
    <td>translated code: <br><br> def f_gold ( str1 , str2 ) :<br>    n1 = len ( str1 )<br>    n2 = len ( str2 )<br>    if n1 != n2 :<br>        return False<br>    str1 = sorted ( str1 )<br>    str2 = sorted ( str2 )<br>    for i in range ( n1 ) :<br>        if str1 [ i ] != str2 [ i ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>CHOCOLATE_DISTRIBUTION_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , m ) :<br>    if ( m == 0 or n == 0 ) :<br>        return 0<br>    arr.sort ( )<br>    if ( n < m ) :<br>        return - 1<br>    min_diff = sys.maxsize<br>    first = 0<br>    last = 0<br>    i = 0<br>    while ( i + m - 1 < n ) :<br>        diff = arr [ i + m - 1 ] - arr [ i ]<br>        if ( diff < min_diff ) :<br>            min_diff = diff<br>            first = i<br>            last = i + m - 1<br>        i += 1<br>    return ( arr [ last ] - arr [ first ] )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , m ) :<br>    if m == 0 or n == 0 :<br>        return 0<br>    arr.sort ( )<br>    if n < m :<br>        return - 1<br>    min_diff = sys.maxint<br>    first , last = 0 , 0<br>    for i in range ( 0 , i + m - 1 , n ) :<br>        diff = arr [ i + m - 1 ] - arr [ i ]<br>        if diff < min_diff :<br>            min_diff = diff<br>            first = i<br>            last = i + m - 1<br>    return ( arr [ last ] - arr [ first ] )<br></td>
  </tr><tr>
    <th>CIRCLE_LATTICE_POINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( r ) :<br>    if ( r <= 0 ) :<br>        return 0<br>    result = 4<br>    for x in range ( 1 , r ) :<br>        ySquare = r * r - x * x<br>        y = int ( math.sqrt ( ySquare ) )<br>        if ( y * y == ySquare ) :<br>            result += 4<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( r ) :<br>    if r <= 0 :<br>        return 0<br>    result = 4<br>    for x in range ( 1 , r ) :<br>        y_square = r ** 2 - x ** 2<br>        y = int ( math.sqrt ( y_square ) )<br>        if y * y == y_square :<br>            result += 4<br>    return result<br></td>
  </tr><tr>
    <th>COMPOSITE_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n <= 1 ) :<br>        return False<br>    if ( n <= 3 ) :<br>        return False<br>    if ( n % 2 == 0 or n % 3 == 0 ) :<br>        return True<br>    i = 5<br>    while ( i * i <= n ) :<br>        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :<br>            return True<br>        i = i + 6<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n <= 1 :<br>        print ( "False" )<br>    if n <= 3 :<br>        print ( "False" )<br>    if n % 2 == 0 or n % 3 == 0 :<br>        return True<br>    for i in range ( 5 , i * i <= n , 6 ) :<br>        if n % i == 0 or n % ( i + 2 ) == 0 :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , r , p ) :<br>    C = [ 0 for i in range ( r + 1 ) ]<br>    C [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( min ( i , r ) , 0 , - 1 ) :<br>            C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p<br>    return C [ r ]<br></td>
    <td>translated code: <br><br> def f_gold ( n , r , p ) :<br>    C = np.zeros ( ( r + 1 , ) )<br>    C [ 0 ] = 1<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( min ( i , r ) , 0 , - 1 ) :<br>            C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p<br>    return C [ r ]<br></td>
  </tr><tr>
    <th>COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , k , x ) :<br>    dp = list ( )<br>    dp.append ( 0 )<br>    dp.append ( 1 )<br>    i = 2<br>    while i < n :<br>        dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] )<br>        i = i + 1<br>    return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] )<br></td>
    <td>translated code: <br><br> def f_gold ( n , k , x ) :<br>    dp = [ 0 ] * 109<br>    dp [ 0 ] = 1<br>    for i in range ( 2 , n ) :<br>        dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ]<br>    return ( x == 1 and ( k - 1 ) * dp [ n - 2 ] or dp [ n - 1 ] )<br></td>
  </tr><tr>
    <th>COUNT_DIGITS_FACTORIAL_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n < 0 ) :<br>        return 0 <br>    if ( n <= 1 ) :<br>        return 1 <br>    digits = 0 <br>    for i in range ( 2 , n + 1 ) :<br>        digits += math.log10 ( i ) <br>    return math.floor ( digits ) + 1 <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n < 0 :<br>        return 0<br>    if n <= 1 :<br>        return 1<br>    digits = 0<br>    for i in range ( 2 , n + 1 ) :<br>        digits += math.log10 ( i )<br>    return int ( math.floor ( digits ) ) + 1<br></td>
  </tr><tr>
    <th>COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , x ) :<br>    cnt = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if i <= x :<br>            if x // i <= n and x % i == 0 :<br>                cnt += 1<br>    return cnt<br></td>
    <td>translated code: <br><br> def f_gold ( n , x ) :<br>    f_gold = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if x / i <= n and x % i == 0 :<br>            f_gold += 1<br>    return f_gold<br></td>
  </tr><tr>
    <th>COUNT_FACTORIAL_NUMBERS_IN_A_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( low , high ) :<br>    fact = 1<br>    x = 1<br>    while ( fact < low ) :<br>        fact = fact * x<br>        x += 1<br>    res = 0<br>    while ( fact <= high ) :<br>        res += 1<br>        fact = fact * x<br>        x += 1<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( low , high ) :<br>    fact , x = 1 , 1<br>    while fact < low :<br>        fact , x = fact * x , x + 1<br>    res = 0<br>    while fact <= high :<br>        res += 1<br>        fact , x = fact * x , x + 1<br>    return res<br></td>
  </tr><tr>
    <th>COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , k ) :<br>    if ( n + 1 >= k ) :<br>        return ( k - 1 )<br>    else :<br>        return ( 2 * n + 1 - k )<br></td>
    <td>translated code: <br><br> def f_gold ( n , k ) :<br>    if n + 1 >= k :<br>        return ( k - 1 )<br>    else :<br>        return ( 2 * n + 1 - k )<br></td>
  </tr><tr>
    <th>COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    ans = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( arr [ i ] == arr [ j ] ) :<br>                ans += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    ans = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] == arr [ j ] :<br>                ans += 1<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_SOLUTIONS_OF_X2_1_MOD_P_IN_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , p ) :<br>    ans = 0 <br>    for x in range ( 1 , p ) :<br>        if ( ( x * x ) % p == 1 ) :<br>            last = x + p * ( n / p ) <br>            if ( last > n ) :<br>                last -= p <br>            ans += ( ( last - x ) / p + 1 ) <br>    return int ( ans ) <br></td>
    <td>translated code: <br><br> def f_gold ( n , p ) :<br>    ans = 0<br>    for x in range ( 1 , p ) :<br>        if ( x ** 2 ) % p == 1 :<br>            last = x + p * ( n // p )<br>        else :<br>            last -= p<br>        ans += ( ( last - x ) // p + 1 )<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( dist ) :<br>    count = [ 0 ] * ( dist + 1 )<br>    count [ 0 ] = 1<br>    count [ 1 ] = 1<br>    count [ 2 ] = 2<br>    for i in range ( 3 , dist + 1 ) :<br>        count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] )<br>    return count [ dist ] <br></td>
    <td>translated code: <br><br> def f_gold ( dist ) :<br>    count = [ 1 , 1 , 2 ]<br>    for i in range ( 3 , dist + 1 ) :<br>        count.append ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] )<br>    return count [ dist ]<br></td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_FILL_A_N_X_4_GRID_USING_1_X_4_TILES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    dp = [ 0 for _ in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        if i <= 3 :<br>            dp [ i ] = 1<br>        elif i == 4 :<br>            dp [ i ] = 2<br>        else :<br>            dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ]<br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    dp [ 0 ] = 0<br>    for i in range ( 1 , n + 1 ) :<br>        if i >= 1 and i <= 3 :<br>            dp [ i ] = 1<br>        elif i == 4 :<br>            dp [ i ] = 2<br>        else :<br>            dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ]<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>COUNT_OF_OCCURRENCES_OF_A_101_PATTERN_IN_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    length = len ( s )<br>    oneSeen = False<br>    count = 0<br>    for i in range ( length ) :<br>        if ( s [ i ] == '1' and oneSeen ) :<br>            if ( s [ i - 1 ] == '0' ) :<br>                count += 1<br>        if ( s [ i ] == '1' and oneSeen == 0 ) :<br>            oneSeen = True<br>        if ( s [ i ] != '0' and s [ i ] != '1' ) :<br>            oneSeen = False<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    len ( str )<br>    one_seen = False<br>    count = 0<br>    for char in str :<br>        if char == '1' and one_seen == True :<br>            if char [ - 1 ] == '0' :<br>                count += 1<br>        if char == '1' and one_seen == False :<br>            one_seen = True<br>        if char != '0' and char != '1' :<br>            one_seen = False<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_DIFFERENCE_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , k ) :<br>    count = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k :<br>                count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , k ) :<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k :<br>                count += 1<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr1 , arr2 , m , n , x ) :<br>    count = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if arr1 [ i ] + arr2 [ j ] == x :<br>                count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( arr1 , arr2 , m , n , x ) :<br>    count = 0<br>    for i in range ( m ) :<br>        for j in range ( n ) :<br>            if ( arr1 [ i ] + arr2 [ j ] ) == x :<br>                count += 1<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    N = len ( str )<br>    cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ]<br>    for i in range ( N ) :<br>        cps [ i ] [ i ] = 1<br>    for L in range ( 2 , N + 1 ) :<br>        for i in range ( N ) :<br>            k = L + i - 1<br>            if ( k < N ) :<br>                if ( str [ i ] == str [ k ] ) :<br>                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 )<br>                else :<br>                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] )<br>    return cps [ 0 ] [ N - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    N = len ( str )<br>    cps = [ 1 for i in range ( N + 1 ) ]<br>    for L in range ( 2 , N + 1 ) :<br>        for i in range ( N ) :<br>            k = L + i - 1<br>            if k < N :<br>                if str [ i ] == str [ k ] :<br>                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1<br>                else :<br>                    cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ]<br>    return cps [ 0 ] [ N - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( p , q ) :<br>    dp = [ 1 for i in range ( q ) ]<br>    for i in range ( p - 1 ) :<br>        for j in range ( 1 , q ) :<br>            dp [ j ] += dp [ j - 1 ]<br>    return dp [ q - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( m , n ) :<br>    dp = np.zeros ( ( n , m ) )<br>    dp [ 0 ] = 1<br>    for i in range ( m ) :<br>        for j in range ( 1 , n ) :<br>            dp [ j ] += dp [ j - 1 ]<br>    return dp [ n - 1 ]<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    count = 0<br>    while ( n ) :<br>        n &= ( n - 1 )<br>        count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    count = 0<br>    while n > 0 :<br>        n &= ( n - 1 )<br>        count += 1<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n == 0 ) :<br>        return 0<br>    else :<br>        return 1 + f_gold ( n & ( n - 1 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 0 :<br>        return 0<br>    else :<br>        return 1 + f_gold ( n & ( n - 1 ) )<br></td>
  </tr><tr>
    <th>COUNT_SORTED_ROWS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , r , c ) :<br>    result = 0<br>    for i in range ( r ) :<br>        j = 0<br>        for j in range ( c - 1 ) :<br>            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :<br>                break<br>        if j == c - 2 :<br>            result += 1<br>    for i in range ( 0 , r ) :<br>        j = 0<br>        for j in range ( c - 1 , 0 , - 1 ) :<br>            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :<br>                break<br>        if c > 1 and j == 1 :<br>            result += 1<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( mat , r , c ) :<br>    result = 0<br>    for i in range ( r ) :<br>        j = 0<br>        for j in range ( c - 1 ) :<br>            if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :<br>                break<br>        if j == c - 1 :<br>            result += 1<br>    for i in range ( r ) :<br>        j = 0<br>        for j in range ( c - 1 , 0 , - 1 ) :<br>            if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :<br>                break<br>        if c > 1 and j == 0 :<br>            result += 1<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return 1 + ( n ** 2 ) + ( n * ( ( n ** 2 ) - 1 ) / 2 )<br></td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    um = dict ( )<br>    curr_sum = 0<br>    for i in range ( n ) :<br>        curr_sum += ( - 1 if ( arr [ i ] == 0 ) else arr [ i ] )<br>        if um.get ( curr_sum ) :<br>            um [ curr_sum ] += 1<br>        else :<br>            um [ curr_sum ] = 1<br>    count = 0<br>    for itr in um :<br>        if um [ itr ] > 1 :<br>            count += ( ( um [ itr ] * int ( um [ itr ] - 1 ) ) / 2 )<br>    if um.get ( 0 ) :<br>        count += um [ 0 ]<br>    return int ( count )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    um = { }<br>    curr_sum = 0<br>    for i in range ( n ) :<br>        curr_sum += ( arr [ i ] == 0 )<br>        um [ curr_sum ] = um [ curr_sum ] if curr_sum != 0 else 1<br>    count = 0<br>    for itr , val in um.items ( ) :<br>        if val > 1 :<br>            count += ( ( val * ( val - 1 ) ) / 2 )<br>    if um.has_key ( 0 ) :<br>        count += um [ 0 ]<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    mp = dict ( )<br>    Sum = 0<br>    count = 0<br>    for i in range ( n ) :<br>        if ( arr [ i ] == 0 ) :<br>            arr [ i ] = - 1<br>        Sum += arr [ i ]<br>        if ( Sum == 0 ) :<br>            count += 1<br>        if ( Sum in mp.keys ( ) ) :<br>            count += mp [ Sum ]<br>        mp [ Sum ] = mp.get ( Sum , 0 ) + 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    mydict = { }<br>    sum = 0<br>    count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] == 0 :<br>            arr [ i ] = - 1<br>        sum += arr [ i ]<br>        if sum == 0 :<br>            count += 1<br>        if mydict.has_key ( sum ) :<br>            count += mydict [ sum ]<br>        if not mydict.has_key ( sum ) :<br>            mydict [ sum ] = 1<br>        else :<br>            mydict [ sum ] = mydict [ sum ] + 1<br>    return count<br></td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_TOTAL_DISTINCT_ELEMENTS_ORIGINAL_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    vis = dict ( )<br>    for i in range ( n ) :<br>        vis [ arr [ i ] ] = 1<br>    k = len ( vis )<br>    vid = dict ( )<br>    ans = 0<br>    right = 0<br>    window = 0<br>    for left in range ( n ) :<br>        while ( right < n and window < k ) :<br>            if arr [ right ] in vid.keys ( ) :<br>                vid [ arr [ right ] ] += 1<br>            else :<br>                vid [ arr [ right ] ] = 1<br>            if ( vid [ arr [ right ] ] == 1 ) :<br>                window += 1<br>            right += 1<br>        if ( window == k ) :<br>            ans += ( n - right + 1 )<br>        vid [ arr [ left ] ] -= 1<br>        if ( vid [ arr [ left ] ] == 0 ) :<br>            window -= 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    vis = { }<br>    for key in arr :<br>        vis [ arr [ key ] ] = 1<br>    k = len ( vis )<br>    vis.clear ( )<br>    ans , right , window = 0 , 0 , 0<br>    for left in range ( n ) :<br>        while right < n and window < k :<br>            vis [ arr [ right ] ] = vis [ arr [ right ] ] + 1<br>            if vis [ arr [ right ] ] == 1 :<br>                window += 1<br>            right += 1<br>        if window == k :<br>            ans += ( n - right + 1 )<br>        vis [ arr [ left ] ] = vis [ arr [ left ] ] - 1<br>        if vis [ arr [ left ] ] == 0 :<br>            window -= 1<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    difference = 0<br>    ans = 0<br>    hash_positive = [ 0 ] * ( n + 1 )<br>    hash_negative = [ 0 ] * ( n + 1 )<br>    hash_positive [ 0 ] = 1<br>    for i in range ( n ) :<br>        if ( arr [ i ] & 1 == 1 ) :<br>            difference = difference + 1<br>        else :<br>            difference = difference - 1<br>        if ( difference < 0 ) :<br>            ans += hash_negative [ - difference ]<br>            hash_negative [ - difference ] = hash_negative [ - difference ] + 1<br>        else :<br>            ans += hash_positive [ difference ]<br>            hash_positive [ difference ] = hash_positive [ difference ] + 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    difference = 0<br>    ans = 0<br>    hash_positive = [ 0 ] * ( n + 1 )<br>    hash_negative = [ 0 ] * ( n + 1 )<br>    hash_positive [ 0 ] = 1<br>    for i in range ( n ) :<br>        if ( arr [ i ] & 1 ) == 1 :<br>            difference += 1<br>        else :<br>            difference -= 1<br>        if difference < 0 :<br>            ans += hash_negative [ - difference ]<br>            hash_negative [ - difference ] += 1<br>        else :<br>            ans += hash_positive [ difference ]<br>            hash_positive [ difference ] += 1<br>    return ans<br></td>
  </tr><tr>
    <th>COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    result = 0 <br>    n = len ( s ) <br>    for i in range ( n ) :<br>        for j in range ( i , n ) :<br>            if ( s [ i ] == s [ j ] ) :<br>                result = result + 1<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    result = 0<br>    n = len ( s )<br>    for i in range ( n ) :<br>        for j in range ( i , n ) :<br>            if s [ i ] == s [ j ] :<br>                result += 1<br>    return result<br></td>
  </tr><tr>
    <th>COUNT_SUM_OF_DIGITS_IN_NUMBERS_FROM_1_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n < 10 ) :<br>        return ( n * ( n + 1 ) / 2 )<br>    d = ( int ) ( math.log10 ( n ) )<br>    a = [ 0 ] * ( d + 1 )<br>    a [ 0 ] = 0<br>    a [ 1 ] = 45<br>    for i in range ( 2 , d + 1 ) :<br>        a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math.ceil ( math.pow ( 10 , i - 1 ) ) )<br>    p = ( int ) ( math.ceil ( math.pow ( 10 , d ) ) )<br>    msd = n // p<br>    return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + f_gold ( n % p ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n < 10 :<br>        return ( n * ( n + 1 ) / 2 )<br>    d = int ( math.log10 ( n ) )<br>    a = [ 0 ] * ( d + 1 )<br>    a [ 0 ] = 45<br>    for i in range ( 2 , d + 1 ) :<br>        a [ i ] = a [ i - 1 ] * 10 + 45 * int ( math.ceil ( math.pow ( 10 , i - 1 ) ) )<br>    p = int ( math.ceil ( math.pow ( 10 , d ) ) )<br>    msd = n / p<br>    return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + f_gold ( n % p ) )<br></td>
  </tr><tr>
    <th>COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A ) :<br>    n = 2 * A<br>    dpArray = [ 0 ] * ( n + 1 )<br>    dpArray [ 0 ] = 1<br>    dpArray [ 2 ] = 1<br>    for i in range ( 4 , n + 1 , 2 ) :<br>        for j in range ( 0 , i - 1 , 2 ) :<br>            dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] )<br>    return int ( dpArray [ n ] )<br></td>
    <td>translated code: <br><br> def f_gold ( A ) :<br>    n = 2 * A<br>    dpArray = [ 1 ] * n + [ 1 ] * n<br>    for i in range ( 4 , n + 1 , 2 ) :<br>        for j in range ( 0 , i - 1 , 2 ) :<br>            dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] )<br>    return dpArray [ n ]<br></td>
  </tr><tr>
    <th>COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( stri , n ) :<br>    m = dict ( )<br>    for i in range ( n ) :<br>        m [ stri [ i ] ] = m.get ( stri [ i ] , 0 ) + 1<br>    res = 0<br>    for i in m.values ( ) :<br>        if i == 2 :<br>            res += 1<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( str , n ) :<br>    m = { }<br>    for i in range ( n ) :<br>        if m.has_key ( str [ i ] ) :<br>            get = m [ str [ i ] ]<br>            m [ str [ i ] ] = get + 1<br>        else :<br>            m [ str [ i ] ] = 1<br>    res = 0<br>    for key , value in m.items ( ) :<br>        if value == 2 :<br>            res += 1<br>    return res<br></td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * f_gold ( n - 1 ) <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    res , i = 1 , 0<br>    for i in range ( 2 , n + 1 ) :<br>        res *= i<br>    return res<br></td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * f_gold ( n - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( n == 1 or n == 0 )<br></td>
  </tr><tr>
    <th>C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    return max ( arr )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    arr.sort ( )<br>    return arr [ n - 1 ]<br></td>
  </tr><tr>
    <th>DECODE_MEDIAN_STRING_ORIGINAL_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    l = len ( s )<br>    s1 = ""<br>    if ( l % 2 == 0 ) :<br>        isEven = True<br>    else :<br>        isEven = False<br>    for i in range ( 0 , l , 2 ) :<br>        if ( isEven ) :<br>            s1 = s [ i ] + s1<br>            s1 += s [ i + 1 ]<br>        else :<br>            if ( l - i > 1 ) :<br>                s1 += s [ i ]<br>                s1 = s [ i + 1 ] + s1<br>            else :<br>                s1 += s [ i ]<br>    return s1<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    l = len ( s )<br>    s1 = ""<br>    is_even = ( l % 2 == 0 )<br>    for i in range ( 0 , l , 2 ) :<br>        if is_even :<br>            s1 = s [ i ] + s1<br>            s1 += s [ i + 1 ]<br>        else :<br>            if l - i > 1 :<br>                s1 += s [ i ]<br>                s1 = s [ i + 1 ] + s1<br>            else :<br>                s1 += s [ i ]<br>    return s1<br></td>
  </tr><tr>
    <th>DIAGONALLY_DOMINANT_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( m , n ) :<br>    for i in range ( 0 , n ) :<br>        sum = 0<br>        for j in range ( 0 , n ) :<br>            sum = sum + abs ( m [ i ] [ j ] )<br>        sum = sum - abs ( m [ i ] [ i ] )<br>        if ( abs ( m [ i ] [ i ] ) < sum ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( m , n ) :<br>    for i in range ( n ) :<br>        sum = 0<br>        for j in range ( n ) :<br>            sum += abs ( m [ i ] [ j ] )<br>        sum -= abs ( m [ i ] [ i ] )<br>        if abs ( m [ i ] [ i ] ) < sum :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>DICE_THROW_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( m , n , x ) :<br>    table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]<br>    for j in range ( 1 , min ( m + 1 , x + 1 ) ) :<br>        table [ 1 ] [ j ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 1 , x + 1 ) :<br>            for k in range ( 1 , min ( m + 1 , j ) ) :<br>                table [ i ] [ j ] += table [ i - 1 ] [ j - k ]<br>    return table [ - 1 ] [ - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( m , n , x ) :<br>    table = [ [ 0 ] * ( n + 1 ) + [ x + 1 ] * ( n + 1 ) for x in range ( 1 , m + 1 ) ]<br>    for j in range ( 1 , x + 1 ) :<br>        table [ 1 ] [ j ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 1 , x + 1 ) :<br>            for k in range ( 1 , j + 1 ) and k <= m :<br>                table [ i ] [ j ] += table [ i - 1 ] [ j - k ]<br>    return table [ n ] [ x ]<br></td>
  </tr><tr>
    <th>DICE_THROW_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( f , d , s ) :<br>    mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ]<br>    mem [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , d + 1 ) :<br>        for j in range ( 1 , s + 1 ) :<br>            mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ]<br>            if j - f - 1 >= 0 :<br>                mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ]<br>    return mem [ d ] [ s ]<br></td>
    <td>translated code: <br><br> def f_gold ( f , d , s ) :<br>    mem = [ 1 ] * ( d + 1 )<br>    mem [ 0 ] [ 0 ] = 1<br>    for i in range ( 1 , d + 1 ) :<br>        for j in range ( i , s + 1 ) :<br>            mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ]<br>            if j - f - 1 >= 0 :<br>                mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ]<br>    return mem [ d ] [ s ]<br></td>
  </tr><tr>
    <th>DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    arr.sort ( )<br>    count = 0 ; max_count = 0 ; min_count = n<br>    for i in range ( 0 , ( n - 1 ) ) :<br>        if arr [ i ] == arr [ i + 1 ] :<br>            count += 1<br>            continue<br>        else :<br>            max_count = max ( max_count , count )<br>            min_count = min ( min_count , count )<br>            count = 0<br>    return max_count - min_count<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    arr.sort ( )<br>    count , max_count , min_count = 0 , 0 , n<br>    for i in range ( ( n - 1 ) ) :<br>        if arr [ i ] == arr [ i + 1 ] :<br>            count += 1<br>            continue<br>        else :<br>            max_count = max ( max_count , count )<br>            min_count = min ( min_count , count )<br>            count = 0<br>    return ( max_count - min_count )<br></td>
  </tr><tr>
    <th>DOUBLE_FACTORIAL_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    res = 1 <br>    for i in range ( n , - 1 , - 2 ) :<br>        if ( i == 0 or i == 1 ) :<br>            return res <br>        else :<br>            res *= i <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    res = 1<br>    for i in range ( n , - 1 , - 1 ) :<br>        if i == 0 or i == 1 :<br>            return res<br>        else :<br>            res *= i<br>    return res<br></td>
  </tr><tr>
    <th>DYCK_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    res = 1<br>    for i in range ( 0 , n ) :<br>        res *= ( 2 * n - i )<br>        res /= ( i + 1 )<br>    return res / ( n + 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    res = 1<br>    for i in range ( n ) :<br>        res *= ( 2 ** n - i )<br>        res /= ( i + 1 )<br>    return res / ( n + 1 )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( high , low , n ) :<br>    if ( n <= 0 ) :<br>        return 0<br>    return max ( high [ n - 1 ] + f_gold ( high , low , ( n - 2 ) ) , low [ n - 1 ] + f_gold ( high , low , ( n - 1 ) ) ) <br></td>
    <td>translated code: <br><br> def f_gold ( high , low , n ) :<br>    if n <= 0 :<br>        return 0<br>    return max ( high [ n - 1 ] + f_gold ( high , low , ( n - 2 ) ) , low [ n - 1 ] + f_gold ( high , low , ( n - 1 ) ) )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    max = 0<br>    msis = [ 0 for x in range ( n ) ]<br>    for i in range ( n ) :<br>        msis [ i ] = arr [ i ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) :<br>                msis [ i ] = msis [ j ] + arr [ i ]<br>    for i in range ( n ) :<br>        if max < msis [ i ] :<br>            max = msis [ i ]<br>    return max<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    i , j , max = 0 , 0 , 0<br>    msis = [ ]<br>    for i in range ( n ) :<br>        msis.append ( arr [ i ] )<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] :<br>                msis [ i ] , msis [ j ] = msis [ j ] , msis [ i ]<br>    for i in range ( n ) :<br>        if max < msis [ i ] :<br>            max = msis [ i ]<br>    return max<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n == 2 or n == 3 ) :<br>        return ( n - 1 )<br>    res = 1<br>    while ( n > 4 ) :<br>        n -= 3 <br>        res *= 3 <br>    return ( n * res )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 2 or n == 3 :<br>        return ( n - 1 )<br>    res = 1<br>    while n > 4 :<br>        n -= 3<br>        res *= 3<br>    return ( n * res )<br></td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( symb , oper , n ) :<br>    F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]<br>    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ]<br>    for i in range ( n ) :<br>        if symb [ i ] == 'F' :<br>            F [ i ] [ i ] = 1<br>        else :<br>            F [ i ] [ i ] = 0<br>        if symb [ i ] == 'T' :<br>            T [ i ] [ i ] = 1<br>        else :<br>            T [ i ] [ i ] = 0<br>    for gap in range ( 1 , n ) :<br>        i = 0<br>        for j in range ( gap , n ) :<br>            T [ i ] [ j ] = F [ i ] [ j ] = 0<br>            for g in range ( gap ) :<br>                k = i + g<br>                tik = T [ i ] [ k ] + F [ i ] [ k ] <br>                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] <br>                if oper [ k ] == '&' :<br>                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ]<br>                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] )<br>                if oper [ k ] == '|' :<br>                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ]<br>                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] )<br>                if oper [ k ] == '^' :<br>                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] )<br>                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] )<br>            i += 1<br>    return T [ 0 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( symb , oper , n ) :<br>    F = [ ]<br>    T = [ ]<br>    for i in range ( n ) :<br>        F.append ( ( symb [ i ] , symb [ i + 1 ] ) )<br>        T.append ( ( symb [ i ] , symb [ i + 1 ] ) )<br>    for gap in range ( 1 , n ) :<br>        for i , j in zip ( gap , n ) :<br>            T [ i ] = F [ i ] = 0<br>            for g in range ( gap ) :<br>                k = i + g<br>                tik = T [ i ] + F [ i ] [ k ]<br>                tkj = T [ k + 1 ] + F [ k + 1 ] [ j ]<br>                if oper [ k ] == '&' :<br>                    T [ i ] += T [ i ] * T [ k + 1 ] [ j ]<br>                    F [ i ] += ( tik * tkj - T [ i ] * T [ k + 1 ] [ j ] )<br>                if oper [ k ] == '|' :<br>                    F [ i ] += F [ i ] * F [ k + 1 ] [ j ]<br>                    T [ i ] += ( tik * tkj - F [ i ] * F [ k + 1 ] [ j ] )<br>                if oper [ k ] == '^' :<br>                    T [ i ] += F [ i ] * T [ k + 1 ] [ j ] + T [ i ] * F [ k + 1 ] [ j ]<br>                    F [ i ] += T [ i ] * T [ k + 1 ] [ j ] + F [ i ] * F [ k + 1 ] [ j ]<br>    return T [ 0 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    s = dict ( )<br>    count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9<br>    for i in range ( n ) :<br>        s [ arr [ i ] ] = 1<br>        if ( arr [ i ] < minm ) :<br>            minm = arr [ i ]<br>        if ( arr [ i ] > maxm ) :<br>            maxm = arr [ i ]<br>    for i in range ( minm , maxm + 1 ) :<br>        if i not in s.keys ( ) :<br>            count += 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    s = set ( )<br>    count , maxm , minm = 0 , int ( min ( arr ) ) , int ( max ( arr ) )<br>    for i in range ( n ) :<br>        s.add ( arr [ i ] )<br>        if arr [ i ] < minm :<br>            minm = arr [ i ]<br>        if arr [ i ] > maxm :<br>            maxm = arr [ i ]<br>    for i in range ( minm , maxm + 1 ) :<br>        if not s.add ( i ) :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>EVEN_FIBONACCI_NUMBERS_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( limit ) :<br>    if ( limit < 2 ) :<br>        return 0<br>    ef1 = 0<br>    ef2 = 2<br>    sm = ef1 + ef2<br>    while ( ef2 <= limit ) :<br>        ef3 = 4 * ef2 + ef1<br>        if ( ef3 > limit ) :<br>            break<br>        ef1 = ef2<br>        ef2 = ef3<br>        sm = sm + ef2<br>    return sm<br></td>
    <td>translated code: <br><br> def f_gold ( limit ) :<br>    if limit < 2 :<br>        return 0<br>    ef1 , ef2 = 0 , 2<br>    sum = ef1 + ef2<br>    while ef2 <= limit :<br>        ef3 = 4 * ef2 + ef1<br>        if ef3 > limit :<br>            break<br>        ef1 , ef2 = ef2 , ef3<br>        sum += ef2<br>    return int ( sum )<br></td>
  </tr><tr>
    <th>FIBONACCI_MODULO_P</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( p ) :<br>    first = 1<br>    second = 1<br>    number = 2<br>    next = 1<br>    while ( next ) :<br>        next = ( first + second ) % p<br>        first = second<br>        second = next<br>        number = number + 1<br>    return number<br></td>
    <td>translated code: <br><br> def f_gold ( p ) :<br>    first , second , number , next = 1 , 1 , 2 , 1<br>    while next > 0 :<br>        next = ( first + second ) % p<br>        first , second , number += 1<br>    return number<br></td>
  </tr><tr>
    <th>FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( n ) :<br>        if arr [ i ] is i :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    i = 0<br>    for i in range ( n ) :<br>        if arr [ i ] == i :<br>            return i<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    brr = [ 0 ] * ( 2 * n + 1 )<br>    for i in range ( n ) :<br>        brr [ i ] = arr [ i ]<br>    for i in range ( n ) :<br>        brr [ n + i ] = arr [ i ]<br>    maxHam = 0<br>    for i in range ( 1 , n ) :<br>        currHam = 0<br>        k = 0<br>        for j in range ( i , i + n ) :<br>            if brr [ j ] != arr [ k ] :<br>                currHam += 1<br>                k = k + 1<br>        if currHam == n :<br>            return n<br>        maxHam = max ( maxHam , currHam )<br>    return maxHam<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    brr = [ arr [ i ] for i in range ( 2 * n + 1 ) ]<br>    for i in range ( n ) :<br>        brr [ n + i ] = arr [ i ]<br>    max_ham = 0<br>    for i in range ( 1 , n ) :<br>        curr_ham = 0<br>        for j , k in enumerate ( ( i , n ) ) :<br>            if brr [ j ] != arr [ k ] :<br>                curr_ham += 1<br>        if curr_ham == n :<br>            return n<br>        max_ham = max ( max_ham , curr_ham )<br>    return max_ham<br></td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , arr_size , sum ) :<br>    for i in range ( 0 , arr_size - 2 ) :<br>        for j in range ( i + 1 , arr_size - 1 ) :<br>            for k in range ( j + 1 , arr_size ) :<br>                if A [ i ] + A [ j ] + A [ k ] == sum :<br>                    print ( "Triplet is" , A [ i ] , ", " , A [ j ] , ", " , A [ k ] )<br>                    return True<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( A , arr_size , sum ) :<br>    l , r = A.shape<br>    for i in range ( arr_size - 2 ) :<br>        for j in range ( i + 1 , arr_size - 1 ) :<br>            for k in range ( j + 1 , arr_size ) :<br>                if A [ i , j , k ] + A [ j , k ] == sum :<br>                    print ( "Triplet is %d, %d, %d" % ( A [ i , j , k ] , A [ j , k ] ) )<br>                    return True<br>    return False<br></td>
  </tr><tr>
    <th>FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( string ) :<br>    Stack = [ ]<br>    for ch in string :<br>        if ch == ')' :<br>            top = Stack.pop ( )<br>            elementsInside = 0<br>            while top != '(' :<br>                elementsInside += 1<br>                top = Stack.pop ( )<br>            if elementsInside < 1 :<br>                return True<br>        else :<br>            Stack.append ( ch )<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    Stack = Stack ( )<br>    str = s.split ( )<br>    for ch in str :<br>        if ch == ')' :<br>            top = Stack.top ( )<br>            Stack.pop ( )<br>            elementsInside = 0<br>            while top != '(' :<br>                elementsInside += 1<br>                top = Stack.top ( )<br>                Stack.pop ( )<br>            if elementsInside < 1 :<br>                return True<br>        else :<br>            Stack.push ( ch )<br>    return False<br></td>
  </tr><tr>
    <th>FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    fibo = 2.078087 * math.log ( n ) + 1.672276<br>    return round ( fibo )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    fibo = 2.078087F * float ( math.log ( n , 2 ) ) + 1.672276F<br>    return round ( fibo , 2 )<br></td>
  </tr><tr>
    <th>FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr1 , arr2 , n ) :<br>    for i in range ( 0 , n ) :<br>        if ( arr1 [ i ] != arr2 [ i ] ) :<br>            return i<br>    return n<br></td>
    <td>translated code: <br><br> def f_gold ( arr1 , arr2 , n ) :<br>    for i in range ( n ) :<br>        if arr1 [ i ] != arr2 [ i ] :<br>            return i<br>    return n<br></td>
  </tr><tr>
    <th>FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr1 , arr2 , n ) :<br>    index = n<br>    left = 0<br>    right = n - 1<br>    while ( left <= right ) :<br>        mid = ( int ) ( ( left + right ) / 2 )<br>        if ( arr2 [ mid ] == arr1 [ mid ] ) :<br>            left = mid + 1<br>        else :<br>            index = mid<br>            right = mid - 1<br>    return index<br></td>
    <td>translated code: <br><br> def f_gold ( arr1 , arr2 , n ) :<br>    index = n<br>    left , right = 0 , n - 1<br>    while left <= right :<br>        mid = ( left + right ) // 2<br>        if arr2 [ mid ] == arr1 [ mid ] :<br>            left = mid + 1<br>        else :<br>            index = mid<br>            right = mid - 1<br>    return index<br></td>
  </tr><tr>
    <th>FIND_LARGEST_PRIME_FACTOR_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    maxPrime = - 1<br>    while n % 2 == 0 :<br>        maxPrime = 2<br>        n >>= 1<br>    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :<br>        while n % i == 0 :<br>            maxPrime = i<br>            n = n / i<br>    if n > 2 :<br>        maxPrime = n<br>    return int ( maxPrime )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    max_prime = - 1<br>    while n % 2 == 0 :<br>        max_prime = 2<br>        n >>= 1<br>    for i in range ( 3 , math.sqrt ( n ) , 2 ) :<br>        while n % i == 0 :<br>            max_prime = i<br>            n = n / i<br>    if n > 2 :<br>        max_prime = n<br>    return max_prime<br></td>
  </tr><tr>
    <th>FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , B ) :<br>    variable = 1<br>    if ( A == B ) :<br>        return 1<br>    elif ( ( B - A ) >= 5 ) :<br>        return 0<br>    else :<br>        for i in range ( A + 1 , B + 1 ) :<br>            variable = ( variable * ( i % 10 ) ) % 10<br>        return variable % 10<br></td>
    <td>translated code: <br><br> def f_gold ( A , B ) :<br>    variable = 1<br>    if A == B :<br>        return 1<br>    elif ( B - A ) >= 5 :<br>        return 0<br>    else :<br>        for i in range ( A + 1 , B + 1 ) :<br>            variable = int ( variable * ( i % 10 ) ) % 10<br>        return variable % 10<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    if n < 3 :<br>        return - 1<br>    max_product = - ( sys.maxsize - 1 )<br>    for i in range ( 0 , n - 2 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] )<br>    return max_product<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    if n < 3 :<br>        return - 1<br>    max_product = int ( '-1' )<br>    for i in range ( n - 2 ) :<br>        for j in range ( i + 1 , n - 1 ) :<br>            for k in range ( j + 1 , n ) :<br>                max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] )<br>    return max_product<br></td>
  </tr><tr>
    <th>FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :<br>    sum1 , sum2 , sum3 = 0 , 0 , 0<br>    for i in range ( n1 ) :<br>        sum1 += stack1 [ i ]<br>    for i in range ( n2 ) :<br>        sum2 += stack2 [ i ]<br>    for i in range ( n3 ) :<br>        sum3 += stack3 [ i ]<br>    top1 , top2 , top3 = 0 , 0 , 0<br>    ans = 0<br>    while ( 1 ) :<br>        if ( top1 == n1 or top2 == n2 or top3 == n3 ) :<br>            return 0<br>        if ( sum1 == sum2 and sum2 == sum3 ) :<br>            return sum1<br>        if ( sum1 >= sum2 and sum1 >= sum3 ) :<br>            sum1 -= stack1 [ top1 ]<br>            top1 = top1 + 1<br>        elif ( sum2 >= sum3 and sum2 >= sum3 ) :<br>            sum2 -= stack2 [ top2 ]<br>            top2 = top2 + 1<br>        elif ( sum3 >= sum2 and sum3 >= sum1 ) :<br>            sum3 -= stack3 [ top3 ]<br>            top3 = top3 + 1<br></td>
    <td>translated code: <br><br> def f_gold ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :<br>    sum1 , sum2 , sum3 = 0 , 0 , 0 , 0<br>    for i in range ( n1 ) :<br>        sum1 += stack1 [ i ]<br>    for i in range ( n2 ) :<br>        sum2 += stack2 [ i ]<br>    for i in range ( n3 ) :<br>        sum3 += stack3 [ i ]<br>    top1 , top2 , top3 = 0 , 0 , 0 , 0<br>    ans = 0<br>    while True :<br>        if top1 == n1 or top2 == n2 or top3 == n3 :<br>            return 0<br>        if sum1 == sum2 and sum2 == sum3 :<br>            return sum1<br>        if sum1 >= sum2 and sum1 >= sum3 :<br>            sum1 -= stack1 [ top1 ]<br>        elif sum2 >= sum3 and sum2 >= sum3 :<br>            sum2 -= stack2 [ top2 ]<br>        elif sum3 >= sum2 and sum3 >= sum1 :<br>            sum3 -= stack3 [ top3 ]<br></td>
  </tr><tr>
    <th>FIND_MINIMUM_DIFFERENCE_PAIR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    arr = sorted ( arr )<br>    diff = 10 ** 20<br>    for i in range ( n - 1 ) :<br>        if arr [ i + 1 ] - arr [ i ] < diff :<br>            diff = arr [ i + 1 ] - arr [ i ]<br>    return diff<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    arr.sort ( )<br>    diff = sys.maxsize<br>    for i in range ( n - 1 ) :<br>        if arr [ i + 1 ] - arr [ i ] < diff :<br>            diff = arr [ i + 1 ] - arr [ i ]<br>    return diff<br></td>
  </tr><tr>
    <th>FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b ) :<br>    m = len ( a )<br>    n = len ( b )<br>    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]<br>    for i in range ( n + 1 ) :<br>        lookup [ 0 ] [ i ] = 0<br>    for i in range ( m + 1 ) :<br>        lookup [ i ] [ 0 ] = 1<br>    for i in range ( 1 , m + 1 ) :<br>        for j in range ( 1 , n + 1 ) :<br>            if a [ i - 1 ] == b [ j - 1 ] :<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]<br>            else :<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]<br>    return lookup [ m ] [ n ]<br></td>
    <td>translated code: <br><br> def f_gold ( a , b ) :<br>    m = len ( a )<br>    n = len ( b )<br>    lookup = [ 0 ] * ( m + 1 ) * ( n + 1 )<br>    for i in range ( 0 , n ) :<br>        lookup [ 0 ] [ i ] = 0<br>    for i in range ( 0 , m ) :<br>        lookup [ i ] [ 0 ] = 1<br>    for i in range ( 1 , m ) :<br>        for j in range ( 1 , n ) :<br>            if a [ i - 1 ] == b [ j - 1 ] :<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ]<br>            else :<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]<br>    return lookup [ m ] [ n ]<br></td>
  </tr><tr>
    <th>FIND_ONE_EXTRA_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( strA , strB ) :<br>    res = 0<br>    for i in range ( 0 , len ( strA ) ) :<br>        res = res ^ ( ord ) ( strA [ i ] )<br>    for i in range ( 0 , len ( strB ) ) :<br>        res = res ^ ( ord ) ( strB [ i ] )<br>    return ( ( chr ) ( res ) ) <br></td>
    <td>translated code: <br><br> def f_gold ( strA , strB ) :<br>    res , i = 0 , 0<br>    for i in range ( len ( strA ) ) :<br>        res ^= strA [ i ]<br>    for i in range ( len ( strB ) ) :<br>        res ^= strB [ i ]<br>    return ( chr ( res ) , i )<br></td>
  </tr><tr>
    <th>FIND_PERIMETER_CYLINDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( diameter , height ) :<br>    return 2 * ( diameter + height )<br></td>
    <td>translated code: <br><br> def f_gold ( diameter , height ) :<br>    return 2 * ( diameter + height )<br></td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += arr [ i ]<br>    return sum - ( ( ( n - 1 ) * n ) / 2 )<br></td>
  </tr><tr>
    <th>FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( 1 << ( n - 1 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( 1 << ( n - 1 ) )<br></td>
  </tr><tr>
    <th>FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( N , K ) :<br>    ans = 0 <br>    for i in range ( 1 , N + 1 ) :<br>        ans += ( i % K ) <br>    return ans <br></td>
    <td>translated code: <br><br> def f_gold ( N , K ) :<br>    ans = 0<br>    for i in range ( 1 , N + 1 ) :<br>        ans += ( i % K )<br>    return ans<br></td>
  </tr><tr>
    <th>FIND_SUM_ODD_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    res = 1<br>    while n % 2 == 0 :<br>        n = n // 2<br>    for i in range ( 3 , int ( math.sqrt ( n ) + 1 ) ) :<br>        count = 0<br>        curr_sum = 1<br>        curr_term = 1<br>        while n % i == 0 :<br>            count += 1<br>            n = n // i<br>            curr_term *= i<br>            curr_sum += curr_term<br>        res *= curr_sum<br>    if n >= 2 :<br>        res *= ( 1 + n )<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    res = 1<br>    while n % 2 == 0 :<br>        n = n // 2<br>    for i in range ( 3 , math.sqrt ( n ) ) :<br>        count , curr_sum = 0 , 1<br>        curr_term = 1<br>        while n % i == 0 :<br>            count += 1<br>            n = n // i<br>            curr_term *= i<br>            curr_sum += curr_term<br>        res *= curr_sum<br>    if n >= 2 :<br>        res *= ( 1 + n )<br>    return res<br></td>
  </tr><tr>
    <th>FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    res = 0<br>    m = dict ( )<br>    for i in range ( n ) :<br>        Sum = 0<br>        for j in range ( i , n ) :<br>            Sum += arr [ j ]<br>            m [ Sum ] = m.get ( Sum , 0 ) + 1<br>    for x in m :<br>        if m [ x ] == 1 :<br>            res += x<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    res = 0<br>    m = { }<br>    for i in range ( n ) :<br>        sum = 0<br>        for j in range ( i , n ) :<br>            sum += arr [ j ]<br>            if m.has_key ( sum ) :<br>                m [ sum ] = m [ sum ] + 1<br>            else :<br>                m [ sum ] = 1<br>    for x , y in m.items ( ) :<br>        if y == 1 :<br>            res += x<br>    return res<br></td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    leftMax = [ None ] * n<br>    leftMax [ 0 ] = float ( '-inf' )<br>    for i in range ( 1 , n ) :<br>        leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] )<br>    rightMin = float ( 'inf' )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] :<br>            return i<br>        rightMin = min ( rightMin , arr [ i ] )<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    left_max = [ int ( x ) for x in arr ]<br>    right_min = int ( arr [ - 1 ] )<br>    for i in range ( 1 , n ) :<br>        left_max [ i ] = max ( left_max [ i - 1 ] , arr [ i - 1 ] )<br>    right_min = int ( arr [ - 1 ] )<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if left_max [ i ] < arr [ i ] and right_min [ i ] > arr [ i ] :<br>            return i<br>        right_min = min ( right_min , arr [ i ] )<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , low , high ) :<br>    max = arr [ low ]<br>    i = low<br>    for i in range ( high + 1 ) :<br>        if arr [ i ] > max :<br>            max = arr [ i ]<br>    return max<br></td>
    <td>translated code: <br><br> def f_gold ( arr , low , high ) :<br>    max = arr [ low ]<br>    i = 0<br>    for i in range ( low , high + 1 ) :<br>        if arr [ i ] > max :<br>            max = arr [ i ]<br>    return max<br></td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    i , total = 0 , 1<br>    for i in range ( 2 , n + 2 ) :<br>        total += i<br>        total -= a [ i - 2 ]<br>    return total<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    total = 1<br>    for i in range ( 2 , ( n + 1 ) + 1 ) :<br>        total += i<br>        total -= a [ i - 2 ]<br>    return total<br></td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    x1 = a [ 0 ]<br>    x2 = 1<br>    for i in range ( 1 , n ) :<br>        x1 = x1 ^ a [ i ]<br>    for i in range ( 2 , n + 2 ) :<br>        x2 = x2 ^ i<br>    return x1 ^ x2<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    x1 = a [ 0 ]<br>    x2 = 1<br>    for i in range ( 1 , n + 1 ) :<br>        x1 = x1 ^ a [ i ]<br>    for i in range ( 2 , n + 1 ) :<br>        x2 = x2 ^ i<br>    return ( x1 ^ x2 )<br></td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , arr_size ) :<br>    for i in range ( 0 , arr_size ) :<br>        count = 0<br>        for j in range ( 0 , arr_size ) :<br>            if arr [ i ] == arr [ j ] :<br>                count += 1<br>        if ( count % 2 != 0 ) :<br>            return arr [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , arr_size ) :<br>    i = 0<br>    for i in range ( arr_size ) :<br>        count = 0<br>        for j in range ( arr_size ) :<br>            if arr [ i ] == arr [ j ] :<br>                count += 1<br>        if count % 2 != 0 :<br>            return arr [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , size ) :<br>    Hash = dict ( )<br>    for i in range ( size ) :<br>        Hash [ arr [ i ] ] = Hash.get ( arr [ i ] , 0 ) + 1 <br>    for i in Hash :<br>        if ( Hash [ i ] % 2 != 0 ) :<br>            return i<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    hdict = { }<br>    for i in range ( n ) :<br>        if hdict.has_key ( arr [ i ] ) :<br>            val = hdict [ arr [ i ] ]<br>            hdict [ arr [ i ] ] = val + 1<br>        else :<br>            hdict [ arr [ i ] ] = 1<br>    for a in hdict.keys ( ) :<br>        if hdict [ a ] % 2 != 0 :<br>            return a<br></td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and ( n & 0xAAAAAAAA ) == 0<br></td>
  </tr><tr>
    <th>FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    for i in range ( 0 , len ( str ) ) :<br>        if ( str [ i ].istitle ( ) ) :<br>            return str [ i ]<br>    return 0<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    for c in str :<br>        if ord ( c ) < 128 :<br>            return c<br>    return 0<br></td>
  </tr><tr>
    <th>FLOOR_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , low , high , x ) :<br>    if ( low > high ) :<br>        return - 1<br>    if ( x >= arr [ high ] ) :<br>        return high<br>    mid = int ( ( low + high ) / 2 )<br>    if ( arr [ mid ] == x ) :<br>        return mid<br>    if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) :<br>        return mid - 1<br>    if ( x < arr [ mid ] ) :<br>        return f_gold ( arr , low , mid - 1 , x )<br>    return f_gold ( arr , mid + 1 , high , x )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , low , high , x ) :<br>    if low > high :<br>        return - 1<br>    if x >= arr [ high ] :<br>        return high<br>    mid = ( low + high ) // 2<br>    if arr [ mid ] == x :<br>        return mid<br>    if mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] :<br>        return mid - 1<br>    if x < arr [ mid ] :<br>        return f_gold ( arr , low , mid - 1 , x )<br>    return f_gold ( arr , mid + 1 , high , x )<br></td>
  </tr><tr>
    <th>FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s1 , s2 , index ) :<br>    s2 [ index ] = s1 [ index ] <br>    if ( index == len ( s1 ) - 1 ) :<br>        return <br>    f_gold ( s1 , s2 , index + 1 ) <br></td>
    <td>translated code: <br><br> def f_gold ( s1 , s2 , index ) :<br>    s2 = s2 [ index ]<br>    if index == len ( s1 ) - 1 :<br>        return s1<br>    return s1 [ index ]<br></td>
  </tr><tr>
    <th>GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( st ) :<br>    l = len ( st )<br>    arr = [ 0 ] * l<br>    for i in range ( 0 , l ) :<br>        for j in range ( i , l ) :<br>            for k in range ( j , l ) :<br>                if ( arr [ i ] % 8 == 0 ) :<br>                    return True<br>                elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) :<br>                    return True<br>                elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) :<br>                    return True<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    i , j , k , l = len ( str ) , len ( str ) , len ( str ) , len ( str )<br>    arr = [ 0 for i in range ( l ) ]<br>    for i in range ( l ) :<br>        for j in range ( i , l ) :<br>            for k in range ( j , l ) :<br>                if arr [ i ] % 8 == 0 :<br>                    return True<br>                elif ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j :<br>                    return True<br>                elif ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k :<br>                    return True<br>    return False<br></td>
  </tr><tr>
    <th>GOOGLE_CASE_GIVEN_SENTENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    s1 = ""<br>    s1 = s1 + s [ 0 ].lower ( )<br>    i = 1<br>    while i < n :<br>        if ( s [ i ] == ' ' and i <= n ) :<br>            s1 = s1 + " " + ( s [ i + 1 ] ).lower ( )<br>            i = i + 1<br>        else :<br>            s1 = s1 + ( s [ i ] ).upper ( )<br>        i = i + 1<br>    return s1<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    s1 = ""<br>    s1 = s1 + chr ( ord ( s [ 0 ] ) )<br>    for i in range ( 1 , n ) :<br>        if s [ i ] == ' ' and i < n :<br>            s1 = s1 + " " + chr ( ord ( s [ i + 1 ] ) )<br>            i += 1<br>        else :<br>            s1 = s1 + chr ( ord ( s [ i ] ) )<br>    return s1<br></td>
  </tr><tr>
    <th>HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( N ) :<br>    return math.ceil ( math.log2 ( N + 1 ) ) - 1<br></td>
    <td>translated code: <br><br> def f_gold ( N ) :<br>    return int ( math.ceil ( math.log ( N + 1 ) / math.log ( 2 ) ) ) - 1<br></td>
  </tr><tr>
    <th>HEXAGONAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return n * ( 2 * n - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return n * ( 2 * n - 1 )<br></td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( no ) :<br>    return 0 if no == 0 else int ( no % 10 ) + f_gold ( int ( no / 10 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( no ) :<br>    return no if no > 0 else no % 10 + f_gold ( no / 10 )<br></td>
  </tr><tr>
    <th>HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , i , n ) :<br>    if i > int ( ( n - 2 ) / 2 ) :<br>        return True<br>    if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and f_gold ( arr , 2 * i + 1 , n ) and f_gold ( arr , 2 * i + 2 , n ) ) :<br>        return True<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( arr , i , n ) :<br>    if i > ( n - 2 ) / 2 :<br>        return True<br>    if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and f_gold ( arr , 2 * i + 1 , n ) and f_gold ( arr , 2 * i + 2 , n ) :<br>        return True<br>    return False<br></td>
  </tr><tr>
    <th>HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :<br>        if arr [ 2 * i + 1 ] > arr [ i ] :<br>            return False<br>        if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( 0 , ( n - 2 ) // 2 ) :<br>        if arr [ 2 * i + 1 ] > arr [ i ] :<br>            return False<br>        if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>HYPERCUBE_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if n == 1 :<br>        return 2<br>    return 2 * f_gold ( n - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 1 :<br>        return 2<br>    return 2 * f_gold ( n - 1 )<br></td>
  </tr><tr>
    <th>K_TH_DIGIT_RAISED_POWER_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b , k ) :<br>    p = a ** b<br>    count = 0<br>    while ( p > 0 and count < k ) :<br>        rem = p % 10<br>        count = count + 1<br>        if ( count == k ) :<br>            return rem<br>        p = p / 10 <br></td>
    <td>translated code: <br><br> def f_gold ( a , b , k ) :<br>    p = int ( math.pow ( a , b ) )<br>    count = 0<br>    while p > 0 and count < k :<br>        rem = p % 10<br>        count += 1<br>        if count == k :<br>            return rem<br>        p = p / 10<br></td>
  </tr><tr>
    <th>K_TH_ELEMENT_TWO_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr1 , arr2 , m , n , k ) :<br>    sorted1 = [ 0 ] * ( m + n )<br>    i = 0<br>    j = 0<br>    d = 0<br>    while ( i < m and j < n ) :<br>        if ( arr1 [ i ] < arr2 [ j ] ) :<br>            sorted1 [ d ] = arr1 [ i ]<br>            i += 1<br>        else :<br>            sorted1 [ d ] = arr2 [ j ]<br>            j += 1<br>        d += 1<br>    while ( i < m ) :<br>        sorted1 [ d ] = arr1 [ i ]<br>        d += 1<br>        i += 1<br>    while ( j < n ) :<br>        sorted1 [ d ] = arr2 [ j ]<br>        d += 1<br>        j += 1<br>    return sorted1 [ k - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( arr1 , arr2 , m , n , k ) :<br>    sorted1 = [ ]<br>    i , j , d = 0 , 0 , 0<br>    while i < m and j < n :<br>        if arr1 [ i ] < arr2 [ j ] :<br>            sorted1.append ( arr1 [ i ++ ] )<br>        else :<br>            sorted1.append ( arr2 [ j ++ ] )<br>    while i < m :<br>        sorted1.append ( arr1 [ i ++ ] )<br>    while j < n :<br>        sorted1.append ( arr2 [ j ++ ] )<br>    return sorted1 [ k - 1 ]<br></td>
  </tr><tr>
    <th>K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , k ) :<br>    sum = [ ]<br>    sum.append ( 0 )<br>    sum.append ( arr [ 0 ] )<br>    for i in range ( 2 , n + 1 ) :<br>        sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )<br>    Q = [ ]<br>    heapq.heapify ( Q )<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i , n + 1 ) :<br>            x = sum [ j ] - sum [ i - 1 ]<br>            if len ( Q ) < k :<br>                heapq.heappush ( Q , x )<br>            else :<br>                if Q [ 0 ] < x :<br>                    heapq.heappop ( Q )<br>                    heapq.heappush ( Q , x )<br>    return Q [ 0 ]<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , k ) :<br>    sum = [ 0 ] * ( n + 1 )<br>    for i in range ( 2 , n + 1 ) :<br>        sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ]<br>    Q = PriorityQueue ( )<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i , n + 1 ) :<br>            x = sum [ j ] - sum [ i - 1 ]<br>            if len ( Q ) < k :<br>                Q.add ( x )<br>            else :<br>                if Q.peek ( ) < x :<br>                    Q.poll ( )<br>                    Q.add ( x )<br>    return Q.get ( )<br></td>
  </tr><tr>
    <th>K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b , k , n1 , n2 ) :<br>    s = set ( )<br>    for i in range ( n2 ) :<br>        s.add ( b [ i ] )<br>    missing = 0<br>    for i in range ( n1 ) :<br>        if a [ i ] not in s :<br>            missing += 1<br>        if missing == k :<br>            return a [ i ]<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( a , b , k , n1 , n2 ) :<br>    s = set ( )<br>    for i in range ( n2 ) :<br>        s.add ( b [ i ] )<br>    missing = 0<br>    for i in range ( n1 ) :<br>        if not s.intersection ( a [ i ] ) :<br>            missing += 1<br>        if missing == k :<br>            return a [ i ]<br>    return - 1<br></td>
  </tr><tr>
    <th>LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( k , s1 , s2 ) :<br>    n = len ( s1 )<br>    m = len ( s2 )<br>    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]<br>    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ]<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( 1 , m + 1 ) :<br>            lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] )<br>            if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :<br>                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 <br>            if ( cnt [ i ] [ j ] >= k ) :<br>                for a in range ( k , cnt [ i ] [ j ] + 1 ) :<br>                    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a )<br>    return lcs [ n ] [ m ]<br></td>
    <td>translated code: <br><br> def f_gold ( k , s1 , s2 ) :<br>    n = len ( s1 )<br>    m = len ( s2 )<br>    lcs = [ [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * n + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m + [ 0 ] * m</td>
  </tr><tr>
    <th>LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    lioes = list ( )<br>    maxLen = 0<br>    for i in range ( n ) :<br>        lioes.append ( 1 )<br>    i = 1<br>    for i in range ( n ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) :<br>                lioes [ i ] = lioes [ j ] + 1<br>    for i in range ( n ) :<br>        if maxLen < lioes [ i ] :<br>            maxLen = lioes [ i ]<br>    return maxLen<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    lioes = [ 1 ] * n<br>    max_len = 0<br>    for i in range ( n ) :<br>        lioes [ i ] = 1<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 :<br>                lioes [ i ] = lioes [ j ] + 1<br>    for i in range ( n ) :<br>        if max_len < lioes [ i ] :<br>            max_len = lioes [ i ]<br>    return max_len<br></td>
  </tr><tr>
    <th>LONGEST_PALINDROME_SUBSEQUENCE_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    a = [ 0 ] * n<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        back_up = 0<br>        for j in range ( i , n ) :<br>            if j == i :<br>                a [ j ] = 1<br>            elif s [ i ] == s [ j ] :<br>                temp = a [ j ]<br>                a [ j ] = back_up + 2<br>                back_up = temp<br>            else :<br>                back_up = a [ j ]<br>                a [ j ] = max ( a [ j - 1 ] , a [ j ] )<br>    return a [ n - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    a = [ ]<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        back_up = 0<br>        for j in range ( i , n ) :<br>            if j == i :<br>                a.append ( 1 )<br>            elif s [ i ] == s [ j ] :<br>                temp = a [ j ]<br>                a [ j ] = back_up + 2<br>                back_up = temp<br>            else :<br>                back_up = a [ j ]<br>                a [ j ] = max ( a [ j - 1 ] , a [ j ] )<br>    return a [ n - 1 ]<br></td>
  </tr><tr>
    <th>LONGEST_PREFIX_ALSO_SUFFIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    lps = [ 0 ] * n<br>    l = 0<br>    i = 1<br>    while ( i < n ) :<br>        if ( s [ i ] == s [ l ] ) :<br>            l = l + 1<br>            lps [ i ] = l<br>            i = i + 1<br>        else :<br>            if ( l != 0 ) :<br>                l = lps [ l - 1 ]<br>            else :<br>                lps [ i ] = 0<br>                i = i + 1<br>    res = lps [ n - 1 ]<br>    if ( res > n / 2 ) :<br>        return n // 2<br>    else :<br>        return res<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    lps = [ 0 ] * n<br>    len = 0<br>    i = 1<br>    while i < n :<br>        if s [ i ] == s [ len ( s ) ] :<br>            len += 1<br>            lps [ i ] = len<br>            i += 1<br>        else :<br>            if len != 0 :<br>                len = lps [ len - 1 ]<br>            else :<br>                lps [ i ] = 0<br>                i += 1<br>    res = lps [ n - 1 ]<br>    return ( res > n / 2 )<br></td>
  </tr><tr>
    <th>MAKING_ELEMENTS_OF_TWO_ARRAYS_SAME_WITH_MINIMUM_INCREMENTDECREMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b , n ) :<br>    a.sort ( reverse = False )<br>    b.sort ( reverse = False )<br>    result = 0<br>    for i in range ( 0 , n , 1 ) :<br>        if ( a [ i ] > b [ i ] ) :<br>            result = result + abs ( a [ i ] - b [ i ] )<br>        elif ( a [ i ] < b [ i ] ) :<br>            result = result + abs ( a [ i ] - b [ i ] )<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( a , b , n ) :<br>    a.sort ( )<br>    b.sort ( )<br>    result = 0<br>    for i in range ( n ) :<br>        if a [ i ] > b [ i ] :<br>            result = result + abs ( a [ i ] - b [ i ] )<br>        elif a [ i ] < b [ i ] :<br>            result = result + abs ( a [ i ] - b [ i ] )<br>    return result<br></td>
  </tr><tr>
    <th>MARKOV_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( m ) :<br>    for i in range ( 0 , len ( m ) ) :<br>        sm = 0<br>        for j in range ( 0 , len ( m [ i ] ) ) :<br>            sm = sm + m [ i ] [ j ]<br>        if ( sm != 1 ) :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( m ) :<br>    for i in range ( len ( m ) ) :<br>        sum = 0<br>        for j in range ( len ( m [ i ] ) ) :<br>            sum = sum + m [ i ] [ j ]<br>        if sum != 1 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>MAXIMIZE_SUM_CONSECUTIVE_DIFFERENCES_CIRCULAR_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    sum = 0<br>    arr.sort ( )<br>    for i in range ( 0 , int ( n / 2 ) ) :<br>        sum -= ( 2 * arr [ i ] )<br>        sum += ( 2 * arr [ n - i - 1 ] )<br>    return sum<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    sum = 0<br>    arr.sort ( )<br>    for i in range ( n // 2 ) :<br>        sum -= ( 2 * arr [ i ] )<br>        sum += ( 2 * arr [ n - i - 1 ] )<br>    return sum<br></td>
  </tr><tr>
    <th>MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    s = [ ]<br>    first = 0<br>    second = 0<br>    for i in range ( n ) :<br>        if arr [ i ] not in s :<br>            s.append ( arr [ i ] )<br>            continue<br>        if ( arr [ i ] > first ) :<br>            second = first<br>            first = arr [ i ]<br>        elif ( arr [ i ] > second ) :<br>            second = arr [ i ]<br>    return ( first * second )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    s = set ( )<br>    first , second = 0 , 0<br>    for i in range ( n ) :<br>        if not s.issubset ( arr [ i ] ) :<br>            s.add ( arr [ i ] )<br>            continue<br>        if arr [ i ] > first :<br>            second = first<br>            first , second = arr [ i ] , arr [ i ]<br>        elif arr [ i ] > second :<br>            second , first = arr [ i ] , arr [ i ]<br>    return ( first , second )<br></td>
  </tr><tr>
    <th>MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , K ) :<br>    n = len ( A ) <br>    pre_sum = [ 0 ] * ( n + 1 ) <br>    pre_sum [ 0 ] = 0 <br>    for i in range ( n ) :<br>        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] <br>    dp = [ 0 ] * n <br>    sum = 0 <br>    for i in range ( n ) :<br>        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) <br>    for k in range ( K - 1 ) :<br>        for i in range ( n ) :<br>            for j in range ( i + 1 , n ) :<br>                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) <br>    return int ( dp [ 0 ] ) <br></td>
    <td>translated code: <br><br> def f_gold ( A , K ) :<br>    n = len ( A )<br>    pre_sum = np.zeros ( ( n + 1 , ) )<br>    pre_sum [ 0 ] = 0<br>    for i in range ( n ) :<br>        pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]<br>    dp = np.zeros ( ( n , ) )<br>    sum = 0<br>    for i in range ( n ) :<br>        dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i )<br>    for k in range ( K - 1 ) :<br>        for i in range ( n ) :<br>            for j in range ( i + 1 , n ) :<br>                dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] )<br>    return dp<br></td>
  </tr><tr>
    <th>MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] <br>    for i in range ( n + 1 ) :<br>        for j in range ( min ( i , n ) + 1 ) :<br>            if ( j == 0 or j == i ) :<br>                C [ i ] [ j ] = 1 <br>            else :<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) <br>    maxvalue = 0 <br>    for i in range ( n + 1 ) :<br>        maxvalue = max ( maxvalue , C [ n ] [ i ] ) <br>    return maxvalue <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    C = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n</td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    n = len ( str )<br>    count = 0<br>    res = str [ 0 ]<br>    cur_count = 1<br>    for i in range ( n ) :<br>        if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :<br>            cur_count += 1<br>        else :<br>            if cur_count > count :<br>                count = cur_count<br>                res = str [ i ]<br>            cur_count = 1<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    n = len ( str )<br>    count = 0<br>    res = str [ 0 ]<br>    cur_count = 1<br>    for i in range ( n ) :<br>        if i < n - 1 and str [ i ] == str [ i + 1 ] :<br>            cur_count += 1<br>        else :<br>            if cur_count > count :<br>                count = cur_count<br>                res = str [ i ]<br>            cur_count = 1<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , m , n ) :<br>    rowSum = [ 0 ] * m<br>    for i in range ( 0 , m ) :<br>        sum = 0<br>        for j in range ( 0 , n ) :<br>            sum += mat [ i ] [ j ]<br>        rowSum [ i ] = sum<br>    max_diff = rowSum [ 1 ] - rowSum [ 0 ]<br>    min_element = rowSum [ 0 ]<br>    for i in range ( 1 , m ) :<br>        if ( rowSum [ i ] - min_element > max_diff ) :<br>            max_diff = rowSum [ i ] - min_element<br>        if ( rowSum [ i ] < min_element ) :<br>            min_element = rowSum [ i ]<br>    return max_diff<br></td>
    <td>translated code: <br><br> def f_gold ( mat , m , n ) :<br>    row_sum = [ ]<br>    for i in range ( m ) :<br>        sum = 0<br>        for j in range ( n ) :<br>            sum += mat [ i , j ]<br>        row_sum.append ( sum )<br>    max_diff = row_sum [ 1 ] - row_sum [ 0 ]<br>    min_element = row_sum [ 0 ]<br>    for i in range ( 1 , m ) :<br>        if row_sum [ i ] - min_element > max_diff :<br>            max_diff = row_sum [ i ] - min_element<br>        if row_sum [ i ] < min_element :<br>            min_element = row_sum [ i ]<br>    return max_diff<br></td>
  </tr><tr>
    <th>MAXIMUM_GAMES_PLAYED_WINNER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( N ) :<br>    dp = [ 0 for i in range ( N ) ]<br>    dp [ 0 ] = 1<br>    dp [ 1 ] = 2<br>    i = 1<br>    while dp [ i ] <= N :<br>        i = i + 1<br>        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]<br>    return ( i - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( N ) :<br>    dp = [ 1 , 2 ]<br>    i = 2<br>    do = dp [ i - 1 ] + dp [ i - 2 ]<br>    while dp [ i ] <= N :<br>        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]<br>    return ( i - 2 )<br></td>
  </tr><tr>
    <th>MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    result = 1<br>    for i in range ( 1 , n ) :<br>        y = ( i * ( i + 1 ) ) / 2<br>        if ( y < n ) :<br>            result = i<br>        else :<br>            break<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    result = 1<br>    for i in range ( 1 , n + 1 ) :<br>        y = ( i * ( i + 1 ) ) / 2<br>        if y < n :<br>            result = i<br>        else :<br>            break<br>    return result<br></td>
  </tr><tr>
    <th>MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s , t ) :<br>    count = 0<br>    for i in range ( 0 , len ( t ) ) :<br>        if ( count == len ( s ) ) :<br>            break<br>        if ( t [ i ] == s [ count ] ) :<br>            count = count + 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( s , t ) :<br>    count = 0<br>    for c in t :<br>        if count == len ( t ) :<br>            break<br>        if c == s [ count ] :<br>            count += 1<br>    return count<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , k ) :<br>    um , curr_rem , maxSum = { } , 0 , 0<br>    sm = [ 0 ] * n<br>    sm [ 0 ] = arr [ 0 ]<br>    for i in range ( 1 , n ) :<br>        sm [ i ] = sm [ i - 1 ] + arr [ i ]<br>    for i in range ( n ) :<br>        curr_rem = sm [ i ] % k<br>        if ( not curr_rem and maxSum < sm [ i ] ) :<br>            maxSum = sm [ i ]<br>        elif ( not curr_rem in um ) :<br>            um [ curr_rem ] = i<br>        elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) :<br>            maxSum = sm [ i ] - sm [ um [ curr_rem ] ]<br>    return maxSum // k<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , k ) :<br>    um = { }<br>    sum = [ ]<br>    curr_rem = 0<br>    max_sum = 0<br>    sum.append ( arr [ 0 ] )<br>    for i in range ( 1 , n ) :<br>        sum [ i ] = sum [ i - 1 ] + arr [ i ]<br>    for i in range ( n ) :<br>        curr_rem = sum [ i ] % k<br>        if curr_rem == 0 :<br>            if max_sum < sum [ i ] :<br>                max_sum = sum [ i ]<br>        elif not um.has_key ( curr_rem ) :<br>            um [ curr_rem ] = i<br>        elif max_sum < ( sum [ i ] - sum [ um [ curr_rem ] ] ) :<br>            max_sum = sum [ i ] - sum [ um [ curr_rem ] ]<br>    return ( max_sum / k )<br></td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( b , m ) :<br>    return ( b / m - 1 ) * ( b / m ) / 2<br></td>
    <td>translated code: <br><br> def f_gold ( b , m ) :<br>    return ( b / m - 1 ) ** 2 / 2<br></td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    mpis = [ 0 ] * ( n )<br>    for i in range ( n ) :<br>        mpis [ i ] = arr [ i ]<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) :<br>                mpis [ i ] = mpis [ j ] * arr [ i ]<br>    return max ( mpis )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    mpis = [ ]<br>    max = int ( arr [ i ] )<br>    for i in range ( n ) :<br>        mpis.append ( arr [ i ] )<br>    for i in range ( 1 , n ) :<br>        for j in range ( i ) :<br>            if arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) :<br>                mpis [ i ] = mpis [ j ] * arr [ i ]<br>    for k in mpis :<br>        if mpis [ k ] > max :<br>            max = mpis [ k ]<br>    return max<br></td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_OF_4_ADJACENT_ELEMENTS_IN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    max = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if ( ( j - 3 ) >= 0 ) :<br>                result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] )<br>                if ( max < result ) :<br>                    max = result<br>            if ( ( i - 3 ) >= 0 ) :<br>                result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] )<br>                if ( max < result ) :<br>                    max = result<br>            if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) :<br>                result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] )<br>                if ( max < result ) :<br>                    max = result<br>    return max<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    max , result = 0 , 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            if ( j - 3 ) >= 0 :<br>                result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ]<br>                if max < result :<br>                    max = result<br>            if ( i - 3 ) >= 0 :<br>                result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ]<br>                if max < result :<br>                    max = result<br>            if ( i - 3 ) >= 0 and ( j - 3 ) >= 0 :<br>                result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ]<br>                if max < result :<br>                    max = result<br>    return max<br></td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_SUBSET_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    if n == 1 :<br>        return a [ 0 ]<br>    max_neg = - 999999999999<br>    count_neg = 0<br>    count_zero = 0<br>    prod = 1<br>    for i in range ( n ) :<br>        if a [ i ] == 0 :<br>            count_zero += 1<br>            continue<br>        if a [ i ] < 0 :<br>            count_neg += 1<br>            max_neg = max ( max_neg , a [ i ] )<br>        prod = prod * a [ i ]<br>    if count_zero == n :<br>        return 0<br>    if count_neg & 1 :<br>        if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) :<br>            return 0<br>        prod = int ( prod / max_neg )<br>    return prod<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    if n == 1 :<br>        return a [ 0 ]<br>    max_neg = int ( a [ 0 ] )<br>    count_neg , count_zero = 0 , 0<br>    prod = 1<br>    for i in range ( n ) :<br>        if a [ i ] == 0 :<br>            count_zero += 1<br>            continue<br>        if a [ i ] < 0 :<br>            count_neg += 1<br>            max_neg = max ( max_neg , a [ i ] )<br>        prod = prod * a [ i ]<br>    if count_zero == n :<br>        return 0<br>    if count_neg % 2 == 1 :<br>        if count_neg == 1 and count_zero > 0 and count_zero + count_neg == n :<br>            return 0<br>        prod = prod / max_neg<br>    return prod<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    res = - sys.maxsize<br>    for i in range ( 0 , n ) :<br>        curr_sum = 0<br>        for j in range ( 0 , n ) :<br>            index = int ( ( i + j ) % n )<br>            curr_sum += j * arr [ index ]<br>        res = max ( res , curr_sum )<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    res = int ( 0 )<br>    for i in range ( n ) :<br>        curr_sum = 0<br>        for j in range ( n ) :<br>            index = ( i + j ) % n<br>            curr_sum += j * arr [ index ]<br>        res = max ( res , curr_sum )<br>    return res<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , N , k ) :<br>    maxSum = 0 <br>    arr.sort ( ) <br>    i = N - 1 <br>    while ( i >= 0 ) :<br>        if ( arr [ i ] - arr [ i - 1 ] < k ) :<br>            maxSum += arr [ i ] <br>            maxSum += arr [ i - 1 ] <br>            i -= 1 <br>        i -= 1 <br>    return maxSum <br></td>
    <td>translated code: <br><br> def f_gold ( arr , N , k ) :<br>    max_sum = 0<br>    arr.sort ( )<br>    for i in range ( N - 1 , 0 , - 1 ) :<br>        if arr [ i ] - arr [ i - 1 ] < k :<br>            max_sum += arr [ i ]<br>            max_sum += arr [ i - 1 ]<br>            del arr [ i ]<br>    return max_sum<br></td>
  </tr><tr>
    <th>MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , N , k ) :<br>    MS = [ 0 for i in range ( N ) ]<br>    MS [ N - 1 ] = arr [ N - 1 ]<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        if ( i + k + 1 >= N ) :<br>            MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )<br>        else :<br>            MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] )<br>    return MS [ 0 ]<br></td>
    <td>translated code: <br><br> def f_gold ( arr , N , k ) :<br>    MS = [ arr [ i ] for i in range ( N ) ]<br>    for i in range ( N - 2 , - 1 , - 1 ) :<br>        if i + k + 1 >= N :<br>            MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )<br>        else :<br>            MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] )<br>    return MS [ 0 ]<br></td>
  </tr><tr>
    <th>MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , N ) :<br>    dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]<br>    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]<br>    for i in range ( 1 , N ) :<br>        dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ]<br>    for i in range ( 1 , N ) :<br>        for j in range ( 1 , min ( i + 1 , N ) ) :<br>            dp [ i ] [ j ] = mat [ i ] [ j ] + \<br>                max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    result = 0<br>    for i in range ( N ) :<br>        if ( result < dp [ N - 1 ] [ i ] ) :<br>            result = dp [ N - 1 ] [ i ]<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( mat , N ) :<br>    dp = [ 0 ] * N<br>    for i in range ( 1 , N ) :<br>        dp [ i ] = mat [ i ] + dp [ i - 1 ]<br>    for i in range ( 1 , N ) :<br>        for j in range ( 1 , i + 1 and j < N ) :<br>            dp [ i ] = mat [ i ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] )<br>    result = 0<br>    for i in range ( N ) :<br>        if result < dp [ N - 1 ] [ i ] :<br>            result = dp [ N - 1 ] [ i ]<br>    return result<br></td>
  </tr><tr>
    <th>MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , B , n ) :<br>    sorted ( A )<br>    sorted ( B )<br>    result = 0<br>    for i in range ( n ) :<br>        result += ( A [ i ] * B [ n - i - 1 ] )<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( A , B , n ) :<br>    A.sort ( )<br>    B.sort ( )<br>    result = 0<br>    for i in range ( n ) :<br>        result += ( A [ i ] * B [ n - i - 1 ] )<br>    return result<br></td>
  </tr><tr>
    <th>MINIMUM_CHARACTERS_ADDED_FRONT_MAKE_STRING_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    l = len ( s )<br>    i = 0<br>    j = l - 1<br>    while i <= j :<br>        if ( s [ i ] != s [ j ] ) :<br>            return False<br>        i += 1<br>        j -= 1<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    l = len ( s )<br>    for i , j in enumerate ( l - 1 ) :<br>        if s [ i ] != s [ j ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>MINIMUM_COST_FOR_ACQUIRING_ALL_COINS_WITH_K_EXTRA_COINS_ALLOWED_WITH_EVERY_COIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( coin , n , k ) :<br>    coin.sort ( )<br>    coins_needed = math.ceil ( 1.0 * n // ( k + 1 ) ) <br>    ans = 0<br>    for i in range ( coins_needed - 1 + 1 ) :<br>        ans += coin [ i ]<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( coin , n , k ) :<br>    coin.sort ( )<br>    coins_needed = int ( math.ceil ( 1.0 * n / ( k + 1 ) ) )<br>    ans = 0<br>    for i in range ( 0 , coins_needed - 1 ) :<br>        ans += coin [ i ]<br>    return ans<br></td>
  </tr><tr>
    <th>MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    return ( ( n - 1 ) * min ( a ) )<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    min = a [ 0 ]<br>    for i in range ( 1 , len ( a ) ) :<br>        if a [ i ] < min :<br>            min = a [ i ]<br>    return ( n - 1 ) * min<br></td>
  </tr><tr>
    <th>MINIMUM_DIFFERENCE_BETWEEN_GROUPS_OF_SIZE_TWO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    a.sort ( ) <br>    s = [ ] <br>    i = 0 <br>    j = n - 1 <br>    while ( i < j ) :<br>        s.append ( ( a [ i ] + a [ j ] ) ) <br>        i += 1 <br>        j -= 1 <br>    mini = min ( s ) <br>    maxi = max ( s ) <br>    return abs ( maxi - mini ) <br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    a.sort ( )<br>    i , j = 0 , n<br>    s = [ ]<br>    for i , j in enumerate ( a ) :<br>        s.append ( ( i , j ) )<br>    mini = min ( s )<br>    maxi = max ( s )<br>    return abs ( maxi - mini )<br></td>
  </tr><tr>
    <th>MINIMUM_DIFFERENCE_MAX_MIN_K_SIZE_SUBSETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , N , K ) :<br>    arr.sort ( )<br>    res = 2147483647<br>    for i in range ( ( N - K ) + 1 ) :<br>        curSeqDiff = arr [ i + K - 1 ] - arr [ i ]<br>        res = min ( res , curSeqDiff )<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( arr , N , K ) :<br>    arr.sort ( )<br>    res = 2147483647<br>    for i in range ( 0 , ( N - K ) ) :<br>        cur_seq_diff = arr [ i + K - 1 ] - arr [ i ]<br>        res = min ( res , cur_seq_diff )<br>    return res<br></td>
  </tr><tr>
    <th>MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , n ) :<br>    flip = 0<br>    for i in range ( n ) :<br>        for j in range ( i ) :<br>            if mat [ i ] [ j ] != mat [ j ] [ i ] :<br>                flip += 1<br>    return flip<br></td>
    <td>translated code: <br><br> def f_gold ( mat , n ) :<br>    flip = 0<br>    for i in range ( n ) :<br>        for j in range ( i ) :<br>            if mat [ i ] [ j ] != mat [ j ] [ i ] :<br>                flip += 1<br>    return flip<br></td>
  </tr><tr>
    <th>MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , k ) :<br>    max1 = max ( arr )<br>    res = 0<br>    for i in range ( 0 , n ) :<br>        if ( ( max1 - arr [ i ] ) % k != 0 ) :<br>            return - 1<br>        else :<br>            res += ( max1 - arr [ i ] ) / k<br>    return int ( res )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , k ) :<br>    arr.sort ( )<br>    max = arr [ - 1 ]<br>    res = 0<br>    for i in range ( n ) :<br>        if ( max - arr [ i ] ) % k != 0 :<br>            return - 1<br>        else :<br>            res += ( max - arr [ i ] ) / k<br>    return res<br></td>
  </tr><tr>
    <th>MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , x ) :<br>    curr_sum = 0 <br>    min_len = n + 1 <br>    start = 0 <br>    end = 0 <br>    while ( end < n ) :<br>        while ( curr_sum <= x and end < n ) :<br>            if ( curr_sum <= 0 and x > 0 ) :<br>                start = end <br>                curr_sum = 0 <br>            curr_sum += arr [ end ] <br>            end += 1 <br>        while ( curr_sum > x and start < n ) :<br>            if ( end - start < min_len ) :<br>                min_len = end - start <br>            curr_sum -= arr [ start ] <br>            start += 1 <br>    return min_len <br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , x ) :<br>    curr_sum , min_len = 0 , n + 1<br>    start , end = 0 , 0<br>    while end < n :<br>        while curr_sum <= x and end < n :<br>            if curr_sum <= 0 and x > 0 :<br>                start = end<br>                curr_sum = 0<br>            curr_sum += arr [ end ]<br>        while curr_sum > x and start < n :<br>            if end - start < min_len :<br>                min_len = end - start<br>            curr_sum -= arr [ start ]<br>    return min_len<br></td>
  </tr><tr>
    <th>MINIMUM_NUMBER_PLATFORMS_REQUIRED_RAILWAYBUS_STATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , dep , n ) :<br>    arr.sort ( )<br>    dep.sort ( )<br>    plat_needed = 1<br>    result = 1<br>    i = 1<br>    j = 0<br>    while ( i < n and j < n ) :<br>        if ( arr [ i ] < dep [ j ] ) :<br>            plat_needed += 1<br>            i += 1<br>            if ( plat_needed > result ) :<br>                result = plat_needed<br>        else :<br>            plat_needed -= 1<br>            j += 1<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( arr , dep , n ) :<br>    arr.sort ( )<br>    dep.sort ( )<br>    plat_needed , result = 1 , 1<br>    i , j = 1 , 0<br>    while i < n and j < n :<br>        if arr [ i ] <= dep [ j ] :<br>            plat_needed += 1<br>            i += 1<br>            if plat_needed > result :<br>                result = plat_needed<br>        else :<br>            plat_needed -= 1<br>            j += 1<br>    return result<br></td>
  </tr><tr>
    <th>MINIMUM_PRODUCT_SUBSET_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    if ( n == 1 ) :<br>        return a [ 0 ]<br>    max_neg = float ( '-inf' )<br>    min_pos = float ( 'inf' )<br>    count_neg = 0<br>    count_zero = 0<br>    prod = 1<br>    for i in range ( 0 , n ) :<br>        if ( a [ i ] == 0 ) :<br>            count_zero = count_zero + 1<br>            continue<br>        if ( a [ i ] < 0 ) :<br>            count_neg = count_neg + 1<br>            max_neg = max ( max_neg , a [ i ] )<br>        if ( a [ i ] > 0 ) :<br>            min_pos = min ( min_pos , a [ i ] )<br>        prod = prod * a [ i ]<br>    if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) :<br>        return 0 <br>    if ( count_neg == 0 ) :<br>        return min_pos<br>    if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :<br>        prod = int ( prod / max_neg )<br>    return prod <br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    if n == 1 :<br>        return a [ 0 ]<br>    negmax = int ( a [ 0 ] )<br>    posmin = int ( a [ 0 ] )<br>    count_neg , count_zero = 0 , 0<br>    product = 1<br>    for i in range ( n ) :<br>        if a [ i ] == 0 :<br>            count_zero += 1<br>            continue<br>        if a [ i ] < 0 :<br>            count_neg += 1<br>            negmax = max ( negmax , a [ i ] )<br>        if a [ i ] > 0 and a [ i ] < posmin :<br>            posmin = a [ i ]<br>        product *= a [ i ]<br>    if count_zero == n or ( count_neg == 0 and count_zero > 0 ) :<br>        return 0<br>    if count_neg == 0 :<br>        return posmin<br>    if count_neg % 2 == 0 and count_neg != 0 :<br>        product = product / negmax<br>    return product<br></td>
  </tr><tr>
    <th>MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( input , unlock_code ) :<br>    rotation = 0 <br>    while ( input > 0 or unlock_code > 0 ) :<br>        input_digit = input % 10 <br>        code_digit = unlock_code % 10 <br>        rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) <br>        input = int ( input / 10 ) <br>        unlock_code = int ( unlock_code / 10 ) <br>    return rotation <br></td>
    <td>translated code: <br><br> def f_gold ( input , unlock_code ) :<br>    rotation = 0<br>    input_digit , code_digit = input<br>    while input or unlock_code :<br>        input_digit = input % 10<br>        code_digit = unlock_code % 10<br>        rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) )<br>        input /= 10<br>        unlock_code /= 10<br>    return rotation<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( ar , n ) :<br>    if ( n <= 4 ) :<br>        return min ( ar )<br>    sum = [ 0 for i in range ( n ) ]<br>    sum [ 0 ] = ar [ 0 ]<br>    sum [ 1 ] = ar [ 1 ]<br>    sum [ 2 ] = ar [ 2 ]<br>    sum [ 3 ] = ar [ 3 ]<br>    for i in range ( 4 , n ) :<br>        sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] )<br>    return min ( sum [ n - 4 : n ] )<br></td>
    <td>translated code: <br><br> def f_gold ( ar , n ) :<br>    if n <= 4 :<br>        return sum ( ar ).min ( ).astype ( int )<br>    sum = [ ar [ i ] for i in range ( n ) ]<br>    for i in range ( 4 , n ) :<br>        sum [ i ] = ar [ i ] + sum [ i - 4 : i ]<br>    return sum [ n - 4 : n ]<br></td>
  </tr><tr>
    <th>MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    a = sorted ( a )<br>    num1 , num2 = 0 , 0<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            num1 = num1 * 10 + a [ i ]<br>        else :<br>            num2 = num2 * 10 + a [ i ]<br>    return num2 + num1<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    a.sort ( )<br>    num1 = 0<br>    num2 = 0<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            num1 = num1 * 10 + a [ i ]<br>        else :<br>            num2 = num2 * 10 + a [ i ]<br>    return num2 + num1<br></td>
  </tr><tr>
    <th>MINIMUM_SWAPS_REQUIRED_BRING_ELEMENTS_LESS_EQUAL_K_TOGETHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , k ) :<br>    count = 0<br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] <= k ) :<br>            count = count + 1<br>    bad = 0<br>    for i in range ( 0 , count ) :<br>        if ( arr [ i ] > k ) :<br>            bad = bad + 1<br>    ans = bad<br>    j = count<br>    for i in range ( 0 , n ) :<br>        if ( j == n ) :<br>            break<br>        if ( arr [ i ] > k ) :<br>            bad = bad - 1<br>        if ( arr [ j ] > k ) :<br>            bad = bad + 1<br>        ans = min ( ans , bad )<br>        j = j + 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , k ) :<br>    count = 0<br>    for i in range ( n ) :<br>        if arr [ i ] <= k :<br>            count += 1<br>    bad = 0<br>    for i in range ( count ) :<br>        if arr [ i ] > k :<br>            bad += 1<br>    ans = bad<br>    for i , j in enumerate ( count , start = 1 ) :<br>        if arr [ i ] > k :<br>            bad -= 1<br>        if arr [ j ] > k :<br>            bad += 1<br>        ans = min ( ans , bad )<br>    return ans<br></td>
  </tr><tr>
    <th>MINIMUM_TIME_TO_FINISH_TASKS_WITHOUT_SKIPPING_TWO_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    if ( n <= 0 ) : return 0<br>    incl = arr [ 0 ]<br>    excl = 0<br>    for i in range ( 1 , n ) :<br>        incl_new = arr [ i ] + min ( excl , incl )<br>        excl_new = incl<br>        incl = incl_new<br>        excl = excl_new<br>    return min ( incl , excl )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    if n <= 0 :<br>        return 0<br>    incl = arr [ 0 ]<br>    excl = 0<br>    for i in range ( 1 , n ) :<br>        incl_new = arr [ i ] + min ( excl , incl )<br>        excl_new = incl<br>        incl = incl_new<br>        excl = excl_new<br>    return min ( incl , excl )<br></td>
  </tr><tr>
    <th>MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( N , insrt , remov , cpy ) :<br>    if N == 0 :<br>        return 0<br>    if N == 1 :<br>        return insrt<br>    dp = [ 0 ] * ( N + 1 )<br>    for i in range ( 1 , N + 1 ) :<br>        if i % 2 == 0 :<br>            dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy )<br>        else :<br>            dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov )<br>    return dp [ N ]<br></td>
    <td>translated code: <br><br> def f_gold ( N , insert , remove , copy ) :<br>    if N == 0 :<br>        return 0<br>    if N == 1 :<br>        return insert<br>    dp = [ 0 ] * ( N + 1 )<br>    for i in range ( 1 , N + 1 ) :<br>        if i % 2 == 0 :<br>            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy )<br>        else :<br>            dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove )<br>    return dp [ N ]<br></td>
  </tr><tr>
    <th>MOBILE_NUMERIC_KEYPAD_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( keypad , n ) :<br>    if ( not keypad or n <= 0 ) :<br>        return 0<br>    if ( n == 1 ) :<br>        return 10<br>    odd = [ 0 ] * 10<br>    even = [ 0 ] * 10<br>    i = 0<br>    j = 0<br>    useOdd = 0<br>    totalCount = 0<br>    for i in range ( 10 ) :<br>        odd [ i ] = 1<br>    for j in range ( 2 , n + 1 ) :<br>        useOdd = 1 - useOdd<br>        if ( useOdd == 1 ) :<br>            even [ 0 ] = odd [ 0 ] + odd [ 8 ]<br>            even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ]<br>            even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ]<br>            even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ]<br>            even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ]<br>            even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ]<br>            even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ]<br>            even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ]<br>            even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ]<br>            even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ]<br>        else :<br>            odd [ 0 ] = even [ 0 ] + even [ 8 ]<br>            odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ]<br>            odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ]<br>            odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ]<br>            odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ]<br>            odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ]<br>            odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ]<br>            odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ]<br>            odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ]<br>            odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ]<br>    totalCount = 0<br>    if ( useOdd == 1 ) :<br>        for i in range ( 10 ) :<br>            totalCount += even [ i ]<br>    else :<br>        for i in range ( 10 ) :<br>            totalCount += odd [ i ]<br>    return totalCount<br></td>
    <td>translated code: <br><br> def f_gold ( keypad , n ) :<br>    if keypad is None or n <= 0 :<br>        return 0<br>    if n == 1 :<br>        return 10<br>    odd = [ ]<br>    even = [ ]<br>    i = 0 , 0 , 0 , useOdd , totalCount = 0<br>    for i in range ( 0 , 9 ) :<br>        odd.append ( 1 )<br>    for j in range ( 2 , n ) :<br>        useOdd = 1 - useOdd<br>        if useOdd == 1 :<br>            even.append ( odd [ 0 ] + odd [ 8 ] )<br>            even.append ( odd [ 1 ] + odd [ 2 ] + odd [ 4 ] )<br>            even.append ( odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] )<br>            even.append ( odd [ 3 ] + odd [ 2 ] + odd [ 6 ] )<br>            even.append ( odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] )<br>            even.append ( odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] )<br>            even.append ( odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] )<br>            even.append ( odd [ 7 ] + odd [ 4 ] + odd [ 8 ] )<br>            even.append ( odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] )<br>            even.append ( odd [ 9 ] + odd [ 6 ] + odd [ 8 ] )<br>        else :<br>            odd.append ( even [ 0 ] + even [ 8 ] )<br>            odd.append ( even [ 1 ] + even [ 2 ] + even [ 4 ] )<br>            odd.append ( even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] )<br>            odd.append ( even [ 3 ] + even [ 2 ] + even [ 6 ] )<br>            odd.append ( even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] )<br>            odd.append ( even [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] )<br>            odd.append ( even [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] )<br>    return sum ( odd )<br>    </td>
  </tr><tr>
    <th>MULTIPLY_AN_INTEGER_WITH_3_5</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x ) :<br>    return ( x << 1 ) + x + ( x >> 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( x ) :<br>    return ( x << 1 ) + x + ( x >> 1 )<br></td>
  </tr><tr>
    <th>NUMBER_IS_DIVISIBLE_BY_29_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    while ( int ( n / 100 ) ) :<br>        last_digit = int ( n % 10 )<br>        n = int ( n / 10 )<br>        n += last_digit * 3<br>    return ( n % 29 == 0 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    while n / 100 > 0 :<br>        last_digit = int ( n % 10 )<br>        n /= 10<br>        n += last_digit * 3<br>    return ( n % 29 == 0 )<br></td>
  </tr><tr>
    <th>NUMBER_N_DIGIT_STEPPING_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] <br>    if ( n == 1 ) :<br>        return 10 <br>    for j in range ( 10 ) :<br>        dp [ 1 ] [ j ] = 1 <br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 10 ) :<br>            if ( j == 0 ) :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] <br>            elif ( j == 9 ) :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] <br>            else :<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) <br>    sum = 0 <br>    for j in range ( 1 , 10 ) :<br>        sum = sum + dp [ n ] [ j ] <br>    return sum <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    if n == 1 : return 10<br>    for j in range ( 0 , 9 ) :<br>        dp [ 1 ] [ j ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        for j in range ( 0 , 9 ) :<br>            if j == 0 :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]<br>            elif j == 9 :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ]<br>    sum = 0<br>    for j in range ( 1 , 9 ) :<br>        sum += dp [ n ] [ j ]<br>    return sum<br></td>
  </tr><tr>
    <th>NUMBER_OF_SUBSTRINGS_WITH_ODD_DECIMAL_VALUE_IN_A_BINARY_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    auxArr = [ 0 for i in range ( n ) ]<br>    if ( s [ 0 ] == '1' ) :<br>        auxArr [ 0 ] = 1<br>    for i in range ( 0 , n ) :<br>        if ( s [ i ] == '1' ) :<br>            auxArr [ i ] = auxArr [ i - 1 ] + 1<br>        else :<br>            auxArr [ i ] = auxArr [ i - 1 ]<br>    count = 0<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if ( s [ i ] == '1' ) :<br>            count += auxArr [ i ]<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    auxArr = [ ]<br>    if s [ 0 ] == '1' :<br>        auxArr.append ( 1 )<br>    for i in range ( 1 , n ) :<br>        if s [ i ] == '1' :<br>            auxArr.append ( auxArr [ i - 1 ] + 1 )<br>        else :<br>            auxArr.append ( auxArr [ i - 1 ] )<br>    count = 0<br>    for i in range ( n - 1 , - 1 , - 1 ) :<br>        if s [ i ] == '1' :<br>            count += auxArr [ i ]<br>    return count<br></td>
  </tr><tr>
    <th>NUMBER_OF_TRIANGLES_IN_A_PLANE_IF_NO_MORE_THAN_TWO_POINTS_ARE_COLLINEAR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( n * ( n - 1 ) * ( n - 2 ) // 6 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return n * ( n - 1 ) ** ( n - 2 ) / 6<br></td>
  </tr><tr>
    <th>NUMBER_ORDERED_PAIRS_AI_AJ_0</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    count = 0<br>    for i in range ( 0 , n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( a [ i ] & a [ j ] ) == 0 :<br>                count += 2<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    count = 0<br>    for i in range ( n ) :<br>        for j in range ( i + 1 , n ) :<br>            if ( a [ i ] & a [ j ] ) == 0 :<br>                count += 2<br>    return count<br></td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_DIVISIBLE_4_STRING_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    count = 0 <br>    for i in range ( 0 , n , 1 ) :<br>        if ( s [ i ] == '4' or s [ i ] == '8' or s [ i ] == '0' ) :<br>            count += 1<br>    for i in range ( 0 , n - 1 , 1 ) :<br>        h = ( ord ( s [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) )<br>        if ( h % 4 == 0 ) :<br>            count = count + i + 1<br>    return count<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    count = 0<br>    for i in range ( n ) :<br>        if s [ i ] in [ '4' , '8' , '0' ] :<br>            count += 1<br>    for i in range ( n - 1 ) :<br>        h = ( s [ i ] - '0' ) * 10 + ( s [ i + 1 ] - '0' )<br>        if h % 4 == 0 :<br>            count = count + i + 1<br>    return count<br></td>
  </tr><tr>
    <th>NUMBER_TRIANGLES_N_MOVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    answer = [ None ] * ( n + 1 ) <br>    answer [ 0 ] = 1 <br>    i = 1<br>    while i <= n :<br>        answer [ i ] = answer [ i - 1 ] * 3 + 2 <br>        i = i + 1<br>    return answer [ n ] <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    answer = [ 1 ] * ( n + 1 )<br>    for i in range ( 1 , n + 1 ) :<br>        answer [ i ] = answer [ i - 1 ] * 3 + 2<br>    return answer [ n ]<br></td>
  </tr><tr>
    <th>NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    ans = 0<br>    for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) :<br>        height = length<br>        while ( height * length <= n ) :<br>            ans += 1<br>            height += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    ans = 0<br>    for length in range ( 1 , math.sqrt ( n ) + 1 ) :<br>        for height in range ( length , length * length <= n ) :<br>            ans += 1<br>    return ans<br></td>
  </tr><tr>
    <th>NUMBER_WAYS_NODE_MAKE_LOOP_SIZE_K_UNDIRECTED_COMPLETE_CONNECTED_GRAPH_N_NODES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , k ) :<br>    p = 1<br>    if ( k % 2 ) :<br>        p = - 1<br>    return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n<br></td>
    <td>translated code: <br><br> def f_gold ( n , k ) :<br>    p = 1<br>    if k % 2 != 0 :<br>        p = - 1<br>    return int ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n<br></td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    nthElement = 19 + ( n - 1 ) * 9<br>    outliersCount = int ( math.log10 ( nthElement ) ) - 1<br>    nthElement += 9 * outliersCount<br>    return nthElement<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    nth_element = 19 + ( n - 1 ) * 9<br>    outliers_count = int ( math.log10 ( nth_element ) - 1 )<br>    nth_element += 9 * outliers_count<br>    return nth_element<br></td>
  </tr><tr>
    <th>N_TH_TERM_SERIES_2_12_36_80_150</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( n * n ) + ( n * n * n )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( n ** 2 ) + ( n ** 2 * n )<br></td>
  </tr><tr>
    <th>PAINTING_FENCE_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , k ) :<br>    total = k<br>    mod = 1000000007<br>    same , diff = 0 , k<br>    for i in range ( 2 , n + 1 ) :<br>        same = diff<br>        diff = total * ( k - 1 )<br>        diff = diff % mod<br>        total = ( same + diff ) % mod<br>    return total<br></td>
    <td>translated code: <br><br> def f_gold ( n , k ) :<br>    total = k<br>    mod = 1000000007<br>    same , diff = 0 , k<br>    for i in range ( 2 , n + 1 ) :<br>        same , diff = diff , int ( total * ( k - 1 ) )<br>        diff = diff % mod<br>        total = ( same + diff ) % mod<br>    return total<br></td>
  </tr><tr>
    <th>PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , x ) :<br>    for i in arr :<br>        for j in arr :<br>            if i * j == x :<br>                return True<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , x ) :<br>    for i in range ( n - 1 ) :<br>        for j in range ( i + 1 , n ) :<br>            if arr [ i ] * arr [ j ] == x :<br>                return True<br>    return False<br></td>
  </tr><tr>
    <th>PERFECT_REVERSIBLE_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    i = 0 ; j = len ( str ) - 1 <br>    while ( i < j ) :<br>        if ( str [ i ] != str [ j ] ) :<br>            return False <br>        i += 1 <br>        j -= 1 <br>    return True <br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    i , j = 0 , len ( str ) - 1<br>    while i < j :<br>        if str [ i ] != str [ j ] :<br>            return False<br>        i += 1<br>        j -= 1<br>    return True<br></td>
  </tr><tr>
    <th>PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return int ( 1 + n * ( n + 1 ) / 2 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return 1 + n * ( n + 1 ) / 2<br></td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n <= 1 ) :<br>        return False<br>    if ( n <= 3 ) :<br>        return True<br>    if ( n % 2 == 0 or n % 3 == 0 ) :<br>        return False<br>    i = 5<br>    while ( i * i <= n ) :<br>        if ( n % i == 0 or n % ( i + 2 ) == 0 ) :<br>            return False<br>        i = i + 6<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n <= 1 :<br>        return False<br>    if n <= 3 :<br>        return True<br>    if n % 2 == 0 or n % 3 == 0 :<br>        return False<br>    for i in range ( 5 , i * i <= n , 6 ) :<br>        if n % i == 0 or n % ( i + 2 ) == 0 :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( p ) :<br>    checkNumber = 2 ** p - 1<br>    nextval = 4 % checkNumber<br>    for i in range ( 1 , p - 1 ) :<br>        nextval = ( nextval * nextval - 2 ) % checkNumber<br>    if ( nextval == 0 ) : return True<br>    else : return False<br></td>
    <td>translated code: <br><br> def f_gold ( p ) :<br>    check_number = math.pow ( 2 , p ) - 1<br>    nextval = 4 % check_number<br>    for i in range ( 1 , p - 1 ) :<br>        nextval = ( nextval * nextval - 2 ) % check_number<br>    return ( nextval == 0 )<br></td>
  </tr><tr>
    <th>PRINT_WORDS_STRING_REVERSE_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str ) :<br>    i = len ( str ) - 1<br>    start = end = i + 1<br>    result = ''<br>    while i >= 0 :<br>        if str [ i ] == ' ' :<br>            start = i + 1<br>            while start != end :<br>                result += str [ start ]<br>                start += 1<br>            result += ' '<br>            end = i<br>        i -= 1<br>    start = 0<br>    while start != end :<br>        result += str [ start ]<br>        start += 1<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( str ) :<br>    i = len ( str ) - 1<br>    start , end = i + 1 , i + 1<br>    result = ""<br>    while i >= 0 :<br>        if str [ i ] == ' ' :<br>            start = i + 1<br>            while start != end :<br>                result += str [ start ]<br>            result += ' '<br>            end = i<br>        i -= 1<br>    start = 0<br>    while start != end :<br>        result += str [ start ]<br>    return result<br></td>
  </tr><tr>
    <th>PROGRAM_BINARY_DECIMAL_CONVERSION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    num = n <br>    dec_value = 0 <br>    base1 = 1 <br>    len1 = len ( num ) <br>    for i in range ( len1 - 1 , - 1 , - 1 ) :<br>        if ( num [ i ] == '1' ) :<br>            dec_value += base1 <br>        base1 = base1 * 2 <br>    return dec_value <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    num = n<br>    dec_value = 0<br>    base = 1<br>    len ( num )<br>    for i in range ( len ( num ) - 1 , - 1 , - 1 ) :<br>        if num [ i ] == '1' :<br>            dec_value += base<br>        base = base * 2<br>    return dec_value<br></td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_AREA_OCTAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( side ) :<br>    return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )<br></td>
    <td>translated code: <br><br> def f_gold ( side ) :<br>    return float ( 2 * ( 1 + np.sqrt ( 2 ) ) * side ** 2 )<br></td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_VOLUME_ELLIPSOID</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( r1 , r2 , r3 ) :<br>    return 1.33 * math.pi * r1 * r2 * r3<br></td>
    <td>translated code: <br><br> def f_gold ( r1 , r2 , r3 ) :<br>    pi = float ( 3.14 )<br>    return float ( 1.33 * pi * r1 * r2 * r3 )<br></td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_VOLUME_OCTAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( side ) :<br>    return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( side ) :<br>    return ( ( side ** 2 ) * ( math.sqrt ( 2 ) / 3 ) )<br></td>
  </tr><tr>
    <th>PROGRAM_CIRCUMFERENCE_PARALLELOGRAM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b ) :<br>    return ( ( 2 * a ) + ( 2 * b ) )<br></td>
    <td>translated code: <br><br> def f_gold ( a , b ) :<br>    return ( ( 2 * a ) + ( 2 * b ) )<br></td>
  </tr><tr>
    <th>PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s , c ) :<br>    res = 0<br>    for i in range ( len ( s ) ) :<br>        if ( s [ i ] == c ) :<br>            res = res + 1<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( s , c ) :<br>    res = 0<br>    for i in range ( len ( s ) ) :<br>        if s [ i ] == c :<br>            res += 1<br>    return res<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * f_gold ( n - 1 ) <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 0 :<br>        return 1<br>    return n * f_gold ( n - 1 )<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * f_gold ( n - 1 ) <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    res , i = 1 , 0<br>    for i in range ( 2 , n + 1 ) :<br>        res *= i<br>    return res<br></td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return 1 if ( n == 1 or n == 0 ) else n * f_gold ( n - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( n == 1 or n == 0 )<br></td>
  </tr><tr>
    <th>PROGRAM_PAGE_REPLACEMENT_ALGORITHMS_SET_2_FIFO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( pages , n , capacity ) :<br>    s = set ( )<br>    indexes = Queue ( )<br>    page_faults = 0<br>    for i in range ( n ) :<br>        if ( len ( s ) < capacity ) :<br>            if ( pages [ i ] not in s ) :<br>                s.add ( pages [ i ] )<br>                page_faults += 1<br>                indexes.put ( pages [ i ] )<br>        else :<br>            if ( pages [ i ] not in s ) :<br>                val = indexes.queue [ 0 ]<br>                indexes.get ( )<br>                s.remove ( val )<br>                s.add ( pages [ i ] )<br>                indexes.put ( pages [ i ] )<br>                page_faults += 1<br>    return page_faults<br></td>
    <td>translated code: <br><br> def f_gold ( pages , n , capacity ) :<br>    s = set ( capacity )<br>    indexes = queue.Queue ( )<br>    page_faults = 0<br>    for i in range ( n ) :<br>        if len ( s ) < capacity :<br>            if not s.issubset ( pages ) :<br>                s.add ( pages [ i ] )<br>                page_faults += 1<br>                indexes.add ( pages [ i ] )<br>        else :<br>            if not s.issubset ( pages ) :<br>                val = indexes.pop ( )<br>                indexes.clear ( )<br>                s.remove ( val )<br>                s.add ( pages [ i ] )<br>                indexes.add ( pages [ i ] )<br>                page_faults += 1<br>    return page_faults<br></td>
  </tr><tr>
    <th>PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return math.pow ( n , 2 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return int ( math.pow ( n , 2 ) )<br></td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a ) :<br>    area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4<br>    return area<br></td>
    <td>translated code: <br><br> def f_gold ( a ) :<br>    area = float ( 'inf' )<br>    area = ( math.sqrt ( 5 * ( 5 + 2 * ( math.sqrt ( 5 ) ) ) ) * a ** 2 ) / 4<br>    return area<br></td>
  </tr><tr>
    <th>PYTHAGOREAN_QUADRUPLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b , c , d ) :<br>    sum = a * a + b * b + c * c <br>    if ( d * d == sum ) :<br>        return True<br>    else :<br>        return False<br></td>
    <td>translated code: <br><br> def f_gold ( a , b , c , d ) :<br>    sum = a ** 2 + b ** 2 + c ** 2<br>    if d ** 2 == sum :<br>        return True<br>    else :<br>        return False<br></td>
  </tr><tr>
    <th>PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( l , w ) :<br>    return ( 2 * ( l + w ) )<br></td>
    <td>translated code: <br><br> def f_gold ( l , w ) :<br>    return ( 2 * ( l + w ) )<br></td>
  </tr><tr>
    <th>QUICK_WAY_CHECK_CHARACTERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    for i in range ( 1 , n ) :<br>        if s [ i ] != s [ 0 ] :<br>            return False<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    n = len ( s )<br>    for i in range ( 1 , n ) :<br>        if s [ i ] != s [ 0 ] :<br>            return False<br>    return True<br></td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    max_idx = n - 1<br>    min_idx = 0<br>    max_elem = arr [ n - 1 ] + 1<br>    for i in range ( 0 , n ) :<br>        if i % 2 == 0 :<br>            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem<br>            max_idx -= 1<br>        else :<br>            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem<br>            min_idx += 1<br>    for i in range ( 0 , n ) :<br>        arr [ i ] = arr [ i ] / max_elem<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    max_idx , min_idx = n - 1 , 0<br>    max_elem = arr [ n - 1 ] + 1<br>    for i in range ( n ) :<br>        if i % 2 == 0 :<br>            arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem<br>            max_idx -= 1<br>        else :<br>            arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem<br>            min_idx += 1<br>    for i in range ( n ) :<br>        arr [ i ] = arr [ i ] / max_elem<br></td>
  </tr><tr>
    <th>RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n == 0 or n == 1 ) :<br>        return n<br>    return max ( ( f_gold ( n // 2 ) + f_gold ( n // 3 ) + f_gold ( n // 4 ) ) , n )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 0 or n == 1 :<br>        return n<br>    return max ( ( f_gold ( n / 2 ) + f_gold ( n / 3 ) + f_gold ( n / 4 ) ) , n )<br></td>
  </tr><tr>
    <th>RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    dp [ 0 ] = 0<br>    dp [ 1 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) <br>    return dp [ n ]<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    dp = [ 0 ] * ( n + 1 )<br>    dp [ 0 ] = 1<br>    for i in range ( 2 , n + 1 ) :<br>        dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i )<br>    return dp [ n ]<br></td>
  </tr><tr>
    <th>RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , l , r , x ) :<br>    if r < l :<br>        return - 1<br>    if arr [ l ] == x :<br>        return l<br>    if arr [ r ] == x :<br>        return r<br>    return f_gold ( arr , l + 1 , r - 1 , x )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , l , r , x ) :<br>    if r < l :<br>        return - 1<br>    if arr [ l ] == x :<br>        return l<br>    if arr [ r ] == x :<br>        return r<br>    return f_gold ( arr , l + 1 , r - 1 , x )<br></td>
  </tr><tr>
    <th>REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( dp , a , low , high , turn ) :<br>    if ( low == high ) :<br>        return a [ low ] * turn<br>    if ( dp [ low ] [ high ] != 0 ) :<br>        return dp [ low ] [ high ]<br>    dp [ low ] [ high ] = max ( a [ low ] * turn + f_gold ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + f_gold ( dp , a , low , high - 1 , turn + 1 ) ) <br>    return dp [ low ] [ high ]<br></td>
    <td>translated code: <br><br> def f_gold ( dp , a , low , high , turn ) :<br>    if low == high :<br>        return a [ low ] * turn<br>    if dp [ low ] [ high ] != 0 :<br>        return dp [ low ] [ high ]<br>    dp [ low ] [ high ] = max ( a [ low ] * turn + f_gold ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + f_gold ( dp , a , low , high - 1 , turn + 1 ) )<br>    return dp [ low ] [ high ]<br></td>
  </tr><tr>
    <th>REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    longest_start = - 1 <br>    longest_end = 0 <br>    for start in range ( n ) :<br>        min = sys.maxsize <br>        max = - sys.maxsize <br>        for end in range ( start , n ) :<br>            val = arr [ end ] <br>            if ( val < min ) :<br>                min = val <br>            if ( val > max ) :<br>                max = val <br>            if ( 2 * min <= max ) :<br>                break <br>            if ( end - start > longest_end - longest_start or longest_start == - 1 ) :<br>                longest_start = start <br>                longest_end = end <br>    if ( longest_start == - 1 ) :<br>        return n <br>    return ( n - ( longest_end - longest_start + 1 ) ) <br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    longest_start , longest_end = - 1 , 0<br>    for start in range ( n ) :<br>        min , max = int ( arr [ start ] ) , int ( arr [ start + 1 ] )<br>        for end in range ( start , n ) :<br>            val = arr [ end ]<br>            if val < min : min , val = val , val<br>            if val > max : max , val = val , val<br>            if 2 * min <= max : break<br>            if end - start > longest_end - longest_start or longest_start == - 1 :<br>                longest_start = start<br>                longest_end = end<br>    if longest_start == - 1 :<br>        return n<br>    return ( n - ( longest_end - longest_start + 1 ) )<br></td>
  </tr><tr>
    <th>REMOVE_MINIMUM_NUMBER_ELEMENTS_NO_COMMON_ELEMENT_EXIST_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b , n , m ) :<br>    countA = dict ( )<br>    countB = dict ( )<br>    for i in range ( n ) :<br>        countA [ a [ i ] ] = countA.get ( a [ i ] , 0 ) + 1<br>    for i in range ( n ) :<br>        countB [ b [ i ] ] = countB.get ( b [ i ] , 0 ) + 1<br>    res = 0<br>    for x in countA :<br>        if x in countB.keys ( ) :<br>            res += min ( countA [ x ] , countB [ x ] )<br>    return res<br></td>
    <td>translated code: <br><br> def f_gold ( a , b , n , m ) :<br>    count_a = { }<br>    count_b = { }<br>    for i in range ( n ) :<br>        if count_a.has_key ( a [ i ] ) :<br>            count_a [ a [ i ] ] = count_a [ a [ i ] ] + 1<br>        else :<br>            count_a [ a [ i ] ] = 1<br>    for i in range ( m ) :<br>        if count_b.has_key ( b [ i ] ) :<br>            count_b [ b [ i ] ] = count_b [ b [ i ] ] + 1<br>        else :<br>            count_b [ b [ i ] ] = 1<br>    res = 0<br>    s = count_a.keys ( )<br>    for x in s :<br>        if count_b.has_key ( x ) :<br>            res += min ( count_b [ x ] , count_a [ x ] )<br>    return res<br></td>
  </tr><tr>
    <th>REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s , c1 , c2 ) :<br>    l = len ( s )<br>    for i in range ( l ) :<br>        if ( s [ i ] == c1 ) :<br>            s = s [ 0 : i ] + c2 + s [ i + 1 : ]<br>        elif ( s [ i ] == c2 ) :<br>            s = s [ 0 : i ] + c1 + s [ i + 1 : ]<br>    return s<br></td>
    <td>translated code: <br><br> def f_gold ( s , c1 , c2 ) :<br>    l = len ( s )<br>    arr = s [ : l ]<br>    for i in range ( l ) :<br>        if arr [ i ] == c1 :<br>            arr [ i ] = c2<br>        elif arr [ i ] == c2 :<br>            arr [ i ] = c1<br>    return str ( arr )<br></td>
  </tr><tr>
    <th>ROUND_THE_GIVEN_NUMBER_TO_NEAREST_MULTIPLE_OF_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    a = ( n // 10 ) * 10<br>    b = a + 10<br>    return ( b if n - a > b - n else a )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    a = ( n // 10 ) * 10<br>    b = a + 10<br>    return ( n - a > b - n )<br></td>
  </tr><tr>
    <th>SEARCHING_ARRAY_ADJACENT_DIFFER_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , x , k ) :<br>    i = 0<br>    while ( i < n ) :<br>        if ( arr [ i ] == x ) :<br>            return i<br>        i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) )<br>    print ( "number is not present!" )<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , x , k ) :<br>    i = 0<br>    while i < n :<br>        if arr [ i ] == x :<br>            return i<br>        i = i + max ( 1 , abs ( arr [ i ] - x ) / k )<br>    print ( "number is " + "not present!" )<br>    return - 1<br></td>
  </tr><tr>
    <th>SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , x ) :<br>    i = 0<br>    while ( i < n ) :<br>        if ( arr [ i ] == x ) :<br>            return i<br>        i = i + abs ( arr [ i ] - x )<br>    print ( "number is not present!" )<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , x ) :<br>    i = 0<br>    while i < n :<br>        if arr [ i ] == x :<br>            return i<br>        i = i + abs ( arr [ i ] - x )<br>    print ( "number is not" + " present!" )<br>    return - 1<br></td>
  </tr><tr>
    <th>SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , B , m , n ) :<br>    A.sort ( )<br>    B.sort ( )<br>    a = 0<br>    b = 0<br>    result = sys.maxsize<br>    while ( a < m and b < n ) :<br>        if ( abs ( A [ a ] - B [ b ] ) < result ) :<br>            result = abs ( A [ a ] - B [ b ] )<br>        if ( A [ a ] < B [ b ] ) :<br>            a += 1<br>        else :<br>            b += 1<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( A , B , m , n ) :<br>    A.sort ( )<br>    B.sort ( )<br>    a , b = 0 , 0<br>    result = sys.maxsize<br>    while a < m and b < n :<br>        if abs ( A [ a ] - B [ b ] ) < result :<br>            result = abs ( A [ a ] - B [ b ] )<br>        if A [ a ] < B [ b ] :<br>            a += 1<br>        else :<br>            b += 1<br>    return result<br></td>
  </tr><tr>
    <th>SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x , y , z ) :<br>    c = 0<br>    while ( x and y and z ) :<br>        x = x - 1<br>        y = y - 1<br>        z = z - 1<br>        c = c + 1<br>    return c<br></td>
    <td>translated code: <br><br> def f_gold ( x , y , z ) :<br>    c = 0<br>    while x != 0 and y != 0 and z != 0 :<br>        x -= 1<br>        y -= 1<br>        z -= 1<br>        c += 1<br>    return c<br></td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    count = 0 <br>    if ( n and not ( n & ( n - 1 ) ) ) :<br>        return n<br>    while ( n != 0 ) :<br>        n >>= 1<br>        count += 1<br>    return 1 << count <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    count = 0<br>    if n and ( n & ( n - 1 ) ) == 0 :<br>        return n<br>    while n != 0 :<br>        n >>= 1<br>        count += 1<br>    return 1 << count<br></td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    p = 1<br>    if ( n and not ( n & ( n - 1 ) ) ) :<br>        return n<br>    while ( p < n ) :<br>        p <<= 1<br>    return p <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    p = 1<br>    if n and ( n & ( n - 1 ) ) == 0 :<br>        return n<br>    while p < n :<br>        p <<= 1<br>    return p<br></td>
  </tr><tr>
    <th>SMALLEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    min_ending_here = sys.maxsize<br>    min_so_far = sys.maxsize<br>    for i in range ( n ) :<br>        if ( min_ending_here > 0 ) :<br>            min_ending_here = arr [ i ]<br>        else :<br>            min_ending_here += arr [ i ]<br>        min_so_far = min ( min_so_far , min_ending_here )<br>    return min_so_far<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    min_ending_here = 2147483647<br>    min_so_far = 2147483647<br>    for i in range ( n ) :<br>        if min_ending_here > 0 :<br>            min_ending_here = arr [ i ]<br>        else :<br>            min_ending_here += arr [ i ]<br>        min_so_far = min ( min_so_far , min_ending_here )<br>    return min_so_far<br></td>
  </tr><tr>
    <th>SORT_ARRAY_APPLYING_GIVEN_EQUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n , A , B , C ) :<br>    for i in range ( n ) :<br>        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C )<br>    index = - ( sys.maxsize - 1 )<br>    maximum = - ( sys.maxsize - 1 )<br>    for i in range ( n ) :<br>        if maximum < arr [ i ] :<br>            index = i<br>            maximum = arr [ i ]<br>    i = 0 ; j = n - 1 <br>    new_arr = [ 0 ] * n<br>    k = 0<br>    while i < index and j > index :<br>        if arr [ i ] < arr [ j ] :<br>            new_arr [ k ] = arr [ i ]<br>            k += 1<br>            i += 1<br>        else :<br>            new_arr [ k ] = arr [ j ]<br>            k += 1<br>            j -= 1<br>    while i < index :<br>        new_arr [ k ] = arr [ i ]<br>        k += 1<br>        i += 1<br>    while j > index :<br>        new_arr [ k ] = arr [ j ]<br>        k += 1<br>        j -= 1<br>        new_arr [ n - 1 ] = maximum<br>    for i in range ( n ) :<br>        arr [ i ] = new_arr [ i ]<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n , A , B , C ) :<br>    for i in range ( n ) :<br>        arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C<br>    index = - 1<br>    maximum = - 999999<br>    for i in range ( n ) :<br>        if maximum < arr [ i ] :<br>            index = i<br>            maximum = arr [ i ]<br>    i , j = 0 , n - 1<br>    new_arr = [ ]<br>    k = 0<br>    while i < index and j > index :<br>        if arr [ i ] < arr [ j ] :<br>            new_arr.append ( arr [ i ++ ] )<br>        else :<br>            new_arr.append ( arr [ j -- ] )<br>    while i < index :<br>        new_arr.append ( arr [ i ++ ] )<br>    while j > index :<br>        new_arr.append ( arr [ j -- ] )<br>    new_arr.append ( maximum )<br>    for p in range ( n ) :<br>        arr [ p ] = new_arr [ p ]<br>    return arr<br></td>
  </tr><tr>
    <th>SORT_ARRAY_TWO_HALVES_SORTED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , n ) :<br>    A.sort ( )<br></td>
    <td>translated code: <br><br> def f_gold ( A , n ) :<br>    A.sort ( )<br></td>
  </tr><tr>
    <th>SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] & 1 ) :<br>            arr [ i ] *= - 1<br>    arr.sort ( )<br>    for i in range ( 0 , n ) :<br>        if ( arr [ i ] & 1 ) :<br>            arr [ i ] *= - 1<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    for i in range ( n ) :<br>        if ( arr [ i ] & 1 ) :<br>            arr [ i ] *= - 1<br>    arr.sort ( )<br>    for i in range ( n ) :<br>        if ( arr [ i ] & 1 ) :<br>            arr [ i ] *= - 1<br></td>
  </tr><tr>
    <th>SPLIT_N_MAXIMUM_COMPOSITE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n < 4 ) :<br>        return - 1<br>    rem = n % 4<br>    if ( rem == 0 ) :<br>        return n // 4<br>    if ( rem == 1 ) :<br>        if ( n < 9 ) :<br>            return - 1<br>        return ( n - 9 ) // 4 + 1<br>    if ( rem == 2 ) :<br>        return ( n - 6 ) // 4 + 1<br>    if ( rem == 3 ) :<br>        if ( n < 15 ) :<br>            return - 1<br>        return ( n - 15 ) // 4 + 2<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n < 4 :<br>        return - 1<br>    rem = n % 4<br>    if rem == 0 :<br>        return n / 4<br>    if rem == 1 :<br>        if n < 9 :<br>            return - 1<br>        return ( n - 9 ) / 4 + 1<br>    if rem == 2 :<br>        return ( n - 6 ) / 4 + 1<br>    if rem == 3 :<br>        if n < 15 :<br>            return - 1<br>        return ( n - 15 ) / 4 + 2<br></td>
  </tr><tr>
    <th>SQUARED_TRIANGULAR_NUMBER_SUM_CUBES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( s ) :<br>    _sum = 0<br>    n = 1<br>    while ( _sum < s ) :<br>        _sum += n * n * n<br>        n += 1<br>    n -= 1<br>    if _sum == s :<br>        return n<br>    return - 1<br></td>
    <td>translated code: <br><br> def f_gold ( s ) :<br>    sum = 0<br>    for n in range ( 1 , s ) :<br>        sum += n ** 2 * n ** 2<br>        if sum == s :<br>            return n<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_AN_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x ) :<br>    if ( x == 0 or x == 1 ) :<br>        return x<br>    i = 1 ; result = 1<br>    while ( result <= x ) :<br>        i += 1<br>        result = i * i<br>    return i - 1<br></td>
    <td>translated code: <br><br> def f_gold ( x ) :<br>    if x == 0 or x == 1 :<br>        return x<br>    i , result = 1 , 1<br>    while result <= x :<br>        i += 1<br>        result = i * i<br>    return i - 1<br></td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_AN_INTEGER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x ) :<br>    if ( x == 0 or x == 1 ) :<br>        return x<br>    start = 1<br>    end = x<br>    while ( start <= end ) :<br>        mid = ( start + end ) // 2<br>        if ( mid * mid == x ) :<br>            return mid<br>        if ( mid * mid < x ) :<br>            start = mid + 1<br>            ans = mid<br>        else :<br>            end = mid - 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( x ) :<br>    if x == 0 or x == 1 :<br>        return x<br>    start , end , ans = 1 , x , 0<br>    while start <= end :<br>        mid = ( start + end ) / 2<br>        if mid * mid == x :<br>            return mid<br>        if mid * mid < x :<br>            start = mid + 1<br>            ans = mid<br>        else :<br>            end = mid - 1<br>    return ans<br></td>
  </tr><tr>
    <th>STEINS_ALGORITHM_FOR_FINDING_GCD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b ) :<br>    if ( a == 0 ) :<br>        return b<br>    if ( b == 0 ) :<br>        return a<br>    k = 0<br>    while ( ( ( a | b ) & 1 ) == 0 ) :<br>        a = a >> 1<br>        b = b >> 1<br>        k = k + 1<br>    while ( ( a & 1 ) == 0 ) :<br>        a = a >> 1<br>    while ( b != 0 ) :<br>        while ( ( b & 1 ) == 0 ) :<br>            b = b >> 1<br>        if ( a > b ) :<br>            temp = a<br>            a = b<br>            b = temp<br>        b = ( b - a )<br>    return ( a << k )<br></td>
    <td>translated code: <br><br> def f_gold ( a , b ) :<br>    if a == 0 :<br>        return b<br>    if b == 0 :<br>        return a<br>    k = 0<br>    for ( ( a | b ) & 1 ) == 0 :<br>        a >>= 1<br>        b >>= 1<br>    while ( a & 1 ) == 0 :<br>        a >>= 1<br>    do :<br>        while ( b & 1 ) == 0 :<br>            b >>= 1<br>        if a > b :<br>            temp = a<br>            a , b = b , temp<br>        b = ( b - a )<br>    while b != 0 :<br>        return a << k<br></td>
  </tr><tr>
    <th>STOOGE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , l , h ) :<br>    if l >= h :<br>        return<br>    if arr [ l ] > arr [ h ] :<br>        t = arr [ l ]<br>        arr [ l ] = arr [ h ]<br>        arr [ h ] = t<br>    if h - l + 1 > 2 :<br>        t = ( int ) ( ( h - l + 1 ) / 3 )<br>        f_gold ( arr , l , ( h - t ) )<br>        f_gold ( arr , l + t , ( h ) )<br>        f_gold ( arr , l , ( h - t ) )<br></td>
    <td>translated code: <br><br> def f_gold ( arr , l , h ) :<br>    if l >= h :<br>        return<br>    if arr [ l ] > arr [ h ] :<br>        t = arr [ l ]<br>        arr [ l ] , arr [ h ] = arr [ h ] , arr [ l ]<br>    if h - l + 1 > 2 :<br>        t = ( h - l + 1 ) // 3<br>        f_gold ( arr , l , h - t )<br>        f_gold ( arr , l + t , h )<br>        f_gold ( arr , l , h - t )<br></td>
  </tr><tr>
    <th>SUBARRAYS_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( arr , n ) :<br>    s = [ ]<br>    j = 0<br>    ans = 0<br>    for i in range ( n ) :<br>        while ( j < n and ( arr [ j ] not in s ) ) :<br>            s.append ( arr [ j ] )<br>            j += 1<br>        ans += ( ( j - i ) * ( j - i + 1 ) ) // 2<br>        s.remove ( arr [ i ] )<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( arr , n ) :<br>    s = set ( )<br>    j , ans = 0 , 0<br>    for i in range ( n ) :<br>        while j < n and not s.issubset ( arr [ j ] ) :<br>            s.add ( arr [ i ] )<br>            j += 1<br>        ans += ( ( j - i ) * ( j - i + 1 ) ) / 2<br>        s.remove ( arr [ i ] )<br>    return ans<br></td>
  </tr><tr>
    <th>SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( A , N , M ) :<br>    sum = 0<br>    ans = 0<br>    for i in range ( 0 , N ) :<br>        for j in range ( i + 1 , N ) :<br>            for k in range ( j + 1 , N ) :<br>                sum = A [ i ] + A [ j ] + A [ k ]<br>                if ( sum % M == 0 ) :<br>                    ans = ans + 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( A , N , M ) :<br>    sum = 0<br>    ans = 0<br>    for i in range ( N ) :<br>        for j in range ( i + 1 , N ) :<br>            for k in range ( j + 1 , N ) :<br>                sum = A [ i ] + A [ j ] + A [ k ]<br>                if sum % M == 0 :<br>                    ans += 1<br>    return ans<br></td>
  </tr><tr>
    <th>SUM_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]<br>    for i in range ( 0 , n + 1 ) :<br>        for j in range ( 0 , min ( i , n ) + 1 ) :<br>            if ( j == 0 or j == i ) :<br>                C [ i ] [ j ] = 1<br>            else :<br>                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ]<br>    sum = 0<br>    for i in range ( 0 , n + 1 ) :<br>        sum += C [ n ] [ i ]<br>    return sum<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    C = [ [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0 ] * n + [ 0</td>
  </tr><tr>
    <th>SUM_BINOMIAL_COEFFICIENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( 1 << n ) <br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( 1 << n )<br></td>
  </tr><tr>
    <th>SUM_DIVISORS_1_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( 1 , n + 1 ) :<br>        sum += int ( n / i ) * i<br>    return int ( sum )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( 1 , n + 1 ) :<br>        sum += ( n / i ) ** i<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    result = 0<br>    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :<br>        if ( n % i == 0 ) :<br>            if ( i == ( n / i ) ) :<br>                result = result + i<br>            else :<br>                result = result + ( i + n // i )<br>    return ( result + n + 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    result = 0<br>    for i in range ( 2 , math.sqrt ( n ) ) :<br>        if n % i == 0 :<br>            if i == ( n / i ) :<br>                result += i<br>            else :<br>                result += ( i + n / i )<br>    return ( result + n + 1 )<br></td>
  </tr><tr>
    <th>SUM_FAI_AJ_PAIRS_ARRAY_N_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , n ) :<br>    cnt = dict ( )<br>    ans = 0<br>    pre_sum = 0<br>    for i in range ( n ) :<br>        ans += ( i * a [ i ] ) - pre_sum<br>        pre_sum += a [ i ]<br>        if ( a [ i ] - 1 ) in cnt :<br>            ans -= cnt [ a [ i ] - 1 ]<br>        if ( a [ i ] + 1 ) in cnt :<br>            ans += cnt [ a [ i ] + 1 ]<br>        if a [ i ] not in cnt :<br>            cnt [ a [ i ] ] = 0<br>        cnt [ a [ i ] ] += 1<br>    return ans<br></td>
    <td>translated code: <br><br> def f_gold ( a , n ) :<br>    cnt = { }<br>    ans , pre_sum = 0 , 0<br>    for i in range ( n ) :<br>        ans += ( i * a [ i ] ) - pre_sum<br>        pre_sum += a [ i ]<br>        if cnt.has_key ( a [ i ] - 1 ) :<br>            ans -= cnt [ a [ i ] - 1 ]<br>        if cnt.has_key ( a [ i ] + 1 ) :<br>            ans += cnt [ a [ i ] + 1 ]<br>        if cnt.has_key ( a [ i ] ) :<br>            cnt [ a [ i ] ] = cnt [ a [ i ] ] + 1<br>        else :<br>            cnt [ a [ i ] ] = 1<br>    return ans<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            arr [ i ] [ j ] = abs ( i - j )<br>    sum = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            sum += arr [ i ] [ j ]<br>    return sum<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    arr = [ [ abs ( i - j ) for j in range ( n ) ] for i in range ( n ) ]<br>    sum = 0<br>    for i in range ( n ) :<br>        for j in range ( n ) :<br>            sum += arr [ i ] [ j ]<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += i * ( n - i )<br>    return 2 * sum<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        sum += i * ( n - i )<br>    return 2 * sum<br></td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    n -= 1<br>    sum = 0<br>    sum += ( n * ( n + 1 ) ) / 2<br>    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6<br>    return int ( sum )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    n -= 1<br>    sum = 0<br>    sum += ( n * ( n + 1 ) ) / 2<br>    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    sum = 1 << n <br>    return ( sum - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    sum = 1 << n<br>    return ( sum - 1 )<br></td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    sm = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i , n + 1 ) :<br>            sm = sm + i * j<br>    return sm<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( 1 , n + 1 ) :<br>        for j in range ( i , n + 1 ) :<br>            sum = sum + i * j<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24<br></td>
  </tr><tr>
    <th>SUM_SERIES_12_32_52_2N_12</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( 1 , n + 1 ) :<br>        sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )<br>    return sum<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    sum = 0<br>    for i in range ( 1 , n + 1 ) :<br>        sum = sum + ( 2 ** i - 1 ) * ( 2 ** i - 1 )<br>    return sum<br></td>
  </tr><tr>
    <th>SUM_SERIES_555555_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return int ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n )<br></td>
  </tr><tr>
    <th>SUM_SUBSETS_SET_FORMED_FIRST_N_NATURAL_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return ( n * ( n + 1 ) / 2 ) ** ( 1 << ( n - 1 ) )<br></td>
  </tr><tr>
    <th>SUM_TWO_LARGE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( str1 , str2 ) :<br>    if ( len ( str1 ) > len ( str2 ) ) :<br>        t = str1 <br>        str1 = str2 <br>        str2 = t <br>    str = "" <br>    n1 = len ( str1 ) <br>    n2 = len ( str2 ) <br>    str1 = str1 [ : : - 1 ] <br>    str2 = str2 [ : : - 1 ] <br>    carry = 0 <br>    for i in range ( n1 ) :<br>        sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) <br>        str += chr ( sum % 10 + 48 ) <br>        carry = int ( sum / 10 ) <br>    for i in range ( n1 , n2 ) :<br>        sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) <br>        str += chr ( sum % 10 + 48 ) <br>        carry = ( int ) ( sum / 10 ) <br>    if ( carry ) :<br>        str += chr ( carry + 48 ) <br>    str = str [ : : - 1 ] <br>    return str <br></td>
    <td>translated code: <br><br> def f_gold ( str1 , str2 ) :<br>    if len ( str1 ) > len ( str2 ) :<br>        t = str1<br>        str1 , str2 = str2 , t<br>    str = ""<br>    n1 , n2 = len ( str1 ) , len ( str2 )<br>    str1 = [ str [ i ] - '0' for i in range ( n1 ) ]<br>    str2 = [ str [ i ] - '0' for i in range ( n2 ) ]<br>    carry = 0<br>    for i in range ( n1 ) :<br>        sum = ( int ( str1 [ i ] - '0' ) + int ( str2 [ i ] - '0' ) + carry )<br>        str += chr ( sum % 10 + '0' )<br>        carry = sum / 10<br>    for i in range ( n1 , n2 ) :<br>        sum = ( int ( str2 [ i ] - '0' ) + carry )<br>        str += chr ( sum % 10 + '0' )<br>        carry = sum / 10<br>    if carry > 0 :<br>        str += chr ( carry + '0' )<br>    str = "".join ( str )<br>    return str<br></td>
  </tr><tr>
    <th>SWAP_BITS_IN_A_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x , p1 , p2 , n ) :<br>    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )<br>    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )<br>    xor = ( set1 ^ set2 )<br>    xor = ( xor << p1 ) | ( xor << p2 )<br>    result = x ^ xor<br>    return result<br></td>
    <td>translated code: <br><br> def f_gold ( x , p1 , p2 , n ) :<br>    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )<br>    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )<br>    xor = ( set1 ^ set2 )<br>    xor = ( xor << p1 ) | ( xor << p2 )<br>    result = x ^ xor<br>    return result<br></td>
  </tr><tr>
    <th>SWAP_TWO_NIBBLES_BYTE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x ) :<br>    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )<br></td>
    <td>translated code: <br><br> def f_gold ( x ) :<br>    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )<br></td>
  </tr><tr>
    <th>TEMPLE_OFFERINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n , templeHeight ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        left = 0<br>        right = 0<br>        for j in range ( i - 1 , - 1 , - 1 ) :<br>            if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) :<br>                left += 1<br>            else :<br>                break<br>        for j in range ( i + 1 , n ) :<br>            if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) :<br>                right += 1<br>            else :<br>                break<br>        sum += max ( right , left ) + 1<br>    return sum<br></td>
    <td>translated code: <br><br> def f_gold ( n , temple_height ) :<br>    sum = 0<br>    for i in range ( n ) :<br>        left , right = 0 , 0<br>        for j in range ( i - 1 , - 1 , - 1 ) :<br>            if temple_height [ j ] < temple_height [ j + 1 ] :<br>                left += 1<br>            else :<br>                break<br>        for j in range ( i + 1 , n ) :<br>            if temple_height [ j ] < temple_height [ j - 1 ] :<br>                right += 1<br>            else :<br>                break<br>        sum += max ( right , left ) + 1<br>    return sum<br></td>
  </tr><tr>
    <th>TRIANGULAR_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( num ) :<br>    if ( num < 0 ) :<br>        return False<br>    sum , n = 0 , 1<br>    while ( sum <= num ) :<br>        sum = sum + n<br>        if ( sum == num ) :<br>            return True<br>        n += 1<br>    return False<br></td>
    <td>translated code: <br><br> def f_gold ( num ) :<br>    if num < 0 :<br>        return False<br>    sum = 0<br>    for n in range ( 1 , num + 1 ) :<br>        sum = sum + n<br>        if sum == num :<br>            return True<br>    return False<br></td>
  </tr><tr>
    <th>TURN_OFF_THE_RIGHTMOST_SET_BIT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    return n & ( n - 1 )<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    return n & ( n - 1 )<br></td>
  </tr><tr>
    <th>UNIQUE_CELLS_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( mat , n , m ) :<br>    rowsum = [ 0 ] * n <br>    colsum = [ 0 ] * m <br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if ( mat [ i ] [ j ] != 0 ) :<br>                rowsum [ i ] += 1 <br>                colsum [ j ] += 1 <br>    uniquecount = 0 <br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) :<br>                uniquecount += 1 <br>    return uniquecount <br></td>
    <td>translated code: <br><br> def f_gold ( mat , n , m ) :<br>    rowsum = [ ]<br>    colsum = [ ]<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if mat [ i ] [ j ] != 0 :<br>                rowsum.append ( i )<br>                colsum.append ( j )<br>    uniquecount = 0<br>    for i in range ( n ) :<br>        for j in range ( m ) :<br>            if mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 :<br>                uniquecount += 1<br>    return uniquecount<br></td>
  </tr><tr>
    <th>WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( a , b ) :<br>    n = len ( a )<br>    m = len ( b )<br>    if m == 0 :<br>        return 1<br>    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]<br>    for i in range ( m ) :<br>        for j in range ( i , n ) :<br>            if i == 0 :<br>                if j == 0 :<br>                    if a [ j ] == b [ i ] :<br>                        dp [ i ] [ j ] = 1<br>                    else :<br>                        dp [ i ] [ j ] = 0<br>                elif a [ j ] == b [ i ] :<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1<br>                else :<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]<br>            else :<br>                if a [ j ] == b [ i ] :<br>                    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] )<br>                else :<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]<br>    return dp [ m - 1 ] [ n - 1 ]<br></td>
    <td>translated code: <br><br> def f_gold ( a , b ) :<br>    n , m = len ( a ) , len ( b )<br>    if m == 0 :<br>        return 1<br>    dp = [ 0 ] * ( m + 1 ) * ( n + 1 )<br>    for i in range ( m ) :<br>        for j in range ( i , n ) :<br>            if i == 0 :<br>                if j == 0 :<br>                    dp [ i ] [ j ] = ( a [ j ] == b [ i ] )<br>                elif a [ j ] == b [ i ] :<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1<br>                else :<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]<br>            elif a [ j ] == b [ i ] :<br>                dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ]<br>            else :<br>                dp [ i ] [ j ] = dp [ i ] [ j - 1 ]<br>    return dp [ m - 1 ] [ n - 1 ]<br></td>
  </tr><tr>
    <th>WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( x , y ) :<br>    if ( y == 0 ) : return 1<br>    elif ( int ( y % 2 ) == 0 ) :<br>        return ( f_gold ( x , int ( y / 2 ) ) * f_gold ( x , int ( y / 2 ) ) )<br>    else :<br>        return ( x * f_gold ( x , int ( y / 2 ) ) * f_gold ( x , int ( y / 2 ) ) )<br></td>
    <td>translated code: <br><br> def f_gold ( x , y ) :<br>    if y == 0 :<br>        return 1<br>    elif y % 2 == 0 :<br>        return f_gold ( x , y / 2 ) * f_gold ( x , y / 2 )<br>    else :<br>        return x * f_gold ( x , y / 2 ) * f_gold ( x , y / 2 )<br></td>
  </tr><tr>
    <th>WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> def f_gold ( n ) :<br>    if ( n == 0 ) :<br>        return False<br>    while ( n != 1 ) :<br>        if ( n % 2 != 0 ) :<br>            return False<br>        n = n // 2<br>    return True<br></td>
    <td>translated code: <br><br> def f_gold ( n ) :<br>    if n == 0 :<br>        return False<br>    while n != 1 :<br>        if n % 2 != 0 :<br>            return False<br>        n = n / 2<br>    return True<br></td>
  </tr></table>
</body>
</html>
