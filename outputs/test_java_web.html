<!DOCTYPE html>
<html>
<head>
<style>
table, td {
  border: 1px solid black;
}

table {
  white-space: pre;
  border-collapse: collapse;
  width: 100%;
}

th {
  height: 50px;
}
</style>
</head>
<body>

<h2>Translating Sentences</h2>
<p>java - left is original, right is translated:</p>
<table>
<tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumChars ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumChars ( String str ) {<br>    int n = str . length ( ) ;<br>    int res = - 1 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( str . charAt ( i ) == str . charAt ( j ) ) && ( str . charAt ( i ) == str . charAt ( j ) ) ) {<br>                int res = Math . max ( res , Math . abs ( j - i - 1 ) ) ;<br>            }<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_MIRROR_IMAGE_POINT_2_D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static pair mirrorImage ( double a , double b , double c , double x1 , double y1 ) {<br>  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ;<br>  double x = temp * a + x1 ;<br>  double y = temp * b + y1 ;<br>  return new pair ( x , y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static Point mirrorImage ( int a , int b , int c , int x1 , int y1 ) {<br>    float temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ;<br>    int x = temp * a + x1 ;<br>    int y = temp * b + y1 ;<br>    mirrorImage ( x , y , a , b , c , x1 , y1 ) ;<br>}</td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 , secondary = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) principal += mat [ i ] [ j ] ;<br>      if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ;<br>    }<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>    int principal = 0 ;<br>    int secondary = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( i == j ) && ( n > 0 ) ){<br>                principal += mat [ i ] [ j ] ;<br>            }<br>            if ( ( ( i + j ) == ( n - 1 ) ) && ( ( i + j ) == ( n - 2 ) ) ){<br>                secondary += mat [ i ] [ j ] ;<br>            }<br>        }<br>    }<br>    System . out . println ( "Principal Diagonal:" + principal ) ;<br>    System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}</td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPaths ( int n , int m ) {<br>  if ( n == 0 || m == 0 ) return 1 ;<br>  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPaths ( int n , int m ) {<br>    if ( ( n == 0 || m == 0 ) && ( n > 0 || m > 0 ) ) {<br>        return 1 ;<br>    }<br>    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean find3Numbers ( int A [ ] , int arr_size , int sum ) {<br>  int l , r ;<br>  quickSort ( A , 0 , arr_size - 1 ) ;<br>  for ( int i = 0 ;<br>  i < arr_size - 2 ;<br>  i ++ ) {<br>    l = i + 1 ;<br>    r = arr_size - 1 ;<br>    while ( l < r ) {<br>      if ( A [ i ] + A [ l ] + A [ r ] == sum ) {<br>        System . out . print ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ;<br>        return true ;<br>      }<br>      else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ;<br>      else r -- ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean find3Numbers ( int [ ] A , int arrSize , int sum ) {<br>    Arrays . sort ( A , 0 , arrSize ) ;<br>    for ( int i = 0 ;  i <= arrSize - 2 ;  i ++ ) {<br>        int l = i + 1 ;<br>        int r = arrSize - 1 ;<br>        while ( ( l = r ) < arrSize ) {<br>            if ( ( A [ i ] + A [ l ] + A [ r ] == sum ) && ( A [ i ] + A [ l ] + A [ r ] == sum ) ) {<br>                System . out . println ( "Triplet is" + A [ i ] + ', ' + A [ l ] + ', ' + A [ r ] ) ;<br>                return find3Numbers ( A , arrSize , sum , 0 ) ;<br>            }<br>            if ( ( A [ i ] + A [ l ] + A [ r ] < sum ) && ( A [ i ] + A [ l ] + A [ r ] < sum ) ) {<br>                l ++ ;<br>            }<br>            if ( sum == 0 ) {<br>                r -- ;<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMagicSquare ( int mat [ ] [ ] ) {<br>  int sum = 0 , sum2 = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) sum = sum + mat [ i ] [ i ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;<br>  if ( sum != sum2 ) return false ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int rowSum = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) rowSum += mat [ i ] [ j ] ;<br>    if ( rowSum != sum ) return false ;<br>  }<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int colSum = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) colSum += mat [ j ] [ i ] ;<br>    if ( sum != colSum ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMagicSquare ( int [ ] [ ] mat ) {<br>    int s = 0 ;<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        s = s + mat [ i ] [ i ] ;<br>    }<br>    int s2 = 0 ;<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        s2 = s2 + mat [ i ] [ N - i - 1 ] ;<br>    }<br>    if ( ( s != s2 ) && ( s != s1 ) ){<br>        return false ;<br>    }<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        int rowSum = 0 ;<br>        for ( int j = 0 ;  j <= N ;  j ++ ) {<br>            rowSum += mat [ i ] [ j ] ;<br>        }<br>        if ( ( rowSum != s ) && ( rowSum != s ) ){<br>            return false ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        int colSum = 0 ;<br>        for ( int j = 0 ;  j <= N ;  j ++ ) {<br>            colSum += mat [ j ] [ i ] ;<br>        }<br>        if ( ( s != colSum ) && ( s != colSum ) ){<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getTotalNumberOfSequences ( int m , int n ) {<br>  int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;<br>      else if ( i < j ) T [ i ] [ j ] = 0 ;<br>      else if ( j == 1 ) T [ i ] [ j ] = i ;<br>      else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ;<br>    }<br>  }<br>  return T [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int getTotalNumberOfSequences ( int m , int n ) {<br>    int [ ] T = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            if ( i == 0 || j == 0 ) {<br>                T [ i ] [ j ] = 0 ;<br>            }<br>            else if ( i < j ){<br>                T [ i ] [ j ] = 0 ;<br>            }<br>            else if ( j == 1 ){<br>                T [ i ] [ j ] = i ;<br>            }<br>            if ( m > n ) {<br>                T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ;<br>            }<br>        }<br>    }<br>    return T [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int difference ( int arr [ ] [ ] , int n ) {<br>  int d1 = 0 , d2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    d1 += arr [ i ] [ i ] ;<br>    d2 += arr [ i ] [ n - i - 1 ] ;<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int difference ( int [ ] [ ] arr , int n ) {<br>    int d1 = 0 ;<br>    int d2 = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        d1 = d1 + arr [ i ] [ i ] ;<br>        d2 = d2 + arr [ i ] [ n - i - 1 ] ;<br>    }<br>    return Math . abs ( d1 - d2 ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int subset ( int ar [ ] , int n ) {<br>  int res = 0 ;<br>  Arrays . sort ( ar ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int count = 1 ;<br>    for ( ;<br>    i < n - 1 ;<br>    i ++ ) {<br>      if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;<br>      else break ;<br>    }<br>    res = Math . max ( res , count ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int subset ( int [ ] ar , int n ) {<br>    int res = 0 ;<br>    Arrays . sort ( ar , 0 , n ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int count = 1 ;<br>        for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>            if ( ar [ i ] == ar [ i + 1 ] ){<br>                count ++ ;<br>            }<br>            if ( n > 0 ) {<br>                break ;<br>            }<br>        }<br>        res = Math . max ( res , count ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String decToBin ( int n ) {<br>  if ( n == 0 ) return "0" ;<br>  String bin = "" ;<br>  while ( n > 0 ) {<br>    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;<br>    n >>= 1 ;<br>  }<br>  return bin ;<br>}<br></td>
    <td>translated code: <br><br> public static String decToBin ( int n ) {<br>    if ( ( n == 0 ) && ( n > 0 ) ) {<br>        return "0" + n ;<br>    }<br>    bin = "" ;<br>    while ( ( n > 0 ) && ( n -- > 0 ) ) {<br>        if ( ( n & 1 == 0 ) ) {<br>            bin = "0" + bin ;<br>        }<br>        else{<br>            bin = "1" + bin ;<br>        }<br>        n = n >>> 1 ;<br>    }<br>    return bin ;<br>}</td>
  </tr><tr>
    <th>FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String Dragon_Curve_Sequence ( int n ) {<br>  String s = "1" ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    String temp = "1" ;<br>    char prev = '1' , zero = '0' , one = '1' ;<br>    for ( int j = 0 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      temp += s . charAt ( j ) ;<br>      if ( prev == '0' ) {<br>        temp += one ;<br>        prev = one ;<br>      }<br>      else {<br>        temp += zero ;<br>        prev = zero ;<br>      }<br>    }<br>    s = temp ;<br>  }<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String Dragon_Curve_Sequence ( int n ) {<br>    String s = "1" ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        String temp = "1" ;<br>        prev = '1' ;<br>        String zero = "0" ;<br>        String one = "1" ;<br>        for ( int j = 0 ;  j < s . length ;  j ++ ) {<br>            temp += s [ j ] ;<br>            if ( ( prev == '0' ) && ( n > 0 ) ){<br>                temp += one ;<br>                long prev = one ;<br>            }<br>            }<br>                temp += zero ;<br>                long prev = zero ;<br>        }<br>        String s = temp ;<br>    }<br>    return s ;<br>}</td>
  </tr><tr>
    <th>STACK_SET_3_REVERSE_STRING_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reverse ( char str [ ] ) {<br>  int n = str . length , i ;<br>  for ( i = 0 ;<br>  i < n / 2 ;<br>  i ++ ) {<br>    swap ( str , i , n - i - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static String reverse ( String string ) {<br>    string = string . substring ( 0 , string . length ( ) - 1 ) ;<br>    return string ;<br>}</td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bitonicGenerator ( int arr [ ] , int n ) {<br>  int i = 1 ;<br>  int j = n - 1 ;<br>  if ( j % 2 != 0 ) j -- ;<br>  while ( i < j ) {<br>    arr = swap ( arr , i , j ) ;<br>    i += 2 ;<br>    j -= 2 ;<br>  }<br>  Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ;<br>  Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ;<br>  int low = ( n + 1 ) / 2 , high = n - 1 ;<br>  while ( low < high ) {<br>    Integer temp = arr [ low ] ;<br>    arr [ low ] = arr [ high ] ;<br>    arr [ high ] = temp ;<br>    low ++ ;<br>    high -- ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] bitonicGenerator ( int [ ] arr , int n ) {<br>    int i = 1 ;<br>    int j = n - 1 ;<br>    if ( ( j % 2 != 0 ) && ( j % 2 == 0 ) ) {<br>        j = j - 1 ;<br>    }<br>    while ( ( i < j ) && ( i < n ) ) {<br>        arr [ j ] = arr [ i ] = arr [ j ] = 0 ;<br>        i = i + 2 ;<br>        j = j - 2 ;<br>    }<br>    int arrF [ ] = new int [ n ] ;<br>    int [ ] arrS = new int [ n ] ;<br>    for ( int i = 0 ;  i < ( int ) ( ( n + 1 ) / 2 ) ;  i ++ ) {<br>        arrF . add ( arr [ i ] ) ;<br>    }<br>    int i = ( int ) ( ( n + 1 ) / 2 ) ;<br>    while ( ( i < n ) && ( i < arr . length ) ) {<br>        arrS . add ( arr [ i ] ) ;<br>        i = i + 1 ;<br>    }<br>    arrF . sort ( ) ;<br>    arrS . sort ( ) ;<br>    for ( int i = 0 ;  i < arr_s . length ;  i ++ ) {<br>        arrF . add ( i -> arr [ i ] ) ;<br>    }<br>    return arrF -> {<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_TWO_NUMBERS_B_FIND_X_X_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void modularEquation ( int a , int b ) {<br>  if ( a < b ) {<br>    System . out . println ( "No solution possible " ) ;<br>    return ;<br>  }<br>  if ( a == b ) {<br>    System . out . println ( "Infinite Solution possible " ) ;<br>    return ;<br>  }<br>  int count = 0 ;<br>  int n = a - b ;<br>  int y = ( int ) Math . sqrt ( a - b ) ;<br>  for ( int i = 1 ;<br>  i <= y ;<br>  ++ i ) {<br>    if ( n % i == 0 ) {<br>      if ( n / i > b ) count ++ ;<br>      if ( i > b ) count ++ ;<br>    }<br>  }<br>  if ( y * y == n && y > b ) count -- ;<br>  System . out . println ( count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void modularEquation ( int a , int b ) {<br>    if ( ( a < b ) && ( a < 5 ) ) {<br>        System . out . println ( "No solution possible " ) ;<br>        }<br>    }<br>    if ( ( a == b ) && ( a == 5 ) ) {<br>        System . out . println ( "Infinite Solution possible " ) ;<br>        }<br>    }<br>    int count = 0 ;<br>    int n = a - b ;<br>    int y = ( int ) ( Math . sqrt ( a - b ) ) ;<br>    for ( int i = 1 ;  i <= y ;{<br>        if ( ( n % i == 0 ) && ( a % i == 0 ) ){<br>            if ( ( n / i > b ) && ( a % i == 0 ) ){<br>                count = count + 1 ;<br>            }<br>            if ( ( i > b ) && ( i < a ) ){<br>                count = count + 1 ;<br>            }<br>        }<br>    }<br>    if ( ( y * y == n && y > b ) || ( y * y == n && y > b ) ){<br>        count = count - 1 ;<br>    }<br>    System . out . println ( count ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_CHARACTERS_GIVEN_STRING_CAN_REARRANGED_FORM_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean canFormPalindrome ( String str ) {<br>  int count [ ] = new int [ NO_OF_CHARS ] ;<br>  Arrays . fill ( count , 0 ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ;<br>  int odd = 0 ;<br>  for ( int i = 0 ;<br>  i < NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( ( count [ i ] & 1 ) == 1 ) odd ++ ;<br>    if ( odd > 1 ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canFormPalindrome ( String st ) {<br>    int [ ] count = {<br>    }<br>    for ( int i = 0 ;  i <= st . length ( ) ;  i ++ ) {<br>        count [ ( int ) st . charAt ( i ++ ) ] = count [ ( int ) st . charAt ( i ++ ) ] + 1 ;<br>    }<br>    odd = 0 ;<br>    for ( int i = 0 ;  i <= NO_OF_CHARS ;  i ++ ) {<br>        if ( ( count [ i ] & 1 ) != 0 ){<br>            odd = odd + 1 ;<br>        }<br>        if ( ( odd > 1 ) && ( odd > 0 ) ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ;<br>}</td>
  </tr><tr>
    <th>FIND_MEDIAN_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binaryMedian ( int m [ ] [ ] , int r , int c ) {<br>  int max = Integer . MIN_VALUE ;<br>  int min = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < r ;<br>  i ++ ) {<br>    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;<br>    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;<br>  }<br>  int desired = ( r * c + 1 ) / 2 ;<br>  while ( min < max ) {<br>    int mid = min + ( max - min ) / 2 ;<br>    int place = 0 ;<br>    int get = 0 ;<br>    for ( int i = 0 ;<br>    i < r ;<br>    ++ i ) {<br>      get = Arrays . binarySearch ( m [ i ] , mid ) ;<br>      if ( get < 0 ) get = Math . abs ( get ) - 1 ;<br>      else {<br>        while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ;<br>      }<br>      place = place + get ;<br>    }<br>    if ( place < desired ) min = mid + 1 ;<br>    else max = mid ;<br>  }<br>  return min ;<br>}<br></td>
    <td>translated code: <br><br> public static void binaryMedian ( int [ ] [ ] m , int r , int d ) {<br>    double mi = m [ 0 ] [ 0 ] ;<br>    int mx = 0 ;<br>    for ( int i = 0 ;  i < r ;  i ++ ) {<br>        if ( m [ i ] [ 0 ] < mi ){<br>            int mi = m [ i ] [ 0 ] ;<br>        }<br>        if ( m [ i ] [ d - 1 ] > mx ){<br>            int mx = m [ i ] [ d - 1 ] ;<br>        }<br>    }<br>    int desired = ( r * d + 1 ) / 2 ;<br>    while ( ( mi < mx ) && ( mi < d ) ){<br>        int mid = mi + ( mx - mi ) / 2 ;<br>        int [ ] place = {<br>        }<br>        for ( int i = 0 ;  i < r ;  i ++ ) {<br>            int j = upperBound ( m [ i ] , mid ) ;<br>            place [ 0 ] = place [ 0 ] + j ;<br>        }<br>        if ( place [ 0 ] < desired ){<br>            int mi = mid + 1 ;<br>        }<br>        else{<br>            mx = mid ;<br>        }<br>    }<br>    System . out . println ( "Median is" + mi ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findHeight ( int [ ] parent , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int p = i , current = 1 ;<br>    while ( parent [ p ] != - 1 ) {<br>      current ++ ;<br>      p = parent [ p ] ;<br>    }<br>    res = Math . max ( res , current ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findHeight ( int [ ] parent , int n ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int p = i ;<br>        int current = 1 ;<br>        while ( ( parent [ p ] != - 1 ) && ( n > 0 ) ) {<br>            current ++ ;<br>            Node p = parent . get ( n ) ;<br>        }<br>        res = Math . max ( res , current ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_20</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static Boolean divisibleBy20 ( String num ) {<br>  int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ;<br>  return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean divisibleBy20 ( String num ) {<br>    lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 ) ) ;<br>    return ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDP ( int n ) {<br>  int res [ ] = new int [ n + 1 ] ;<br>  res [ 0 ] = 0 ;<br>  res [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ;<br>  return res [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDP ( int n ) {<br>    List < Integer > res = Lists . newArrayList ( ) ;<br>    res . add ( 0 ) ;<br>    res . add ( 1 ) ;<br>    int i = 2 ;<br>    while ( i < n + 1 ) {<br>        res . add ( Math . max ( i , ( res . get ( Integer . valueOf ( i / 2 ) ) + res . get ( Integer . valueOf ( i / 3 ) ) + res . get ( Integer . valueOf ( i / 4 ) ) + res . get ( Integer . valueOf ( i / 5 ) ) ) ) ;<br>        i = i + 1 ;<br>    }<br>    return res [ n ] ;<br>}</td>
  </tr><tr>
    <th>QUERIES_ON_ARRAY_WITH_DISAPPEARING_AND_REAPPEARING_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void PerformQueries ( int [ ] a , int [ ] [ ] vec ) {<br>  Vector < Integer > ans = new Vector < > ( ) ;<br>  int n = ( int ) a . length - 1 ;<br>  int q = ( int ) vec . length ;<br>  for ( int i = 0 ;<br>  i < q ;<br>  ++ i ) {<br>    long t = vec [ i ] [ 0 ] ;<br>    int m = vec [ i ] [ 1 ] ;<br>    if ( m > n ) {<br>      ans . add ( - 1 ) ;<br>      continue ;<br>    }<br>    int turn = ( int ) ( t / n ) ;<br>    int rem = ( int ) ( t % n ) ;<br>    if ( rem == 0 && turn % 2 == 1 ) {<br>      ans . add ( - 1 ) ;<br>      continue ;<br>    }<br>    if ( rem == 0 && turn % 2 == 0 ) {<br>      ans . add ( a [ m ] ) ;<br>      continue ;<br>    }<br>    if ( turn % 2 == 0 ) {<br>      int cursize = n - rem ;<br>      if ( cursize < m ) {<br>        ans . add ( - 1 ) ;<br>        continue ;<br>      }<br>      ans . add ( a [ m + rem ] ) ;<br>    }<br>    else {<br>      int cursize = rem ;<br>      if ( cursize < m ) {<br>        ans . add ( - 1 ) ;<br>        continue ;<br>      }<br>      ans . add ( a [ m ] ) ;<br>    }<br>  }<br>  for ( int i : ans ) System . out . print ( i + "\n" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void PerformQueries ( int [ ] [ ] a , int [ ] [ ] vec ) {<br>    int [ ] ans = new int [ vec . length ] ;<br>    int n = a . length - 1 ;<br>    int q = vec . length ;<br>    for ( int i = 0 ;  i < q ;{<br>        int t = vec [ i ] [ 0 ] ;<br>        int m = vec [ i ] [ 1 ] ;<br>        if ( ( m > n ) && ( m < n ) ){<br>            ans . add ( - 1 ) ;<br>            continue ;<br>        }<br>        turn = t / n ;<br>        int rem = t % n ;<br>        if ( ( rem == 0 && turn % 2 == 1 ) || ( rem == 1 && turn % 2 == 0 ) ){<br>            ans . add ( - 1 ) ;<br>            continue ;<br>        }<br>        if ( ( rem == 0 && turn % 2 == 0 ) || ( rem == 1 && turn % 2 == 1 ) ){<br>            ans . add ( a [ m ] ) ;<br>            continue ;<br>        }<br>        if ( ( turn % 2 == 0 ) && ( turn % 3 == 0 ) ){<br>            cursize = n - rem ;<br>            if ( ( cursize < m ) && ( cursize > m ) ){<br>                ans . add ( - 1 ) ;<br>                continue ;<br>            }<br>            ans . add ( a [ m + rem ] ) ;<br>        }<br>        if ( vec == null ) {<br>            cursize = rem ;<br>            if ( ( cursize < m ) && ( cursize > m ) ){<br>                ans . add ( - 1 ) ;<br>                continue ;<br>            }<br>            ans . add ( a [ m ] ) ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < ans . length ;{<br>        System . out . println ( i ++ ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int minDist ( int arr [ ] , int n , int x , int y ) {<br>  int i = 0 ;<br>  int min_dist = Integer . MAX_VALUE ;<br>  int prev = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      prev = i ;<br>      break ;<br>    }<br>  }<br>  for ( ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x || arr [ i ] == y ) {<br>      if ( arr [ prev ] != arr [ i ] && ( i - prev ) < min_dist ) {<br>        min_dist = i - prev ;<br>        prev = i ;<br>      }<br>      else prev = i ;<br>    }<br>  }<br>  return min_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDist ( int [ ] arr , int n , int x , int y ) {<br>    int minDist = Integer . MAX_VALUE ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == x || arr [ i ] == y ) {<br>            prev = i ;<br>            break ;<br>        }<br>    }<br>    while ( i < n ) {<br>        if ( arr [ i ] == x || arr [ i ] == y ) {<br>            if ( arr [ prev ] != arr [ i ] && ( i - prev ) < minDist ){<br>                min_dist = i - prev ;<br>                prev = i ;<br>            }<br>            else {<br>                prev = i ;<br>            }<br>        }<br>        i ++ ;<br>    }<br>    return min_dist ;<br>}</td>
  </tr><tr>
    <th>UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 , j = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " " ) ;<br>    else if ( arr2 [ j ] < arr1 [ i ] ) System . out . print ( arr2 [ j ++ ] + " " ) ;<br>    else {<br>      System . out . print ( arr2 [ j ++ ] + " " ) ;<br>      i ++ ;<br>    }<br>  }<br>  while ( i < m ) System . out . print ( arr1 [ i ++ ] + " " ) ;<br>  while ( j < n ) System . out . print ( arr2 [ j ++ ] + " " ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) {<br>    int i = 0 , j = 0 ;<br>    while ( i < m && j < n ) {<br>        if ( arr1 [ i ] < arr2 [ j ] ){<br>            System . out . println ( arr1 [ i ] ) ;<br>            i ++ ;<br>        }<br>        else if ( arr2 [ j ] < arr1 [ i ] ){<br>            System . out . println ( arr2 [ j ] ) ;<br>            j ++ ;<br>        }<br>        else {<br>            System . out . println ( arr2 [ j ] ) ;<br>            j ++ ;<br>            i ++ ;<br>        }<br>    }<br>    while ( i < m ) {<br>        System . out . println ( arr1 [ i ] ) ;<br>        i ++ ;<br>    }<br>    while ( j < n ) {<br>        System . out . println ( arr2 [ j ] ) ;<br>        j ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solveWordWrap ( int arr [ ] , int n , int k ) {<br>  int i , j ;<br>  int currlen ;<br>  int cost ;<br>  int dp [ ] = new int [ n ] ;<br>  int ans [ ] = new int [ n ] ;<br>  dp [ n - 1 ] = 0 ;<br>  ans [ n - 1 ] = n - 1 ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    currlen = - 1 ;<br>    dp [ i ] = Integer . MAX_VALUE ;<br>    for ( j = i ;<br>    j < n ;<br>    j ++ ) {<br>      currlen += ( arr [ j ] + 1 ) ;<br>      if ( currlen > k ) break ;<br>      if ( j == n - 1 ) cost = 0 ;<br>      else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ;<br>      if ( cost < dp [ i ] ) {<br>        dp [ i ] = cost ;<br>        ans [ i ] = j ;<br>      }<br>    }<br>  }<br>  i = 0 ;<br>  while ( i < n ) {<br>    System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1 ) + " " ) ;<br>    i = ans [ i ] + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void solveWordWrap ( int [ ] arr , int n , int k ) {<br>    int [ ] dp = new int [ n ] ;<br>    int [ ] ans = new int [ n ] ;<br>    dp [ n - 1 ] = 0 ;<br>    ans [ n - 1 ] = n - 1 ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        int currlen = - 1 ;<br>        dp [ i ] = Integer . MAX_VALUE ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            currlen += ( arr [ j ] + 1 ) ;<br>            if ( ( currlen > k ) && ( currlen < n ) ) {<br>                break ;<br>            }<br>            if ( ( j == n - 1 ) && ( k == n - 1 ) ) {<br>                int cost = 0 ;<br>            }<br>            else {<br>                cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) ;<br>            }<br>            if ( ( cost < dp [ i ] ) && ( cost < dp [ k ] ) ) {<br>                dp [ i ] = cost ;<br>                ans [ i ] = j ;<br>            }<br>        }<br>    }<br>    int i = 0 ;<br>    while ( ( i = n ) < k ) {<br>        System . out . print ( i + 1 + ans [ i ] + 1 + " " ) ;<br>        i = ans [ i ] + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_DISTINCT_SUBSEQUENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSub ( String str ) {<br>  int [ ] last = new int [ MAX_CHAR ] ;<br>  Arrays . fill ( last , - 1 ) ;<br>  int n = str . length ( ) ;<br>  int [ ] dp = new int [ n + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = 2 * dp [ i - 1 ] ;<br>    if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) str . charAt ( i - 1 ) ] ] ;<br>    last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSub ( String ss ) {<br>    int last = new int [ MAX_CHAR + 1 ] ;<br>    int n = ss . length ;<br>    int [ ] dp = new int [ n + 1 ] ;<br>    dp [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        dp [ i ] = 2 * dp [ i - 1 ] ;<br>        if ( last [ ( int ) ss . charAt ( i - 1 ) ] != - 1 ){<br>            dp [ i ] = dp [ i ] - dp [ last [ ( char ) ss . charAt ( i - 1 ) ] ] ;<br>        }<br>        last [ ( char ) ss . charAt ( i - 1 ) ] = i - 1 ;<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str , int n ) {<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 2 ;<br>  i ++ ) {<br>    int l = i , r = i + 1 ;<br>    int lsum = 0 , rsum = 0 ;<br>    while ( r < n && l >= 0 ) {<br>      lsum += str . charAt ( l ) - '0' ;<br>      rsum += str . charAt ( r ) - '0' ;<br>      if ( lsum == rsum ) {<br>        ans = Math . max ( ans , r - l + 1 ) ;<br>      }<br>      l -- ;<br>      r ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String st , int n ) {<br>    total = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        total [ i ] = ( total [ i - 1 ] + Integer . parseInt ( st . substring ( i - 1 , n ) ) - Integer . parseInt ( "0" ) ) ;<br>    }<br>    int ans = 0 ;<br>    int l = 2 ;<br>    while ( ( l = st . findLength ( n ) ) <= n ){<br>        for ( int i = 0 ;  i < n - l + 1 ;  i ++ ) {<br>            int j = i + l - 1 ;<br>            if ( ( total [ i + ( int ) ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + ( int ) ( l / 2 ) ] ) ){<br>                ans = Math . max ( ans , l ) ;<br>            }<br>        }<br>        l = l + 2 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxPath ( int mat [ ] [ ] ) {<br>  int res = - 1 ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    res = - 1 ;<br>    for ( int j = 0 ;<br>    j < M ;<br>    j ++ ) {<br>      if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ;<br>      else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ;<br>      else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ;<br>      res = max ( mat [ i ] [ j ] , res ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxPath ( int [ ] [ ] mat ) {<br>    int res = - 1 ;<br>    for ( int i = 0 ;  i < M ;  i ++ ) {<br>        res [ 0 ] = Math . max ( res [ 0 ] , mat [ 0 ] [ i ] ) ;<br>    }<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        int res = - 1 ;<br>        for ( int j = 0 ;  j < M ;  j ++ ) {<br>            if ( ( j > 0 && j < M - 1 ) || ( j > 0 && j < M - 1 ) ){<br>                mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , Math . max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ;<br>            }<br>            else if ( ( j > 0 ) && ( j < mat . length ) ){<br>                mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ;<br>            }<br>            else if ( ( j < M - 1 ) && ( j < M - 2 ) ){<br>                mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ;<br>            }<br>            res [ i ] [ j ] = 0 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char maxRepeating ( String str ) {<br>  int len = str . length ( ) ;<br>  int count = 0 ;<br>  char res = str . charAt ( 0 ) ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) {<br>    int cur_count = 1 ;<br>    for ( int j = i + 1 ;<br>    j < len ;<br>    j ++ ) {<br>      if ( str . charAt ( i ) != str . charAt ( j ) ) break ;<br>      cur_count ++ ;<br>    }<br>    if ( cur_count > count ) {<br>      count = cur_count ;<br>      res = str . charAt ( i ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String maxRepeating ( String str ) {<br>    int l = str . length ( ) ;<br>    int count = 0 ;<br>    String res = str . substring ( 0 , str . length ( ) - 1 ) ;<br>    for ( int i = 0 ;  i < l ;  i ++ ) {<br>        curCount = 1 ;<br>        for ( int j = i + 1 ;  j < l ;  j ++ ) {<br>            if ( ( str . charAt ( i ) != str . charAt ( j ) ) && ( str . charAt ( i ) != str . charAt ( j ) ) ) {<br>                break ;<br>            }<br>            curCount ++ ;<br>        }<br>        if ( curCount > count ){<br>            count = curCount ;<br>            String res = str . substring ( i ) ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHER_0_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int maxLenSub ( int arr [ ] , int n ) {<br>  int mls [ ] = new int [ n ] , max = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) mls [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLenSub ( int [ ] arr , int n ) {<br>    int [ ] mls = new int [ n ] ;<br>    int max = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        mls . add ( 1 ) ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) || ( Math . abs ( arr [ i ] - arr [ j ] ) > 1 && mls [ i ] < mls [ j ] + 1 ) ){<br>                mls [ i ] = mls [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( max < mls [ i ] ) && ( max > mls [ i ] ) ){<br>            int max = mls [ i ] ;<br>        }<br>    }<br>    return max ;<br>}</td>
  </tr><tr>
    <th>BREAKING_NUMBER_FIRST_PART_INTEGRAL_DIVISION_SECOND_POWER_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int calculate ( String N ) {<br>  int len = N . length ( ) ;<br>  int l = ( len ) / 2 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= l ;<br>  i ++ ) {<br>    String s = N . substring ( 0 , i ) ;<br>    int l1 = s . length ( ) ;<br>    String t = N . substring ( i , l1 + i ) ;<br>    if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ;<br>    if ( s . compareTo ( t ) == 0 ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculate ( String N ) {<br>    int length = N . length ( ) ;<br>    int l = ( int ) ( ( length ) / 2 ) ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < l + 1 ;  i ++ ) {<br>        String s = N . substring ( 0 , 0 + i ) ;<br>        int l1 = s . length ;<br>        String t = N . substring ( i , l1 + i ) ;<br>        switch ( N ) {<br>            if ( s [ 0 ] == '0' || t [ 0 ] == '0' ){<br>                continue ;<br>            }<br>        }<br>        }<br>            continue ;<br>        if ( s == t ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_BINARY_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binaryToDecimal ( int n ) {<br>  int num = n ;<br>  int dec_value = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( temp > 0 ) {<br>    int last_digit = temp % 10 ;<br>    temp = temp / 10 ;<br>    dec_value += last_digit * base ;<br>    base = base * 2 ;<br>  }<br>  return dec_value ;<br>}<br></td>
    <td>translated code: <br><br> public static int binaryToDecimal ( int n ) {<br>    num . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) ;<br>    decValue = 0 ;<br>    int base = 1 ;<br>    BigDecimal temp = num ;<br>    while ( ( temp = n ) != - 1 ) {<br>        lastDigit = temp % 10 ;<br>        int temp ;<br>        decValue += lastDigit * base ;<br>        int base = n . bitLength ( ) ;<br>    }<br>    return decValue ;<br>}</td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSum ( int n ) {<br>  int sum = 0 ;<br>  while ( n != 0 ) {<br>    sum = sum + n % 10 ;<br>    n = n / 10 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSum ( int n ) {<br>    int sum = 0 ;<br>    while ( ( n != 0 ) && ( n % 2 == 0 ) ) {<br>        sum = sum + ( int ) ( n % 10 ) ;<br>        n = ( int ) ( n / 10 ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSDSFunc ( int n ) {<br>  int DP [ ] = new int [ n + 1 ] ;<br>  DP [ 0 ] = 0 ;<br>  DP [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;<br>    else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ;<br>  }<br>  return DP [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSDSFunc ( int n ) {<br>    DP = new int [ n + 1 ] ;<br>    DP [ 0 ] = 0 ;<br>    DP [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        if ( ( int ) ( i % 2 ) == 0 ) {<br>            DP [ i ] = DP [ ( int ) ( i / 2 ) ] ;<br>        }<br>        }<br>            DP [ i ] = ( DP [ ( int ) ( ( i - 1 ) / 2 ) ] + DP [ ( int ) ( ( i + 1 ) / 2 ) ] ) ;<br>    }<br>    return DP [ n ] ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SINK_NODES_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) {<br>  int [ ] mark = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) mark [ edgeFrom [ i ] ] = 1 ;<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) if ( mark [ i ] == 0 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSink ( int n , int m , int [ ] edgeFrom , int [ ] edgeTo ) {<br>    int [ ] mark = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        mark [ edgeFrom [ i ] ] = 1 ;<br>    }<br>    int count = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( ( ! mark [ i ] ) && ( ! mark [ i ] ) ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>BREAK_NUMBER_THREE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long count_of_ways ( long n ) {<br>  long count = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) for ( int k = 0 ;<br>  k <= n ;<br>  k ++ ) if ( i + j + k == n ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfWays ( int n ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            for ( int k = 0 ;  k <= n ;  k ++ ) {<br>                if ( ( i + j + k == n ) && ( i + j + k == n ) ) {<br>                    count = count + 1 ;<br>                }<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistinct ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) if ( arr [ i ] == arr [ j ] ) break ;<br>    if ( i == j ) System . out . print ( arr [ i ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printDistinct ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int d = 0 ;<br>        for ( int j = 0 ;  j <= i ;  j ++ ) {<br>            if ( ( arr [ i ] == arr [ j ] ) && ( arr [ i ] == arr [ j ] ) ) {<br>                int d = 1 ;<br>                break ;<br>            }<br>        }<br>        if ( ( d == 0 ) && ( n > 0 ) ) {<br>            System . out . println ( arr [ i ] ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSegments ( int n , int a , int b , int c ) {<br>  int dp [ ] = new int [ n + 10 ] ;<br>  Arrays . fill ( dp , - 1 ) ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( dp [ i ] != - 1 ) {<br>      if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ;<br>      if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ;<br>      if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ;<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSegments ( int n , int a , int b , int c ) {<br>    int [ ] dp = new int [ n + 10 ] ;<br>    dp [ 0 ] = 0 ;<br>    for ( int i = 0 ;  i <= n ;{<br>        if ( ( dp [ i ] != - 1 ) && ( dp [ i ] > a ) ){<br>            if ( ( i + a ) <= n ){<br>                dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ;<br>            }<br>            if ( ( i + b <= n ) && ( i + a <= n ) ){<br>                dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ;<br>            }<br>            if ( ( i + c ) <= n ){<br>                dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>CHECK_VALID_SEQUENCE_DIVISIBLE_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( int n , int index , int sum , int M , int arr [ ] , int dp [ ] [ ] ) {<br>  if ( index == n ) {<br>    if ( ( sum % M ) == 0 ) return true ;<br>    return false ;<br>  }<br>  else if ( sum < 0 || sum >= MAX ) return false ;<br>  if ( dp [ index ] [ sum ] != - 1 ) {<br>    if ( dp [ index ] [ sum ] == 0 ) return false ;<br>    return true ;<br>  }<br>  boolean placeAdd = isPossible ( n , index + 1 , sum + arr [ index ] , M , arr , dp ) ;<br>  boolean placeMinus = isPossible ( n , index + 1 , sum - arr [ index ] , M , arr , dp ) ;<br>  boolean res = ( placeAdd || placeMinus ) ;<br>  dp [ index ] [ sum ] = ( res ) ? 1 : 0 ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( int n , int index , int Sum , int M , int [ ] arr , int [ ] [ ] dp ) {<br>    MAX = 0 ;<br>    if ( index == n ) {<br>        if ( ( Sum % M ) == 0 ) {<br>            return isPossible ( n , index , Sum , M , arr , dp , null ) ;<br>        }<br>        return false ;<br>    }<br>    if ( dp [ index ] [ Sum ] != - 1 ) {<br>        return dp [ index ] [ Sum ] ;<br>    }<br>    boolean placeAdd = isPossible ( n , index + 1 , Sum + arr [ index ] , M , arr , dp ) ;<br>    int placeMinus = isPossible ( n , index + 1 , Sum - arr [ index ] , M , arr , dp ) ;<br>    boolean res = placeAdd || placeMinus ;<br>    dp [ index ] [ Sum ] = res ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findGreatest ( int [ ] arr , int n ) {<br>  int result = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n - 1 ;<br>  j ++ ) for ( int k = j + 1 ;<br>  k < n ;<br>  k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int findGreatest ( int [ ] arr , int n ) {<br>    int result = - 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n - 1 ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                if ( ( arr [ j ] * arr [ k ] == arr [ i ] ) && ( arr [ j ] * arr [ k ] == arr [ i ] ) ) {<br>                    result = Math . max ( result , arr [ i ] ) ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {<br>  int max_so_far = 0 ;<br>  int INT_MIN , max_ending_here = 0 ;<br>  for ( int i = 0 ;<br>  i < n * k ;<br>  i ++ ) {<br>    max_ending_here = max_ending_here + a [ i % n ] ;<br>    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;<br>    if ( max_ending_here < 0 ) max_ending_here = 0 ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySumRepeated ( int [ ] a , int n , int k ) {<br>    int maxSoFar = - 2147483648 ;<br>    int maxEndingHere = 0 ;<br>    for ( int i = 0 ;<br>        maxEndingHere = maxEndingHere + a [ i % n ] ;<br>        if ( ( maxSo_far < maxEndingHere ) && ( a < 5 ) ) {<br>            maxSoFar = maxEndingHere ;<br>        }<br>        if ( ( maxEndingHere < 0 ) && ( a < 5 ) ) {<br>            int maxEndingHere = 0 ;<br>        }<br>    return maxSoFar ;<br>}</td>
  </tr><tr>
    <th>LEONARDO_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int leonardo ( int n ) {<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int leonardo ( int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    dp . add ( 1 ) ;<br>    dp . add ( 1 ) ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        dp . add ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ;<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int sumOfSubstrings ( String num ) {<br>  int n = num . length ( ) ;<br>  int sumofdigit [ ] = new int [ n ] ;<br>  sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ;<br>  int res = sumofdigit [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int numi = num . charAt ( i ) - '0' ;<br>    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ;<br>    res += sumofdigit [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumOfSubstrings ( String num ) {<br>    int n = num . length ( ) ;<br>    String [ ] sumofdigit = new String [ num . length ( ) ] ;<br>    sumofdigit . add ( Integer . parseInt ( num . substring ( 0 , 1 ) ) ) ;<br>    int res = sumofdigit [ 0 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        int numi = Integer . parseInt ( num . substring ( i ) ) ;<br>        sumofdigit . add ( ( i + 1 ) * numi + 10 * sumofdigit . get ( i - 1 ) ) ;<br>        res += sumofdigit [ i ] ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PRUFER_CODE_TREE_CREATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printTreeEdges ( int prufer [ ] , int m ) {<br>  int vertices = m + 2 ;<br>  int vertex_set [ ] = new int [ vertices ] ;<br>  for ( int i = 0 ;<br>  i < vertices ;<br>  i ++ ) vertex_set [ i ] = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;<br>  System . out . print ( "\nThe edge set E(G) is :\n" ) ;<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices - 2 ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < vertices ;<br>    j ++ ) {<br>      if ( vertex_set [ j ] == 0 ) {<br>        vertex_set [ j ] = - 1 ;<br>        System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ;<br>        vertex_set [ prufer [ i ] - 1 ] -- ;<br>        break ;<br>      }<br>    }<br>  }<br>  j = 0 ;<br>  for ( int i = 0 ;<br>  i < vertices ;<br>  i ++ ) {<br>    if ( vertex_set [ i ] == 0 && j == 0 ) {<br>      System . out . print ( "(" + ( i + 1 ) + ", " ) ;<br>      j ++ ;<br>    }<br>    else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + ")\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printTreeEdges ( int [ ] prufer , int m ) {<br>    int vertices = m + 2 ;<br>    vertexSet = new int [ vertices ] ;<br>    for ( int i = 0 ;  i < vertices - 2 ;  i ++ ) {<br>        vertexSet [ prufer [ i ] - 1 ] ++ ;<br>    }<br>    System . out . println ( "The edge set E(G)is:" ) ;<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < vertices - 2 ;  i ++ ) {<br>        for ( int j = 0 ;  j < vertices ;  j ++ ) {<br>            if ( ( vertexSet [ j ] == 0 ) && ( m == 0 ) ){<br>                vertexSet [ j ] = - 1 ;<br>                System . out . print ( "(" + ( j + 1 ) + ", " + prufer [ i ] + ") " ) ;<br>                vertexSet [ prufer [ i ] - 1 ] -- ;<br>                break ;<br>            }<br>        }<br>    }<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < vertices ;  i ++ ) {<br>        if ( ( vertexSet [ i ] == 0 && j == 0 ) || ( vertexSet [ i ] == 1 && j == 1 ) ){<br>            System . out . println ( "(" + ( i + 1 ) + ", " + sep + m ) ;<br>            j ++ ;<br>        }<br>        else if ( ( vertexSet [ i ] == 0 && j == 1 ) || ( vertexSet [ i ] == 1 && j == 2 ) ){<br>            System . out . print ( ( i + 1 ) + ")" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findMinimumAngle ( int arr [ ] , int n ) {<br>  int l = 0 , sum = 0 , ans = 360 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    while ( sum >= 180 ) {<br>      ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ;<br>      sum -= arr [ l ] ;<br>      l ++ ;<br>    }<br>    ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinimumAngle ( int [ ] arr , int n ) {<br>    int l = 0 ;<br>    _sum = 0 ;<br>    int ans = 360 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        _sum += arr [ i ] ;<br>        while ( mSum >= 180 ) {<br>            ans = Math . min ( ans , 2 * Math . abs ( 180 - mSum ) ) ;<br>            _sum -= arr [ l ] ;<br>            l ++ ;<br>        }<br>        ans = Math . min ( ans , 2 * Math . abs ( 180 - mSum ) ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>  if ( k > n ) return - 1 ;<br>  int [ ] csum = new int [ n ] ;<br>  csum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;<br>  int max_sum = csum [ k - 1 ] , max_end = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_sum = csum [ i ] - csum [ i - k ] ;<br>    if ( curr_sum > max_sum ) {<br>      max_sum = curr_sum ;<br>      max_end = i ;<br>    }<br>  }<br>  return max_end - k + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>    if ( k > n ) {<br>        return - 1 ;<br>    }<br>    int [ ] csum = new int [ n ] ;<br>    csum [ 0 ] = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        csum [ i ] = csum [ i - 1 ] + arr [ i ] ;<br>    }<br>    int maxSum = csum [ k - 1 ] ;<br>    int maxEnd = k - 1 ;<br>    for ( int i = k ;  i < n ;  i ++ ) {<br>        int currSum = csum [ i ] - csum [ i - k ] ;<br>        if ( currSum > maxSum ) {<br>            maxSum = currSum ;<br>            int maxEnd = i ;<br>        }<br>    }<br>    return maxEnd - k + 1 ;<br>}</td>
  </tr><tr>
    <th>SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findS ( int s ) {<br>  int sum = 0 ;<br>  for ( int n = 1 ;<br>  sum < s ;<br>  n ++ ) {<br>    sum += n * n ;<br>    if ( sum == s ) return n ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findS ( int s ) {<br>    _sum = 0 ;<br>    int n = 1 ;<br>    while ( ( _sum < s ) && ( _sum < s ) ) {<br>        _sum += n * n ;<br>        n ++ ;<br>    }<br>    n -- ;<br>    if ( _sum == s ) {<br>        return n ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_CALCULATE_AREA_OF_AN_CIRCLE_INSCRIBED_IN_A_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double areaOfInscribedCircle ( float a ) {<br>  return ( PI / 4 ) * a * a ;<br>}<br></td>
    <td>translated code: <br><br> public static double areaOfInscribedCircle ( double a ) {<br>    return ( PI / 4 ) * a * a ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_CHARACTERS_REMOVED_MAKE_BINARY_STRING_ALTERNATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countToMake0lternate ( String s ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < ( s . length ( ) - 1 ) ;<br>  i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countToMake0lternate ( String s ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < s . length ( ) - 1 ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == s . charAt ( i + 1 ) ) && ( s . charAt ( i + 2 ) == s . charAt ( i + 3 ) ) ) {<br>            result ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMissing ( int a [ ] , int b [ ] , int n , int m ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < m ;<br>    j ++ ) if ( a [ i ] == b [ j ] ) break ;<br>    if ( j == m ) System . out . print ( a [ i ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findMissing ( int [ ] a , int [ ] b , int n , int m ) {<br>    for ( int i = 0 ;  i < n ;{<br>        for ( int j = 0 ;  j < m ;{<br>            if ( ( a [ i ] == b [ j ] ) && ( a [ i ] == b [ j ] ) ) {<br>                break ;<br>            }<br>        }<br>        if ( ( j == m - 1 ) && ( a == b ) ){<br>            System . out . print ( a [ i ] + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int [ ] arr , int n ) {<br>  int temp [ ] = new int [ n ] ;<br>  int small = 0 , large = n - 1 ;<br>  boolean flag = true ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( flag ) temp [ i ] = arr [ large -- ] ;<br>    else temp [ i ] = arr [ small ++ ] ;<br>    flag = ! flag ;<br>  }<br>  arr = temp . clone ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] rearrange ( int [ ] arr , int n ) {<br>    Object temp = n * new Object [ n ] ;<br>    int small = 0 , large = n - 1 ;<br>    flag = true ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( flag == true ) {<br>            temp [ i ] = arr [ large ] ;<br>            large -- ;<br>        }<br>        else {<br>            temp [ i ] = arr [ small ] ;<br>            small ++ ;<br>        }<br>        boolean flag = ( boolean ) ( 1 - flag ) ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = temp [ i ] ;<br>    }<br>    return rearrange ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lbs ( int arr [ ] , int n ) {<br>  int i , j ;<br>  int [ ] lis = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) for ( j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  int [ ] lds = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lds [ i ] = 1 ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) for ( j = n - 1 ;<br>  j > i ;<br>  j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ;<br>  int max = lis [ 0 ] + lds [ 0 ] - 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int lbs ( int [ ] arr ) {<br>    int n = arr . length ;<br>    lis = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= i ;  j ++ ) {<br>            if ( ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) || ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) ){<br>                lis [ i ] = lis [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    int [ ] lds = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        for ( int j = reversed ( i - 1 ) ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) || ( arr [ i ] > arr [ j ] && lds [ i ] > lds [ j ] + 1 ) ){<br>                lds [ i ] = lds [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    int maximum = lis . length + lds . length - 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        maximum = Math . max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) ;<br>    }<br>    return maximum ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      for ( int k = 0 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( arr [ k ] == product ) {<br>          result ++ ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int product = arr [ i ] * arr [ j ] ;<br>            for ( int k = 0 ;  k <= n ;  k ++ ) {<br>                if ( ( arr [ k ] == product ) && ( n == 1 ) ) {<br>                    result = result + 1 ;<br>                    break ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_SINGLE_NODE_ISOLATED_SUB_GRAPHS_DISCONNECTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute ( int [ ] graph , int N ) {<br>  int count = 0 ;<br>  for ( int i = 1 ;<br>  i < 7 ;<br>  i ++ ) {<br>    if ( graph [ i ] == 0 ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int compute ( int [ ] [ ] graph , int N ) {<br>    int count = 0 ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        if ( ( graph [ i ] . length == 0 ) && ( graph [ i ] [ N ] . length == 0 ) ) {<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>HARDY_RAMANUJAN_THEOREM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int exactPrimeFactorCount ( int n ) {<br>  int count = 0 ;<br>  if ( n % 2 == 0 ) {<br>    count ++ ;<br>    while ( n % 2 == 0 ) n = n / 2 ;<br>  }<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i = i + 2 ) {<br>    if ( n % i == 0 ) {<br>      count ++ ;<br>      while ( n % i == 0 ) n = n / i ;<br>    }<br>  }<br>  if ( n > 2 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int exactPrimeFactorCount ( int n ) {<br>    int count = 0 ;<br>    if ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) {<br>        count = count + 1 ;<br>        while ( ( n % 2 == 0 ) && ( n % 3 == 0 ) ) {<br>            n = ( int ) ( n / 2 ) ;<br>        }<br>    }<br>    int i = 3 ;<br>    while ( ( i <= ( int ) Math . sqrt ( n ) ) && ( i % 2 == 0 ) ) {<br>        if ( ( n % i == 0 ) && ( n % i == 0 ) ) {<br>            count = count + 1 ;<br>            while ( ( n % i == 0 ) && ( n % i == 0 ) ) {<br>                n = ( int ) ( n / i ) ;<br>            }<br>        }<br>        i = i + 2 ;<br>    }<br>    if ( ( n > 2 ) && ( n > 3 ) ) {<br>        count = count + 1 ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int superSeq ( String X , String Y , int m , int n ) {<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int superSeq ( int [ ] X , int [ ] Y , int m , int n ) {<br>    int [ ] [ ] dp = new int [ m + 2 ] [ n + 2 ] ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            if ( ( ! i ) && ( ! i ) ) {<br>                dp [ i ] [ j ] = j ;<br>            }<br>            }<br>                dp [ i ] [ j ] = i ;<br>            else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && ( X [ i ] == Y [ j ] ) ) {<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>            }<br>            else {<br>                dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>POWER_SET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printPowerSet ( char [ ] set , int set_size ) {<br>  long pow_set_size = ( long ) Math . pow ( 2 , set_size ) ;<br>  int counter , j ;<br>  for ( counter = 0 ;<br>  counter < pow_set_size ;<br>  counter ++ ) {<br>    for ( j = 0 ;<br>    j < set_size ;<br>    j ++ ) {<br>      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( set [ j ] ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printPowerSet ( int [ ] set , int setSize ) {<br>    int pow_set_size = ( int ) ( Math . pow ( 2 , setSize ) ) ;<br>    counter = 0 ;<br>    int j = 0 ;<br>    for ( int counter = 0 ;  counter <= pow_set_size ;  counter ++ ) {<br>        for ( int j = 0 ;  j <= setSize ;  j ++ ) {<br>            if ( ( ( counter & ( 1 << j ) ) > 0 ) && ( ( counter & ( 1 << j ) ) > 0 ) ){<br>                System . out . print ( set . get ( j ) + " " ) ;<br>            }<br>        }<br>        System . out . println ( "" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_ARRAY_MAJORITY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMajority ( int a [ ] , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ;<br>  else mp . put ( a [ i ] , 1 ) ;<br>  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) if ( x . getValue ( ) >= n / 2 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMajority ( int [ ] a ) {<br>    Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i < a ;  i ++ ) {<br>        if ( i == mp ){<br>            mp [ i ] ++ ;<br>        }<br>        else {<br>            mp [ i ++ ] = 1 ;<br>        }<br>    }<br>    for ( int x : mp ){<br>        if ( mp [ x ] >= a . length / 2 ){<br>            return true ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>PRINT_GIVEN_MATRIX_COUNTER_CLOCK_WISE_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void counterClockspiralPrint ( int m , int n , int arr [ ] [ ] ) {<br>  int i , k = 0 , l = 0 ;<br>  int cnt = 0 ;<br>  int total = m * n ;<br>  while ( k < m && l < n ) {<br>    if ( cnt == total ) break ;<br>    for ( i = k ;<br>    i < m ;<br>    ++ i ) {<br>      System . out . print ( arr [ i ] [ l ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    l ++ ;<br>    if ( cnt == total ) break ;<br>    for ( i = l ;<br>    i < n ;<br>    ++ i ) {<br>      System . out . print ( arr [ m - 1 ] [ i ] + " " ) ;<br>      cnt ++ ;<br>    }<br>    m -- ;<br>    if ( cnt == total ) break ;<br>    if ( k < m ) {<br>      for ( i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        System . out . print ( arr [ i ] [ n - 1 ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      n -- ;<br>    }<br>    if ( cnt == total ) break ;<br>    if ( l < n ) {<br>      for ( i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        System . out . print ( arr [ k ] [ i ] + " " ) ;<br>        cnt ++ ;<br>      }<br>      k ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void counterClockspiralPrint ( int m , int n , int [ ] [ ] arr ) {<br>    int k = 0 ;<br>    int cnt = 0 ;<br>    int total = m * n ;<br>    while ( ( k < m && l < n ) || ( k < m && l < n ) ) {<br>        if ( ( cnt == total ) && ( arr != null ) ){<br>            break ;<br>        }<br>        for ( int i = k ;  i < m ;  i ++ ) {<br>            System . out . print ( arr [ i ] [ l ] + " " ) ;<br>            cnt ++ ;<br>        }<br>        l ++ ;<br>        if ( ( cnt == total ) && ( arr != null ) ){<br>            break ;<br>        }<br>        for ( int i = l ;  i < n ;  i ++ ) {<br>            System . out . print ( arr [ m - 1 ] [ i ] + " " ) ;<br>            cnt ++ ;<br>        }<br>        m -- ;<br>        if ( ( cnt == total ) && ( arr != null ) ){<br>            break ;<br>        }<br>        if ( ( k < m ) && ( k < n ) ) {<br>            for ( int i = m - 1 ;  i >= k - 1 ;  i -- ) {<br>                System . out . print ( arr [ i ] [ n - 1 ] + " " ) ;<br>                cnt ++ ;<br>            }<br>            n -- ;<br>        }<br>        if ( ( cnt == total ) && ( arr != null ) ){<br>            break ;<br>        }<br>        if ( ( l < n ) && ( l < m ) ) {<br>            for ( int i = n - 1 ;  i >= l - 1 ;  i -- ) {<br>                System . out . print ( arr [ k ] [ i ] + " " ) ;<br>                cnt ++ ;<br>            }<br>            k ++ ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( n % i == 0 ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n ) {<br>    if ( n <= 1 ) {<br>        return false ;<br>    }<br>    for ( int i = 2 ;  i < n ;  i ++ ) {<br>        if ( n % i == 0 ){<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>FIND_CHARACTER_FIRST_STRING_PRESENT_MINIMUM_INDEX_SECOND_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMinIndexChar ( String str , String patt ) {<br>  int minIndex = Integer . MAX_VALUE ;<br>  int m = str . length ( ) ;<br>  int n = patt . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( patt . charAt ( i ) == str . charAt ( j ) && j < minIndex ) {<br>        minIndex = j ;<br>        break ;<br>      }<br>    }<br>  }<br>  if ( minIndex != Integer . MAX_VALUE ) System . out . println ( "Minimum Index Character = " + str . charAt ( minIndex ) ) ;<br>  else System . out . println ( "No character present" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printMinIndexChar ( String Str , String patt ) {<br>    int minIndex = 10 * 9 ;<br>    int m = Str . indexOf ( '.' ) ;<br>    int n = patt . length ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) || ( patt . charAt ( i ) == Str . charAt ( j ) && j < minIndex ) ) {<br>                minIndex = j ;<br>                break ;<br>            }<br>        }<br>    }<br>    if ( ( minIndex != 10 * 9 ) && ( minIndex != 10 * 9 ) ) {<br>        System . out . println ( "Minimum Index Character = " + Str . charAt ( minIndex ) ) ;<br>    }<br>    else {<br>        System . out . println ( "No character present" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < M ;<br>  j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void transpose ( double [ ] [ ] A , double [ ] [ ] B ) {<br>    for ( int i = 0 ;  i < N ;{<br>        for ( int j = 0 ;  j < M ;{<br>            B [ i ] [ j ] = A [ j ] [ i ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNumber ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 1 ;<br>  i <= 9 ;<br>  i ++ ) {<br>    Stack < Integer > s = new Stack < > ( ) ;<br>    if ( i <= n ) {<br>      s . push ( i ) ;<br>      result ++ ;<br>    }<br>    while ( ! s . empty ( ) ) {<br>      int tp = s . peek ( ) ;<br>      s . pop ( ) ;<br>      for ( int j = tp % 10 ;<br>      j <= 9 ;<br>      j ++ ) {<br>        int x = tp * 10 + j ;<br>        if ( x <= n ) {<br>          s . push ( x ) ;<br>          result ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNumber ( int n ) {<br>    int result = 0 ;<br>    for ( int i = 1 ;  i <= 10 ;  i ++ ) {<br>        StringBuilder sb = new StringBuilder ( ) ;<br>        if ( ( i <= n ) && ( i <= n ) ){<br>            s . add ( i ++ ) ;<br>            result ++ ;<br>        }<br>        while ( s . length ( ) != 0 ) {<br>            int tp = s . get ( s . length - 1 ) ;<br>            s . remove ( ) ;<br>            for ( int j = tp % 10 ;  j < 10 ;  j ++ ) {<br>                int x = tp * 10 + j ;<br>                if ( ( x <= n ) && ( x <= n ) ) {<br>                    s . add ( x ) ;<br>                    result ++ ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstFactorialDivisibleNumber ( int x ) {<br>  int i = 1 ;<br>  int fact = 1 ;<br>  for ( i = 1 ;<br>  i < x ;<br>  i ++ ) {<br>    fact = fact * i ;<br>    if ( fact % x == 0 ) break ;<br>  }<br>  return i ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstFactorialDivisibleNumber ( int x ) {<br>    int i = 1 ;<br>    int fact = 1 ;<br>    for ( int i = 1 ;  i <= x ;  i ++ ) {<br>        fact = fact * i ;<br>        if ( ( fact % x == 0 ) && ( fact % x == 0 ) ) {<br>            break ;<br>        }<br>    }<br>    return i ++ ;<br>}</td>
  </tr><tr>
    <th>PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printEqualSumSets ( int [ ] arr , int n ) {<br>  int i , currSum , sum = 0 ;<br>  for ( i = 0 ;<br>  i < arr . length ;<br>  i ++ ) sum += arr [ i ] ;<br>  if ( ( sum & 1 ) == 1 ) {<br>    System . out . print ( "-1" ) ;<br>    return ;<br>  }<br>  int k = sum >> 1 ;<br>  boolean [ ] [ ] dp = new boolean [ n + 1 ] [ k + 1 ] ;<br>  for ( i = 1 ;<br>  i <= k ;<br>  i ++ ) dp [ 0 ] [ i ] = false ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = true ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( currSum = 1 ;<br>    currSum <= k ;<br>    currSum ++ ) {<br>      dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;<br>      if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ;<br>    }<br>  }<br>  List < Integer > set1 = new ArrayList < Integer > ( ) ;<br>  List < Integer > set2 = new ArrayList < Integer > ( ) ;<br>  if ( ! dp [ n ] [ k ] ) {<br>    System . out . print ( "-1\n" ) ;<br>    return ;<br>  }<br>  i = n ;<br>  currSum = k ;<br>  while ( i > 0 && currSum >= 0 ) {<br>    if ( dp [ i - 1 ] [ currSum ] ) {<br>      i -- ;<br>      set2 . add ( arr [ i ] ) ;<br>    }<br>    else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) {<br>      i -- ;<br>      currSum -= arr [ i ] ;<br>      set1 . add ( arr [ i ] ) ;<br>    }<br>  }<br>  System . out . print ( "Set 1 elements: " ) ;<br>  for ( i = 0 ;<br>  i < set1 . size ( ) ;<br>  i ++ ) System . out . print ( set1 . get ( i ) + " " ) ;<br>  System . out . print ( "\nSet 2 elements: " ) ;<br>  for ( i = 0 ;<br>  i < set2 . size ( ) ;<br>  i ++ ) System . out . print ( set2 . get ( i ) + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printEqualSumSets ( int [ ] arr , int n ) {<br>    int sumArray = Arrays . stream ( arr ) . mapToInt ( Integer :: intValue ) . sum ( ) ;<br>    if ( ( sumArray & 1 ) != 0 ) {<br>        System . out . println ( "-1" ) ;<br>        return ;<br>    }<br>    int k = sumArray >>> 1 ;<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= k ;  i ++ ) {<br>        dp [ 0 ] [ i ] = false ;<br>    }<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        dp [ i ] [ 0 ] = true ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int currSum = 1 ;  currSum <= k ;  currSum ++ ) {<br>            dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;<br>            if ( ( arr [ i - 1 ] <= currSum ) && ( arr [ i ] > currSum ) ) {<br>                dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] != null ? dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] : null ) ;<br>            }<br>        }<br>    }<br>    int [ ] set1 = new int [ n ] , set2 = new int [ n ] ;<br>    if ( ( ! dp [ n ] [ k ] ) && ( ! dp [ n ] [ k ] ) ) {<br>        System . out . println ( "-1" ) ;<br>        return ;<br>    }<br>    int i = n ;<br>    currSum = k ;<br>    while ( ( i > 0 && currSum >= 0 ) || ( i < n ) ) {<br>        if ( ( dp [ i - 1 ] [ currSum ] ) != 0 ) {<br>            i -- ;<br>            set2 . add ( arr [ i ] ) ;<br>        }<br>        if ( ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) != 0 ) {<br>            i -- ;<br>            currSum -= arr [ i ] ;<br>            set1 . add ( arr [ i ] ) ;<br>        }<br>    }<br>    System . out . print ( "Set 1 elements:" + n + " " ) ;<br>    for ( int i = 0 ;  i < set1 . length ;  i ++ ) {<br>        System . out . print ( set1 [ i ] + " " ) ;<br>    }<br>    System . out . print ( " \ " nSet SPACETOKEN 2 SPACETOKEN elements : " + n + " \ " " ) ;<br>    for ( int i = 0 ;  i < set2 . length ;  i ++ ) {<br>        System . out . print ( set2 [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfWays ( int x ) {<br>  int dp [ ] = new int [ x + 1 ] ;<br>  dp [ 0 ] = dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= x ;<br>  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>  return dp [ x ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfWays ( int x ) {<br>    if ( x == 0 || x == 1 ) {<br>        return 1 ;<br>    }<br>    }<br>        return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNegative ( int M [ ] [ ] , int n , int m ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( M [ i ] [ j ] < 0 ) count += 1 ;<br>      else break ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNegative ( int [ ] [ ] M , int n , int m ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( M [ i ] [ j ] < 0 ) {<br>                count ++ ;<br>            }<br>            else {<br>                break ;<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSetBits ( int n ) {<br>  int count = 0 ;<br>  while ( n > 0 ) {<br>    count += n & 1 ;<br>    n >>= 1 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> static int countSetBits ( long n ) {<br>    count = 0 ;<br>    while ( ( n -- ) > 0 ) {<br>        count += n & 1 ;<br>        n >>= 1 ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>MODULUS_TWO_FLOAT_DOUBLE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double findMod ( double a , double b ) {<br>  if ( a < 0 ) a = - a ;<br>  if ( b < 0 ) b = - b ;<br>  double mod = a ;<br>  while ( mod >= b ) mod = mod - b ;<br>  if ( a < 0 ) return - mod ;<br>  return mod ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMod ( int a , int b ) {<br>    if ( ( a < 0 ) && ( b < 0 ) ) {<br>        a = - a ;<br>    }<br>    if ( ( b < 0 ) && ( a % b == 0 ) ) {<br>        b = - b ;<br>    }<br>    int mod = a ;<br>    while ( ( mod >= b ) && ( mod < a ) ) {<br>        mod = mod - b ;<br>    }<br>    if ( ( a < 0 ) && ( b < 0 ) ) {<br>        return - mod ;<br>    }<br>    return mod ;<br>}</td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int N , int mat [ ] [ ] ) {<br>  int maxValue = Integer . MIN_VALUE ;<br>  int maxArr [ ] [ ] = new int [ N ] [ N ] ;<br>  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;<br>  int maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  for ( int j = N - 2 ;<br>  j >= 0 ;<br>  j -- ) {<br>    if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ;<br>    maxArr [ N - 1 ] [ j ] = maxv ;<br>  }<br>  maxv = mat [ N - 1 ] [ N - 1 ] ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ;<br>    maxArr [ i ] [ N - 1 ] = maxv ;<br>  }<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = N - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ;<br>      maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ;<br>    }<br>  }<br>  return maxValue ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] [ ] mat ) {<br>    double maxValue = - Double . MAX_VALUE - 1 ;<br>    int [ ] [ ] maxArr = new int [ N ] [ N ] ;<br>    maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;<br>    int maxv = mat [ N - 1 ] [ N - 1 ] ;<br>    for ( int j = N - 2 ;  j >= 0 ;  j -- ) {<br>        if ( ( mat [ N - 1 ] [ j ] > maxv ) && ( mat [ N - 1 ] [ j ] < maxv ) ){<br>            int maxv = mat [ N - 1 ] [ j ] ;<br>        }<br>        maxArr [ N - 1 ] [ j ] = maxv ;<br>    }<br>    int maxv = mat [ N - 1 ] [ N - 1 ] ;<br>    for ( int i = N - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( mat [ i ] [ N - 1 ] > maxv ) && ( mat [ i ] [ N - 1 ] > maxv ) ){<br>            int maxv = mat [ i ] [ N - 1 ] ;<br>        }<br>        maxArr [ i ] [ N - 1 ] = maxv ;<br>    }<br>    for ( int i = N - 2 ;  i >= 0 ;  i -- ) {<br>        for ( int j = N - 2 ;  j >= 0 ;  j -- ) {<br>            if ( ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) > maxValue ) {<br>                int maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) ;<br>            }<br>            maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ;<br>        }<br>    }<br>    return maxValue ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int a = 0 , b = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ;<br>    else b = b * 10 + arr [ i ] ;<br>  }<br>  return a + b ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] arr , int n ) {<br>    sort ( arr , 0 , n ) ;<br>    int a = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( i % 2 != 0 ) && ( i % 2 == 0 ) ){<br>            a = a * 10 + arr [ i ] ;<br>        }<br>        else{<br>            b = b * 10 + arr [ i ] ;<br>        }<br>    }<br>    return a + b ;<br>}</td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSolutions ( int n ) {<br>  int x = 0 , yCount , res = 0 ;<br>  for ( yCount = 0 ;<br>  yCount * yCount < n ;<br>  yCount ++ ) ;<br>  while ( yCount != 0 ) {<br>    res += yCount ;<br>    x ++ ;<br>    while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSolutions ( int n ) {<br>    int x = 0 ;<br>    int res = 0 ;<br>    yCount = 0 ;<br>    while ( ( yCount * yCount ) < n ) {<br>        yCount = yCount + 1 ;<br>    }<br>    while ( ( yCount != 0 ) && ( yCount < n ) ) {<br>        res = res + yCount ;<br>        x = x + 1 ;<br>        while ( ( yCount != 0 ) && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) {<br>            yCount = yCount - 1 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findIndex ( int n ) {<br>  if ( n <= 1 ) return n ;<br>  int a = 0 , b = 1 , c = 1 ;<br>  int res = 1 ;<br>  while ( c < n ) {<br>    c = a + b ;<br>    res ++ ;<br>    a = b ;<br>    b = c ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findIndex ( int n ) {<br>    if ( ( n <= 1 ) && ( n > 2 ) ) {<br>        return n ;<br>    }<br>    int a = 0 ;<br>    int b = 1 ;<br>    int c = 1 ;<br>    int res = 1 ;<br>    while ( ( c < n ) && ( c < n ) ) {<br>        int c = a + b ;<br>        int res = res + 1 ;<br>        int a = b ;<br>        b = c ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_OCTAL_DECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int octalToDecimal ( int n ) {<br>  int num = n ;<br>  int dec_value = 0 ;<br>  int base = 1 ;<br>  int temp = num ;<br>  while ( temp > 0 ) {<br>    int last_digit = temp % 10 ;<br>    temp = temp / 10 ;<br>    dec_value += last_digit * base ;<br>    base = base * 8 ;<br>  }<br>  return dec_value ;<br>}<br></td>
    <td>translated code: <br><br> public static int octalToDecimal ( int n ) {<br>    num . setScale ( 2 , BigDecimal . ROUND_HALF_UP ) ;<br>    BigDecimal decValue = new BigDecimal ( n ) ;<br>    int base = 1 ;<br>    int temp = num . intValue ( ) ;<br>    while ( ( temp = n % 5 ) != 0 ) {<br>        lastDigit = temp % 10 ;<br>        int temp ;<br>        decValue += lastDigit * base ;<br>        int base = n * 8 ;<br>    }<br>    return decValue ;<br>}</td>
  </tr><tr>
    <th>FIND_PERMUTED_ROWS_GIVEN_ROW_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) {<br>  LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) s . add ( mat [ r ] [ j ] ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( i == r ) continue ;<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ;<br>    if ( j != n ) continue ;<br>    System . out . print ( i + ", " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void permutatedRows ( int [ ] [ ] mat , int m , int n , int r ) {<br>    Set < Double > s = new HashSet < Double > ( ) ;<br>    for ( int j = 0 ;  j < n ;  j ++ ) {<br>        s . add ( mat [ r ] [ j ] ) ;<br>    }<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        if ( i == r ){<br>            continue ;<br>        }<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( mat [ i ] [ j ] != s ){<br>                j = j - 2 ;<br>                break ;<br>            }<br>        }<br>        if ( j + 1 != n ){<br>            continue ;<br>        }<br>        System . out . println ( i ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICATES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String noAdjacentDup ( String s1 ) {<br>  int n = s1 . length ( ) ;<br>  char [ ] s = s1 . toCharArray ( ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s [ i ] == s [ i - 1 ] ) {<br>      s [ i ] = 'a' ;<br>      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ;<br>      i ++ ;<br>    }<br>  }<br>  return ( new String ( s ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String noAdjacentDup ( String s ) {<br>    int n = s . length ( ) ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == s . charAt ( i - 1 ) ) && ( s . charAt ( i - 2 ) == s . charAt ( i - 1 ) ) ) {<br>            s . charAt ( i ++ ) = "a" ;<br>            while ( ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) && ( s [ i ] != s [ i ] ) ) {<br>                s [ i ] ++ ;<br>            }<br>            i ++ ;<br>        }<br>    }<br>    return s ;<br>}</td>
  </tr><tr>
    <th>SUM_MANHATTAN_DISTANCES_PAIRS_POINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int distancesum ( int x [ ] , int y [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int distancesum ( int [ ] x , int [ ] y , int n ) {<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_STRING_START_END_GEEKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isCornerPresent ( String str , String corner ) {<br>  int n = str . length ( ) ;<br>  int cl = corner . length ( ) ;<br>  if ( n < cl ) return false ;<br>  return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isCornerPresent ( String str , String corner ) {<br>    int n = str . length ( ) ;<br>    int cl = corner . length ;<br>    if ( ( n < cl ) && ( corner < n + 1 ) ){<br>        return false ;<br>    }<br>    return ( ( str . substring ( 0 , cl ) . equals ( corner ) ) && ( str . substring ( n - cl , n ) . equals ( corner ) ) ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenOfLongSubarr ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;<br>  int sum = 0 , maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] == 0 ? - 1 : 1 ;<br>    if ( sum == 1 ) maxLen = i + 1 ;<br>    else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ;<br>    if ( um . containsKey ( sum - 1 ) ) {<br>      if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenOfLongSubarr ( int [ ] arr , int n ) {<br>    Map < Long , Long > um = new HashMap < Long , Long > ( ) ;<br>    long sum = 0 ;<br>    int maxLen = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == 0 ) {<br>            sum += - 1 ;<br>        }<br>        if ( n > 0 ) {<br>            sum ++ ;<br>        }<br>        if ( ( sum == 1 ) && ( n > 0 ) ) {<br>            int maxLen = i + 1 ;<br>        }<br>        }<br>            um [ sum ++ ] = i ;<br>        if ( ( ( sum - 1 ) & um ) != 0 ) {<br>            if ( ( maxLen < ( i - um [ sum - 1 ] ) ) && ( n > 0 ) ){<br>                maxLen = i - um [ sum - 1 ] ;<br>            }<br>        }<br>    }<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>DIVIDE_CONQUER_SET_6_SEARCH_ROW_WISE_COLUMN_WISE_SORTED_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) {<br>  int i = fromRow + ( toRow - fromRow ) / 2 ;<br>  int j = fromCol + ( toCol - fromCol ) / 2 ;<br>  if ( mat [ i ] [ j ] == key ) System . out . println ( "Found " + key + " at " + i + " " + j ) ;<br>  else {<br>    if ( i != toRow || j != fromCol ) search ( mat , fromRow , i , j , toCol , key ) ;<br>    if ( fromRow == toRow && fromCol + 1 == toCol ) if ( mat [ fromRow ] [ toCol ] == key ) System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ;<br>    if ( mat [ i ] [ j ] < key ) {<br>      if ( i + 1 <= toRow ) search ( mat , i + 1 , toRow , fromCol , toCol , key ) ;<br>    }<br>    else {<br>      if ( j - 1 >= fromCol ) search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void search ( int [ ] [ ] mat , int fromRow , int toRow , int fromCol , int toCol , int key ) {<br>    int i = fromRow + ( toRow - fromRow ) / 2 ;<br>    int j = fromCol + ( toCol - fromCol ) / 2 ;<br>    if ( ( mat [ i ] [ j ] == key ) && ( mat [ fromRow ] [ fromCol ] == key ) && ( mat [ toRow ] [ toCol ] == key ) ) {<br>        System . out . println ( "Found " + key + " at " + i + " " + j ) ;<br>    }<br>    else {<br>        if ( ( i != toRow || j != fromCol ) && ( i != fromCol || j != toRow ) ){<br>            search ( mat , fromRow , i , j , toCol , key ) ;<br>        }<br>        if ( ( fromRow == toRow && fromCol + 1 == toCol ) || ( fromRow == toRow && fromCol + 1 == toCol ) ) {<br>            if ( ( mat [ fromRow ] [ toCol ] == key ) && ( mat [ fromCol ] [ toRow ] == key ) ) {<br>                System . out . println ( "Found " + key + " at " + fromRow + " " + toCol ) ;<br>            }<br>        }<br>        if ( ( mat [ i ] [ j ] < key ) && ( mat [ i ] [ j ] > key ) ) {<br>            if ( ( i + 1 <= toRow ) && ( i + 1 <= fromCol ) ){<br>                search ( mat , i + 1 , toRow , fromCol , toCol , key ) ;<br>            }<br>        }<br>        else {<br>            if ( ( j - 1 ) >= fromCol ){<br>                search ( mat , fromRow , toRow , fromCol , j - 1 , key ) ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>SHORTEST_COMMON_SUPERSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int superSeq ( String X , String Y , int m , int n ) {<br>  if ( m == 0 ) return n ;<br>  if ( n == 0 ) return m ;<br>  if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ;<br>  return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int superSeq ( int [ ] X , int [ ] Y , int m , int n ) {<br>    if ( ( ! m ) && ( ! n ) ) {<br>        return n ;<br>    }<br>    if ( ( ! n ) && ( m > 0 ) ) {<br>        return m ;<br>    }<br>    if ( ( X [ m - 1 ] == Y [ n - 1 ] ) && ( X [ m - 1 ] == Y [ n - 1 ] ) ) {<br>        return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ;<br>    }<br>    return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>URLIFY_GIVEN_STRING_REPLACE_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char [ ] replaceSpaces ( char [ ] str ) {<br>  int space_count = 0 , i = 0 ;<br>  for ( i = 0 ;<br>  i < str . length ;<br>  i ++ ) if ( str [ i ] == ' ' ) space_count ++ ;<br>  while ( str [ i - 1 ] == ' ' ) {<br>    space_count -- ;<br>    i -- ;<br>  }<br>  int new_length = i + space_count * 2 ;<br>  if ( new_length > MAX ) return str ;<br>  int index = new_length - 1 ;<br>  char [ ] new_str = str ;<br>  str = new char [ new_length ] ;<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) {<br>    if ( new_str [ j ] == ' ' ) {<br>      str [ index ] = '0' ;<br>      str [ index - 1 ] = '2' ;<br>      str [ index - 2 ] = '%' ;<br>      index = index - 3 ;<br>    }<br>    else {<br>      str [ index ] = new_str [ j ] ;<br>      index -- ;<br>    }<br>  }<br>  return str ;<br>}<br></td>
    <td>translated code: <br><br> public static int replaceSpaces ( String string ) {<br>    string = string . trim ( ) ;<br>    int i = string . indexOf ( ' ' ) ;<br>    int spaceCount = string . length ( ) ;<br>    int newLength = i + spaceCount * 2 ;<br>    if ( new_length > MAX ){<br>        return - 1 ;<br>    }<br>    index = newLength - 1 ;<br>    string = Arrays . asList ( string . split ( " " ) ) ;<br>    for ( int f = i - 2 ;  f < newLength - 2 ;  f ++ ) {<br>        string . append ( '0' ) ;<br>    }<br>    for ( int j = i - 1 ;  j > 0 ;  j -- ) {<br>        if ( string . charAt ( j ) == '' ){<br>            string . replace ( index , index + 1 , '0' ) ;<br>            string . replace ( index - 1 , 2 , " " ) ;<br>            string . replace ( index - 2 , index - 2 , "%" ) ;<br>            index = index - 3 ;<br>        }<br>        else {<br>            string . replace ( index , j , string . charAt ( j ) ) ;<br>            index -- ;<br>        }<br>    }<br>    return replaceSpaces ( string , " " ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_STARTING_CELL_0_TH_ROW_ENDING_CELL_N_1_TH_ROW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumPath ( int Mat [ ] [ ] ) {<br>  int result = 0 ;<br>  int dp [ ] [ ] = new int [ N ] [ N + 2 ] ;<br>  for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= N ;<br>  j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumPath ( int [ ] [ ] Mat ) {<br>    int result = 0 ;<br>    int [ ] [ ] dp = new int [ N + 2 ] [ N ] ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        for ( int j = 1 ;  j <= N ;  j ++ ) {<br>            dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + \<br>                Mat [ i ] [ j - 1 ] = 0 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < N + 1 ;  i ++ ) {<br>        result = Math . max ( result , dp [ N - 1 ] [ i ] ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getAbs ( int n ) {<br>  int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ;<br>  return ( ( n + mask ) ^ mask ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getAbs ( int n ) {<br>    int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ;<br>    return ( ( n + mask ) ^ mask ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPS ( int i , int j ) {<br>  if ( i >= n || j < 0 ) return 0 ;<br>  if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;<br>  if ( ( i - j == 1 ) || ( i - j == - 1 ) ) {<br>    if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = 3 ;<br>    else return dp [ i ] [ j ] = 2 ;<br>  }<br>  if ( i == j ) return dp [ 1 ] [ j ] = 1 ;<br>  else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ;<br>  else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPS ( int i , int j ) {<br>    if ( ( i >= n || j < 0 ) && ( i < 0 || j < 0 ) ){<br>        return 0 ;<br>    }<br>    if ( ( dp [ i ] [ j ] != - 1 ) && ( dp [ i ] [ j ] != - 1 ) ) {<br>        return dp [ i ] [ j ] ;<br>    }<br>    if ( ( Math . abs ( i - j ) == 1 ) && ( i > j ) ) {<br>        if ( ( str [ i ] == str [ j ] ) && ( str [ i ] != str [ j ] ) ) {<br>            dp [ i ] [ j ] = 3 ;<br>            return dp [ i ] [ j ] ;<br>        }<br>        }<br>            dp [ i ] [ j ] = 2 ;<br>            return dp [ i ] [ j ] ;<br>    }<br>    if ( ( i == j ) && ( i != 0 ) ) {<br>        dp [ 1 ] [ j ] = 1 ;<br>        return dp [ 1 ] [ j ] ;<br>    }<br>    }<br>        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) ;<br>        return dp [ i ] [ j ] ;<br>    }<br>        dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) ;<br>        return dp [ i ] [ j ] ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = a [ 0 ] ;<br>  int curr_max = a [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < size ;<br>  i ++ ) {<br>    curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , curr_max ) ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>    int maxSoFar = a [ 0 ] ;<br>    int currMax = a [ 0 ] ;<br>    for ( int i = 1 ;  i < size ;  i ++ ) {<br>        int currMax = Math . max ( a [ i ] , currMax + a [ i ] ) ;<br>        maxSoFar = Math . max ( maxSoFar , currMax ) ;<br>    }<br>    return max_so_far ;<br>}</td>
  </tr><tr>
    <th>COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countMinOperations ( int n ) {<br>  int result = 0 ;<br>  while ( true ) {<br>    int zero_count = 0 ;<br>    int i ;<br>    for ( i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( arr [ i ] % 2 == 1 ) break ;<br>      else if ( arr [ i ] == 0 ) zero_count ++ ;<br>    }<br>    if ( zero_count == n ) return result ;<br>    if ( i == n ) {<br>      for ( int j = 0 ;<br>      j < n ;<br>      j ++ ) arr [ j ] = arr [ j ] / 2 ;<br>      result ++ ;<br>    }<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] % 2 == 1 ) {<br>        arr [ j ] -- ;<br>        result ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int countMinOperations ( int [ ] target , int n ) {<br>    int result = 0 ;<br>    while ( ( true ) && ( target < n ) ) {<br>        long zeroCount = 0 ;<br>        int i = 0 ;<br>        while ( ( i = target ) < n ) {<br>            if ( ( ( target [ i ] & 1 ) > 0 ) && ( ( target [ i ] & 2 ) > 0 ) ) {<br>                break ;<br>            }<br>            else if ( ( target [ i ] == 0 ) && ( target [ i ] != n ) ) {<br>                zeroCount ++ ;<br>            }<br>            i ++ ;<br>        }<br>        if ( ( zeroCount == n ) && ( zeroCount == target ) ) {<br>            return result ;<br>        }<br>        if ( ( i == n ) && ( target > target ) ) {<br>            for ( int j = 0 ;  j < n ;  j ++ ) {<br>                target [ j ] = target [ j ] / 2 ;<br>            }<br>            result ++ ;<br>        }<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            if ( ( target [ j ] & 1 ) != 0 ) {<br>                target [ j ] -- ;<br>                result ++ ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void fib ( int n ) {<br>  int a = 0 , b = 1 ;<br>  if ( n >= 0 ) System . out . print ( a + " " ) ;<br>  if ( n >= 1 ) System . out . print ( b + " " ) ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . print ( a + b + " " ) ;<br>    b = a + b ;<br>    a = b - a ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void fib ( int n ) {<br>    int a = 0 ;<br>    b = 1 ;<br>    if ( ( n >= 0 ) && ( n < 5 ) ){<br>        System . out . print ( a + " " ) ;<br>    }<br>    if ( ( n >= 1 ) && ( n <= 5 ) ) {<br>        System . out . print ( b + " " ) ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        System . out . print ( a + b + " " ) ;<br>        b = a + b ;<br>        a = b - a ;<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_CHECK_INPUT_INTEGER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isNumber ( String s ) {<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isNumber ( String s ) {<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( s . charAt ( i ) . matches ( "[0-9]+" ) != true ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_HEIGHT_TRIANGLE_GIVEN_BASE_AREA</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double minHeight ( double base , double area ) {<br>  double d = ( 2 * area ) / base ;<br>  return Math . ceil ( d ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minHeight ( int area , int base ) {<br>    return Math . ceil ( ( 2 * area ) / base ) ;<br>}</td>
  </tr><tr>
    <th>FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findpos ( String n ) {<br>  int k = 0 , pos = 0 , i = 0 ;<br>  while ( k != n . length ( ) ) {<br>    switch ( n . charAt ( i ) ) {<br>      case '4' : pos = pos * 2 + 1 ;<br>      break ;<br>      case '7' : pos = pos * 2 + 2 ;<br>      break ;<br>    }<br>    i ++ ;<br>    k ++ ;<br>  }<br>  return pos ;<br>}<br></td>
    <td>translated code: <br><br> public static int findpos ( String n ) {<br>    int i ;<br>    int j = n . length ( ) ;<br>    int pos = 0 ;<br>    while ( ( i < j ) && ( i < n ) ){<br>        if ( ( n . charAt ( i ) == '4' ) && ( n . charAt ( i + 1 ) == '5' ) ) {<br>            pos = pos * 2 + 1 ;<br>        }<br>        if ( ( n . charAt ( i ++ ) == '7' ) && ( n . charAt ( i ++ ) == 'a' ) ){<br>            pos = pos * 2 + 2 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    return pos ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minOperation ( boolean arr [ ] [ ] ) {<br>  int ans = 0 ;<br>  for ( int i = N - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( arr [ i ] [ j ] == false ) {<br>        ans ++ ;<br>        for ( int k = 0 ;<br>        k <= i ;<br>        k ++ ) {<br>          for ( int h = 0 ;<br>          h <= j ;<br>          h ++ ) {<br>            if ( arr [ k ] [ h ] == true ) {<br>              arr [ k ] [ h ] = false ;<br>            }<br>            else {<br>              arr [ k ] [ h ] = true ;<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int minOperation ( int [ ] [ ] arr ) {<br>    int ans = 0 ;<br>    for ( int i = N - 1 ;  i >= 0 ;  i -- ) {<br>        for ( int j = M - 1 ;  j >= 0 ;  j -- ) {<br>            if ( ( arr [ i ] [ j ] == 0 ) && ( arr [ i ] [ j ] == 1 ) ) {<br>                ans ++ ;<br>                for ( int k = 0 ;  k < i + 1 ;  k ++ ) {<br>                    for ( int h = 0 ;  h < j + 1 ;  h ++ ) {<br>                        if ( ( arr [ k ] [ h ] == 1 ) && ( arr [ k ] [ h ] == 2 ) ) {<br>                            arr [ k ] [ h ] = 0 ;<br>                        }<br>                        else {<br>                            arr [ k ] [ h ] = 1 ;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str , int n ) {<br>  int sum [ ] = new int [ n + 1 ] ;<br>  sum [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ;<br>  int ans = 0 ;<br>  for ( int len = 2 ;<br>  len <= n ;<br>  len += 2 ) {<br>    for ( int i = 0 ;<br>    i <= n - len ;<br>    i ++ ) {<br>      int j = i + len - 1 ;<br>      if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string , int n ) {<br>    int [ ] Sum = {<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        Sum [ i ] = ( Sum [ i - 1 ] + Integer . parseInt ( string . substring ( i - 1 , n ) ) ) ;<br>    }<br>    int ans = 0 ;<br>    for ( int length = 2 ;  length <= n ;  length += 2 ) {<br>        for ( int i = 0 ;  i <= n - length + 1 ;  i ++ ) {<br>            int j = i + length - 1 ;<br>            if ( ( Sum [ i + length / 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length / 2 ] ) ) {<br>                ans = Math . max ( ans , length ) ;<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MULTIPLY_LARGE_NUMBERS_REPRESENTED_AS_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String multiply ( String num1 , String num2 ) {<br>  int len1 = num1 . length ( ) ;<br>  int len2 = num2 . length ( ) ;<br>  if ( len1 == 0 || len2 == 0 ) return "0" ;<br>  int result [ ] = new int [ len1 + len2 ] ;<br>  int i_n1 = 0 ;<br>  int i_n2 = 0 ;<br>  for ( int i = len1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int carry = 0 ;<br>    int n1 = num1 . charAt ( i ) - '0' ;<br>    i_n2 = 0 ;<br>    for ( int j = len2 - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int n2 = num2 . charAt ( j ) - '0' ;<br>      int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ;<br>      carry = sum / 10 ;<br>      result [ i_n1 + i_n2 ] = sum % 10 ;<br>      i_n2 ++ ;<br>    }<br>    if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ;<br>    i_n1 ++ ;<br>  }<br>  int i = result . length - 1 ;<br>  while ( i >= 0 && result [ i ] == 0 ) i -- ;<br>  if ( i == - 1 ) return "0" ;<br>  String s = "" ;<br>  while ( i >= 0 ) s += ( result [ i -- ] ) ;<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String multiply ( String num1 , String num2 ) {<br>    int len1 = num1 . length ( ) ;<br>    int len2 = num2 . length ( ) ;<br>    if ( len1 == 0 || len2 == 0 ) {<br>        return "0" ;<br>    }<br>    int [ ] result = new int [ len1 + len2 ] ;<br>    int i_n1 = 0 ;<br>    int i_n2 = 0 ;<br>    for ( int i = len1 - 1 ;  i >= 0 ;  i -- ) {<br>        int carry = 0 ;<br>        int n1 = ( byte ) ( num1 [ i ] - 48 ) ;<br>        int i_n2 = 0 ;<br>        for ( int j = len2 - 1 ;  j >= 0 ;  j -- ) {<br>            int n2 = ( int ) num2 [ j ] - 48 ;<br>            summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry ;<br>            carry = summ / 10 ;<br>            result [ i_n1 + i_n2 ] = summ % 10 ;<br>            i_n2 ++ ;<br>        }<br>        if ( ( carry > 0 ) && ( num1 > num2 ) ) {<br>            result [ i_n1 + i_n2 ] += carry ;<br>        }<br>        i_n1 ++ ;<br>    }<br>    int i = result . length - 1 ;<br>    while ( ( i >= 0 && result [ i ] == 0 ) || ( i >= 0 && result [ i ] > num2 ) ) {<br>        i -- ;<br>    }<br>    if ( ( i == - 1 ) && ( num2 == - 1 ) ) {<br>        return "0" ;<br>    }<br>    String s = "" ;<br>    while ( ( i >= 0 ) && ( i < num2 ) ) {<br>        s += ( char ) ( result [ i ] + 48 ) ;<br>        i -- ;<br>    }<br>    return s ;<br>}</td>
  </tr><tr>
    <th>PARTITION_NUMBER_TWO_DIVISBLE_PARTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findDivision ( String str , int a , int b ) {<br>  int len = str . length ( ) ;<br>  int [ ] lr = new int [ len + 1 ] ;<br>  lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str . charAt ( i ) - ( int ) '0' ) ) % a ;<br>  int [ ] rl = new int [ len + 1 ] ;<br>  rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int ) '0' ) % b ;<br>  int power10 = 10 ;<br>  for ( int i = len - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i ) - ( int ) '0' ) * power10 ) % b ;<br>    power10 = ( power10 * 10 ) % b ;<br>  }<br>  for ( int i = 0 ;<br>  i < len - 1 ;<br>  i ++ ) {<br>    if ( lr [ i ] != 0 ) continue ;<br>    if ( rl [ i + 1 ] == 0 ) {<br>      System . out . println ( "YES" ) ;<br>      for ( int k = 0 ;<br>      k <= i ;<br>      k ++ ) System . out . print ( str . charAt ( k ) ) ;<br>      System . out . print ( ", " ) ;<br>      for ( int k = i + 1 ;<br>      k < len ;<br>      k ++ ) System . out . print ( str . charAt ( k ) ) ;<br>      return ;<br>    }<br>  }<br>  System . out . println ( "NO" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findDivision ( String str , int a , int b ) {<br>    int lenn = str . length ( ) ;<br>    int [ ] lr = new int [ lenn + 1 ] ;<br>    lr [ 0 ] = ( Integer . parseInt ( str ) ) % a ;<br>    for ( int i = 1 ;  i < lenn ;{<br>        lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ " " + str ) % a ;<br>    }<br>    int [ ] rl = {<br>    }<br>    rl [ lenn - 1 ] = Integer . parseInt ( str . substring ( lenn - 1 ) ) % b ;<br>    int power10 = 10 ;<br>    for ( int i = lenn - 2 ;  i >= 0 ;{<br>        rl [ i ] = ( rl [ i + 1 ] + Integer . parseInt ( str . substring ( i , i + 1 ) ) * power10 ) % b ;<br>        power10 = ( power10 * 10 ) % b ;<br>    }<br>    for ( int i = 0 ;  i <= lenn - 1 ;{<br>        if ( ( lr [ i ] != 0 ) && ( lr [ i ] != b ) ){<br>            continue ;<br>        }<br>        if ( ( rl [ i + 1 ] == 0 ) && ( rl [ i + 2 ] == 0 ) ){<br>            System . out . println ( "YES" ) ;<br>            for ( int k = 0 ;  k <= i ;{<br>                System . out . print ( str [ k ] + " " ) ;<br>            }<br>            System . out . print ( "," ) ;<br>            for ( int i = i + 1 ;  i < lenn ;{<br>                System . out . print ( str [ k ] + " " ) ;<br>                findDivision ( str , a , b , null ) ;<br>            }<br>        }<br>    }<br>    System . out . println ( "NO" ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < allocation . length ;<br>  i ++ ) allocation [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int bestIdx = - 1 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        if ( bestIdx == - 1 ) bestIdx = j ;<br>        else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ;<br>      }<br>    }<br>    if ( bestIdx != - 1 ) {<br>      allocation [ i ] = bestIdx ;<br>      blockSize [ bestIdx ] -= processSize [ i ] ;<br>    }<br>  }<br>  System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( "   " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ;<br>    else System . out . print ( "Not Allocated" ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bestFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>    allocation = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        bestIdx = - 1 ;<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( blockSize [ j ] >= processSize [ i ] ){<br>                if ( bestIdx == - 1 ) {<br>                    bestIdx = j ;<br>                }<br>                else if ( blockSize [ bestIdx ] > blockSize [ j ] ){<br>                    bestIdx = j ;<br>                }<br>            }<br>        }<br>        if ( bestIdx != - 1 ){<br>            allocation [ i ++ ] = bestIdx ;<br>            blockSize [ bestIdx ++ ] -= processSize [ i ] ;<br>        }<br>    }<br>    System . out . println ( "Process No.Process Size     Block no." ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . println ( i + "         " + processSize [ i ] + "         " ) ;<br>        if ( allocation [ i ] != - 1 ){<br>            System . out . println ( allocation [ i ] + 1 ) ;<br>        }<br>        else{<br>            System . out . println ( "Not Allocated" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largestKSubmatrix ( int [ ] [ ] a ) {<br>  int [ ] [ ] dp = new int [ Row ] [ Col ] ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < Row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < Col ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;<br>      else {<br>        if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) {<br>          dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ;<br>        }<br>        else dp [ i ] [ j ] = 1 ;<br>      }<br>      result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int largestKSubmatrix ( int [ ] [ ] a ) {<br>    int [ ] [ ] dp = new int [ Row ] [ Col ] ;<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < Row ;{<br>        for ( int j = 0 ;  j < Col ;{<br>            if ( ( i == 0 || j == 0 ) && ( i == 0 || j == 0 ) ) {<br>                dp [ i ] [ j ] = 1 ;<br>            }<br>            else{<br>                if ( ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) || ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) ) {<br>                    dp [ i ] [ j ] = Math . min ( Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ;<br>                }<br>                else{<br>                    dp [ i ] [ j ] = 1 ;<br>                }<br>            }<br>            result = Math . max ( result , dp [ i ] [ j ] ) ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  if ( dp [ n ] != - 1 ) return dp [ n ] ;<br>  if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ;<br>  else return dp [ n ] = n ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>    int [ ] dp = new int [ 100 ] ;<br>    if ( ( dp [ n ] != - 1 ) && ( dp [ n ] != - 2 ) ) {<br>        return dp [ n ] ;<br>    }<br>    if ( ( n > 2 ) && ( n > 3 ) ) {<br>        dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) ;<br>        return dp [ n ] ;<br>    }<br>    else {<br>        dp [ n ] = n ;<br>        return dp [ n ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstElement ( int arr [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > count_map = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int a = 0 ;<br>    if ( count_map . get ( arr [ i ] ) != null ) {<br>      a = count_map . get ( arr [ i ] ) ;<br>    }<br>    count_map . put ( arr [ i ] , a + 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count_map . get ( arr [ i ] ) == k ) {<br>      return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstElement ( int [ ] arr , int n , int k ) {<br>    HashMap < Integer , Integer > countMap = new HashMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] = countMap . get ( n ) ) < 0 ) {<br>            countMap [ arr [ i ] ] ++ ;<br>        }<br>        else {<br>            countMap . put ( arr [ i ] , 1 ) ;<br>        }<br>        i ++ ;<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( countMap [ arr [ i ] ] == k ) && ( countMap [ arr [ n ] ] == k ) ) {<br>            return arr [ i ++ ] ;<br>        }<br>        i ++ ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumOfSeries ( int n ) {<br>  return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double sumOfSeries ( int n ) {<br>    return ( ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_WORDS_IN_A_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWords ( String str ) {<br>  int state = OUT ;<br>  int wc = 0 ;<br>  int i = 0 ;<br>  while ( i < str . length ( ) ) {<br>    if ( str . charAt ( i ) == ' ' || str . charAt ( i ) == '\n' || str . charAt ( i ) == '\t' ) state = OUT ;<br>    else if ( state == OUT ) {<br>      state = IN ;<br>      ++ wc ;<br>    }<br>    ++ i ;<br>  }<br>  return wc ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWords ( String string ) {<br>    state = OUT ;<br>    int wc = 0 ;<br>    for ( int i = 0 ;  i < string . length ( ) ;  i ++ ) {<br>        if ( ( string . charAt ( i ) == ' ' || string . charAt ( i ) == '\n' || string . charAt ( i ) == '\t' ) && ( string . charAt ( i + 1 ) == ' ' || string . charAt ( i + 1 ) == '\n' || string . charAt ( i + 1 ) == '\t' ) ) {<br>            state = OUT ;<br>        }<br>        else if ( state == OUT ) {<br>            state = IN ;<br>            wc ++ ;<br>        }<br>    }<br>    return wc ;<br>}</td>
  </tr><tr>
    <th>PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_THE_DIFFERENCE_OF_SUMS_IS_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDifference ( int arr [ ] , int N , int k ) {<br>  int M , S = 0 , S1 = 0 , max_difference = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) S += arr [ i ] ;<br>  int temp ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( arr [ i ] < arr [ j ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ j ] ;<br>        arr [ j ] = temp ;<br>      }<br>    }<br>  }<br>  M = Math . max ( k , N - k ) ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) S1 += arr [ i ] ;<br>  max_difference = S1 - ( S - S1 ) ;<br>  return max_difference ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDifference ( int [ ] arr , int N , int k ) {<br>    int S = 0 ;<br>    int S1 = 0 ;<br>    int maxDifference = 0 ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        S += arr [ i ] ;<br>    }<br>    Arrays . sort ( arr , 0 , N ) ;<br>    int M = Math . max ( k , N - k ) ;<br>    for ( int i = 0 ;  i < M ;  i ++ ) {<br>        S1 += arr [ i ] ;<br>    }<br>    int maxDifference = S1 - ( S - S1 ) ;<br>    return maxDifference ;<br>}</td>
  </tr><tr>
    <th>HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printNos ( int n ) {<br>  if ( n > 0 ) {<br>    printNos ( n - 1 ) ;<br>    System . out . print ( n + " " ) ;<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> static void printNos ( int n ) {<br>    if ( n > 0 ) {<br>        printNos ( n - 1 ) ;<br>        System . out . print ( n + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pairsInSortedRotated ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  int cnt = 0 ;<br>  while ( l != r ) {<br>    if ( arr [ l ] + arr [ r ] == x ) {<br>      cnt ++ ;<br>      if ( l == ( r - 1 + n ) % n ) {<br>        return cnt ;<br>      }<br>      l = ( l + 1 ) % n ;<br>      r = ( r - 1 + n ) % n ;<br>    }<br>    else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;<br>    else r = ( n + r - 1 ) % n ;<br>  }<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int pairsInSortedRotated ( int [ ] arr , int n , int x ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] > arr [ i + 1 ] ) {<br>            break ;<br>        }<br>    }<br>    int l = ( i + 1 ) % n ;<br>    int r = i ;<br>    int cnt = 0 ;<br>    while ( ( l != r ) && ( l != n ) ) {<br>        if ( arr [ l ] + arr [ r ] == x ){<br>            cnt ++ ;<br>            if ( l == ( r - 1 + n ) % n ){<br>                return cnt ;<br>            }<br>            l = ( l + 1 ) % n ;<br>            r = ( r - 1 + n ) % n ;<br>        }<br>        if ( arr [ l ] + arr [ r ] < x ){<br>            l = ( l + 1 ) % n ;<br>        }<br>        else {<br>            r = ( n + r - 1 ) % n ;<br>        }<br>    }<br>    return cnt ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSingle ( int arr [ ] , int n ) {<br>  int ones = 0 , twos = 0 ;<br>  int common_bit_mask ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    twos = twos | ( ones & arr [ i ] ) ;<br>    ones = ones ^ arr [ i ] ;<br>    common_bit_mask = ~ ( ones & twos ) ;<br>    ones &= common_bit_mask ;<br>    twos &= common_bit_mask ;<br>  }<br>  return ones ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSingle ( int [ ] arr , int n ) {<br>    int ones = 0 ;<br>    int twos = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        twos = twos | ( ones & arr [ i ] ) ;<br>        ones = ones ^ arr [ i ] ;<br>        common_bit_mask = ~ ( ones & twos ) ;<br>        ones &= common_bit_mask ;<br>        twos &= common_bit_mask ;<br>    }<br>    return ones ;<br>}</td>
  </tr><tr>
    <th>CASSINIS_IDENTITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int cassini ( int n ) {<br>  return ( n & 1 ) != 0 ? - 1 : 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int cassini ( int n ) {<br>    return n == 0 ? 1 : - 1 ;<br>}</td>
  </tr><tr>
    <th>DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean distributingBalls ( long k , long n , String str ) {<br>  int [ ] a = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( a [ i ] > k ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean distributingBalls ( int k , int n , String string ) {<br>    char [ ] a = {<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        a [ ( int ) string . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        if ( ( a [ i ] > k ) && ( a [ i ] < n ) ) a [ i ] = 5 ;<br>            return false ;<br>    }<br>    return distributingBalls ( k , n , string , null ) ;<br>}</td>
  </tr><tr>
    <th>DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkCount ( int [ ] arr , int n , int k ) {<br>  int count ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] == arr [ i ] ) count ++ ;<br>      if ( count > 2 * k ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkCount ( int [ ] arr , int n , int k ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int count = 0 ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( arr [ j ] == arr [ i ] ) {<br>                count ++ ;<br>            }<br>            if ( count > 2 * k ) {<br>                return false ;<br>            }<br>        }<br>    }<br>    return checkCount ( arr , n , k , 0 , 0 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int [ ] arr , int n ) {<br>  if ( n < 4 ) {<br>    System . out . println ( "The array should have" + " atleast 4 elements" ) ;<br>  }<br>  int table1 [ ] = new int [ n + 1 ] ;<br>  int table2 [ ] = new int [ n ] ;<br>  int table3 [ ] = new int [ n - 1 ] ;<br>  int table4 [ ] = new int [ n - 2 ] ;<br>  Arrays . fill ( table1 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table2 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table3 , Integer . MIN_VALUE ) ;<br>  Arrays . fill ( table4 , Integer . MIN_VALUE ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;<br>  }<br>  for ( int i = n - 3 ;<br>  i >= 0 ;<br>  i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;<br>  for ( int i = n - 4 ;<br>  i >= 0 ;<br>  i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;<br>  return table4 [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] arr , int n ) {<br>    if ( n < 4 ) {<br>        System . out . println ( "The array should have atlest 4 elements" ) ;<br>        return MIN ;<br>    }<br>    int [ ] table1 = new int [ n + 1 ] , table2 = new int [ n ] ;<br>    int [ ] table3 = {<br>    }<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ;<br>    }<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ;<br>    }<br>    for ( int i = n - 3 ;  i >= 0 ;  i -- ) {<br>        table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ;<br>    }<br>    for ( int i = n - 4 ;  i >= 0 ;  i -- ) {<br>        table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ;<br>    }<br>    return table4 [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNegative ( int M [ ] [ ] , int n , int m ) {<br>  int count = 0 ;<br>  int i = 0 ;<br>  int j = m - 1 ;<br>  while ( j >= 0 && i < n ) {<br>    if ( M [ i ] [ j ] < 0 ) {<br>      count += j + 1 ;<br>      i += 1 ;<br>    }<br>    else j -= 1 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNegative ( int [ ] [ ] M , int n , int m ) {<br>    int count = 0 ;<br>    int i = 0 ;<br>    int j = m - 1 ;<br>    while ( j >= 0 && i < n ) {<br>        if ( M [ i ] [ j ] < 0 ) {<br>            count += ( j + 1 ) ;<br>            i ++ ;<br>        }<br>        else {<br>            j -- ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>SORT_AN_ARRAY_OF_0S_1S_AND_2S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sort012 ( int a [ ] , int arr_size ) {<br>  int lo = 0 ;<br>  int hi = arr_size - 1 ;<br>  int mid = 0 , temp = 0 ;<br>  while ( mid <= hi ) {<br>    switch ( a [ mid ] ) {<br>      case 0 : {<br>        temp = a [ lo ] ;<br>        a [ lo ] = a [ mid ] ;<br>        a [ mid ] = temp ;<br>        lo ++ ;<br>        mid ++ ;<br>        break ;<br>      }<br>      case 1 : mid ++ ;<br>      break ;<br>      case 2 : {<br>        temp = a [ mid ] ;<br>        a [ mid ] = a [ hi ] ;<br>        a [ hi ] = temp ;<br>        hi -- ;<br>        break ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sort012 ( int [ ] a , int arrSize ) {<br>    int lo = 0 ;<br>    int hi = arrSize - 1 ;<br>    int mid = 0 ;<br>    while ( mid <= hi ) {<br>        if ( a [ mid ] == 0 ) {<br>            a [ lo ] = a [ mid ] ;<br>            lo = lo + arrSize ;<br>            int mid = arrSize - 1 ;<br>        }<br>        else if ( a [ mid ] == 1 ) a [ mid ] = 5 ;<br>            int mid = arrSize - 1 ;<br>        if ( arrSize > 0 ) {    int [ ] newArray = new int [ arrSize ] ;    System . arraycopy ( a , 0 , newArray , 0 , arrSize ) ;  }  else {<br>            a [ mid ] = a [ hi ] ;<br>            hi = hi - 1 ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>NTH_EVEN_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long evenFib ( int n ) {<br>  if ( n < 1 ) return n ;<br>  if ( n == 1 ) return 2 ;<br>  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int evenFib ( int n ) {<br>    if ( ( n < 1 ) && ( n > 0 ) ) {<br>        return n ;<br>    }<br>    if ( ( n == 1 ) && ( n % 2 == 0 ) ) {<br>        return 2 ;<br>    }<br>    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>NEXT_GREATER_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printNGE ( int arr [ ] , int n ) {<br>  int next , i , j ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    next = - 1 ;<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ i ] < arr [ j ] ) {<br>        next = arr [ j ] ;<br>        break ;<br>      }<br>    }<br>    System . out . println ( arr [ i ] + " -- " + next ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printNGE ( int [ ] arr ) {<br>    for ( int i = 0 ;  i < arr . length ;  i += 1 ) {<br>        next = - 1 ;<br>        for ( int j = i + 1 ;  j < arr . length ;  j += 1 ) {<br>            if ( arr [ i ] < arr [ j ] ) {<br>                int next = arr [ j ] ;<br>                break ;<br>            }<br>        }<br>        System . out . println ( String . valueOf ( arr [ i ] ) + " -- " + next ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_CIRCLE_INNER_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void fitOrNotFit ( int R , int r , int x , int y , int rad ) {<br>  double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ;<br>  if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ;<br>  else System . out . println ( "Doesn't Fit" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void fitOrNotFit ( double R , double r , double x , double y , double rad ) {<br>    double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ;<br>    if ( ( val + rad <= R && val - rad >= R - r ) || ( val - rad >= R - r ) ){<br>        System . out . println ( "Fits\n" ) ;<br>    }<br>    else {<br>        System . out . println ( "Doesn't Fit" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int gcdExtended ( int a , int b , int x , int y ) {<br>  if ( a == 0 ) {<br>    x = 0 ;<br>    y = 1 ;<br>    return b ;<br>  }<br>  int x1 = 1 , y1 = 1 ;<br>  int gcd = gcdExtended ( b % a , a , x1 , y1 ) ;<br>  x = y1 - ( b / a ) * x1 ;<br>  y = x1 ;<br>  return gcd ;<br>}<br></td>
    <td>translated code: <br><br> public static int gcdExtended ( int a , int b , int x , int y ) {<br>    if ( a == 0 ){<br>        x = 0 ;<br>        y = 1 ;<br>        gcdExtended ( a , b , x , y , 0 ) ;<br>    }<br>    double x1 = 1 ;<br>    double y1 = 1 ;<br>    int gcd = gcdExtended ( b % a , a , x1 , y1 ) ;<br>    x = y1 - ( b / a ) * x1 ;<br>    y = x1 ;<br>    return gcd ;<br>}</td>
  </tr><tr>
    <th>FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) {<br>  int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ;<br>  for ( i = 0 ;<br>  i <= k ;<br>  i ++ ) {<br>    ptr [ i ] = 0 ;<br>  }<br>  minrange = Integer . MAX_VALUE ;<br>  while ( true ) {<br>    minind = - 1 ;<br>    minval = Integer . MAX_VALUE ;<br>    maxval = Integer . MIN_VALUE ;<br>    flag = 0 ;<br>    for ( i = 0 ;<br>    i < k ;<br>    i ++ ) {<br>      if ( ptr [ i ] == n ) {<br>        flag = 1 ;<br>        break ;<br>      }<br>      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) {<br>        minind = i ;<br>        minval = arr [ i ] [ ptr [ i ] ] ;<br>      }<br>      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) {<br>        maxval = arr [ i ] [ ptr [ i ] ] ;<br>      }<br>    }<br>    if ( flag == 1 ) {<br>      break ;<br>    }<br>    ptr [ minind ] ++ ;<br>    if ( ( maxval - minval ) < minrange ) {<br>      minel = minval ;<br>      maxel = maxval ;<br>      minrange = maxel - minel ;<br>    }<br>  }<br>  System . out . printf ( "The smallest range is [%d , %d]\n" , minel , maxel ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findSmallestRange ( int [ ] arr , int n , int k ) {<br>    int i = 0 , minval = 0 , maxval = 0 , minrange = 0 , minel = 0 , maxel = 0 , flag = 0 , minind = 0 ;<br>    for ( int i = 0 ;  i < k + 1 ;  i ++ ) {<br>        ptr [ i ++ ] = 0 ;<br>    }<br>    int minrange = 10 * 9 ;<br>    while ( ( 1 ) ) {<br>        int minind = - 1 ;<br>        int minval = 10 * 9 ;<br>        int maxval = - 10 * 9 ;<br>        int flag = 0 ;<br>        for ( int i = 0 ;  i < k ;  i ++ ) {<br>            if ( ( ptr [ i ] == n ) && ( ptr [ i + 1 ] == k ) ) {<br>                int flag = 1 ;<br>                break ;<br>            }<br>            if ( ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) || ( ptr [ i ] < k && arr [ i ] [ ptr [ i ] ] > k ) ){<br>                int minind = i ;<br>                int minval = arr [ i ] [ ptr [ i ] ] ;<br>            }<br>            if ( ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) || ( ptr [ i ] < k && arr [ i ] [ ptr [ i ] ] > maxval ) ){<br>                int maxval = arr [ i ] [ ptr [ i ] ] ;<br>            }<br>        }<br>        if ( ( flag ) && ( arr != null ) ) {<br>            break ;<br>        }<br>        ptr [ minind ] ++ ;<br>        if ( ( ( maxval - minval ) < minrange ) && ( ( maxval - minval ) > minrange ) ) {<br>            int minel = minval ;<br>            int maxel = maxval ;<br>            int minrange = maxel - minel ;<br>        }<br>    }<br>    System . out . println ( "The smallest range is [" + minel + "," + maxel + "]" ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STATION_IS_CONNECTED_IN_ONE_DIRECTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCost ( int cost [ ] [ ] ) {<br>  int dist [ ] = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dist [ i ] = INF ;<br>  dist [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < N ;<br>  j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ;<br>  return dist [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] [ ] cost ) {<br>    int [ ] dist = new int [ N ] ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        dist [ i ] = INF ;<br>    }<br>    dist [ 0 ] = 0 ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < N ;  j ++ ) {<br>            if ( ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) && ( dist [ i ] > dist [ j ] + cost [ j ] [ i ] ) ){<br>                dist [ j ] = dist [ i ] + cost [ i ] [ j ] ;<br>            }<br>        }<br>    }<br>    return dist [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( a > b ) {<br>    if ( b > c ) return b ;<br>    else if ( a > c ) return c ;<br>    else return a ;<br>  }<br>  else {<br>    if ( a > c ) return a ;<br>    else if ( b > c ) return c ;<br>    else return b ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>    if ( a > b ) {<br>        if ( ( b > c ) && ( b < a ) ) {<br>            return b ;<br>        }<br>        }<br>            return c ;<br>        }<br>            return a ;<br>    }<br>    }<br>        if ( ( a > c ) && ( b > c ) ) {<br>            return a ;<br>        }<br>        }<br>            return c ;<br>        }<br>            return b ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int oddDigSum = 0 , evenDigSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ;<br>    else evenDigSum += ( str . charAt ( i ) - '0' ) ;<br>  }<br>  return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>    int n = st . length ( ) ;<br>    oddDigSum = 0 ;<br>    evenDigSum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( i % 2 == 0 ) && ( i % 3 == 0 ) ) {<br>            oddDigSum = oddDigSum + ( ( Integer ) ( st . charAt ( i ) ) ) ;<br>        }<br>        }<br>            evenDigSum = evenDigSum + ( ( Integer ) ( st [ i ] ) ) ;<br>    }<br>    return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getModulo ( int n , int d ) {<br>  return ( n & ( d - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int getModulo ( int n , int d ) {<br>    return ( n & ( d - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n , int k ) {<br>  int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;<br>  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;<br>  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i && j < k + 1 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ;<br>      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;<br>      if ( j - 1 >= 0 ) {<br>        dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrings ( int n , int k ) {<br>    int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ;<br>    dp [ 1 ] [ 0 ] [ 0 ] = 1 ;<br>    dp [ 1 ] [ 0 ] [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j < k + 1 ;  j ++ ) {<br>            dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ;<br>            dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;<br>            if ( j >= 1 ){<br>                dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ;<br>            }<br>        }<br>    }<br>    return dp [ n ] [ k ] . intValue ( ) + dp [ n ] [ k ] . intValue ( ) ;<br>}</td>
  </tr><tr>
    <th>FINDING_K_MODULUS_ARRAY_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printEqualModNumbers ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int d = arr [ n - 1 ] - arr [ 0 ] ;<br>  Vector < Integer > v = new Vector < > ( ) ;<br>  for ( int i = 1 ;<br>  i * i <= d ;<br>  i ++ ) {<br>    if ( d % i == 0 ) {<br>      v . add ( i ) ;<br>      if ( i != d / i ) v . add ( d / i ) ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < v . size ( ) ;<br>  i ++ ) {<br>    int temp = arr [ 0 ] % v . get ( i ) ;<br>    int j ;<br>    for ( j = 1 ;<br>    j < n ;<br>    j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ;<br>    if ( j == n ) System . out . print ( v . get ( i ) + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printEqualModNumbers ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int d = arr [ n - 1 ] - arr [ 0 ] ;<br>    int [ ] v = new int [ n ] ;<br>    int i = 1 ;<br>    while ( ( i * i <= d ) && ( n * i <= d ) ){<br>        if ( ( d % i == 0 ) && ( d % n == 0 ) ){<br>            v . add ( i ) ;<br>            if ( ( i != d / i ) && ( n != d / i ) ){<br>                v . add ( d / i ) ;<br>            }<br>        }<br>        i ++ ;<br>    }<br>    for ( int i = 0 ;  i < v . length ;  i ++ ) {<br>        int temp = arr [ 0 ] % v [ i ] ;<br>        int j = 1 ;<br>        while ( ( j < n ) && ( j < arr . length ) ) {<br>            if ( ( arr [ j ] % v [ i ] != temp ) && ( arr [ j ] % v [ i ] != 0 ) ){<br>                break ;<br>            }<br>            j ++ ;<br>        }<br>        if ( ( j == n ) && ( j != 0 ) ) {<br>            System . out . print ( v [ i ] + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SPIRAL_WAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void spiralFill ( int m , int n , int a [ ] [ ] ) {<br>  int val = 1 ;<br>  int k = 0 , l = 0 ;<br>  while ( k < m && l < n ) {<br>    for ( int i = l ;<br>    i < n ;<br>    ++ i ) {<br>      a [ k ] [ i ] = val ++ ;<br>    }<br>    k ++ ;<br>    for ( int i = k ;<br>    i < m ;<br>    ++ i ) {<br>      a [ i ] [ n - 1 ] = val ++ ;<br>    }<br>    n -- ;<br>    if ( k < m ) {<br>      for ( int i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        a [ m - 1 ] [ i ] = val ++ ;<br>      }<br>      m -- ;<br>    }<br>    if ( l < n ) {<br>      for ( int i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        a [ i ] [ l ] = val ++ ;<br>      }<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void spiralFill ( int m , int n , int [ ] [ ] a ) {<br>    int val = 1 ;<br>    int k = 0 , l = 0 ;<br>    while ( ( k < m && l < n ) || ( k < m && l < n ) ) {<br>        for ( int i = l ;  i < n ;{<br>            a [ k ] [ i ] = val ;<br>            val ++ ;<br>        }<br>        k ++ ;<br>        for ( int i = k ;  i < m ;{<br>            a [ i ] [ n - 1 ] = val ;<br>            val ++ ;<br>        }<br>        n -- ;<br>        if ( ( k < m ) && ( k < n ) ){<br>            for ( int i = n - 1 ;  i >= l - 1 ;{<br>                a [ m - 1 ] [ i ] = val ;<br>                val ++ ;<br>            }<br>            m -- ;<br>        }<br>        if ( ( l < n ) && ( l < m ) ){<br>            for ( int i = m - 1 ;  i >= k - 1 ;{<br>                a [ i ] [ l ] = val ;<br>                val ++ ;<br>            }<br>            l ++ ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int xor = arr [ 0 ] ;<br>  int set_bit_no ;<br>  int i ;<br>  int n = size - 2 ;<br>  int x = 0 , y = 0 ;<br>  for ( i = 1 ;<br>  i < size ;<br>  i ++ ) xor ^= arr [ i ] ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) xor ^= i ;<br>  set_bit_no = ( xor & ~ ( xor - 1 ) ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int a = arr [ i ] & set_bit_no ;<br>    if ( a != 0 ) x = x ^ arr [ i ] ;<br>    else y = y ^ arr [ i ] ;<br>  }<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    int a = i & set_bit_no ;<br>    if ( a != 0 ) x = x ^ i ;<br>    else y = y ^ i ;<br>  }<br>  System . out . println ( "The two reppeated elements are :" ) ;<br>  System . out . println ( x + " " + y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>    int xor = arr [ 0 ] ;<br>    int n = size - 2 ;<br>    int x = 0 ;<br>    int y = 0 ;<br>    for ( int i = 1 ;  i < size ;  i ++ ) {<br>        xor ^= arr [ i ++ ] ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        xor ^= i ++ ;<br>    }<br>    int setBitNo = xor & ~ ( xor - 1 ) ;<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        if ( ( arr [ i ] & setBitNo ) != 0 ) {<br>            x = x ^ arr [ i ++ ] ;<br>        }<br>        if ( size > 0 ) {<br>            y = y ^ arr [ i ] ;<br>        }<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( ( i & setBitNo ) != 0 ){<br>            x = x ^ i ;<br>        }<br>        if ( size > 0 ) {<br>            y = y ^ i ;<br>        }<br>    }<br>    System . out . println ( "The two repeating" + "elements are" + y + " and" + x ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_WAYS_TO_CONSTRUCT_BUILDINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int N ) {<br>  if ( N == 1 ) return 4 ;<br>  int countB = 1 , countS = 1 , prev_countB , prev_countS ;<br>  for ( int i = 2 ;<br>  i <= N ;<br>  i ++ ) {<br>    prev_countB = countB ;<br>    prev_countS = countS ;<br>    countS = prev_countB + prev_countS ;<br>    countB = prev_countS ;<br>  }<br>  int result = countS + countB ;<br>  return ( result * result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int N ) {<br>    if ( ( N == 1 ) && ( N > 0 ) ) {<br>        return 4 ;<br>    }<br>    countB = 1 ;<br>    countS = 1 ;<br>    for ( int i = 2 ;  i <= N ;  i ++ ) {<br>        prevCountB = countB ;<br>        prevCountS = countS ;<br>        countS = prevCountB + prevCountS ;<br>        countB = prevCountS ;<br>    }<br>    int result = countS + countB ;<br>    return ( result * result ) ;<br>}</td>
  </tr><tr>
    <th>ONE_LINE_FUNCTION_FOR_FACTORIAL_OF_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int factorial ( int n ) {<br>  return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int factorial ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_MATRIX_SPARSE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSparse ( int array [ ] [ ] , int m , int n ) {<br>  int counter = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  ++ i ) for ( int j = 0 ;<br>  j < n ;<br>  ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ;<br>  return ( counter > ( ( m * n ) / 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSparse ( int [ ] [ ] array , int m , int n ) {<br>    int counter = 0 ;<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( array [ i ] [ j ] == 0 ) && ( array [ j ] [ i ] == 0 ) ) {<br>                counter = counter + 1 ;<br>            }<br>        }<br>    }<br>    return ( counter > ( ( m * n ) / 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , double [ ] wt , double [ ] val , int n ) {<br>    if ( n == 0 || W == 0 ) {<br>        return 0 ;<br>    }<br>    if ( ( wt [ n - 1 ] > W ) && ( wt [ n - 1 ] > val ) ) {<br>        return knapSack ( W , wt , val , n - 1 ) ;<br>    }<br>    else {<br>        return Math . max ( val [ n - 1 ] + knapSack ( W . length - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_SUBARRAY_LEAST_AVERAGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMinAvgSubarray ( int n , int k ) {<br>  if ( n < k ) return ;<br>  int res_index = 0 ;<br>  int curr_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) curr_sum += arr [ i ] ;<br>  int min_sum = curr_sum ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    curr_sum += arr [ i ] - arr [ i - k ] ;<br>    if ( curr_sum < min_sum ) {<br>      min_sum = curr_sum ;<br>      res_index = ( i - k + 1 ) ;<br>    }<br>  }<br>  System . out . println ( "Subarray between [" + res_index + ", " + ( res_index + k - 1 ) + "] has minimum average" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMinAvgSubarray ( int [ ] arr , int n , int k ) {<br>    if ( ( n < k ) && ( n > k ) ) {<br>        return 0 ;<br>    }<br>    int resIndex = 0 ;<br>    int currSum = 0 ;<br>    for ( int i = 0 ;  i < k ;  i ++ ) {<br>        currSum += arr [ i ] ;<br>    }<br>    minSum = currSum ;<br>    for ( int i = k ;  i < n ;  i ++ ) {<br>        currSum += arr [ i ] - arr [ i - k ] ;<br>        if ( ( currSum < minSum ) && ( currSum > 0 ) ) {<br>            minSum = currSum ;<br>            int resIndex = ( i - k + 1 ) ;<br>        }<br>    }<br>    System . out . println ( "Subarray between [" + resIndex + ", " + ( resIndex + k - 1 ) + "] has minimum average" ) ;<br>}</td>
  </tr><tr>
    <th>QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void query ( String s , int i , int j ) {<br>  int n = s . length ( ) ;<br>  i %= n ;<br>  j %= n ;<br>  if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( "Yes" ) ;<br>  else System . out . println ( "No" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void query ( String s , int i , int j ) {<br>    int n = s . length ( ) ;<br>    i %= n ;<br>    j %= n ;<br>    System . out . println ( "Yes" ) ;<br>}</td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void productArray ( int arr [ ] , int n ) {<br>  if ( n == 1 ) {<br>    System . out . print ( "0" ) ;<br>    return ;<br>  }<br>  int i , temp = 1 ;<br>  int prod [ ] = new int [ n ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) prod [ j ] = 1 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    prod [ i ] = temp ;<br>    temp *= arr [ i ] ;<br>  }<br>  temp = 1 ;<br>  for ( i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    prod [ i ] *= temp ;<br>    temp *= arr [ i ] ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( prod [ i ] + " " ) ;<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void productArray ( int [ ] arr , int n ) {<br>    if ( n == 1 ) {<br>        System . out . println ( 0 ) ;<br>        }<br>    }<br>    int i = 1 , temp = 1 ;<br>    int [ ] prod = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        prod [ i ++ ] = temp ;<br>        temp *= arr [ i ] ;<br>    }<br>    int temp = 1 ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        prod [ i ] *= temp ;<br>        temp *= arr [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( prod [ i ] + " " ) ;<br>    }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pairSum ( int mat [ ] [ ] , int n , int sum ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) Arrays . sort ( mat [ i ] ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int left = 0 , right = n - 1 ;<br>      while ( left < n && right >= 0 ) {<br>        if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) {<br>          System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ;<br>          left ++ ;<br>          right -- ;<br>        }<br>        else {<br>          if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ;<br>          else right -- ;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void pairSum ( int [ ] [ ] mat , int n , int sum ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        mat [ i ] . sort ( ) ;<br>    }<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int left = 0 ;<br>            int right = n - 1 ;<br>            while ( ( left < n && right >= 0 ) || ( left < n && right >= 0 ) ) {<br>                if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) && ( ( mat [ i ] [ right ] + mat [ j ] [ left ] ) == sum ) ) {<br>                    System . out . print ( "(" + mat [ i ] [ left ] + ", " + mat [ j ] [ right ] + "), " ) ;<br>                    left ++ ;<br>                    right -- ;<br>                }<br>                if ( sum == 0 ) {<br>                    if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) && ( ( mat [ i ] [ right ] + mat [ j ] [ left ] ) > sum ) ){<br>                        left ++ ;<br>                    }<br>                    if ( sum == 0 ) {<br>                        right -- ;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRotated ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) != str2 . length ( ) ) return false ;<br>  String clock_rot = "" ;<br>  String anticlock_rot = "" ;<br>  int len = str2 . length ( ) ;<br>  anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ;<br>  clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ;<br>  return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRotated ( String str1 , String str2 ) {<br>    if ( ( str1 . length ( ) != str2 . length ( ) ) && ( str1 . length ( ) != str2 . length ( ) ) ) {<br>        return false ;<br>    }<br>    clock_rot = "" ;<br>    anticlockRot = "" ;<br>    int l = str2 . length ( ) ;<br>    anticlockRot = ( anticlockRot + str2 . substring ( l - 2 ) + str2 . substring ( 0 , l - 2 ) ) ;<br>    clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ;<br>    return ( str1 == clock_rot || str1 == anticlock_rot ) ;<br>}</td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  for ( int curr = 1 ;<br>  ;<br>  curr ++ ) {<br>    int sum = 0 ;<br>    for ( int x = curr ;<br>    x > 0 ;<br>    x = x / 10 ) sum = sum + x % 10 ;<br>    if ( sum == 10 ) count ++ ;<br>    if ( count == n ) return curr ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findNth ( int n ) {<br>    int count = 0 ;<br>    for ( int curr = 0 ;  curr < n ;  curr ++ ) {<br>        int sum = 0 ;<br>        int x = curr ;<br>        while ( ( x = n ) != 0 ) {<br>            sum = sum + x % 10 ;<br>            x = x / 10 ;<br>        }<br>        if ( ( sum == 10 ) && ( n > 0 ) ) {<br>            count = count + 1 ;<br>        }<br>        if ( ( count == n ) && ( count > 0 ) ) {<br>            return curr ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_SLOPE_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float slope ( float x1 , float y1 , float x2 , float y2 ) {<br>  return ( y2 - y1 ) / ( x2 - x1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static float slope ( float x1 , float y1 , float x2 , float y2 ) {<br>    return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ;<br>}</td>
  </tr><tr>
    <th>GCD_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int rangeGCD ( int n , int m ) {<br>  return ( n == m ) ? n : 1 ;<br>}<br></td>
    <td>translated code: <br><br> static int rangeGCD ( int n , int m ) {<br>    return n == m ? 1 : ( n == m ? 0 : 1 ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSubarray ( boolean arr [ ] , int n ) {<br>  int count = 1 ;<br>  boolean prev = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( ( arr [ i ] ^ prev ) == false ) {<br>      while ( count > 0 ) {<br>        System . out . print ( count -- + " " ) ;<br>      }<br>    }<br>    ++ count ;<br>    prev = arr [ i ] ;<br>  }<br>  while ( count != 0 ) {<br>    System . out . print ( count -- + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSubarray ( int [ ] arr , int n ) {<br>    int count = 1 ;<br>    int prev = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( ( arr [ i ] ^ prev ) == 0 ) && ( ( arr [ i ] ^ prev ) == 1 ) ) {<br>            while ( ( count -- ) > 0 ) {<br>                System . out . print ( count ++ + " " ) ;<br>                count -- ;<br>            }<br>        }<br>        count ++ ;<br>        int prev = arr [ i ] ;<br>    }<br>    while ( ( count -- ) > 0 ) {<br>        System . out . print ( count ++ + " " ) ;<br>        count -- ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int unitDigitXRaisedY ( int x , int y ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < y ;<br>  i ++ ) res = ( res * x ) % 10 ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int unitDigitXRaisedY ( int x , int y ) {<br>    int res = 1 ;<br>    for ( int i = 0 ;  i < y ;  i ++ ) {<br>        res = ( res * x ) % 10 ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long moduloMultiplication ( long a , long b , long mod ) {<br>  long res = 0 ;<br>  a %= mod ;<br>  while ( b > 0 ) {<br>    if ( ( b & 1 ) > 0 ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( 2 * a ) % mod ;<br>    b >>= 1 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int moduloMultiplication ( int a , int b , int mod ) {<br>    int res = 0 ;<br>    a = a % mod ;<br>    while ( ( b -- ) != 0 ) {<br>        if ( ( b & 1 ) != 0 ){<br>            int res = ( res + a ) % mod ;<br>        }<br>        a = ( 2 * a ) % mod ;<br>        b >>= 1 ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findSmallest ( int m , int s ) {<br>  if ( s == 0 ) {<br>    System . out . print ( m == 1 ? "Smallest number is 0" : "Not possible" ) ;<br>    return ;<br>  }<br>  if ( s > 9 * m ) {<br>    System . out . println ( "Not possible" ) ;<br>    return ;<br>  }<br>  int [ ] res = new int [ m ] ;<br>  s -= 1 ;<br>  for ( int i = m - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( s > 9 ) {<br>      res [ i ] = 9 ;<br>      s -= 9 ;<br>    }<br>    else {<br>      res [ i ] = s ;<br>      s = 0 ;<br>    }<br>  }<br>  res [ 0 ] = s + 1 ;<br>  System . out . print ( "Smallest number is " ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) System . out . print ( res [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findSmallest ( int m , int s ) {<br>    if ( ( s == 0 ) && ( m > 0 ) ) {<br>        if ( ( m == 1 ) && ( s != null ) ) {<br>            System . out . println ( "Smallest number is 0" ) ;<br>        }<br>        if ( m < s ) {<br>            System . out . println ( "Not possible" ) ;<br>        }<br>        return 0 ;<br>    }<br>    if ( ( s > 9 * m ) && ( s < 9 * m ) ) {<br>        System . out . println ( "Not possible" ) ;<br>        return 0 ;<br>    }<br>    int [ ] res = new int [ m + 1 ] ;<br>    s -- ;<br>    for ( int i = m - 1 ;  i > 0 ;  i -- ) {<br>        if ( ( s > 9 ) && ( m > s ) ) {<br>            res [ i ++ ] = 9 ;<br>            s -= 9 ;<br>        }<br>        if ( m < s ) {<br>            res [ i ++ ] = s ;<br>            s = 0 ;<br>        }<br>    }<br>    res [ 0 ] = s + 1 ;<br>    System . out . print ( "Smallest number is " ) ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        System . out . print ( res [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largest ( ) {<br>  int i ;<br>  int max = arr [ 0 ] ;<br>  for ( i = 1 ;<br>  i < arr . length ;<br>  i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int largest ( int [ ] arr , int n ) {<br>    int max = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] > max ){<br>            int max = arr [ i ] ;<br>        }<br>    }<br>    return max ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNums ( int n , int x , int y ) {<br>  boolean [ ] arr = new boolean [ n + 1 ] ;<br>  if ( x <= n ) arr [ x ] = true ;<br>  if ( y <= n ) arr [ y ] = true ;<br>  int result = 0 ;<br>  for ( int i = Math . min ( x , y ) ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( arr [ i ] ) {<br>      if ( i + x <= n ) arr [ i + x ] = true ;<br>      if ( i + y <= n ) arr [ i + y ] = true ;<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNums ( int n , int x , int y ) {<br>    boolean [ ] arr = new boolean [ n + 2 ] ;<br>    if ( ( x <= n ) && ( y <= n ) ) {<br>        arr [ x ] = true ;<br>    }<br>    if ( ( y <= n ) && ( x <= y ) ) {<br>        arr [ y ] = true ;<br>    }<br>    int result = 0 ;<br>    for ( int i = Math . min ( x , y ) ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] ) . length > 0 ) {<br>            if ( ( i + x <= n ) && ( i + y <= n ) ) {<br>                arr [ i + x ] = true ;<br>            }<br>            if ( ( i + y <= n ) && ( i + y <= x ) ) {<br>                arr [ i + y ] = true ;<br>            }<br>            result = result + 1 ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>BUBBLE_SORT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bubbleSort ( int arr [ ] , int n ) {<br>  int i , j , temp ;<br>  boolean swapped ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    swapped = false ;<br>    for ( j = 0 ;<br>    j < n - i - 1 ;<br>    j ++ ) {<br>      if ( arr [ j ] > arr [ j + 1 ] ) {<br>        temp = arr [ j ] ;<br>        arr [ j ] = arr [ j + 1 ] ;<br>        arr [ j + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( swapped == false ) break ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bubbleSort ( int [ ] arr ) {<br>    int n = arr . length ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        swapped = false ;<br>        for ( int j = 0 ;  j <= n - i - 1 ;  j ++ ) {<br>            if ( arr [ j ] > arr [ j + 1 ] ) {<br>                arr [ j ] = arr [ j + 1 ] ;<br>                swapped = true ;<br>            }<br>        }<br>        if ( swapped == false ) {<br>            break ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int maxSum ( int grid [ ] [ ] , int n ) {<br>  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;<br>  int excl = 0 , excl_new ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    excl_new = Math . max ( excl , incl ) ;<br>    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;<br>    excl = excl_new ;<br>  }<br>  return Math . max ( excl , incl ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] [ ] grid , int n ) {<br>    int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;<br>    int excl = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        exclNew = Math . max ( excl , incl ) ;<br>        incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;<br>        Excl excl = exclNew ;<br>    }<br>    return Math . max ( excl , incl ) ;<br>}</td>
  </tr><tr>
    <th>GCD_FACTORIALS_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int gcdOfFactorial ( int m , int n ) {<br>  int min = m < n ? m : n ;<br>  return factorial ( min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double gcdOfFactorial ( int m , int n ) {<br>    return Math . factorial ( Math . min ( m , n ) ) ;<br>}</td>
  </tr><tr>
    <th>AREA_OF_A_SECTOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void SectorArea ( double radius , double angle ) {<br>  if ( angle >= 360 ) System . out . println ( "Angle not possible" ) ;<br>  else {<br>    double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ;<br>    System . out . println ( sector ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void SectorArea ( int radius , int angle ) {<br>    double pi = 22 / 7 ;<br>    if ( angle >= 360 ) {<br>        System . out . println ( "Angle not possible" ) ;<br>        return null ;<br>    }<br>    else {<br>        double sector = ( Math . PI * radius * radius ) * ( angle / 360 ) ;<br>        System . out . println ( sector ) ;<br>        return null ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSeq ( int n ) {<br>  int nCr = 1 , res = 1 ;<br>  for ( int r = 1 ;<br>  r <= n ;<br>  r ++ ) {<br>    nCr = ( nCr * ( n + 1 - r ) ) / r ;<br>    res += nCr * nCr ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSeq ( int n ) {<br>    int nCr = 1 ;<br>    int res = 1 ;<br>    for ( int r = 1 ;  r <= n ;  r ++ ) {<br>        nCr = ( nCr * ( n + 1 - r ) ) / r ;<br>        res += nCr * nCr ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLength ( String str ) {<br>  int n = str . length ( ) ;<br>  int maxlen = 0 ;<br>  int sum [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ;<br>  for ( int len = 2 ;<br>  len <= n ;<br>  len ++ ) {<br>    for ( int i = 0 ;<br>    i < n - len + 1 ;<br>    i ++ ) {<br>      int j = i + len - 1 ;<br>      int k = len / 2 ;<br>      sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ;<br>      if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ;<br>    }<br>  }<br>  return maxlen ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string ) {<br>    int n = string . length ( ) ;<br>    int maxlen = 0 ;<br>    int [ ] Sum = new int [ n ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        Sum [ i ] [ i ] = Integer . parseInt ( string . substring ( i ) ) ;<br>    }<br>    for ( int length = 2 ;  length <= n ;  length ++ ) {<br>        for ( int i = 0 ;  i <= n - length + 1 ;  i ++ ) {<br>            int j = i + length - 1 ;<br>            int k = length / 2 ;<br>            Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) ;<br>            if ( ( length % 2 == 0 && Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] && length > maxlen ) ){<br>                maxlen = length ;<br>            }<br>        }<br>    }<br>    return maxlen ;<br>}</td>
  </tr><tr>
    <th>SWAP_ALL_ODD_AND_EVEN_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int swapBits ( int x ) {<br>  int even_bits = x & 0xAAAAAAAA ;<br>  int odd_bits = x & 0x55555555 ;<br>  even_bits >>= 1 ;<br>  odd_bits <<= 1 ;<br>  return ( even_bits | odd_bits ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int swapBits ( int x ) {<br>    evenBits = x & 0xAAAAAAAA ;<br>    odd_bits = x & 0x55555555 ;<br>    evenBits >>= 1 ;<br>    odd_bits <<= 1 ;<br>    return ( evenBits | oddBits ) ;<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void sortInWave ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i += 2 ) swap ( arr , i , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void sortInWave ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i < n - 1 ;  i += 2 ) {<br>        arr [ i ] = arr [ i + 1 ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double compute ( int a , int b ) {<br>  double AM , GM , HM ;<br>  AM = ( a + b ) / 2 ;<br>  GM = Math . sqrt ( a * b ) ;<br>  HM = ( GM * GM ) / AM ;<br>  return HM ;<br>}<br></td>
    <td>translated code: <br><br> public static double compute ( double a , double b ) {<br>    AM = ( a + b ) / 2 ;<br>    double GM = Math . sqrt ( a * b ) ;<br>    HM = ( GM * GM ) / AM ;<br>    return new HM ( ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_BALANCED_BINARY_TREES_HEIGHT_H</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long countBT ( int h ) {<br>  long [ ] dp = new long [ h + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= h ;<br>  ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ;<br>  return dp [ h ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countBT ( int h ) {<br>    MOD = 1000000007 ;<br>    int [ ] dp = new int [ h + 1 ] ;<br>    dp [ 0 ] = 1 ;<br>    dp [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= h ;  i ++ ) {<br>        dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ;<br>    }<br>    return dp [ h ] ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInsertion ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = 0 ;<br>  int [ ] count = new int [ 26 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < 26 ;<br>  i ++ ) {<br>    if ( count [ i ] % 2 == 1 ) res ++ ;<br>  }<br>  return ( res == 0 ) ? 0 : res - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInsertion ( String tr1 ) {<br>    int n = str1 . length ( ) ;<br>    int res = 0 ;<br>    int [ ] count = new int [ 26 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        count [ ( int ) str1 . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < 26 ;  i ++ ) {<br>        if ( ( count [ i ] % 2 == 1 ) && ( count [ i ] % 3 == 0 ) ){<br>            res ++ ;<br>        }<br>    }<br>    if ( ( res == 0 ) && ( a . intValue ( ) == 5 ) ) {<br>        return 0 ;<br>    }<br>    }<br>        return res - 1 ;<br>}</td>
  </tr><tr>
    <th>SHUFFLE_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void randomize ( int arr [ ] , int n ) {<br>  Random r = new Random ( ) ;<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  i -- ) {<br>    int j = r . nextInt ( i + 1 ) ;<br>    int temp = arr [ i ] ;<br>    arr [ i ] = arr [ j ] ;<br>    arr [ j ] = temp ;<br>  }<br>  System . out . println ( Arrays . toString ( arr ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] randomize ( int [ ] arr , int n ) {<br>    for ( int i = n - 1 ;  i > 0 ;  i -- ) {<br>        int j = random . nextInt ( i + 1 ) ;<br>        arr [ i ] = arr [ j ] ;<br>    }<br>    return randomize ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>UGLY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getNthUglyNo ( int n ) {<br>  int ugly [ ] = new int [ n ] ;<br>  int i2 = 0 , i3 = 0 , i5 = 0 ;<br>  int next_multiple_of_2 = 2 ;<br>  int next_multiple_of_3 = 3 ;<br>  int next_multiple_of_5 = 5 ;<br>  int next_ugly_no = 1 ;<br>  ugly [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    next_ugly_no = Math . min ( next_multiple_of_2 , Math . min ( next_multiple_of_3 , next_multiple_of_5 ) ) ;<br>    ugly [ i ] = next_ugly_no ;<br>    if ( next_ugly_no == next_multiple_of_2 ) {<br>      i2 = i2 + 1 ;<br>      next_multiple_of_2 = ugly [ i2 ] * 2 ;<br>    }<br>    if ( next_ugly_no == next_multiple_of_3 ) {<br>      i3 = i3 + 1 ;<br>      next_multiple_of_3 = ugly [ i3 ] * 3 ;<br>    }<br>    if ( next_ugly_no == next_multiple_of_5 ) {<br>      i5 = i5 + 1 ;<br>      next_multiple_of_5 = ugly [ i5 ] * 5 ;<br>    }<br>  }<br>  return next_ugly_no ;<br>}<br></td>
    <td>translated code: <br><br> public static int getNthUglyNo ( int n ) {<br>    ugly = new int [ n ] ;<br>    ugly [ 0 ] = 1 ;<br>    int i2 = i3 = i5 = 0 ;<br>    nextMultipleOf2 = 2 ;<br>    nextMultipleOf3 = 3 ;<br>    nextMultipleOf5 = 5 ;<br>    for ( int l = 1 ;  l <= n ;  l ++ ) {<br>        ugly [ l ++ ] = Math . min ( nextMultipleOf2 , nextMultipleOf3 , nextMultipleOf5 ) ;<br>        if ( ugly [ l ] == next_multiple_of_2 ) {<br>            i2 ++ ;<br>            nextMultipleOf2 = ugly [ i2 ] * 2 ;<br>        }<br>        if ( ugly [ l ] == next_multiple_of_3 ) {<br>            i3 ++ ;<br>            nextMultipleOf3 = ugly [ i3 ] * 3 ;<br>        }<br>        if ( ugly [ l ] == next_multiple_of_5 ) {<br>            i5 ++ ;<br>            int nextMultipleOf5 = ugly [ i5 ] * 5 ;<br>        }<br>    }<br>    return ugly [ ugly . length - 1 ] ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_CUT_BOARD_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) {<br>  int res = 0 ;<br>  Arrays . sort ( X , Collections . reverseOrder ( ) ) ;<br>  Arrays . sort ( Y , Collections . reverseOrder ( ) ) ;<br>  int hzntl = 1 , vert = 1 ;<br>  int i = 0 , j = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( X [ i ] > Y [ j ] ) {<br>      res += X [ i ] * vert ;<br>      hzntl ++ ;<br>      i ++ ;<br>    }<br>    else {<br>      res += Y [ j ] * hzntl ;<br>      vert ++ ;<br>      j ++ ;<br>    }<br>  }<br>  int total = 0 ;<br>  while ( i < m ) total += X [ i ++ ] ;<br>  res += total * vert ;<br>  total = 0 ;<br>  while ( j < n ) total += Y [ j ++ ] ;<br>  res += total * hzntl ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double minimumCostOfBreaking ( double [ ] X , double [ ] Y , int m , int n ) {<br>    int res = 0 ;<br>    Arrays . sort ( X , 0 , m , n ) ;<br>    Arrays . sort ( X , 0 , m , n ) ;<br>    int hzntl = 1 ;<br>    int i = 0 ;<br>    while ( ( i < m && j < n ) || ( i < n && j < m && i < m && j < n ) ) {<br>        if ( ( X [ i ] > Y [ j ] ) && ( X [ j ] > Y [ i ] ) ) {<br>            res += X [ i ] * vert ;<br>            hzntl ++ ;<br>            i ++ ;<br>        }<br>        if ( m > 0 ) {<br>            res += Y [ j ] * hzntl ;<br>            vert ++ ;<br>            j ++ ;<br>        }<br>    }<br>    int total = 0 ;<br>    while ( ( i < m ) && ( i < n ) ) {<br>        total += X [ i ] [ m ] ;<br>        i ++ ;<br>    }<br>    res += total * vert ;<br>    int total = 0 ;<br>    while ( ( j < n ) && ( j < m ) ) {<br>        total += Y [ j ] ;<br>        j ++ ;<br>    }<br>    res += total * hzntl ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>    K = new int [ W + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int w = 0 ;  w < W + 1 ;  w ++ ) {<br>            if ( i == 0 || w == 0 ){<br>                K [ i ] [ w ] = 0 ;<br>            }<br>            else if ( wt [ i - 1 ] <= w ){<br>                K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>            }<br>            else {<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>            }<br>        }<br>    }<br>    return K [ n ] [ W ] ;<br>}</td>
  </tr><tr>
    <th>STACK_PERMUTATIONS_CHECK_IF_AN_ARRAY_IS_STACK_PERMUTATION_OF_OTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkStackPermutation ( int ip [ ] , int op [ ] , int n ) {<br>  Queue < Integer > input = new LinkedList < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    input . add ( ip [ i ] ) ;<br>  }<br>  Queue < Integer > output = new LinkedList < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    output . add ( op [ i ] ) ;<br>  }<br>  Stack < Integer > tempStack = new Stack < > ( ) ;<br>  while ( ! input . isEmpty ( ) ) {<br>    int ele = input . poll ( ) ;<br>    if ( ele == output . peek ( ) ) {<br>      output . poll ( ) ;<br>      while ( ! tempStack . isEmpty ( ) ) {<br>        if ( tempStack . peek ( ) == output . peek ( ) ) {<br>          tempStack . pop ( ) ;<br>          output . poll ( ) ;<br>        }<br>        else break ;<br>      }<br>    }<br>    else {<br>      tempStack . push ( ele ) ;<br>    }<br>  }<br>  return ( input . isEmpty ( ) && tempStack . isEmpty ( ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkStackPermutation ( int [ ] ip , int [ ] op , int n ) {<br>    Queue < Integer > Input = new LinkedList < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        Input . put ( ip [ i ] ) ;<br>    }<br>    Queue < Integer > output = new LinkedList < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        output . put ( op [ i ] ) ;<br>    }<br>    int [ ] tempStack = new int [ n ] ;<br>    while ( ( ! Input . isEmpty ( ) ) && ( ip [ 0 ] == op ) && ( ip [ 1 ] == op ) && ( ip [ 2 ] == op ) && ( ip [ 3 ] == op ) ) {<br>        int ele = Input . queue . get ( 0 ) ;<br>        Input . get ( ) ;<br>        if ( ( ele == output . queue . get ( 0 ) ) && ( op == output . queue . get ( 1 ) ) && ( n == output . queue . get ( 2 ) ) ) {<br>            output . get ( ) ;<br>            while ( ( tempStack . size ( ) != 0 ) && ( ip < tempStack . size ( ) ) ) {<br>                if ( ( tempStack . get ( tempStack . size ( ) - 1 ) == output . queue . get ( 0 ) ) && ( ip == ip + n ) ){<br>                    tempStack . pop ( ) ;<br>                    output . get ( ) ;<br>                }<br>                if ( ip . length > n ) {<br>                    break ;<br>                }<br>            }<br>        }<br>        if ( ip . length > n ) {<br>            tempStack . add ( ele ) ;<br>        }<br>    }<br>    return ( Input . isEmpty ( ) && tempStack . length == 0 ) ;<br>}</td>
  </tr><tr>
    <th>PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double procal ( int n ) {<br>  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double procal ( double n ) {<br>    return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;<br>}</td>
  </tr><tr>
    <th>REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String simplify ( String str ) {<br>  int len = str . length ( ) ;<br>  char res [ ] = new char [ len ] ;<br>  int index = 0 , i = 0 ;<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  s . push ( 0 ) ;<br>  while ( i < len ) {<br>    if ( str . charAt ( i ) == '+' ) {<br>      if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ;<br>      if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ;<br>    }<br>    else if ( str . charAt ( i ) == '-' ) {<br>      if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ;<br>      else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ;<br>    }<br>    else if ( str . charAt ( i ) == '(' && i > 0 ) {<br>      if ( str . charAt ( i - 1 ) == '-' ) {<br>        int x = ( s . peek ( ) == 1 ) ? 0 : 1 ;<br>        s . push ( x ) ;<br>      }<br>      else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s . peek ( ) ) ;<br>    }<br>    else if ( str . charAt ( i ) == ')' ) s . pop ( ) ;<br>    else res [ index ++ ] = str . charAt ( i ) ;<br>    i ++ ;<br>  }<br>  return new String ( res ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String simplify ( String Str ) {<br>    int Len = Str . length ( ) ;<br>    String [ ] res = new String [ Len ] ;<br>    int index = 0 ;<br>    int i = 0 ;<br>    StringBuilder sb = new StringBuilder ( ) ;<br>    s . add ( 0 ) ;<br>    while ( ( i < Len ) && ( i < Len ) ) {<br>        if ( ( Str . charAt ( i ) == '+' ) && ( Str . charAt ( i + 1 ) == '-' ) ) {<br>            if ( ( s . charAt ( s . length ( ) - 1 ) == 1 ) && ( s . charAt ( s . length ( ) - 2 ) == 1 ) ) {<br>                res [ index ++ ] = '-' ;<br>                index ++ ;<br>            }<br>            if ( ( s . charAt ( s . length ( ) - 1 ) == 0 ) && ( s . charAt ( s . length ( ) - 1 ) == 1 ) ) {<br>                res [ index ++ ] = '+' ;<br>                index ++ ;<br>            }<br>        }<br>        if ( ( Str . charAt ( i ) == '-' ) && ( Str . charAt ( i + 1 ) == '-' ) ) {<br>            if ( ( s . charAt ( s . length ( ) - 1 ) == 1 ) && ( s . charAt ( s . length ( ) - 2 ) == 1 ) ) {<br>                res [ index ++ ] = '+' ;<br>                index ++ ;<br>            }<br>            if ( ( s . charAt ( s . length ( ) - 1 ) == 0 ) && ( s . charAt ( s . length ( ) - 1 ) == 1 ) ) {<br>                res [ index ++ ] = '-' ;<br>                index ++ ;<br>            }<br>        }<br>        if ( ( Str . charAt ( i ) == '(' ) && i > 0 ) {<br>            if ( ( Str . charAt ( i - 1 ) == '-' ) && ( Str . charAt ( i - 2 ) == '-' ) ) {<br>                int x = Str . length ( ) == 0 ? 1 : 0 ;<br>                s . add ( x ) ;<br>            }<br>            else if ( ( Str . charAt ( i - 1 ) == '+' ) && ( Str . charAt ( i - 2 ) == '-' ) ) {<br>                s . add ( s . charAt ( s . length ( ) - 1 ) ) ;<br>            }<br>        }<br>        if ( ( Str . charAt ( i ) == ')' ) && ( Str . charAt ( i + 1 ) == '(' ) ) {<br>            s . remove ( ) ;<br>        }<br>        if ( Str == null ) {  }  else {<br>            res [ index ++ ] = Str . charAt ( i ++ ) ;<br>            index ++ ;<br>        }<br>        i ++ ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSquares ( int a , int b ) {<br>  int cnt = 0 ;<br>  for ( int i = a ;<br>  i <= b ;<br>  i ++ ) for ( int j = 1 ;<br>  j * j <= i ;<br>  j ++ ) if ( j * j == i ) cnt ++ ;<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountSquares ( int a , int b ) {<br>    int cnt = 0 ;<br>    for ( int i = a ;  i <= b ;  i ++ ) {<br>        int j = 1 ;<br>        while ( j * j <= i ){<br>            if ( j * j == i ){<br>                cnt = cnt + 1 ;<br>            }<br>            j = j + 1 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    return cnt ;<br>}</td>
  </tr><tr>
    <th>K_NUMBERS_DIFFERENCE_MAXIMUM_MINIMUM_K_NUMBER_MINIMIZED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minDiff ( int arr [ ] , int n , int k ) {<br>  int result = Integer . MAX_VALUE ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i <= n - k ;<br>  i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDiff ( int [ ] arr , int n , int k ) {<br>    int result = + 2147483647 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i < n - k + 1 ;  i ++ ) {<br>        int result = ( int ) Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkDivisibility ( String num ) {<br>  int length = num . length ( ) ;<br>  if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( length % 3 == 1 ) {<br>    num += "00" ;<br>    length += 2 ;<br>  }<br>  else if ( length % 3 == 2 ) {<br>    num += "0" ;<br>    length += 1 ;<br>  }<br>  int sum = 0 , p = 1 ;<br>  for ( int i = length - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int group = 0 ;<br>    group += num . charAt ( i -- ) - '0' ;<br>    group += ( num . charAt ( i -- ) - '0' ) * 10 ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    sum = sum + group * p ;<br>    p *= ( - 1 ) ;<br>  }<br>  sum = Math . abs ( sum ) ;<br>  return ( sum % 13 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkDivisibility ( String num ) {<br>    int length = num . length ( ) ;<br>    if ( ( length == 1 && num . charAt ( 0 ) == '0' ) || ( length == 2 && num . charAt ( 0 ) == '1' ) ) {<br>        return checkDivisibility ( num , false ) ;<br>    }<br>    if ( ( length % 3 == 1 ) && ( num % 2 == 1 ) ) {<br>        num = Integer . toString ( num ) + "00" ;<br>        length += 2 ;<br>    }<br>    }<br>        num = String . valueOf ( num ) + "0" ;<br>        length ++ ;<br>    int sum = 0 ;<br>    int p = 1 ;<br>    for ( int i = length - 1 ;  i >= 0 ;  i -- ) {<br>        int group = 0 ;<br>        group += ( char ) num . charAt ( i ++ ) - '0' ;<br>        i -- ;<br>        group += ( ( char ) num . charAt ( i ++ ) - '0' ) * 10 ;<br>        i -- ;<br>        group += ( ( char ) num . charAt ( i ++ ) - '0' ) * 100 ;<br>        sum = sum + group * p ;<br>        p *= ( - 1 ) ;<br>    }<br>    sum = Math . abs ( sum ) ;<br>    return ( sum % 13 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSumSimple ( int mat [ ] [ ] , int k ) {<br>  if ( k > n ) return ;<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      int sum = 0 ;<br>      for ( int p = i ;<br>      p < k + i ;<br>      p ++ ) for ( int q = j ;<br>      q < k + j ;<br>      q ++ ) sum += mat [ p ] [ q ] ;<br>      System . out . print ( sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSumSimple ( int [ ] [ ] mat , int k ) {<br>    if ( ( k > n ) && ( k < k + 1 ) ){<br>        return ;<br>    }<br>    for ( int i = 0 ;  i < n - k + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n - k + 1 ;  j ++ ) {<br>            double sum = 0 ;<br>            for ( int p = i ;  p <= k + i ;  p ++ ) {<br>                for ( int q = j ;  q <= k + j ;  q ++ ) {<br>                    sum += mat [ p ] [ q ] ;<br>                }<br>            }<br>            System . out . print ( sum + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void maxOverlap ( int [ ] start , int [ ] end , int n ) {<br>  int maxa = Arrays . stream ( start ) . max ( ) . getAsInt ( ) ;<br>  int maxb = Arrays . stream ( end ) . max ( ) . getAsInt ( ) ;<br>  int maxc = Math . max ( maxa , maxb ) ;<br>  int [ ] x = new int [ maxc + 2 ] ;<br>  Arrays . fill ( x , 0 ) ;<br>  int cur = 0 , idx = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    ++ x [ start [ i ] ] ;<br>    -- x [ end [ i ] + 1 ] ;<br>  }<br>  int maxy = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i <= maxc ;<br>  i ++ ) {<br>    cur += x [ i ] ;<br>    if ( maxy < cur ) {<br>      maxy = cur ;<br>      idx = i ;<br>    }<br>  }<br>  System . out . println ( "Maximum value is:" + maxy + " at position: " + idx + "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maxOverlap ( int [ ] start , int [ ] end ) {<br>    int n = start . length ( ) ;<br>    maxa = Math . max ( start , end ) ;<br>    maxb = Math . max ( end , start ) ;<br>    maxc = Math . max ( maxa , maxb ) ;<br>    int x = ( maxc + 2 ) * new int [ ] {<br>    }<br>    int cur = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        x [ start [ i ] ] ++ ;<br>        x [ end [ i ] + 1 ] -- ;<br>    }<br>    maxy = - 1 ;<br>    for ( int i = 0 ;  i <= maxc ;  i ++ ) {<br>        cur += x [ i ] ;<br>        if ( maxy < cur ){<br>            maxy = cur ;<br>            idx = i ;<br>        }<br>    }<br>    System . out . println ( "Maximum value is:{<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumWO3Consec ( int n ) {<br>  if ( sum [ n ] != - 1 ) return sum [ n ] ;<br>  if ( n == 0 ) return sum [ n ] = 0 ;<br>  if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;<br>  if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;<br>  return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumWO3Consec ( int n ) {<br>    if ( ( sum [ n ] != - 1 ) && ( sum [ n ] != - 2 ) ) {<br>        return sum [ n ] ;<br>    }<br>    if ( ( n == 0 ) && ( n > 1 ) ) {<br>        sum [ n ] = 0 ;<br>        return sum [ n ] ;<br>    }<br>    if ( ( n == 1 ) || ( n == 2 ) ) {<br>        sum [ n ] = arr [ 0 ] ;<br>        return sum [ n ] ;<br>    }<br>    if ( ( n == 2 ) && ( n == 3 ) ) {<br>        sum [ n ] = arr [ 1 ] + arr [ 0 ] ;<br>        return sum [ n ] ;<br>    }<br>    sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ;<br>    return sum [ n ] ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_ADDITION_TWO_MATRICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < N ;<br>  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void add ( int [ ] [ ] A , int [ ] [ ] B , int [ ] [ ] C ) {<br>    for ( int i = 0 ;  i < N ;{<br>        for ( int j = 0 ;  j < N ;{<br>            C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxAverage ( int arr [ ] , int n , int k ) {<br>  if ( k > n ) return - 1 ;<br>  int sum = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < k ;<br>  i ++ ) sum += arr [ i ] ;<br>  int max_sum = sum , max_end = k - 1 ;<br>  for ( int i = k ;<br>  i < n ;<br>  i ++ ) {<br>    sum = sum + arr [ i ] - arr [ i - k ] ;<br>    if ( sum > max_sum ) {<br>      max_sum = sum ;<br>      max_end = i ;<br>    }<br>  }<br>  return max_end - k + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxAverage ( int [ ] arr , int n , int k ) {<br>    if ( ( k > n ) && ( k < n ) ) {<br>        return - 1 ;<br>    }<br>    int sum = arr [ 0 ] ;<br>    for ( int i = 1 ;  i <= k ;  i ++ ) {<br>        sum += arr [ i ] ;<br>    }<br>    maxSum = sum ;<br>    int maxEnd = k - 1 ;<br>    for ( int i = k ;  i < n ;  i ++ ) {<br>        sum = sum + arr [ i ] - arr [ i - k ] ;<br>        if ( ( sum > maxSum ) && ( sum < maxSum ) ) {<br>            maxSum = sum ;<br>            int maxEnd = i ;<br>        }<br>    }<br>    return maxEnd - k + 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void center ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( float ) ( y1 + y2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void center ( int x1 , int x2 , int y1 , int y2 ) {<br>    System . out . print ( ( int ) ( ( x1 + x2 ) / 2 ) + " " ) ;<br>    System . out . print ( "," + ( int ) ( ( y1 + y2 ) / 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNonDecreasing ( int n ) {<br>  int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) dp [ i ] [ 1 ] = 1 ;<br>  for ( int digit = 0 ;<br>  digit <= 9 ;<br>  digit ++ ) {<br>    for ( int len = 2 ;<br>    len <= n ;<br>    len ++ ) {<br>      for ( int x = 0 ;<br>      x <= digit ;<br>      x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ;<br>    }<br>  }<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) count += dp [ i ] [ n ] ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonDecreasing ( int n ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < 10 ;  i ++ ) {<br>        dp [ i ] [ 1 ] = 1 ;<br>    }<br>    for ( int digit = 0 ;  digit < 10 ;  digit ++ ) {<br>        for ( int len = 2 ;  len <= n ;  len ++ ) {<br>            for ( int x = 0 ;  x < digit + 1 ;  x ++ ) {<br>                dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ;<br>            }<br>        }<br>    }<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < 10 ;  i ++ ) {<br>        count += dp [ i ] [ n ] ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>PRINT_REVERSE_STRING_REMOVING_VOWELS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void replaceOriginal ( String s , int n ) {<br>  char r [ ] = new char [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    r [ i ] = s . charAt ( n - 1 - i ) ;<br>    if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) {<br>      System . out . print ( r [ i ] ) ;<br>    }<br>  }<br>  System . out . println ( "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void replaceOriginal ( String s , int n ) {<br>    StringBuilder r = new StringBuilder ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        r [ i ] = s . charAt ( n - 1 - i ) ;<br>        if ( ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) || ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) ){<br>            System . out . print ( r [ i ] + " " ) ;<br>        }<br>    }<br>    System . out . println ( ) ;<br>}</td>
  </tr><tr>
    <th>FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMissing ( int a [ ] , int b [ ] , int n , int m ) {<br>  HashSet < Integer > s = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) s . add ( b [ i ] ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMissing ( int [ ] a , int [ ] b , int n , int m ) {<br>    Map < Integer , Integer > s = Collections . < Integer , Integer > emptyMap ( ) ;<br>    for ( int i = 0 ;  i < m ;{<br>        s [ b [ i ] ] = 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;{<br>        if ( a [ i ] != s . length ) a [ i ] = 5 ;<br>            System . out . print ( a [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStr ( int n , int bCount , int cCount ) {<br>  if ( bCount < 0 || cCount < 0 ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  if ( bCount == 0 && cCount == 0 ) return 1 ;<br>  int res = countStr ( n - 1 , bCount , cCount ) ;<br>  res += countStr ( n - 1 , bCount - 1 , cCount ) ;<br>  res += countStr ( n - 1 , bCount , cCount - 1 ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStr ( int n , int bCount , int cCount ) {<br>    if ( ( bCount < 0 || cCount < 0 ) && ( n < 5 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n == 0 ) && ( bCount > 0 ) ) {<br>        return 1 ;<br>    }<br>    if ( ( bCount == 0 && cCount == 0 ) || ( bCount == 1 && cCount == 1 ) ) {<br>        return 1 ;<br>    }<br>    String res = countStr ( n - 1 , bCount , cCount ) ;<br>    res += countStr ( n - 1 , bCount - 1 , cCount ) ;<br>    res += countStr ( n - 1 , bCount , cCount - 1 ) ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>GOLD_MINE_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMaxGold ( int gold [ ] [ ] , int m , int n ) {<br>  int goldTable [ ] [ ] = new int [ m ] [ n ] ;<br>  for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ;<br>  for ( int col = n - 1 ;<br>  col >= 0 ;<br>  col -- ) {<br>    for ( int row = 0 ;<br>    row < m ;<br>    row ++ ) {<br>      int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ;<br>      int right_up = ( row == 0 || col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ;<br>      int right_down = ( row == m - 1 || col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ;<br>      goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ;<br>      ;<br>    }<br>  }<br>  int res = goldTable [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMaxGold ( int [ ] [ ] gold , int m , int n ) {<br>    int goldTable [ ] = new int [ n ] ;<br>    for ( int col = n - 1 ;  col >= 0 ;  col -- ) {<br>        for ( int row = 0 ;  row < m ;  row ++ ) {<br>            if ( ( col == n - 1 ) && ( gold [ col ] > 0 ) ) {<br>                int right = 0 ;<br>            }<br>            else {<br>                right = goldTable [ row ] [ col + 1 ] ;<br>            }<br>            if ( ( row == 0 || col == n - 1 ) && ( col == m - 1 || row == n - 1 ) ) {<br>                int rightUp ;<br>            }<br>            else {<br>                int rightUp = goldTable [ row - 1 ] [ col + 1 ] ;<br>            }<br>            if ( ( row == m - 1 || col == n - 1 ) && ( gold == 0 || gold == 1 ) ) {<br>                rightDown = 0 ;<br>            }<br>            else {<br>                rightDown = goldTable [ row + 1 ] [ col + 1 ] ;<br>            }<br>            goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , rightUp , rightDown ) ;<br>        }<br>    }<br>    int res = goldTable [ 0 ] [ 0 ] ;<br>    for ( int i = 1 ;  i < m ;  i ++ ) {<br>        res = Math . max ( res , goldTable [ i ] [ 0 ] ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countWays ( int n ) {<br>  long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ;<br>  dp [ 0 ] [ 1 ] = 1 ;<br>  dp [ 1 ] [ 1 ] = 2 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;<br>    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ;<br>  }<br>  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>    int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ;<br>    dp [ 0 ] [ 1 ] = 1 ;<br>    dp [ 1 ] [ 1 ] = 2 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;<br>        dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ;<br>    }<br>    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int getFirstSetBitPos ( int n ) {<br>  return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getFirstSetBitPos ( int n ) {<br>    return MathUtils . log2 ( n & - n ) + 1 ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longestSubseqWithK ( String str , int k ) {<br>  int n = str . length ( ) ;<br>  int freq [ ] = new int [ MAX_CHARS ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    freq [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( freq [ str . charAt ( i ) - 'a' ] >= k ) {<br>      System . out . print ( str . charAt ( i ) ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void longestSubseqWithK ( String str , int k ) {<br>    int n = str . length ( ) ;<br>    int [ ] freq = new int [ MAX_CHARS ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        freq [ ( int ) str . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( freq [ ( int ) str . charAt ( i ) - 'a' ] >= k ) && ( freq [ ( int ) str . charAt ( i ) - 'a' ] <= k ) ){<br>            System . out . print ( str . charAt ( i ++ ) + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>POSSIBLE_TO_MAKE_A_DIVISIBLE_BY_3_NUMBER_USING_ALL_DIGITS_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isPossibleToMakeDivisible ( int arr [ ] , int n ) {<br>  int remainder = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) remainder = ( remainder + arr [ i ] ) % 3 ;<br>  return ( remainder == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossibleToMakeDivisible ( int [ ] arr , int n ) {<br>    int remainder = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        remainder = ( remainder + arr [ i ] ) % 3 ;<br>    }<br>    return ( remainder == 0 ) ? true : false ;<br>}</td>
  </tr><tr>
    <th>AREA_SQUARE_CIRCUMSCRIBED_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_Area ( int r ) {<br>  return ( 2 * r * r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findArea ( int r ) {<br>    return ( 2 * r * r ) ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = i ;<br>  j <= m ;<br>  j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ;<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static double MaxDotProduct ( double [ ] A , double [ ] B , int m , int n ) {<br>    double [ ] dp = new double [ m + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i += 1 ) {<br>        for ( int j = i ;  j <= m ;{<br>            dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ;<br>        }<br>    }<br>    return dp [ n ] [ m ] ;<br>}</td>
  </tr><tr>
    <th>FIND_DISTINCT_SUBSET_SUBSEQUENCE_SUMS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistSum ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = true ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i - 1 ] ] = true ;<br>    for ( int j = 1 ;<br>    j <= sum ;<br>    j ++ ) {<br>      if ( dp [ i - 1 ] [ j ] == true ) {<br>        dp [ i ] [ j ] = true ;<br>        dp [ i ] [ j + arr [ i - 1 ] ] = true ;<br>      }<br>    }<br>  }<br>  for ( int j = 0 ;<br>  j <= sum ;<br>  j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDistSum ( int [ ] arr , int n ) {<br>    int Sum = sum ( arr ) ;<br>    int [ ] [ ] dp = new int [ Sum + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        dp [ i ] [ 0 ] = true ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        dp [ i ] [ arr [ i - 1 ] ] = true ;<br>        for ( int j = 1 ;  j <= Sum + 1 ;  j ++ ) {<br>            if ( ( dp [ i - 1 ] [ j ] == true ) && ( dp [ i - 1 ] [ j ] == false ) ) {<br>                dp [ i ] [ j ] = true ;<br>                dp [ i ] [ j + arr [ i - 1 ] ] = true ;<br>            }<br>        }<br>    }<br>    for ( int j = 0 ;  j < Sum + 1 ;  j ++ ) {<br>        if ( ( dp [ n ] [ j ] == true ) && ( arr [ n ] [ j ] != 0 ) ) {<br>            System . out . print ( j + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void splitString ( String str ) {<br>  StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ;<br>    else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ;<br>    else special . append ( str . charAt ( i ) ) ;<br>  }<br>  System . out . println ( alpha ) ;<br>  System . out . println ( num ) ;<br>  System . out . println ( special ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void splitString ( String str ) {<br>    String alpha = "" ;<br>    String num = "" ;<br>    special = "" ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == 'a' ) && ( str . charAt ( i + 1 ) == 'z' ) ) {<br>            num = num + str . charAt ( i ) ;<br>        }<br>        else if ( ( ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) || ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) ) ) {<br>            alpha += str . charAt ( i ) ;<br>        }<br>        else {<br>            special += str . charAt ( i ) ;<br>        }<br>    }<br>    System . out . println ( alpha ) ;<br>    System . out . println ( num ) ;<br>    System . out . println ( special ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxAlternateSum ( int arr [ ] , int n ) {<br>  if ( n == 1 ) return arr [ 0 ] ;<br>  int dec [ ] = new int [ n ] ;<br>  int inc [ ] = new int [ n ] ;<br>  dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;<br>  int flag = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( arr [ j ] > arr [ i ] ) {<br>        dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ;<br>        flag = 1 ;<br>      }<br>      else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ;<br>    }<br>  }<br>  int result = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( result < inc [ i ] ) result = inc [ i ] ;<br>    if ( result < dec [ i ] ) result = dec [ i ] ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxAlternateSum ( int [ ] arr , int n ) {<br>    if ( ( n == 1 ) && ( arr [ 0 ] == 1 ) ) {<br>        return maxAlternateSum ( arr , 0 , n ) ;<br>    }<br>    int [ ] dec = new int [ n + 1 ] ;<br>    int [ ] inc = new int [ n + 1 ] ;<br>    dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;<br>    int flag = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ j ] > arr [ i ] ) && ( arr [ j ] > arr [ i ] ) ) {<br>                dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ;<br>                flag = 1 ;<br>            }<br>            else if ( ( arr [ j ] < arr [ i ] && flag == 1 ) || ( arr [ j ] > arr [ i ] && flag == 2 ) ){<br>                inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ;<br>            }<br>        }<br>    }<br>    int result = - 2147483648 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( result < inc [ i ] ) && ( result < inc [ i + 1 ] ) ){<br>            int result = inc [ i ] ;<br>        }<br>        if ( ( result < dec [ i ] ) && ( result < dec [ n ] ) ){<br>            int result = dec [ i ] ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>FIND_PAIR_MAXIMUM_GCD_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findMaxGCD ( int arr [ ] , int n ) {<br>  int high = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) high = Math . max ( high , arr [ i ] ) ;<br>  int divisors [ ] = new int [ high + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= Math . sqrt ( arr [ i ] ) ;<br>    j ++ ) {<br>      if ( arr [ i ] % j == 0 ) {<br>        divisors [ j ] ++ ;<br>        if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ;<br>      }<br>    }<br>  }<br>  for ( int i = high ;<br>  i >= 1 ;<br>  i -- ) if ( divisors [ i ] > 1 ) return i ;<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxGCD ( int [ ] arr , int n ) {<br>    int high = 0 ;<br>    int i = 0 ;<br>    while ( i < n ) {<br>        high = Math . max ( high , arr [ i ] ) ;<br>        i = i + 1 ;<br>    }<br>    int [ ] divisors = new int [ n ] ;<br>    int i = 0 ;<br>    while ( i < n ) {<br>        int j = 1 ;<br>        while ( j <= Math . sqrt ( arr [ i ] ) ) {<br>            if ( ( arr [ i ] % j == 0 ) && ( arr [ i ] % j == 0 ) ) {<br>                divisors [ j ] = divisors [ j ] + 1 ;<br>                if ( ( j != arr [ i ] / j ) && ( j != arr [ i ] / j ) ){<br>                    divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] ;<br>                        return + 1 ;<br>                }<br>            }<br>            j = j + 1 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    int i = high ;<br>    while ( i >= 1 ) {<br>        if ( ( divisors [ i ] > 1 ) && ( divisors [ i ] > 2 ) ) {<br>            return i ;<br>        }<br>        i = i - 1 ;<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCoins ( int coins [ ] , int m , int V ) {<br>  int table [ ] = new int [ V + 1 ] ;<br>  table [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) table [ i ] = Integer . MAX_VALUE ;<br>  for ( int i = 1 ;<br>  i <= V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) if ( coins [ j ] <= i ) {<br>      int sub_res = table [ i - coins [ j ] ] ;<br>      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ;<br>    }<br>  }<br>  return table [ V ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCoins ( int [ ] coins , int m , int V ) {<br>    int table [ ] = new int [ V + 1 ] ;<br>    table [ 0 ] = 0 ;<br>    for ( int i = 1 ;  i <= V ;  i ++ ) {<br>        table [ i ] = Integer . MAX_VALUE ;<br>    }<br>    for ( int i = 1 ;  i <= V ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( coins [ j ] <= i ) && ( coins [ j ] >= m ) && ( coins [ j ] >= V ) ){<br>                int subRes = table [ i - coins [ j ] ] ;<br>                if ( ( subRes != Integer . MAX_VALUE && subRes + 1 < table [ i ] ) || ( subRes + 2 < table [ i ] ) ){<br>                    table [ i ] = subRes + 1 ;<br>                }<br>            }<br>        }<br>    }<br>    return table [ V ] ;<br>}</td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int sum = 0 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( tree . charAt ( i ) == '(' ) level ++ ;<br>    else if ( tree . charAt ( i ) == ')' ) level -- ;<br>    else {<br>      if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumAtKthLevel ( String tree , int k ) {<br>    int level = - 1 ;<br>    int sum = 0 ;<br>    int n = tree . size ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( tree . charAt ( i ) == '(' ) ) {<br>            level ++ ;<br>        }<br>        else if ( ( tree . charAt ( i ) == ')' ) ) {<br>            level -- ;<br>        }<br>        else {<br>            if ( ( level == k ) && ( level == 0 ) ) {<br>                sum += ( ( char ) tree . charAt ( i ++ ) - '0' ) ;<br>            }<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int lcs ( char [ ] X , char [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y , int m , int n ) {<br>    if ( m == 0 || n == 0 ) {<br>        return 0 ;<br>    }<br>    else if ( X [ m - 1 ] == Y [ n - 1 ] ) {<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>    }<br>    else {<br>        return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_SENTENCE_GIVEN_SET_SIMPLE_GRAMMER_RULES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkSentence ( char [ ] str ) {<br>  int len = str . length ;<br>  if ( str [ 0 ] < 'A' || str [ 0 ] > 'Z' ) return false ;<br>  if ( str [ len - 1 ] != '.' ) return false ;<br>  int prev_state = 0 , curr_state = 0 ;<br>  int index = 1 ;<br>  while ( index <= str . length ) {<br>    if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ;<br>    else if ( str [ index ] == ' ' ) curr_state = 1 ;<br>    else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ;<br>    else if ( str [ index ] == '.' ) curr_state = 3 ;<br>    if ( prev_state == curr_state && curr_state != 2 ) return false ;<br>    if ( prev_state == 2 && curr_state == 0 ) return false ;<br>    if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ;<br>    index ++ ;<br>    prev_state = curr_state ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkSentence ( String string ) {<br>    int length = string . length ( ) ;<br>    if ( string . charAt ( 0 ) < 'A' || string . charAt ( 0 ) > 'Z' ) {<br>        return false ;<br>    }<br>    if ( string . charAt ( length - 1 ) != '.' ){<br>        return false ;<br>    }<br>    prev_state = 0 ;<br>    currState = 0 ;<br>    index = 1 ;<br>    while ( ( string . charAt ( index ++ ) ) != ' ' ) {<br>        if ( string . charAt ( index ) >= 'A' && string . charAt ( index ) <= 'Z' ) {<br>            currState = 0 ;<br>        }<br>        else if ( string . charAt ( index ) == ' ' ) {<br>            currState = 1 ;<br>        }<br>        if ( string . charAt ( index ) >= 'a' && string . charAt ( index ) <= 'z' ) {<br>            currState = 2 ;<br>        }<br>        else if ( string . charAt ( index ) == '.' ) {<br>            currState = 3 ;<br>        }<br>        if ( prev_state == currState && currState != 2 ) {<br>            return false ;<br>        }<br>        if ( prev_state == 2 && curr_state == 0 ) {<br>            return false ;<br>        }<br>        if ( currState == 3 && prev_state != 1 ) {<br>            return checkSentence ( string , false ) ;<br>        }<br>        index ++ ;<br>        prev_state = currState ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>CHECK_DIVISIBILITY_LARGE_NUMBER_999</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisible999 ( String num ) {<br>  int n = num . length ( ) ;<br>  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( n % 3 == 1 ) num = "00" + num ;<br>  if ( n % 3 == 2 ) num = "0" + num ;<br>  int gSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int group = 0 ;<br>    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;<br>    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;<br>    group += num . charAt ( i ) - '0' ;<br>    gSum += group ;<br>  }<br>  if ( gSum > 1000 ) {<br>    num = Integer . toString ( gSum ) ;<br>    n = num . length ( ) ;<br>    gSum = isDivisible999 ( num ) ? 1 : 0 ;<br>  }<br>  return ( gSum == 999 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisible999 ( String num ) {<br>    int n = num . length ( ) ;<br>    if ( ( n == 0 || num . charAt ( 0 ) == '0' ) && ( num . charAt ( 1 ) == '.' ) ) {<br>        return true ;<br>    }<br>    if ( ( ( n % 3 ) == 1 ) && ( ( n % 2 ) == 0 ) ) {<br>        num = "00" + num ;<br>    }<br>    if ( ( ( n % 3 ) == 2 ) && ( ( n % 4 ) == 0 ) ) {<br>        num = "0" + num ;<br>    }<br>    gSum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i += 3 ) {<br>        int group = 0 ;<br>        group += ( ( char ) num . charAt ( i ++ ) - 48 ) * 100 ;<br>        group += ( ( char ) num . charAt ( i + 1 ) - 48 ) * 10 ;<br>        group += ( ( char ) num . charAt ( i + 2 ) - 48 ) ;<br>        gSum += group ;<br>    }<br>    if ( ( gSum > 1000 ) && ( num > 0 ) ) {<br>        num = String . valueOf ( gSum ) ;<br>        int n = num . length ( ) ;<br>        gSum = isDivisible999 ( num ) ;<br>    }<br>    return ( gSum == 999 ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int digitSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;<br>  return ( digitSum % 9 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>    int n = st . length ( ) ;<br>    int digitSum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        digitSum = digitSum + ( int ) ( st [ i ] ) ;<br>    }<br>    return ( digitSum % 9 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_OF_BINARY_TREES_FOR_GIVEN_PREORDER_SEQUENCE_LENGTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countTrees ( int n ) {<br>  int BT [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) BT [ i ] = 0 ;<br>  BT [ 0 ] = BT [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  ++ i ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ;<br>  return BT [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countTrees ( int n ) {<br>    BT = new int [ n + 1 ] ;<br>    BT [ 0 ] = BT [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            BT [ i ] += BT [ j ] * BT [ i - j - 1 ] ;<br>        }<br>    }<br>    return BT [ n ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swapUpperToLower ( int arr [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int temp = arr [ i ] [ j ] ;<br>      arr [ i ] [ j ] = arr [ j ] [ i ] ;<br>      arr [ j ] [ i ] = temp ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void swapUpperToLower ( int [ ] [ ] arr ) {<br>    int n = 4 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int temp = arr [ i ] [ j ] ;<br>            arr [ i ] [ j ] = arr [ j ] [ i ] ;<br>            arr [ j ] [ i ] = temp ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            System . out . print ( arr [ i ] [ j ] + " " ) ;<br>        }<br>        System . out . print ( " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int N , int K ) {<br>  int ans = 0 ;<br>  int y = N / K ;<br>  int x = N % K ;<br>  ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int N , int K ) {<br>    int ans = 0 ;<br>    int y = N / K ;<br>    int x = N % K ;<br>    int ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ;<br>    return ( int ) ans ;<br>}</td>
  </tr><tr>
    <th>WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int xorZero ( String s ) {<br>  int one_count = 0 , zero_count = 0 ;<br>  char [ ] str = s . toCharArray ( ) ;<br>  int n = str . length ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( str [ i ] == '1' ) one_count ++ ;<br>  else zero_count ++ ;<br>  if ( one_count % 2 == 0 ) return zero_count ;<br>  return one_count ;<br>}<br></td>
    <td>translated code: <br><br> public static int xorZero ( String str ) {<br>    oneCount = 0 ;<br>    zeroCount = 0 ;<br>    int n = str . length ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i += 1 ) {<br>        if ( ( str . charAt ( i ) == '1' ) && ( str . charAt ( i + 1 ) == '0' ) ) {<br>            oneCount ++ ;<br>        }<br>        else {<br>            zeroCount ++ ;<br>        }<br>    }<br>    if ( ( oneCount % 2 == 0 ) && ( oneCount % 3 == 0 ) ) {<br>        return zeroCount ;<br>    }<br>    return oneCount ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_7_COIN_CHANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int S [ ] , int m , int n ) {<br>  if ( n == 0 ) return 1 ;<br>  if ( n < 0 ) return 0 ;<br>  if ( m <= 0 && n >= 1 ) return 0 ;<br>  return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int [ ] S , int m , int n ) {<br>    if ( ( n == 0 ) && ( m == 0 ) ) {<br>        return 1 ;<br>    }<br>    if ( ( n < 0 ) && ( m < n ) ) {<br>        return 0 ;<br>    }<br>    if ( ( m <= 0 && n >= 1 ) || ( m == 0 && n >= 1 ) ) {<br>        return 0 ;<br>    }<br>    return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int [ ] arr , int n ) {<br>  int [ ] dp = new int [ n ] ;<br>  if ( n == 1 ) return arr [ 0 ] ;<br>  if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ;<br>  if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ;<br>  if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ;<br>  dp [ 0 ] = arr [ 0 ] ;<br>  dp [ 1 ] = arr [ 1 ] ;<br>  dp [ 2 ] = arr [ 2 ] ;<br>  dp [ 3 ] = arr [ 3 ] ;<br>  for ( int i = 4 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ;<br>  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSum ( int [ ] arr , int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    if ( ( n == 1 ) && ( arr [ 0 ] == 1 ) ) {<br>        return minSum ( arr , 0 , n ) ;<br>    }<br>    if ( ( n == 2 ) && ( arr [ 0 ] == arr [ 1 ] ) ) {<br>        return Math . min ( arr [ 0 ] , arr [ 1 ] ) ;<br>    }<br>    if ( ( n == 3 ) && ( arr [ 0 ] == arr [ 1 ] ) && ( arr [ 2 ] == arr [ 3 ] ) ) {<br>        return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ;<br>    }<br>    if ( ( n == 4 ) && ( arr [ 0 ] == 5 ) ) {<br>        return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ;<br>    }<br>    dp [ 0 ] = arr [ 0 ] ;<br>    dp [ 1 ] = arr [ 1 ] ;<br>    dp [ 2 ] = arr [ 2 ] ;<br>    dp [ 3 ] = arr [ 3 ] ;<br>    for ( int i = 4 ;  i < n ;  i ++ ) {<br>        dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ;<br>    }<br>    return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PATH_SUM_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxPathSum ( int tri [ ] [ ] , int m , int n ) {<br>  for ( int i = m - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) {<br>      if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ;<br>      else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;<br>    }<br>  }<br>  return tri [ 0 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxPathSum ( int [ ] [ ] tri , int m , int n ) {<br>    for ( int i = m - 1 ;  i >= 0 ;  i -- ) {<br>        for ( int j = 0 ;  j < i + 1 ;  j ++ ) {<br>            if ( ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) && ( tri [ i + 1 ] [ j + 1 ] < tri [ i + 1 ] [ j + 2 ] ) ){<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ;<br>            }<br>            if ( tri . m == 0 ) {<br>                tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;<br>            }<br>        }<br>    }<br>    return maxPathSum ( tri , 0 , m , n ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) {<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n2 ;<br>  j ++ ) for ( int k = 0 ;<br>  k < n3 ;<br>  k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) {<br>    for ( int i = 0 ;  i <= n1 ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n2 ;  j ++ ) {<br>            for ( int k = 0 ;  k <= n3 ;  k ++ ) {<br>                if ( ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) && ( a1 [ i ] + a2 [ k ] + a3 [ k ] == sum ) ){<br>                    return findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum , 0 ) ;<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>TAIL_RECURSION_FIBONACCI</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int fib ( int n , int a , int b ) {<br>  if ( n == 0 ) return a ;<br>  if ( n == 1 ) return b ;<br>  return fib ( n - 1 , b , a + b ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fib ( int n , int a , int b ) {<br>    if ( n == 0 ){<br>        return a ;<br>    }<br>    if ( n == 1 ){<br>        return b ;<br>    }<br>    return fib ( n - 1 , b , a + b ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DIFFERENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isLucky ( int n ) {<br>  boolean arr [ ] = new boolean [ 10 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) arr [ i ] = false ;<br>  while ( n > 0 ) {<br>    int digit = n % 10 ;<br>    if ( arr [ digit ] ) return false ;<br>    arr [ digit ] = true ;<br>    n = n / 10 ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static int isLucky ( int n ) {<br>    int [ ] ar = new int [ 10 ] ;<br>    while ( ( n > 0 ) && ( n % 2 == 0 ) ) {<br>        int digit = Math . floor ( n % 10 ) ;<br>        if ( ( ar [ digit ] ) != 0 ) {<br>            return 0 ;<br>        }<br>        ar [ digit ] = 1 ;<br>        n = n / 10 ;<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSumTricky ( int mat [ ] [ ] , int k ) {<br>  if ( k > n ) return ;<br>  int stripSum [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    int sum = 0 ;<br>    for ( int i = 0 ;<br>    i < k ;<br>    i ++ ) sum += mat [ i ] [ j ] ;<br>    stripSum [ 0 ] [ j ] = sum ;<br>    for ( int i = 1 ;<br>    i < n - k + 1 ;<br>    i ++ ) {<br>      sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ;<br>      stripSum [ i ] [ j ] = sum ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n - k + 1 ;<br>  i ++ ) {<br>    int sum = 0 ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) sum += stripSum [ i ] [ j ] ;<br>    System . out . print ( sum + " " ) ;<br>    for ( int j = 1 ;<br>    j < n - k + 1 ;<br>    j ++ ) {<br>      sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ;<br>      System . out . print ( sum + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSumTricky ( int [ ] [ ] mat , int k ) {<br>    n = 0 ;<br>    if ( k > n ){<br>        }<br>    }<br>    stripSum = new int [ n ] [ ] ;<br>    for ( int j = 0 ;  j < n ;  j ++ ) {<br>        int Sum = 0 ;<br>        for ( int i = 0 ;  i < k ;  i ++ ) {<br>            Sum += mat [ i ] [ j ] ;<br>        }<br>        stripSum [ 0 ] [ j ] = Sum ;<br>        for ( int i = 1 ;  i <= n - k + 1 ;  i ++ ) {<br>            Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ;<br>            stripSum [ i ] [ j ] = Sum ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n - k + 1 ;  i ++ ) {<br>        int Sum = 0 ;<br>        for ( int j = 0 ;  j < k ;  j ++ ) {<br>            Sum += stripSum [ i ] [ j ] ;<br>        }<br>        System . out . print ( Sum + " " ) ;<br>        for ( int j = 1 ;  j <= n - k ;  j ++ ) {<br>            Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ;<br>            System . out . print ( Sum + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SCHEDULE_ELEVATOR_TO_REDUCE_THE_TOTAL_TIME_TAKEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minTime ( int n , int k , int a [ ] ) {<br>  int temp ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( a [ i ] < a [ j ] ) {<br>        temp = a [ i ] ;<br>        a [ i ] = a [ j ] ;<br>        a [ j ] = temp ;<br>      }<br>    }<br>  }<br>  int minTime = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += k ) minTime += ( 2 * a [ i ] ) ;<br>  return minTime ;<br>}<br></td>
    <td>translated code: <br><br> public static int minTime ( int n , int k , int [ ] a ) {<br>    Arrays . sort ( a , 0 , n ) ;<br>    minTime = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        minTime += ( 2 * a [ i ] ) ;<br>    }<br>    return minTime ;<br>}</td>
  </tr><tr>
    <th>ODD_EVEN_SORT_BRICK_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void oddEvenSort ( int arr [ ] , int n ) {<br>  boolean isSorted = false ;<br>  while ( ! isSorted ) {<br>    isSorted = true ;<br>    int temp = 0 ;<br>    for ( int i = 1 ;<br>    i <= n - 2 ;<br>    i = i + 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ i + 1 ] ;<br>        arr [ i + 1 ] = temp ;<br>        isSorted = false ;<br>      }<br>    }<br>    for ( int i = 0 ;<br>    i <= n - 2 ;<br>    i = i + 2 ) {<br>      if ( arr [ i ] > arr [ i + 1 ] ) {<br>        temp = arr [ i ] ;<br>        arr [ i ] = arr [ i + 1 ] ;<br>        arr [ i + 1 ] = temp ;<br>        isSorted = false ;<br>      }<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void oddEvenSort ( int [ ] arr , int n ) {<br>    isSorted = 0 ;<br>    while ( isSorted == 0 ) {<br>        isSorted = 1 ;<br>        int temp = 0 ;<br>        for ( int i = 1 ;  i < n - 1 ;  i += 2 ) {<br>            if ( arr [ i ] > arr [ i + 1 ] ) {<br>                arr [ i ] = arr [ i + 1 ] ;<br>                isSorted = 0 ;<br>            }<br>        }<br>        for ( int i = 0 ;  i < n - 1 ;  i += 2 ) {<br>            if ( arr [ i ] > arr [ i + 1 ] ) {<br>                arr [ i ] = arr [ i + 1 ] ;<br>                isSorted = 0 ;<br>            }<br>        }<br>    }<br>    }<br>}</td>
  </tr><tr>
    <th>RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char getMaxOccuringChar ( String str ) {<br>  int count [ ] = new int [ ASCII_SIZE ] ;<br>  int len = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) count [ str . charAt ( i ) ] ++ ;<br>  int max = - 1 ;<br>  char result = ' ' ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) {<br>    if ( max < count [ str . charAt ( i ) ] ) {<br>      max = count [ str . charAt ( i ) ] ;<br>      result = str . charAt ( i ) ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static char getMaxOccuringChar ( String str ) {<br>    int [ ] count = new int [ ASCII_SIZE ] ;<br>    int max = - 1 ;<br>    char c = '\0' ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        count [ ( int ) str . charAt ( 0 ) ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( max < count [ ( int ) i ] ) {<br>            int max = count [ ( int ) str . charAt ( str . length ( ) - 1 ) ] ;<br>            char c = i ;<br>        }<br>    }<br>    return c ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int CountPairs ( int n ) {<br>  int k = n ;<br>  int imin = 1 ;<br>  int ans = 0 ;<br>  while ( imin <= n ) {<br>    int imax = n / k ;<br>    ans += k * ( imax - imin + 1 ) ;<br>    imin = imax + 1 ;<br>    k = n / imin ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountPairs ( int n ) {<br>    int k = n ;<br>    int imin = 1 ;<br>    int ans = 0 ;<br>    while ( ( imin <= n ) && ( imin <= n ) ){<br>        int imax = n / k ;<br>        ans += k * ( imax - imin + 1 ) ;<br>        imin = imax + 1 ;<br>        int k = n / imin ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printKDistinct ( int arr [ ] , int n , int k ) {<br>  Map < Integer , Integer > h = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( h . containsKey ( arr [ i ] ) ) h . put ( arr [ i ] , h . get ( arr [ i ] ) + 1 ) ;<br>    else h . put ( arr [ i ] , 1 ) ;<br>  }<br>  if ( h . size ( ) < k ) return - 1 ;<br>  int dist_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( h . get ( arr [ i ] ) == 1 ) dist_count ++ ;<br>    if ( dist_count == k ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int printKDistinct ( int arr [ ] , int size , int KthIndex ) {<br>    HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ;<br>    int [ ] vect = new int [ size ] ;<br>    for ( int i = 0 ;  i < size ;  i ++ ) {<br>        if ( ( arr [ i ] instanceof Map ) && ( size > KthIndex ) ) {<br>            dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 ;<br>        }<br>        else {<br>            dict [ arr [ i ] ] = 1 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < size ;  i ++ ) {<br>        if ( ( map [ arr [ i ] ] > 1 ) && ( map [ arr [ i ] ] > 2 ) ) {<br>            continue ;<br>        }<br>        else {<br>            KthIndex = KthIndex - 1 ;<br>        }<br>        if ( ( KthIndex == 0 ) && ( arr != null ) ) {<br>            return printKDistinct ( arr , i -> size - i , KthIndex ) ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void generate ( int ones , int zeroes , String str , int len ) {<br>  if ( len == str . length ( ) ) {<br>    System . out . print ( str + " " ) ;<br>    return ;<br>  }<br>  generate ( ones + 1 , zeroes , str + "1" , len ) ;<br>  if ( ones > zeroes ) {<br>    generate ( ones , zeroes + 1 , str + "0" , len ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void generate ( int ones , int zeroes , String str , int len1 ) {<br>    if ( ( len1 == str . length ( ) ) && ( ones == zeroes ) ) {<br>        System . out . print ( str + " " ) ;<br>        generate ( ones , zeroes , str , len1 , null ) ;<br>    }<br>    generate ( ones + 1 , zeroes , str + "1" , len1 ) ;<br>    if ( ( ones > zeroes ) && ( ones < zeroes ) ) {<br>        generate ( ones , zeroes + 1 , str + "0" , len1 ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findElement ( int arr [ ] , int n , int key ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] == key ) return i ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findElement ( int [ ] arr , int n , int key ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] == key ) && ( arr [ i + 1 ] == key ) ) {<br>            return i ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) {<br>  int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k <= o ;<br>      k ++ ) {<br>        if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ;<br>        else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ;<br>        else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ;<br>      }<br>    }<br>  }<br>  return L [ m ] [ n ] [ o ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcsOf3 ( int [ ] X , int [ ] Y , int [ ] Z , int m , int n , int o ) {<br>    int [ ] [ ] L = new int [ o + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            for ( int k = 0 ;  k < o + 1 ;  k ++ ) {<br>                if ( ( i == 0 || j == 0 || k == 0 ) && ( o == 0 ) ) {<br>                    L [ i ] [ j ] [ k ] = 0 ;<br>                }<br>                else if ( ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) || ( X [ i - 1 ] == Z [ k - 1 ] ) ) {<br>                    L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ;<br>                }<br>                else {<br>                    L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ;<br>                }<br>            }<br>        }<br>    }<br>    return L [ m ] [ n ] [ o ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) {<br>  int fw [ ] = new int [ n ] ;<br>  int bw [ ] = new int [ n ] ;<br>  int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;<br>  fw [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , cur_max ) ;<br>    fw [ i ] = cur_max ;<br>  }<br>  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>    max_so_far = Math . max ( max_so_far , cur_max ) ;<br>    bw [ i ] = cur_max ;<br>  }<br>  int fans = max_so_far ;<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;<br>  return fans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumSubarrayRemovingOneEle ( int [ ] arr , int n ) {<br>    int [ ] fw = new int [ n ] ;<br>    int [ ] bw = new int [ n ] ;<br>    int curMax = arr [ 0 ] , maxSoFar = arr [ 0 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>        maxSoFar = Math . max ( maxSoFar , curMax ) ;<br>        fw [ i ] = cur_max ;<br>    }<br>    int curMax = maxSoFar = bw [ n - 1 ] = arr [ n - 1 ] ;<br>    int i = n - 2 ;<br>    while ( i >= 0 ) {<br>        cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ;<br>        maxSoFar = Math . max ( maxSoFar , curMax ) ;<br>        bw [ i ] = curMax ;<br>        i -- ;<br>    }<br>    int fans = max_so_far ;<br>    for ( int i = 1 ;  i <= n - 1 ;  i ++ ) {<br>        fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;<br>    }<br>    return fans ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n , int m ) {<br>  int count [ ] = new int [ n + 1 ] ;<br>  count [ 0 ] = 0 ;<br>  int i ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ;<br>    else if ( i < m ) count [ i ] = 1 ;<br>    else count [ i ] = 2 ;<br>  }<br>  return count [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n , int m ) {<br>    int [ ] count = new int [ m ] ;<br>    for ( int i = 0 ;  i < n + 2 ;  i ++ ) {<br>        count . add ( 0 ) ;<br>    }<br>    count [ 0 ] = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( ( i > m ) && ( i < n ) ) {<br>            count [ i ] = count [ i - 1 ] + count [ i - m ] ;<br>        }<br>        else if ( ( i < m ) && ( i < n ) ) {<br>            count [ i ] = 1 ;<br>        }<br>        else{<br>            count [ i ] = 2 ;<br>        }<br>    }<br>    return count [ n ] ;<br>}</td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;<br>  else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ;<br>  else return c ;<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>    if ( ( ( a < b && b < c ) || ( c < b && b < a ) ) ) {<br>        return b ;<br>    }<br>    if ( ( ( b < a && a < c ) || ( c < a && a < b ) ) ) {<br>        return a ;<br>    }<br>    }<br>        return c ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_INCREASING_SUBSEQUENCE_LCS_LIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {<br>  int table [ ] = new int [ m ] ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) table [ j ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int current = 0 ;<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ;<br>      if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ;<br>    }<br>  }<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) if ( table [ i ] > result ) result = table [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCIS ( int [ ] arr1 , int n , int [ ] arr2 , int m ) {<br>    int [ ] table = new int [ m ] ;<br>    for ( int j = 0 ;  j < m ;  j ++ ) {<br>        table [ j ] = 0 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int current = 0 ;<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( arr1 [ i ] == arr2 [ j ] ) && ( arr1 [ j ] != 0 ) ) {<br>                if ( ( current + 1 > table [ j ] ) && ( current + 1 > table [ m ] ) ){<br>                    table [ j ] = current ++ ;<br>                }<br>            }<br>            if ( ( arr1 [ i ] > arr2 [ j ] ) && ( arr1 [ i ] < arr2 [ j ] ) ){<br>                if ( ( table [ j ] > current ) && ( ( table [ j ] < arr1 ) || ( table [ j ] > arr2 ) ) ){<br>                    int current = table [ j ] ;<br>                }<br>            }<br>        }<br>    }<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        if ( ( table [ i ] > result ) && ( ( table [ i ] < arr1 ) || ( table [ i ] > arr2 ) ) ){<br>            int result = table [ i ] ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumWO3Consec ( int arr [ ] , int n ) {<br>  int sum [ ] = new int [ n ] ;<br>  if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;<br>  if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;<br>  if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ;<br>  for ( int i = 3 ;<br>  i < n ;<br>  i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ;<br>  return sum [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumWO3Consec ( int [ ] arr , int n ) {<br>    int [ ] sum = new int [ n ] ;<br>    if ( n >= 1 ) {<br>        sum [ 0 ] = arr [ 0 ] ;<br>    }<br>    if ( n >= 2 ) {<br>        sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;<br>    }<br>    if ( n > 2 ) {<br>        sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ;<br>    }<br>    for ( int i = 3 ;  i < n ;  i ++ ) {<br>        sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ;<br>    }<br>    return sum [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>EULERIAN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int eulerian ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      if ( i > j ) {<br>        if ( j == 0 ) dp [ i ] [ j ] = 1 ;<br>        else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int eulerian ( int n , int m ) {<br>    int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= m ;  j ++ ) {<br>            if ( ( i > j ) && ( i < j ) ){<br>                if ( ( j == 0 ) && ( m == 0 ) ) {<br>                    dp [ i ] [ j ] = 1 ;<br>                }<br>                else {<br>                    dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) ;<br>                }<br>            }<br>        }<br>    }<br>    return dp [ n ] [ m ] ;<br>}</td>
  </tr><tr>
    <th>DOUBLE_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long doublefactorial ( long n ) {<br>  if ( n == 0 || n == 1 ) return 1 ;<br>  return n * doublefactorial ( n - 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int doublefactorial ( int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) {<br>        return 1 ;<br>    }<br>    return n * doublefactorial ( n - 2 ) ;<br>}</td>
  </tr><tr>
    <th>REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int arr [ ] , int n ) {<br>  int i = - 1 , temp = 0 ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) {<br>    if ( arr [ j ] < 0 ) {<br>      i ++ ;<br>      temp = arr [ i ] ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = temp ;<br>    }<br>  }<br>  int pos = i + 1 , neg = 0 ;<br>  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {<br>    temp = arr [ neg ] ;<br>    arr [ neg ] = arr [ pos ] ;<br>    arr [ pos ] = temp ;<br>    pos ++ ;<br>    neg += 2 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] arr , int n ) {<br>    int i = - 1 ;<br>    for ( int j = 0 ;  j < n ;  j ++ ) {<br>        if ( ( arr [ j ] < 0 ) && ( arr [ j ] > n ) ) {<br>            i ++ ;<br>            arr [ i ] = arr [ j ] ;<br>        }<br>    }<br>    int pos = i + 1 , neg = 0 ;<br>    while ( ( pos < n && neg < pos && arr [ neg ] < 0 ) || ( pos > n && arr [ neg ] > 0 ) ) {<br>        arr [ neg ] = arr [ pos ] ;<br>        pos ++ ;<br>        neg += 2 ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSum ( int arr [ ] , int n , int k ) {<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int min = + 2147483647 ;<br>    int index = - 1 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] < min ) {<br>        min = arr [ j ] ;<br>        index = j ;<br>      }<br>    }<br>    if ( min == 0 ) break ;<br>    arr [ index ] = - arr [ index ] ;<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSum ( int [ ] arr , int n , int k ) {<br>    for ( int i = 1 ;  i <= k ;  i ++ ) {<br>        int min = + 2147483647 ;<br>        int index = - 1 ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ j ] < min ) && ( arr [ j ] > max ) ) {<br>                int min = arr [ j ] ;<br>                int index = j ;<br>            }<br>        }<br>        if ( ( min == 0 ) && ( n > k ) ) {<br>            break ;<br>        }<br>        arr [ index ] = - arr [ index ] ;<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        sum += arr [ i ] ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ELEMENT_AFTER_PREFIX_IS_MUST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pre_compute ( int a [ ] , int n , int index , int k ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ;<br>    else dp [ 0 ] [ i ] = a [ i ] ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( a [ j ] > a [ i ] && j > i ) {<br>        if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ;<br>        else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>      }<br>      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return dp [ index ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int preCompute ( int [ ] a , int n , int index , int k ) {<br>    int [ ] dp = new int [ n ] ;<br>    for ( int i = 0 ;<br>        if ( a [ i ] > a [ 0 ] ) a [ i ] = 5 ;<br>            dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ;<br>        else a [ index ] = 5 ;<br>            dp [ 0 ] [ i ] = a [ i ] ;<br>    for ( int i = 1 ;<br>        for ( int j = 0 ;<br>            if ( a [ j ] > a [ i ] && j > i ) a [ j ] = 5 ;<br>                if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) a [ j ] = 5 ;<br>                    dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ;<br>                else a [ index ] = 5 ;<br>                    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>            else a [ index ] = 5 ;<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>    return dp [ index ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void myCopy ( char s1 [ ] , char s2 [ ] ) {<br>  int i = 0 ;<br>  for ( i = 0 ;<br>  i < s1 . length ;<br>  i ++ ) s2 [ i ] = s1 [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void myCopy ( String s1 , String s2 ) {<br>    for ( int i = 0 ;  i < s1 . length ( ) ;  i ++ ) {<br>        s2 [ i ] = s1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubSequence ( String str1 , String str2 , int m , int n ) {<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n && j < m ;<br>  i ++ ) if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) j ++ ;<br>  return ( j == m ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubSequence ( String str1 , String str2 , int m , int n ) {<br>    int j = 0 ;<br>    int i = 0 ;<br>    while ( j < m && i < n ) {<br>        if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) {<br>            j = j + 1 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    return j == m ;<br>}</td>
  </tr><tr>
    <th>FIND_UNIT_DIGIT_X_RAISED_POWER_Y_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int unitnumber ( int x , int y ) {<br>  x = x % 10 ;<br>  if ( y != 0 ) y = y % 4 + 4 ;<br>  return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int unitNumber ( int x , int y ) {<br>    x = x % 10 ;<br>    if ( y != 0 ) {<br>        y = y % 4 + 4 ;<br>    }<br>    return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] , j = 0 ;<br>  Arrays . fill ( allocation , - 1 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( j < m ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>      j = ( j + 1 ) % m ;<br>    }<br>  }<br>  System . out . print ( "\nProcess No.\tProcess Size\tBlock no.\n" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( i + 1 + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) {<br>      System . out . print ( allocation [ i ] + 1 ) ;<br>    }<br>    else {<br>      System . out . print ( "Not Allocated" ) ;<br>    }<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void NextFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>    allocation = new int [ n ] ;<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        while ( j < m ) {<br>            if ( blockSize [ j ] >= processSize [ i ] ){<br>                allocation [ i ++ ] = j ;<br>                blockSize [ j ] -= processSize [ i ] ;<br>                break ;<br>            }<br>            j = ( j + 1 ) % m ;<br>        }<br>    }<br>    System . out . println ( "Process No.Process Size Block no." ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . println ( i + "         " + processSize [ i ] + "     " ) ;<br>        if ( allocation [ i ] != - 1 ){<br>            System . out . println ( allocation [ i ] + 1 ) ;<br>        }<br>        else{<br>            System . out . println ( "Not Allocated" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL_TO_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int nobleInteger ( int arr [ ] ) {<br>  int size = arr . length ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < size ;<br>    j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ;<br>    if ( count == arr [ i ] ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int nobleInteger ( int [ ] arr , int size ) {<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        int count = 0 ;<br>        for ( int j = 0 ;  j <= size ;  j ++ ) {<br>            if ( ( arr [ i ] < arr [ j ] ) && ( arr [ i ] > arr [ j ] ) ) {<br>                count ++ ;<br>            }<br>        }<br>        if ( ( count == arr [ i ] ) && ( count == arr [ i + 1 ] ) ) {<br>            return arr [ i ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumflip ( int mat [ ] [ ] , int n ) {<br>  int transpose [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ;<br>  int flip = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ;<br>  return flip / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minimumFlip ( int [ ] [ ] mat , int n ) {<br>    double [ ] transpose = new double [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            transpose [ i ] [ j ] = mat [ j ] [ i ] ;<br>        }<br>    }<br>    int flip = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ){<br>                flip ++ ;<br>            }<br>        }<br>    }<br>    return ( int ) ( flip / 2 ) ;<br>}</td>
  </tr><tr>
    <th>SEGREGATE_EVEN_ODD_NUMBERS_SET_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void arrayEvenAndOdd ( int arr [ ] , int n ) {<br>  int i = - 1 , j = 0 ;<br>  while ( j != n ) {<br>    if ( arr [ j ] % 2 == 0 ) {<br>      i ++ ;<br>      int temp = arr [ i ] ;<br>      arr [ i ] = arr [ j ] ;<br>      arr [ j ] = temp ;<br>    }<br>    j ++ ;<br>  }<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) System . out . print ( arr [ k ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void arrayEvenAndOdd ( int [ ] arr , int n ) {<br>    int i = - 1 ;<br>    int j = 0 ;<br>    while ( ( j != n ) && ( j != 0 ) ) {<br>        if ( ( arr [ j ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) {<br>            i = i + 1 ;<br>            arr [ i ] = arr [ j ] = arr [ i ] = 0 ;<br>        }<br>        j = j + 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( Integer . toString ( i ) + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>DFS_N_ARY_TREE_ACYCLIC_GRAPH_REPRESENTED_ADJACENCY_LIST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void dfs ( LinkedList < Integer > list [ ] , int node , int arrival ) {<br>  System . out . println ( node ) ;<br>  for ( int i = 0 ;<br>  i < list [ node ] . size ( ) ;<br>  i ++ ) {<br>    if ( list [ node ] . get ( i ) != arrival ) dfs ( list , list [ node ] . get ( i ) , node ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void dfs ( int [ ] [ ] List , int node , int arrival ) {<br>    System . out . println ( node ) ;<br>    for ( int i = 0 ;  i < List [ node ] . length ;  i ++ ) {<br>        if ( ( List [ node ] [ i ] != arrival ) && ( List [ node ] [ i ] != arrival ) ) {<br>            dfs ( List , List [ node ] [ i ] , node ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int turnOffK ( int n , int k ) {<br>  if ( k <= 0 ) return n ;<br>  return ( n & ~ ( 1 << ( k - 1 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int turnOffK ( int n , int k ) {<br>    if ( ( k <= 0 ) && ( n > 0 ) ) {<br>        return n ;<br>    }<br>    return ( n & ~ ( 1 << ( k - 1 ) ) ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_DIVISIBLE_8_NOT_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( String s , int len ) {<br>  int MAX = 1000 ;<br>  int cur = 0 , dig = 0 ;<br>  int [ ] sum = new int [ MAX ] ;<br>  int [ ] [ ] dp = new int [ MAX ] [ 3 ] ;<br>  dp [ 0 ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= len ;<br>  i ++ ) {<br>    dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ;<br>    cur += dig ;<br>    cur %= 3 ;<br>    sum [ i ] = cur ;<br>    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ;<br>    dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ;<br>    dp [ i ] [ sum [ i ] ] ++ ;<br>  }<br>  int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ;<br>  for ( int i = 1 ;<br>  i <= len ;<br>  i ++ ) {<br>    dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ;<br>    if ( dig == 8 ) ans ++ ;<br>    if ( i - 2 >= 0 ) {<br>      dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = dprev * 10 + dig ;<br>      if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ;<br>    }<br>    if ( i - 3 >= 0 ) {<br>      dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ;<br>      dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ;<br>      value = dprev2 * 100 + dprev * 10 + dig ;<br>      if ( value % 8 != 0 ) continue ;<br>      ans += ( i - 2 ) ;<br>      ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( String s , int Len ) {<br>    MAX = 0 ;<br>    int cur = 0 ;<br>    int dig = 0 ;<br>    Sum = new int [ MAX ] ;<br>    int [ ] dp = new int [ MAX ] ;<br>    dp [ 0 ] [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= Len ;  i ++ ) {<br>        int dig = ( int ) Bytes [ i - 1 ] - 48 ;<br>        cur += dig ;<br>        cur %= 3 ;<br>        Sum [ i ++ ] = cur ;<br>        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>        dp [ i ] . y = dp [ i - 1 ] . y ;<br>        dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ;<br>        dp [ i ] [ Sum [ i ] ] ++ ;<br>    }<br>    int ans = 0 ;<br>    dprev = 0 ;<br>    int value = 0 ;<br>    int dprev2 = 0 ;<br>    for ( int i = 1 ;  i <= Len ;  i ++ ) {<br>        int dig = ( int ) Bytes [ i - 1 ] - 48 ;<br>        if ( dig == 8 ){<br>            ans ++ ;<br>        }<br>        if ( i - 2 >= 0 ){<br>            int dprev = ( int ) s [ i - 2 ] - 48 ;<br>            value = dprev * 10 + dig ;<br>            if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) {<br>                ans ++ ;<br>            }<br>        }<br>        if ( i - 3 >= 0 ){<br>            int dprev2 = ( int ) Bytes [ i - 3 ] - 48 ;<br>            int dprev = ( int ) s [ i - 2 ] - 48 ;<br>            int value = ( dprev2 * 100 + dprev * 10 + dig ) ;<br>            if ( value % 8 != 0 ){<br>                continue ;<br>            }<br>            ans += ( i - 2 ) ;<br>            ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>ADD_1_TO_A_GIVEN_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int addOne ( int x ) {<br>  return ( - ( ~ x ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int addOne ( int x ) {<br>    return ( - ( ~ x ) ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isAnBn ( String s ) {<br>  int l = s . length ( ) ;<br>  if ( l % 2 == 1 ) {<br>    return false ;<br>  }<br>  int i = 0 ;<br>  int j = l - 1 ;<br>  while ( i < j ) {<br>    if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) {<br>      return false ;<br>    }<br>    i ++ ;<br>    j -- ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isAnBn ( String str ) {<br>    int n = str . length ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( str . charAt ( i ) != 'a' ) && ( str . charAt ( i ) != 'b' ) ) {<br>            break ;<br>        }<br>    }<br>    if ( ( i * 2 != n ) && ( i * 2 != n ) ) {<br>        return false ;<br>    }<br>    for ( int j = i ;  j < n ;  j ++ ) {<br>        if ( ( str . charAt ( j ) != 'b' ) && ( str . charAt ( j ) != 'a' ) ) {<br>            return false ;<br>        }<br>    }<br>    return isAnBn ( str , false ) ;<br>}</td>
  </tr><tr>
    <th>FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFirstRepeating ( int arr [ ] ) {<br>  int min = - 1 ;<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i = arr . length - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( set . contains ( arr [ i ] ) ) min = i ;<br>    else set . add ( arr [ i ] ) ;<br>  }<br>  if ( min != - 1 ) System . out . println ( "The first repeating element is " + arr [ min ] ) ;<br>  else System . out . println ( "There are no repeating elements" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printFirstRepeating ( int [ ] arr , int n ) {<br>    int Min = - 1 ;<br>    Map < Integer , Integer > myset = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        if ( arr [ i ] == myset . keySet ( ) . stream ( ) . filter ( x -> x . equals ( myset . get ( x ) ) ) . findFirst ( ) ) {<br>            int Min = i ;<br>        }<br>        if ( n > 0 ) {<br>            myset . put ( arr [ i ] , 1 ) ;<br>        }<br>    }<br>    if ( ( Min != - 1 ) && ( n > 0 ) ) {<br>        System . out . println ( "The first repeating element is" + arr [ Min ] ) ;<br>    }<br>    if ( n > 0 ) {<br>        System . out . println ( "There are no repeating elements" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COST_BALANCE_PARANTHESES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int costToBalance ( String s ) {<br>  if ( s . length ( ) == 0 ) System . out . println ( 0 ) ;<br>  int ans = 0 ;<br>  int o = 0 , c = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == '(' ) o ++ ;<br>    if ( s . charAt ( i ) == ')' ) c ++ ;<br>  }<br>  if ( o != c ) return - 1 ;<br>  int [ ] a = new int [ s . length ( ) ] ;<br>  if ( s . charAt ( 0 ) == '(' ) a [ 0 ] = 1 ;<br>  else a [ 0 ] = - 1 ;<br>  if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ;<br>  for ( int i = 1 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == '(' ) a [ i ] = a [ i - 1 ] + 1 ;<br>    else a [ i ] = a [ i - 1 ] - 1 ;<br>    if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int costToBalance ( String s ) {<br>    if ( ( s . length ( ) == 0 ) && ( s . charAt ( 0 ) == 'a' ) ) {<br>        System . out . println ( 0 ) ;<br>    }<br>    int ans = 0 ;<br>    int o = 0 ;<br>    int c = 0 ;<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == '(' ) && ( s . charAt ( i + 1 ) == ')' ) ) {<br>            o ++ ;<br>        }<br>        if ( ( s . charAt ( i ++ ) == ')' ) ) {<br>            c ++ ;<br>        }<br>    }<br>    if ( ( o != c ) && ( o != o ) ){<br>        return - 1 ;<br>    }<br>    int [ ] a = new int [ s . length ( ) ] ;<br>    if ( ( s . charAt ( 0 ) == '(' ) && ( s . charAt ( 1 ) == ')' ) ) {<br>        a [ 0 ] = 1 ;<br>    }<br>    else {<br>        a [ 0 ] = - 1 ;<br>    }<br>    if ( ( a [ 0 ] < 0 ) && ( a [ 1 ] > 0 ) ) a [ 0 ] = 5 ;<br>        ans += Math . abs ( a [ 0 ] ) ;<br>    for ( int i = 1 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == '(' ) && ( s . charAt ( i + 1 ) == ')' ) ) {<br>            a [ i ] = a [ i - 1 ] + 1 ;<br>        }<br>        else {<br>            a [ i ] = a [ i - 1 ] - 1 ;<br>        }<br>        if ( ( a [ i ] < 0 ) && ( a [ i ] > 5 ) ) {<br>            ans += Math . abs ( a [ i ] ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COIN_GAME_WINNER_EVERY_PLAYER_THREE_CHOICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findWinner ( int x , int y , int n ) {<br>  boolean [ ] dp = new boolean [ n + 1 ] ;<br>  Arrays . fill ( dp , false ) ;<br>  dp [ 0 ] = false ;<br>  dp [ 1 ] = true ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ;<br>    else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ;<br>    else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ;<br>    else dp [ i ] = false ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findWinner ( int x , int y , int n ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    dp [ 0 ] = false ;<br>    dp [ 1 ] = true ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        if ( ( i - 1 >= 0 && ! dp [ i - 1 ] ) || ( i - 1 >= 0 && dp [ i - 1 ] ) ){<br>            dp [ i ] = true ;<br>        }<br>        else if ( ( i - x >= 0 && ! dp [ i - x ] ) ){<br>            dp [ i ] = true ;<br>        }<br>        else if ( ( i - y >= 0 && ! dp [ i - y ] ) ){<br>            dp [ i ] = true ;<br>        }<br>        else {<br>            dp [ i ] = false ;<br>        }<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getTotalNumberOfSequences ( int m , int n ) {<br>  if ( m < n ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getTotalNumberOfSequences ( int m , int n ) {<br>    if ( m < n ) {<br>        return 0 ;<br>    }<br>    if ( n == 0 ) {<br>        return 1 ;<br>    }<br>    int res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ) ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void printDuplicates ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > map = new HashMap < > ( ) ;<br>  int count = 0 ;<br>  boolean dup = false ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( map . containsKey ( arr [ i ] ) ) {<br>      count = map . get ( arr [ i ] ) ;<br>      map . put ( arr [ i ] , count + 1 ) ;<br>    }<br>    else {<br>      map . put ( arr [ i ] , 1 ) ;<br>    }<br>  }<br>  for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) {<br>    if ( entry . getValue ( ) > 1 ) {<br>      System . out . print ( entry . getKey ( ) + " " ) ;<br>      dup = true ;<br>    }<br>  }<br>  if ( ! dup ) {<br>    System . out . println ( "-1" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printDuplicates ( String [ ] arr ) {<br>    Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ;<br>    for ( int ele : arr ) {<br>        try {<br>            dict [ ele ] ++ ;<br>        }<br>        }<br>            dict . put ( ele , 1 ) ;<br>    }<br>    for ( int i = 0 ;  i < dict . length ;  i ++ ) {<br>        if ( ( Map . get ( item ) > 1 ) && ( Map . get ( item ) < arr . length ) ) {<br>            System . out . print ( item + " " ) ;<br>        }<br>    }<br>    System . out . println ( "\n" ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestRepeatingSubSeq ( char X [ ] , int m , int n ) {<br>  if ( dp [ m ] [ n ] != - 1 ) {<br>    return dp [ m ] [ n ] ;<br>  }<br>  if ( m == 0 || n == 0 ) {<br>    return dp [ m ] [ n ] = 0 ;<br>  }<br>  if ( X [ m - 1 ] == X [ n - 1 ] && m != n ) {<br>    return dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ;<br>  }<br>  return dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestRepeatingSubSeq ( int [ ] X , int m , int n ) {<br>    if ( ( dp [ m ] [ n ] != - 1 ) && ( dp [ m ] [ n ] != - 1 ) ) {<br>        return dp [ m ] [ n ] ;<br>    }<br>    if ( ( m == 0 || n == 0 ) && ( X [ m ] == 0 || X [ n ] == 0 ) ) {<br>        dp [ m ] [ n ] = 0 ;<br>        return dp [ m ] [ n ] ;<br>    }<br>    if ( ( X [ m - 1 ] == X [ n - 1 ] && m != n ) || ( X [ m - 1 ] == X [ n - 1 ] && m != n ) ) {<br>        dp [ m ] [ n ] = findLongestRepeatingSubSeq ( X , m - 1 , n - 1 ) + 1 ;<br>        return dp [ m ] [ n ] ;<br>    }<br>    dp [ m ] [ n ] = Math . max ( findLongestRepeatingSubSeq ( X , m , n - 1 ) , findLongestRepeatingSubSeq ( X , m - 1 , n ) ) ;<br>    return dp [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void findCount ( int n , int sum ) {<br>  int start = ( int ) Math . pow ( 10 , n - 1 ) ;<br>  int end = ( int ) Math . pow ( 10 , n ) - 1 ;<br>  int count = 0 ;<br>  int i = start ;<br>  while ( i < end ) {<br>    int cur = 0 ;<br>    int temp = i ;<br>    while ( temp != 0 ) {<br>      cur += temp % 10 ;<br>      temp = temp / 10 ;<br>    }<br>    if ( cur == sum ) {<br>      count ++ ;<br>      i += 9 ;<br>    }<br>    else i ++ ;<br>  }<br>  System . out . println ( count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findCount ( int n , int sum ) {<br>    double start = Math . pow ( 10 , n - 1 ) ;<br>    int end = Math . pow ( 10 , n ) - 1 ;<br>    int count = 0 ;<br>    int i = start ;<br>    while ( ( i <= end ) && ( i < n ) ) {<br>        int cur = 0 ;<br>        int temp = i ;<br>        while ( ( temp = n ) != 0 ) {<br>            cur += temp % 10 ;<br>            temp = temp / 10 ;<br>        }<br>        if ( ( cur == sum ) && ( n == n ) ) {<br>            count = count + 1 ;<br>            i += 9 ;<br>        }<br>        if ( n > 0 ) {<br>            i = i + 1 ;<br>        }<br>    }<br>    System . out . println ( count ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimum_cost ( int a [ ] , int n ) {<br>  int mn = Integer . MAX_VALUE ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mn = Math . min ( a [ i ] , mn ) ;<br>    sum += a [ i ] ;<br>  }<br>  return mn * ( sum - mn ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long minimumCost ( long [ ] a , int n ) {<br>    int mn = Integer . MAX_VALUE ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int mn = Math . min ( a [ i ] , mn ) ;<br>        sum += a [ i ] ;<br>    }<br>    return mn * ( sum - mn ) ;<br>}</td>
  </tr><tr>
    <th>FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDivisors ( int n ) {<br>  Vector < Integer > v = new Vector < > ( ) ;<br>  for ( int i = 1 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    if ( n % i == 0 ) {<br>      if ( n / i == i ) System . out . printf ( "%d " , i ) ;<br>      else {<br>        System . out . printf ( "%d " , i ) ;<br>        v . add ( n / i ) ;<br>      }<br>    }<br>  }<br>  for ( int i = v . size ( ) - 1 ;<br>  i >= 0 ;<br>  i -- ) System . out . printf ( "%d " , v . get ( i ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDivisors ( int n ) {<br>    List < Integer > list = new ArrayList < Integer > ( ) ;<br>    for ( int i = 1 ;  i <= ( int ) Math . sqrt ( n ) + 1 ;  i ++ ) {<br>        if ( ( n % i == 0 ) && ( n % i == 0 ) ) {<br>            if ( ( n / i == i ) && ( n % i == 0 ) ) {<br>                System . out . print ( i + " " ) ;<br>            }<br>            if ( n > 0 ) {<br>                System . out . print ( i + " " ) ;<br>                list . add ( ( int ) ( n / i ) ) ;<br>            }<br>        }<br>    }<br>    for ( int i = list . length - 1 ;  i >= 0 ;  i -- ) {<br>        System . out . print ( i + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) {<br>  System . out . print ( " Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) ;<br>  }<br>  System . out . println ( ) ;<br>  System . out . print ( " Diagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void diagonalSquare ( int [ ] [ ] mat , int row , int column ) {<br>    System . out . print ( "Diagonal one:" + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " "<br>    for ( int i = 0 ;  i <= row ;  i ++ ) {<br>        System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " " ) ;<br>    }<br>    System . out . print ( " \ n \ nDiagonal SPACETOKEN two : " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN "<br>    for ( int i = 0 ;  i <= row ;  i ++ ) {<br>        System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double polygonArea ( double X [ ] , double Y [ ] , int n ) {<br>  double area = 0.0 ;<br>  int j = n - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;<br>    j = i ;<br>  }<br>  return Math . abs ( area / 2.0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double polygonArea ( double [ ] X , double [ ] Y , int n ) {<br>    double area = 0.0 ;<br>    int j = n - 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;<br>        int j = i ;<br>    }<br>    return Math . abs ( area / 2.0 ) ;<br>}</td>
  </tr><tr>
    <th>RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) {<br>  int count = 0 ;<br>  for ( int i = left - 1 ;<br>  i < right ;<br>  ++ i ) if ( arr [ i ] == element ) ++ count ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFrequency ( int [ ] arr , int n , int left , int right , int element ) {<br>    int count = 0 ;<br>    for ( int i = left - 1 ;  i < right ;  i ++ ) {<br>        if ( ( arr [ i ] == element ) && ( left == right ) ) {<br>            count ++ ;<br>        }<br>    }<br>    return count ++ ;<br>}</td>
  </tr><tr>
    <th>SERIES_LARGEST_GCD_SUM_EQUALS_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void print_sequence ( int n , int k ) {<br>  int b = n / ( k * ( k + 1 ) / 2 ) ;<br>  if ( b == 0 ) {<br>    System . out . println ( "-1" ) ;<br>  }<br>  else {<br>    int r = 1 ;<br>    for ( int x = 1 ;<br>    x * x <= n ;<br>    x ++ ) {<br>      if ( n % x != 0 ) continue ;<br>      if ( x <= b && x > r ) r = x ;<br>      if ( n / x <= b && n / x > r ) r = n / x ;<br>    }<br>    for ( int i = 1 ;<br>    i < k ;<br>    i ++ ) System . out . print ( r * i + " " ) ;<br>    int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;<br>    System . out . println ( res ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSequence ( int n , int k ) {<br>    int b = ( int ) ( n / ( k * ( k + 1 ) / 2 ) ) ;<br>    if ( b == 0 ){<br>        System . out . println ( "-1" ) ;<br>    }<br>    else{<br>        int r = 1 ;<br>        int x = 1 ;<br>        while ( x * x * x <= n ){<br>            if ( n % x != 0 ){<br>                continue ;<br>            }<br>            else if ( x <= b && x > r ){<br>                int r = x ;<br>            }<br>            else if ( n / x <= b && n / x > r ){<br>                int r = n / x ;<br>            }<br>            x = x + 1 ;<br>        }<br>        int i = 1 ;<br>        while ( i < k ) {<br>            System . out . print ( r * i ++ + " " ) ;<br>            i = i + 1 ;<br>        }<br>        lastTerm = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;<br>        System . out . println ( lastTerm ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT_A_B_C_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    s . add ( a1 [ i ] ) ;<br>  }<br>  ArrayList < Integer > al = new ArrayList < > ( s ) ;<br>  for ( int i = 0 ;<br>  i < n2 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n3 ;<br>    j ++ ) {<br>      if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al . get ( al . size ( ) - 1 ) ) {<br>        return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n1 ;  i ++ ) {<br>        s . add ( a1 [ i ] ) ;<br>    }<br>    for ( int i = 0 ;  i < n2 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n3 ;  j ++ ) {<br>            if ( sum - a2 [ i ] - a3 [ j ] in s ){<br>                return findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum , 0 ) ;<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaximum ( int arr [ ] , int low , int high ) {<br>  if ( low == high ) return arr [ low ] ;<br>  if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ;<br>  if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;<br>  else return findMaximum ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaximum ( int [ ] arr , int low , int high ) {<br>    if ( low == high ) {<br>        return findMaximum ( arr , low , high , 0 ) ;<br>    }<br>    if ( high == low + 1 && arr [ low ] >= arr [ high ] ) {<br>        return findMaximum ( arr , low , high , 0 ) ;<br>    }<br>    if ( high == low + 1 && arr [ low ] < arr [ high ] ) {<br>        return findMaximum ( arr , high , low , 0 ) ;<br>    }<br>    int mid = ( low + high ) / 2 ;<br>    if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) {<br>        return arr [ mid ] ;<br>    }<br>    if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) {<br>        return findMaximum ( arr , low , mid - 1 ) ;<br>    }<br>    else {<br>        return findMaximum ( arr , mid + 1 , high ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int fib ( int n ) {<br>  if ( lookup [ n ] == NIL ) {<br>    if ( n <= 1 ) lookup [ n ] = n ;<br>    else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;<br>  }<br>  return lookup [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> static int fib ( int n , int [ ] lookup ) {<br>    if ( n == 0 || n == 1 ) {<br>        lookup [ n ] = n ;<br>    }<br>    if ( lookup [ n ] == 0 ) {<br>        lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ;<br>    }<br>    return lookup [ n ] ;<br>}</td>
  </tr><tr>
    <th>MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int power ( int x , int y , int p ) {<br>  int res = 1 ;<br>  x = x % p ;<br>  while ( y > 0 ) {<br>    if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;<br>    y = y >> 1 ;<br>    x = ( x * x ) % p ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int power ( int x , int y , int p ) {<br>    int res = 1 ;<br>    x = x % p ;<br>    while ( ( y -- > 0 ) && ( x & p ) != 0 ) {<br>        if ( ( ( y & 1 ) == 1 ) && ( ( x & 1 ) == 0 ) ) {<br>            res = ( res * x ) % p ;<br>        }<br>        y = y >> 1 ;<br>        x = ( x * x ) % p ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPowerOfTwo ( int x ) {<br>  return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfTwo ( int x ) {<br>    return ( x > 0 && ( ! ( x & ( x - 1 ) ) ) ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longestString ( String str1 , String str2 ) {<br>  int count1 [ ] = new int [ 26 ] , count2 [ ] = new int [ 26 ] ;<br>  for ( int i = 0 ;<br>  i < str1 . length ( ) ;<br>  i ++ ) {<br>    count1 [ str1 . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < str2 . length ( ) ;<br>  i ++ ) {<br>    count2 [ str2 . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  String result = "" ;<br>  for ( int i = 0 ;<br>  i < 26 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= Math . min ( count1 [ i ] , count2 [ i ] ) ;<br>    j ++ ) {<br>      result += ( char ) ( 'a' + i ) ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longestString ( String str1 , String str2 ) {<br>    int [ ] count1 = new int [ 26 ] ;<br>    int [ ] count2 = {<br>    }<br>    for ( int i = 0 ;  i < str1 . length ( ) ;  i ++ ) {<br>        count1 [ ( int ) str1 . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < str2 . length ( ) ;  i ++ ) {<br>        count2 [ ( int ) str2 . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    String result = "" ;<br>    for ( int i = 0 ;  i < 26 ;  i ++ ) {<br>        for ( int j = 1 ;  j <= Math . min ( count1 [ i ] , count2 [ i ] ) + 1 ;  j ++ ) {<br>            StringBuilder sb = new StringBuilder ( str1 . length ( ) + str2 . length ( ) ) ;<br>        }<br>    }<br>    System . out . println ( result ) ;<br>}</td>
  </tr><tr>
    <th>DIFFERENCE_MAXIMUM_SUM_MINIMUM_SUM_N_M_ELEMENTSIN_REVIEW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_difference ( int arr [ ] , int n , int m ) {<br>  int max = 0 , min = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 , j = n - 1 ;<br>  i < m ;<br>  i ++ , j -- ) {<br>    min += arr [ i ] ;<br>    max += arr [ j ] ;<br>  }<br>  return ( max - min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findDifference ( int [ ] arr , int n , int m ) {<br>    int max = 0 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int j = n - 1 ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        min += arr [ i ] ;<br>        max += arr [ j ] ;<br>        j = j - 1 ;<br>    }<br>    return ( max - min ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_NUMBER_ASCENDING_ORDER_CONTAINS_1_2_3_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static String printNumbers ( int [ ] numbers ) {<br>  ArrayList < Integer > array = new ArrayList < > ( ) ;<br>  for ( int number : numbers ) {<br>    if ( findContainsOneTwoThree ( number ) ) array . add ( number ) ;<br>  }<br>  Collections . sort ( array ) ;<br>  StringBuffer strbuf = new StringBuffer ( ) ;<br>  Iterator it = array . iterator ( ) ;<br>  while ( it . hasNext ( ) ) {<br>    int value = ( int ) it . next ( ) ;<br>    if ( strbuf . length ( ) > 0 ) strbuf . append ( ", " ) ;<br>    strbuf . append ( Integer . toString ( value ) ) ;<br>  }<br>  return ( strbuf . length ( ) > 0 ) ? strbuf . toString ( ) : "-1" ;<br>}<br></td>
    <td>translated code: <br><br> public static List < String > printNumbers ( List < String > numbers ) {<br>    numbers = CollectionUtils . toCollection ( numbers ) ;<br>    StringBuilder result = new StringBuilder ( ) ;<br>    for ( Integer num : numbers ) {<br>        if ( ( "1" . equals ( num ) && "2" . equals ( num ) && "3" . equals ( num ) ) || ( "0" . equals ( num ) && "1" . equals ( num ) && "2" . equals ( num ) && "3" . equals ( num ) ) ) {<br>            result . add ( num ) ;<br>        }<br>    }<br>    if ( ! result ) {<br>        StringBuilder result = new StringBuilder ( ) ;<br>    }<br>    Collections . sort ( result ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  max_ref = 1 ;<br>  _lis ( arr , n ) ;<br>  return max_ref ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>    maximum = arr ;<br>    int n = arr . length ;<br>    int maximum = 1 ;<br>    _lis ( arr , n ) ;<br>    return maximum ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) {<br>  double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ;<br>  return Math . ceil ( d / ( 2 * r ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double minRevolutions ( double r , double x1 , double y1 , double x2 , double y2 ) {<br>    double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ;<br>    return Math . ceil ( d / ( 2 * r ) ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) {<br>  for ( int i = 0 ;<br>  i < set1 . length ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < set2 . length ;<br>    j ++ ) {<br>      if ( set1 [ i ] == set2 [ j ] ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) {<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( set1 [ i ] == set2 [ j ] ) && ( set1 [ i ] == set2 [ j ] ) ) {<br>                return areDisjoint ( set1 , set2 , m , n , null ) ;<br>            }<br>        }<br>    }<br>    return areDisjoint ( set1 , set2 , m , n , null ) ;<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_SUM_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinSum ( int num ) {<br>  int sum = 0 ;<br>  for ( int i = 2 ;<br>  i * i <= num ;<br>  i ++ ) {<br>    while ( num % i == 0 ) {<br>      sum += i ;<br>      num /= i ;<br>    }<br>  }<br>  sum += num ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinSum ( int num ) {<br>    int sum = 0 ;<br>    int i = 2 ;<br>    while ( ( i * i <= num ) && ( i * i <= num ) ) {<br>        while ( ( num % i == 0 ) && ( num % i == 0 ) ) {<br>            sum += i ;<br>            num /= i ;<br>        }<br>        i ++ ;<br>    }<br>    sum += num ;<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int mostFrequent ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int max_count = 1 , res = arr [ 0 ] ;<br>  int curr_count = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ;<br>    else {<br>      if ( curr_count > max_count ) {<br>        max_count = curr_count ;<br>        res = arr [ i - 1 ] ;<br>      }<br>      curr_count = 1 ;<br>    }<br>  }<br>  if ( curr_count > max_count ) {<br>    max_count = curr_count ;<br>    res = arr [ n - 1 ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int mostFrequent ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int maxCount = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] == arr [ i - 1 ] ) && ( n > 0 ) ) {<br>            currCount ++ ;<br>        }<br>        else {<br>            if ( ( currCount > maxCount ) && ( n > 0 ) ) {<br>                maxCount = currCount ;<br>                int res = arr [ i - 1 ] ;<br>            }<br>            int currCount = 1 ;<br>        }<br>    }<br>    if ( ( currCount > maxCount ) && ( n > 0 ) ) {<br>        maxCount = currCount ;<br>        int res = arr [ n - 1 ] ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minXOR ( int arr [ ] , int n ) {<br>  Arrays . parallelSort ( arr ) ;<br>  int minXor = Integer . MAX_VALUE ;<br>  int val = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    val = arr [ i ] ^ arr [ i + 1 ] ;<br>    minXor = Math . min ( minXor , val ) ;<br>  }<br>  return minXor ;<br>}<br></td>
    <td>translated code: <br><br> public static int minXOR ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int minXor = ( int ) Integer . MAX_VALUE ;<br>    int val = 0 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        int val = arr [ i ] ^ arr [ i + 1 ] ;<br>        minXor = Math . min ( minXor , val ) ;<br>    }<br>    return minXor ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_PRODUCT_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minproduct ( int a [ ] , int b [ ] , int n , int k ) {<br>  int diff = 0 , res = 0 ;<br>  int temp = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int pro = a [ i ] * b [ i ] ;<br>    res = res + pro ;<br>    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>    int d = Math . abs ( pro - temp ) ;<br>    if ( d > diff ) diff = d ;<br>  }<br>  return res - diff ;<br>}<br></td>
    <td>translated code: <br><br> public static double minproduct ( double [ ] a , double [ ] b , int n , double k ) {<br>    int diff = 0 ;<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        double pro = a [ i ] * b [ i ] ;<br>        res = res + pro ;<br>        if ( ( pro < 0 && b [ i ] < 0 ) || ( b [ i ] > n && b [ i ] > k ) ){<br>            int temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>        }<br>        else if ( ( pro < 0 && a [ i ] < 0 ) || ( pro > n && a [ i ] > b [ i ] ) ) a [ i ] = 5 ;<br>            int temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>        else if ( ( pro > 0 && a [ i ] < 0 ) || ( pro > 0 && b [ i ] < 0 ) ) a [ i ] = 5 ;<br>            int temp = ( a [ i ] + 2 * k ) * b [ i ] ;<br>        else if ( ( pro > 0 && a [ i ] > 0 ) || ( pro > 0 && b [ i ] > 0 ) ) a [ i ] = 5 ;<br>            int temp = ( a [ i ] - 2 * k ) * b [ i ] ;<br>        double d = Math . abs ( pro - temp ) ;<br>        if ( ( d > diff ) && ( d < 0 ) ){<br>            int diff = d ;<br>        }<br>    }<br>    return res - diff ;<br>}</td>
  </tr><tr>
    <th>FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERATOR_RUSSIAN_PEASANTS_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int russianPeasant ( int a , int b ) {<br>  int res = 0 ;<br>  while ( b > 0 ) {<br>    if ( ( b & 1 ) != 0 ) res = res + a ;<br>    a = a << 1 ;<br>    b = b >> 1 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int russianPeasant ( int a , int b ) {<br>    int res = 0 ;<br>    while ( ( b > 0 ) && ( a > b ) ) {<br>        if ( ( b & 1 ) != 0 ){<br>            res = res + a ;<br>        }<br>        a = a << 1 ;<br>        b = b >> 1 ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>DIVISIBILITY_9_USING_BITWISE_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivBy9 ( int n ) {<br>  if ( n == 0 || n == 9 ) return true ;<br>  if ( n < 9 ) return false ;<br>  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivBy9 ( int n ) {<br>    if ( ( n == 0 || n == 9 ) && ( n % 2 == 0 ) ) {<br>        return true ;<br>    }<br>    if ( ( n < 9 ) && ( n % 9 == 0 ) ) {<br>        return false ;<br>    }<br>    return isDivBy9 ( ( int ) ( n >>> 3 ) - ( int ) ( n & 7 ) ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isInorder ( int [ ] arr , int n ) {<br>  if ( n == 0 || n == 1 ) {<br>    return true ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i - 1 ] > arr [ i ] ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isInorder ( int [ ] arr , int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] == arr [ 1 ] ) ) {<br>        return isInorder ( arr , 0 , n ) ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i <<= 1 ) {<br>        if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] > arr [ n - 1 ] ) ) {<br>            return false ;<br>        }<br>    }<br>    return isInorder ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>GIVEN_TWO_UNSORTED_ARRAYS_FIND_PAIRS_WHOSE_SUM_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= m ;  j ++ ) {<br>            if ( ( arr1 [ i ] + arr2 [ j ] == x ) && ( arr1 [ i ] + arr2 [ j ] == x ) ) {<br>                System . out . println ( arr1 [ i ] + " " + arr2 [ j ] ) ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>BINARY_REPRESENTATION_OF_NEXT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String nextGreater ( String num ) {<br>  int l = num . length ( ) ;<br>  int i ;<br>  for ( i = l - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( num . charAt ( i ) == '0' ) {<br>      num = num . substring ( 0 , i ) + '1' + num . substring ( i + 1 ) ;<br>      break ;<br>    }<br>    else {<br>      num = num . substring ( 0 , i ) + '0' + num . substring ( i + 1 ) ;<br>    }<br>  }<br>  if ( i < 0 ) {<br>    num = "1" + num ;<br>  }<br>  return num ;<br>}<br></td>
    <td>translated code: <br><br> public static String nextGreater ( String num1 ) {<br>    int l = num1 . length ( ) ;<br>    int [ ] num = Arrays . copyOf ( num1 , num1 + 1 ) ;<br>    int i = l - 1 ;<br>    while ( ( i >= 0 ) && ( i < num1 ) ) {<br>        if ( ( num [ i ] . equals ( "0" ) ) && ( num [ i + 1 ] . equals ( "0" ) ) ) {<br>            num [ i ++ ] = '1' ;<br>            break ;<br>        }<br>        else {<br>            num [ i ++ ] = '0' ;<br>        }<br>        i -- ;<br>    }<br>    num1 = "" + num ;<br>    if ( ( i < 0 ) && ( num1 > 0 ) ) {<br>        num1 = "1" + num1 ;<br>    }<br>    return num1 ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findSubArray ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  int maxsize = - 1 , startindex = 0 ;<br>  int endindex = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ j ] == 0 ) sum += - 1 ;<br>      else sum += 1 ;<br>      if ( sum == 0 && maxsize < j - i + 1 ) {<br>        maxsize = j - i + 1 ;<br>        startindex = i ;<br>      }<br>    }<br>  }<br>  endindex = startindex + maxsize - 1 ;<br>  if ( maxsize == - 1 ) System . out . println ( "No such subarray" ) ;<br>  else System . out . println ( startindex + " to " + endindex ) ;<br>  return maxsize ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubArray ( int [ ] arr , int n ) {<br>    int sum = 0 ;<br>    int maxsize = - 1 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        int sum = n == 0 ? - 1 : ( arr [ i ] == 0 ? 1 : arr [ i ] ) ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            sum = sum + ( - 1 ) == 0 ? ( arr [ j ] == 0 ) ? sum + 1 : ( arr [ j ] == n ? 1 : 0 ) ;<br>            if ( ( sum == 0 && maxsize < j - i + 1 ) || ( sum == 0 && j - i + 1 < n ) ){<br>                int maxsize = j - i + 1 ;<br>                startindex = i ;<br>            }<br>        }<br>    }<br>    if ( ( maxsize == - 1 ) && ( n > 0 ) ){<br>        System . out . println ( "No such subarray" ) ;<br>    }<br>    if ( n > 0 ) {<br>        System . out . println ( startindex + "to" + startindex + maxsize - 1 ) ;<br>    }<br>    return maxsize ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  HashSet < Integer > Hash = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    Hash . add ( arr [ i ] ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int product = arr [ i ] * arr [ j ] ;<br>      if ( Hash . contains ( product ) ) {<br>        result ++ ;<br>      }<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>    int result = 0 ;<br>    HashSet < Integer > Hash = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        Hash . add ( arr [ i ] ) ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int product = arr [ i ] * arr [ j ] ;<br>            if ( product == Hash . class ) {<br>                result ++ ;<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lps ( String seq ) {<br>  int n = seq . length ( ) ;<br>  int i , j , cl ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ i ] = 1 ;<br>  for ( cl = 2 ;<br>  cl <= n ;<br>  cl ++ ) {<br>    for ( i = 0 ;<br>    i < n - cl + 1 ;<br>    i ++ ) {<br>      j = i + cl - 1 ;<br>      if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ;<br>      else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ;<br>      else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;<br>    }<br>  }<br>  return L [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lps ( String str ) {<br>    int n = str . length ( ) ;<br>    L = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        L [ i ] [ i ] = 1 ;<br>    }<br>    for ( int cl = 2 ;  cl <= n ;  cl ++ ) {<br>        for ( int i = 0 ;  i < n - cl + 1 ;  i ++ ) {<br>            int j = i + cl - 1 ;<br>            if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) {<br>                L [ i ] [ j ] = 2 ;<br>            }<br>            if ( str . charAt ( i ) == str . charAt ( j ) ) {<br>                L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ;<br>            }<br>            }<br>                L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ;<br>        }<br>    }<br>    return L [ 0 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getInvCount ( int arr [ ] , int n ) {<br>  int invcount = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int small = 0 ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;<br>    int great = 0 ;<br>    for ( int j = i - 1 ;<br>    j >= 0 ;<br>    j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;<br>    invcount += great * small ;<br>  }<br>  return invcount ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr , int n ) {<br>    invcount = 0 ;<br>    for ( int i = 1 ;  i <= n - 1 ;  i ++ ) {<br>        int small = 0 ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] ) && ( arr [ i ] < arr [ j ] ) ) {<br>                small ++ ;<br>            }<br>        }<br>        int great = 0 ;<br>        for ( int j = i - 1 ;  j >= 0 ;  j -- ) {<br>            if ( ( arr [ i ] < arr [ j ] ) && ( arr [ i ] > arr [ j ] ) ) {<br>                great ++ ;<br>            }<br>        }<br>        invcount += great * small ;<br>    }<br>    return invcount ;<br>}</td>
  </tr><tr>
    <th>DECIMAL_REPRESENTATION_GIVEN_BINARY_STRING_DIVISIBLE_10_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisibleBy10 ( String bin ) {<br>  int n = bin . length ( ) ;<br>  if ( bin . charAt ( n - 1 ) == '1' ) return false ;<br>  int sum = 0 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( bin . charAt ( i ) == '1' ) {<br>      int posFromRight = n - i - 1 ;<br>      if ( posFromRight % 4 == 1 ) sum = sum + 2 ;<br>      else if ( posFromRight % 4 == 2 ) sum = sum + 4 ;<br>      else if ( posFromRight % 4 == 3 ) sum = sum + 8 ;<br>      else if ( posFromRight % 4 == 0 ) sum = sum + 6 ;<br>    }<br>  }<br>  if ( sum % 10 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisibleBy10 ( String bin ) {<br>    int n = bin . length ;<br>    if ( ( bin . charAt ( n - 1 ) == '1' ) && ( bin . charAt ( n - 2 ) == '1' ) ) {<br>        return false ;<br>    }<br>    int sum = 0 ;<br>    int i = n - 2 ;<br>    while ( i >= 0 ) {<br>        if ( ( bin . charAt ( i ) == '1' ) && ( bin . charAt ( i + 1 ) == '2' ) ) {<br>            posFromRight = n - i - 1 ;<br>            if ( ( posFromRight % 4 == 1 ) && ( posFromRight % 4 == 0 ) ) {<br>                sum = sum + 2 ;<br>            }<br>            else if ( ( posFromRight % 4 == 2 ) && ( posFromRight % 4 == 0 ) ) {<br>                sum = sum + 4 ;<br>            }<br>            else if ( ( posFromRight % 4 == 3 ) && ( posFromLeft % 4 == 3 ) ) {<br>                sum = sum + 8 ;<br>            }<br>            else if ( ( posFromRight % 4 == 0 ) && ( posFromLeft % 4 == 0 ) ) {<br>                sum = sum + 6 ;<br>            }<br>        }<br>        i = i - 1 ;<br>    }<br>    if ( ( sum % 10 == 0 ) && ( sum % 10 == 0 ) ) {<br>        return isDivisibleBy10 ( bin , 10 ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 , j = 0 ;<br>  if ( m < n ) return false ;<br>  Arrays . sort ( arr1 ) ;<br>  Arrays . sort ( arr2 ) ;<br>  while ( i < n && j < m ) {<br>    if ( arr1 [ j ] < arr2 [ i ] ) j ++ ;<br>    else if ( arr1 [ j ] == arr2 [ i ] ) {<br>      j ++ ;<br>      i ++ ;<br>    }<br>    else if ( arr1 [ j ] > arr2 [ i ] ) return false ;<br>  }<br>  if ( i < n ) return false ;<br>  else return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubset ( int [ ] arr1 , int [ ] arr2 , int m , int n ) {<br>    int i = 0 ;<br>    int j = 0 ;<br>    if ( m < n ) {<br>        return 0 ;<br>    }<br>    Arrays . sort ( arr1 ) ;<br>    Arrays . sort ( arr1 ) ;<br>    while ( i < n && j < m ) {<br>        if ( arr1 [ j ] < arr2 [ i ] ){<br>            j ++ ;<br>        }<br>        else if ( arr1 [ j ] == arr2 [ i ] ){<br>            j ++ ;<br>            i ++ ;<br>        }<br>        else if ( arr1 [ j ] > arr2 [ i ] ){<br>            return 0 ;<br>        }<br>    }<br>    return i < n ? false : i < m ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubsetSum ( int set [ ] , int n , int sum ) {<br>  boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) subset [ 0 ] [ i ] = true ;<br>  for ( int i = 1 ;<br>  i <= sum ;<br>  i ++ ) subset [ i ] [ 0 ] = false ;<br>  for ( int i = 1 ;<br>  i <= sum ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ;<br>      if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ;<br>    }<br>  }<br>  return subset [ sum ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubsetSum ( int [ ] set , int n , int sum ) {<br>    boolean [ ] subset = ( new boolean [ sum + 1 ] ) ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        subset [ i ] [ 0 ] = true ;<br>        for ( int i = 1 ;  i <= sum ;  i ++ ) {<br>            subset [ 0 ] [ i ] = false ;<br>        }<br>        for ( int i = 1 ;  i <= n ;  i ++ ) {<br>            for ( int j = 1 ;  j <= sum ;  j ++ ) {<br>                if ( j < set [ i - 1 ] ){<br>                    subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ;<br>                }<br>                if ( j >= set [ i - 1 ] ){<br>                    subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] > sum || subset [ i - 1 ] [ j - set [ i - 1 ] ] ) ;<br>                }<br>            }<br>        }<br>    }<br>    return subset [ n ] [ sum ] ;<br>}</td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int kthgroupsum ( int k ) {<br>  return k * k * k ;<br>}<br></td>
    <td>translated code: <br><br> public static double kthGroupSum ( double k ) {<br>    return k * k * k ;<br>}</td>
  </tr><tr>
    <th>THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void thirdLargest ( int arr [ ] , int arr_size ) {<br>  if ( arr_size < 3 ) {<br>    System . out . printf ( " Invalid Input " ) ;<br>    return ;<br>  }<br>  int first = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;<br>  int second = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ;<br>  int third = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < arr_size ;<br>  i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ;<br>  System . out . printf ( "The third Largest " + "element is %d\n" , third ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void thirdLargest ( int arr [ ] , int arrSize ) {<br>    if ( ( arrSize < 3 ) && ( arr [ 0 ] > arr [ 1 ] ) ) {<br>        System . out . print ( " Invalid Input " ) ;<br>        }<br>    }<br>    int first = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < arrSize ;  i ++ ) {<br>        if ( ( arr [ i ] > first ) && ( arr [ i ] < last ) ) {<br>            int first = arr [ i ] ;<br>        }<br>    }<br>    int second = - Integer . MAX_VALUE ;<br>    for ( int i = 0 ;  i <= arrSize ;  i ++ ) {<br>        if ( ( arr [ i ] > second && arr [ i ] < first ) || ( arr [ i ] > first && arr [ i ] > second ) ) {<br>            int second = arr [ i ] ;<br>        }<br>    }<br>    int third = - Integer . MAX_VALUE ;<br>    for ( int i = 0 ;  i <= arrSize ;  i ++ ) {<br>        if ( ( arr [ i ] > third && arr [ i ] < second ) || ( arr [ i ] > third && arr [ i ] > second ) ) {<br>            int third = arr [ i ] ;<br>        }<br>    }<br>    System . out . println ( "The Third Largest" + "element is" + third ) ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumNodes ( int l ) {<br>  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>  double sumLastLevel = 0 ;<br>  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;<br>  double sum = sumLastLevel * l ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumNodes ( int l ) {<br>    leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>    sumLastLevel = 0 ;<br>    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ;<br>    sum = sumLastLevel * l ;<br>    return ( int ) sum ;<br>}</td>
  </tr><tr>
    <th>MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>  int x = a - b ;<br>  int y = b - c ;<br>  int z = a - c ;<br>  if ( x * y > 0 ) return b ;<br>  else if ( x * z > 0 ) return c ;<br>  else return a ;<br>}<br></td>
    <td>translated code: <br><br> public static int middleOfThree ( int a , int b , int c ) {<br>    int x = a - b ;<br>    int y = b - c ;<br>    int z = a - c ;<br>    if ( x * y > 0 ) {<br>        return b ;<br>    }<br>    }<br>        }<br>    }<br>        return a ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  int maxA = - 100000000 , maxB = - 100000000 ;<br>  int maxC = - 100000000 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > maxA ) {<br>      maxC = maxB ;<br>      maxB = maxA ;<br>      maxA = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > maxB ) {<br>      maxC = maxB ;<br>      maxB = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > maxC ) maxC = arr [ i ] ;<br>  }<br>  return ( maxA + maxB + maxC ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>    int maxA = - 100000000 ;<br>    int maxB = - 100000000 ;<br>    int maxC = - 100000000 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] > maxA ) && ( arr [ i ] < maxB ) ) {<br>            int maxC = maxB ;<br>            int maxB = maxA ;<br>            int maxA = arr [ i ] ;<br>        }<br>        if ( ( arr [ i ] > maxB ) && ( arr [ i ] < maxA ) ) {<br>            int maxC = maxB ;<br>            int maxB = arr [ i ] ;<br>        }<br>        if ( ( arr [ i ] > maxC ) && ( arr [ i ] < maxC ) ) {<br>            int maxC = arr [ i ] ;<br>        }<br>    }<br>    return ( maxA + maxB + maxC ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 ;<br>  HashSet < Integer > us = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) us . add ( arr1 [ i ] ) ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>    int count = 0 ;<br>    Set < Integer > us = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        us . add ( arr1 [ i ] ) ;<br>    }<br>    for ( int j = 0 ;  j < n ;  j ++ ) {<br>        if ( x - arr2 [ j ] == us ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_STEPS_REACH_END_ARRAY_CONSTRAINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinStepToReachEnd ( int arr [ ] , int N ) {<br>  boolean [ ] visit = new boolean [ N ] ;<br>  int [ ] distance = new int [ N ] ;<br>  Vector < Integer > [ ] digit = new Vector [ 10 ] ;<br>  for ( int i = 0 ;<br>  i < 10 ;<br>  i ++ ) digit [ i ] = new Vector < > ( ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) visit [ i ] = false ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) digit [ arr [ i ] ] . add ( i ) ;<br>  distance [ 0 ] = 0 ;<br>  visit [ 0 ] = true ;<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  q . add ( 0 ) ;<br>  while ( ! q . isEmpty ( ) ) {<br>    int idx = q . peek ( ) ;<br>    q . remove ( ) ;<br>    if ( idx == N - 1 ) break ;<br>    int d = arr [ idx ] ;<br>    for ( int i = 0 ;<br>    i < digit [ d ] . size ( ) ;<br>    i ++ ) {<br>      int nextidx = digit [ d ] . get ( i ) ;<br>      if ( ! visit [ nextidx ] ) {<br>        visit [ nextidx ] = true ;<br>        q . add ( nextidx ) ;<br>        distance [ nextidx ] = distance [ idx ] + 1 ;<br>      }<br>    }<br>    digit [ d ] . clear ( ) ;<br>    if ( idx - 1 >= 0 && ! visit [ idx - 1 ] ) {<br>      visit [ idx - 1 ] = true ;<br>      q . add ( idx - 1 ) ;<br>      distance [ idx - 1 ] = distance [ idx ] + 1 ;<br>    }<br>    if ( idx + 1 < N && ! visit [ idx + 1 ] ) {<br>      visit [ idx + 1 ] = true ;<br>      q . add ( idx + 1 ) ;<br>      distance [ idx + 1 ] = distance [ idx ] + 1 ;<br>    }<br>  }<br>  return distance [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinStepToReachEnd ( int [ ] arr , int N ) {<br>    boolean [ ] visit = new boolean [ N ] ;<br>    int [ ] distance = new int [ N ] ;<br>    int [ ] digit = new int [ N ] ;<br>    for ( int i = 1 ;  i < N ;  i ++ ) {<br>        digit [ arr [ i ] ] . add ( i ) ;<br>    }<br>    distance [ 0 ] = 0 ;<br>    visit [ 0 ] = true ;<br>    int [ ] q = new int [ N ] ;<br>    q . add ( 0 ) ;<br>    while ( ( int ) q . length > 0 ) {<br>        int idx = q [ 0 ] ;<br>        q . remove ( q . size ( ) - 1 ) ;<br>        if ( ( idx == N - 1 ) && ( arr [ idx ] > 0 ) ) {<br>            break ;<br>        }<br>        int d = arr [ idx ++ ] ;<br>        for ( int i = 0 ;  i < digit [ d ] . length ;  i ++ ) {<br>            nextidx = digit [ d ] [ i ] ;<br>            if ( ( visit [ nextidx ] == false ) && ( arr [ nextidx ] != 0 ) ){<br>                visit [ nextidx ] = true ;<br>                q . add ( nextidx ) ;<br>                distance [ nextidx ] = distance [ idx ] + 1 ;<br>            }<br>        }<br>        if ( ( idx - 1 >= 0 && visit [ idx - 1 ] == false ) || ( idx - 1 >= 0 && visit [ idx - 1 ] == true ) ){<br>            visit [ idx - 1 ] = true ;<br>            q . add ( idx - 1 ) ;<br>            distance [ idx - 1 ] = distance [ idx ] + 1 ;<br>        }<br>        if ( ( idx + 1 < N && visit [ idx + 1 ] == false ) || ( idx + 1 < N && visit [ idx + 1 ] == true ) ) {<br>            visit [ idx + 1 ] = true ;<br>            q . add ( idx + 1 ) ;<br>            distance [ idx + 1 ] = distance [ idx ] + 1 ;<br>        }<br>    }<br>    return distance [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n - 1 && k > 0 ;<br>  ++ i ) {<br>    int pos = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( j - i > k ) break ;<br>      if ( arr [ j ] < arr [ pos ] ) pos = j ;<br>    }<br>    int temp ;<br>    for ( int j = pos ;<br>    j > i ;<br>    -- j ) {<br>      temp = arr [ j ] ;<br>      arr [ j ] = arr [ j - 1 ] ;<br>      arr [ j - 1 ] = temp ;<br>    }<br>    k -= pos - i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void minimizeWithKSwaps ( int [ ] arr , int n , int k ) {<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        int pos = i ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( j - i > k ) && ( j - i > n ) ) {<br>                break ;<br>            }<br>            if ( ( arr [ j ] < arr [ pos ] ) && ( arr [ pos ] > arr [ j ] ) ) {<br>                int pos = j ;<br>            }<br>        }<br>        for ( int j = pos ;  j < i ;  j ++ ) {<br>            arr [ j ] = arr [ j - 1 ] ;<br>        }<br>        k -= pos - i ;<br>    }<br>}</td>
  </tr><tr>
    <th>CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String printSequence ( String arr [ ] , String input ) {<br>  String output = "" ;<br>  int n = input . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( input . charAt ( i ) == ' ' ) output = output + "0" ;<br>    else {<br>      int position = input . charAt ( i ) - 'A' ;<br>      output = output + arr [ position ] ;<br>    }<br>  }<br>  return output ;<br>}<br></td>
    <td>translated code: <br><br> public static String printSequence ( char [ ] arr , String input ) {<br>    int n = input . length ( ) ;<br>    String output = "" ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( input . charAt ( i ++ ) == ' ' ) && ( input . charAt ( i ++ ) == ' ' ) ) {<br>            output = output + "0" ;<br>        }<br>        if ( arr != null ) {<br>            int position = ( int ) input . charAt ( i ++ ) - 'A' ;<br>            output = output + arr [ position ++ ] ;<br>        }<br>    }<br>    return output ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int arraySortedOrNot ( int arr [ ] , int n ) {<br>  if ( n == 1 || n == 0 ) return 1 ;<br>  if ( arr [ n - 1 ] < arr [ n - 2 ] ) return 0 ;<br>  return arraySortedOrNot ( arr , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arraySortedOrNot ( int [ ] arr ) {<br>    int n = arr . length ;<br>    if ( n == 1 || n == 0 ) {<br>        return arraySortedOrNot ( arr , 0 , arr . length ) ;<br>    }<br>    return arr [ 0 ] <= arr [ 1 ] && arraySortedOrNot ( arr , 1 ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) {<br>  int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;<br>  int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;<br>  if ( distSq == radSumSq ) return 1 ;<br>  else if ( distSq > radSumSq ) return - 1 ;<br>  else return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int circle ( float x1 , float y1 , float x2 , float y2 , float r1 , float r2 ) {<br>    float distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;<br>    float radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;<br>    if ( ( distSq == radSumSq ) && ( x1 < x2 ) && ( y1 < y2 ) ) {<br>        return 1 ;<br>    }<br>    else if ( ( distSq > radSumSq ) && ( distSq < radSumSq ) ) {<br>        return - 1 ;<br>    }<br>    else {<br>        return 0 ;<br>    }<br>}</td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>    n -- ;<br>    n |= n >> 1 ;<br>    n |= n >>> 2 ;<br>    n |= n >>> 4 ;<br>    n |= n >> 8 ;<br>    n |= n >>> 16 ;<br>    n ++ ;<br>    return n ;<br>}</td>
  </tr><tr>
    <th>PADOVAN_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pad ( int n ) {<br>  int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    pNext = pPrevPrev + pPrev ;<br>    pPrevPrev = pPrev ;<br>    pPrev = pCurr ;<br>    pCurr = pNext ;<br>  }<br>  return pNext ;<br>}<br></td>
    <td>translated code: <br><br> public static int pad ( int n ) {<br>    int pPrevPrev = 1 , pPrev = 0 , pCurr = 1 , pNext = 0 ;<br>    for ( int i = 3 ;  i <= n ;  i ++ ) {<br>        pNext = pPrevPrev + pPrev ;<br>        pPrevPrev = pPrev ;<br>        pPrev = pCurr ;<br>        pCurr = pNext ;<br>    }<br>    return pNext ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean check ( String s ) {<br>  if ( s . length ( ) >= 10 ) return true ;<br>  for ( int i = 1 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < s . length ( ) ;<br>      k ++ ) {<br>        String s1 = "" , s2 = "" , s3 = "" , s4 = "" ;<br>        try {<br>          s1 = s . substring ( 0 , i ) ;<br>          s2 = s . substring ( i , j - i ) ;<br>          s3 = s . substring ( j , k - j ) ;<br>          s4 = s . substring ( k , s . length ( ) - k ) ;<br>        }<br>        catch ( StringIndexOutOfBoundsException e ) {<br>        }<br>        if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String s ) {<br>    if ( ( s . length ( ) >= 10 ) && ( s . charAt ( 0 ) == 'a' ) ) {<br>        return true ;<br>    }<br>    for ( int i = 1 ;  i < s . length ( ) ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < s . length ( ) ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < s . length ( ) ;  k ++ ) {<br>                String s1 = s . substring ( 0 , i ) ;<br>                String s2 = s . substring ( i , j - i ) ;<br>                String s3 = s . substring ( j , k - j ) ;<br>                String s4 = s . substring ( k , s . length ( ) - k ) ;<br>                if ( ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) || ( s1 != s2 && s1 != s3 && s2 != s4 && s3 != s4 ) ){<br>                    return true ;<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) {<br>  Arrays . sort ( a , Collections . reverseOrder ( ) ) ;<br>  Arrays . sort ( b ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( int [ ] a , int [ ] b , int n , int k ) {<br>    Arrays . sort ( a , 0 , a . length - n ) ;<br>    Arrays . sort ( a , 0 , a . length ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( a [ i ] + b [ i ] < k ) && ( a [ i ] + b [ i ] < n ) ) a [ i ] = 5 ;<br>            return false ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int winner ( int a [ ] , int n , int k ) {<br>  if ( k >= n - 1 ) return n ;<br>  int best = 0 , times = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > best ) {<br>      best = a [ i ] ;<br>      if ( i == 1 ) times = 1 ;<br>    }<br>    else times += 1 ;<br>    if ( times >= k ) return best ;<br>  }<br>  return best ;<br>}<br></td>
    <td>translated code: <br><br> public static int winner ( int [ ] a , int n , int k ) {<br>    if ( k >= n - 1 ){<br>        return n ;<br>    }<br>    int best = 0 ;<br>    int times = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( a [ i ] > best ) a [ i ] = 5 ;<br>            int best = a [ i ] ;<br>            if ( i == true ){<br>                times = 1 ;<br>            }<br>        else{<br>            times ++ ;<br>        }<br>        if ( times >= k ){<br>            return best ;<br>        }<br>    }<br>    return best ;<br>}</td>
  </tr><tr>
    <th>DIRECTION_LAST_SQUARE_BLOCK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void direction ( int R , int C ) {<br>  if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( R == C && R % 2 != 0 && C % 2 != 0 ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {<br>    System . out . println ( "Left" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {<br>    System . out . println ( "Up" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {<br>    System . out . println ( "Down" ) ;<br>    return ;<br>  }<br>  if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {<br>    System . out . println ( "Right" ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void direction ( int R , int C ) {<br>    if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 == 0 && C < C ) ){<br>        System . out . println ( "Left" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) || ( R == C && R % 2 == 0 && C > R ) ){<br>        System . out . println ( "Up" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( R == C && R % 2 != 0 && C % 2 != 0 ){<br>        System . out . println ( "Right" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( R == C && R % 2 == 0 && C % 2 == 0 ) {<br>        System . out . println ( "Left" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 != 0 && C < C ) ){<br>        System . out . println ( "Right" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) || ( R != C && R % 2 != 0 && C > R ) ){<br>        System . out . println ( "Down" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 == 0 && C < C ) ){<br>        System . out . println ( "Left" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) || ( R == C && R % 2 == 0 && C > R ) ){<br>        System . out . println ( "Up" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) || ( R != C && R % 2 != 0 && C > R ) ){<br>        System . out . println ( "Down" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>    if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) || ( R != C && R % 2 != 0 && C < C ) ){<br>        System . out . println ( "Right" ) ;<br>        direction ( R , C , 0 ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIntegralSolutions ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n - i ;<br>  j ++ ) for ( int k = 0 ;<br>  k <= ( n - i - j ) ;<br>  k ++ ) if ( i + j + k == n ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIntegralSolutions ( int n ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            for ( int k = 0 ;  k < n + 1 ;  k ++ ) {<br>                if ( i + j + k == n ) {<br>                    result ++ ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swapDiagonal ( int matrix [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    int temp = matrix [ i ] [ i ] ;<br>    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;<br>    matrix [ i ] [ N - i - 1 ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void swapDiagonal ( int [ ] [ ] matrix ) {<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        matrix [ i ] [ i ] = \<br>            matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ i ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_OPERATIONS_MAKE_GCD_ARRAY_MULTIPLE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MinOperation ( int a [ ] , int n , int k ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( a [ i ] != 1 && a [ i ] > k ) {<br>      result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ;<br>    }<br>    else {<br>      result = result + k - a [ i ] ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int MinOperation ( int [ ] a , int n , int k ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        if ( ( a [ i ] != 1 && a [ i ] > k ) || ( a [ i ] == 0 && a [ i ] == n ) ) a [ i ] = 5 ;<br>            int result = ( result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ) ;<br>        else{<br>            result = result + k - a [ i ] ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) {<br>  if ( i >= N || j >= N ) {<br>    return 0 ;<br>  }<br>  int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ;<br>  if ( mat [ i ] [ j ] == 1 ) {<br>    return ( int ) ( Math . pow ( 2 , p ) + result ) ;<br>  }<br>  else {<br>    return result ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static double maxDecimalValue ( double [ ] [ ] mat , int i , int j , double p ) {<br>    if ( i >= N || j >= N ){<br>        return 0 ;<br>    }<br>    double result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ;<br>    if ( mat [ i ] [ j ] == 1 ) {<br>        return Math . pow ( 2 , p ) + result ;<br>    }<br>    if ( p > 0 ) {<br>        return result ;<br>    }<br>}</td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long squareRoot ( int n ) {<br>  int x = n ;<br>  int y = 1 ;<br>  while ( x > y ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  }<br>  return ( long ) x ;<br>}<br></td>
    <td>translated code: <br><br> public static int squareRoot ( int n ) {<br>    int x = n ;<br>    int y = 1 ;<br>    while ( ( x > y ) && ( x < y ) ) {<br>        x = ( x + y ) / 2 ;<br>        int y = n / x ;<br>    }<br>    return x ;<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KMP ( int m , int n , String str2 , String str1 ) {<br>  int pos = 0 , len = 0 ;<br>  int [ ] p = new int [ m + 1 ] ;<br>  int k = 0 ;<br>  char [ ] ch1 = str1 . toCharArray ( ) ;<br>  char [ ] ch2 = str2 . toCharArray ( ) ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ;<br>    if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ;<br>    p [ i ] = k ;<br>  }<br>  for ( int j = 0 , i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ;<br>    if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ;<br>    if ( j > len ) {<br>      len = j ;<br>      pos = i - j + 1 ;<br>    }<br>  }<br>  System . out . println ( "Shift = " + pos ) ;<br>  System . out . println ( "Prefix = " + str1 . substring ( 0 , len ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void KMP ( int m , int n , String str2 , String str1 ) {<br>    int pos = 0 ;<br>    int Len = 0 ;<br>    int [ ] p = new int [ m + 1 ] ;<br>    int k = 0 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        while ( ( k > 0 ) && str1 . charAt ( k ) != str1 . charAt ( i - 1 ) ) {<br>            int k = p [ k ] ;<br>        }<br>        if ( ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) && ( str2 . charAt ( i - 1 ) == str2 . charAt ( i - 1 ) ) ) {<br>            k ++ ;<br>        }<br>        p [ i ++ ] = k ;<br>    }<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        while ( ( j > 0 && j < n && str1 . charAt ( j ) != str2 . charAt ( i ) ) || ( j > 0 && j < n && str1 . charAt ( j ) != str2 . charAt ( i ) ) ) {<br>            int j = p [ j ] ;<br>        }<br>        if ( ( j < n && str1 . charAt ( j ) == str2 . charAt ( i ) ) || ( j < m && str2 . charAt ( j ) == str1 . charAt ( j ) ) ) {<br>            j ++ ;<br>        }<br>        if ( ( j > Len ) && ( j < Len ) ){<br>            Len = j ;<br>            pos = i - j + 1 ;<br>        }<br>    }<br>    System . out . println ( "Shift = " + pos ) ;<br>    System . out . println ( "Prefix = " + str1 . substring ( 0 , Len ) ) ;<br>}</td>
  </tr><tr>
    <th>SORTED_ORDER_PRINTING_OF_AN_ARRAY_THAT_REPRESENTS_A_BST</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static void printSorted ( int [ ] arr , int start , int end ) {<br>  if ( start > end ) return ;<br>  printSorted ( arr , start * 2 + 1 , end ) ;<br>  System . out . print ( arr [ start ] + " " ) ;<br>  printSorted ( arr , start * 2 + 2 , end ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSorted ( int [ ] arr , int start , int end ) {<br>    if ( start > end ) {<br>        }<br>    }<br>    printSorted ( arr , start * 2 + 1 , end ) ;<br>    System . out . print ( arr [ start ] + " " ) ;<br>    printSorted ( arr , start * 2 + 2 , end ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( int degree [ ] , int n ) {<br>  int deg_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    deg_sum += degree [ i ] ;<br>  }<br>  return ( 2 * ( n - 1 ) == deg_sum ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int [ ] degree , int n ) {<br>    int degSum = sum ( degree ) ;<br>    if ( ( 2 * ( n - 1 ) ) == deg_sum ) {<br>        return check ( degree , n , 0 ) ;<br>    }<br>    else {<br>        return false ;<br>    }<br>}</td>
  </tr><tr>
    <th>MOVE_ZEROES_END_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pushZerosToEnd ( int arr [ ] , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ;<br>  while ( count < n ) arr [ count ++ ] = 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void pushZerosToEnd ( int [ ] arr , int n ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] != 0 ){<br>            arr [ count ++ ] = arr [ i ++ ] ;<br>            count ++ ;<br>        }<br>    }<br>    while ( count < n ) {<br>        arr [ count ++ ] = 0 ;<br>        count ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_ELEMENTS_WHICH_DIVIDE_ALL_NUMBERS_IN_RANGE_L_R</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int answerQuery ( int a [ ] , int n , int l , int r ) {<br>  int count = 0 ;<br>  l = l - 1 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i ++ ) {<br>    int element = a [ i ] ;<br>    int divisors = 0 ;<br>    for ( int j = l ;<br>    j < r ;<br>    j ++ ) {<br>      if ( a [ j ] % a [ i ] == 0 ) divisors ++ ;<br>      else break ;<br>    }<br>    if ( divisors == ( r - l ) ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int answerQuery ( int [ ] a , int n , int l , int r ) {<br>    int count = 0 ;<br>    l = l - 1 ;<br>    for ( int i = l ;  i < r ;  i += 1 ) {<br>        int element = a [ i ++ ] ;<br>        int divisors = 0 ;<br>        for ( int j = l ;  j < r ;  j += 1 ) {<br>            if ( ( a [ j ] % a [ i ] == 0 ) && ( a [ l ] % a [ i ] == 0 ) ) a [ i ] = 5 ;<br>                divisors ++ ;<br>            if ( l > r ) {<br>                break ;<br>            }<br>        }<br>        if ( ( divisors == ( r - l ) ) && ( n > l ) ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>SUM_LARGEST_PRIME_FACTOR_NUMBER_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumOfLargePrimeFactor ( int n ) {<br>  int prime [ ] = new int [ n + 1 ] , sum = 0 ;<br>  Arrays . fill ( prime , 0 ) ;<br>  int max = n / 2 ;<br>  for ( int p = 2 ;<br>  p <= max ;<br>  p ++ ) {<br>    if ( prime [ p ] == 0 ) {<br>      for ( int i = p * 2 ;<br>      i <= n ;<br>      i += p ) prime [ i ] = p ;<br>    }<br>  }<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( prime [ p ] != 0 ) sum += prime [ p ] ;<br>    else sum += p ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumOfLargePrimeFactor ( int n ) {<br>    int prime [ ] = {<br>    }<br>    int sum = 0 ;<br>    int max = ( int ) ( n / 2 ) ;<br>    for ( int p = 2 ;  p <= max ;  p ++ ) {<br>        if ( prime [ p ] == 0 ) {<br>            for ( int i = p * 2 ;  i <= n ;  i += p ) {<br>                prime [ i ] = p ;<br>            }<br>        }<br>    }<br>    for ( int p = 2 ;  p <= n ;  p ++ ) {<br>        if ( prime [ p ] ) {<br>            sum += prime [ p ] ;<br>        }<br>        else {<br>            sum += p ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String arrangeString ( String str ) {<br>  int char_count [ ] = new int [ MAX_CHAR ] ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) char_count [ str . charAt ( i ) - 'A' ] ++ ;<br>    else sum = sum + ( str . charAt ( i ) - '0' ) ;<br>  }<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    char ch = ( char ) ( 'A' + i ) ;<br>    while ( char_count [ i ] -- != 0 ) res = res + ch ;<br>  }<br>  if ( sum > 0 ) res = res + sum ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String arrangeString ( String string ) {<br>    charCount = new int [ MAX_CHAR ] ;<br>    int s = 0 ;<br>    for ( int i = 0 ;  i < string . length ( ) ;  i ++ ) {<br>        if ( string . charAt ( i ) >= 'A' && string . charAt ( i ) <= 'Z' ) {<br>            charCount [ ( int ) string . charAt ( i ) - 'A' ] ++ ;<br>        }<br>        else {<br>            s += ( char ) ( string . charAt ( i ) - '0' ) ;<br>        }<br>    }<br>    String res = "" ;<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        char ch = ( char ) ( Character . MIN_VALUE + i ) ;<br>        while ( charCount [ i ++ ] -- > 0 ) {<br>            res += ch ;<br>            charCount [ i ] -- ;<br>        }<br>    }<br>    if ( s > 0 ) {<br>        res += String . valueOf ( s ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  int count [ ] [ ] = new int [ m ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) count [ i ] [ 0 ] = 1 ;<br>  for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) count [ 0 ] [ j ] = 1 ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ;<br>  }<br>  return count [ m - 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>    int [ ] [ ] count = new int [ m ] [ n ] ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        count [ i ] [ 0 ] = 1 ;<br>    }<br>    for ( int j = 0 ;  j < n ;  j ++ ) {<br>        count [ 0 ] [ j ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ;<br>        }<br>    }<br>    return count [ m - 1 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int editDistDP ( String str1 , String str2 , int m , int n ) {<br>  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int editDistDP ( String str1 , String str2 , int m , int n ) {<br>    int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            if ( i == 0 ) {<br>                dp [ i ] [ j ] = j ;<br>            }<br>            else if ( j == 0 ){<br>                dp [ i ] [ j ] = i ;<br>            }<br>            else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ){<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>            }<br>            else {<br>                dp [ i ] [ j ] = 1 + Math . min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSol ( int coeff [ ] , int start , int end , int rhs ) {<br>  if ( rhs == 0 ) return 1 ;<br>  int result = 0 ;<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSol ( int [ ] coeff , int start , int end , int rhs ) {<br>    if ( ( rhs == 0 ) && ( coeff == 0 ) ) {<br>        return 1 ;<br>    }<br>    int result = 0 ;<br>    for ( int i = start ;  i <= end ;  i ++ ) {<br>        if ( ( coeff [ i ] <= rhs ) && ( start < end ) ) {<br>            result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minheapify ( int [ ] a , int index ) {<br>  int small = index ;<br>  int l = 2 * index + 1 ;<br>  int r = 2 * index + 2 ;<br>  if ( l < n && a [ l ] < a [ small ] ) small = l ;<br>  if ( r < n && a [ r ] < a [ small ] ) small = r ;<br>  if ( small != index ) {<br>    int t = a [ small ] ;<br>    a [ small ] = a [ index ] ;<br>    a [ index ] = t ;<br>    minheapify ( a , small ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void minheapify ( int [ ] a , int index ) {<br>    small = index ;<br>    int l = 2 * index + 1 ;<br>    int r = 2 * index + 2 ;<br>    if ( ( l < n && a [ l ] < a [ small ] ) || ( l > small && a [ l ] > a [ small ] ) ) a [ small ] = 5 ;<br>        small = l ;<br>    if ( ( r < n && a [ r ] < a [ small ] ) || ( r < small && a [ r ] > a [ small ] ) ) a [ r ] = 5 ;<br>        small = r ;<br>    if ( ( small != index ) && ( small != index ) ){<br>        ( ( Integer ) a [ small ] ) . hashCode ( ) ;<br>        minHeapify ( a , small ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void computeLPSArray ( String pat , int M , int lps [ ] ) {<br>  int len = 0 ;<br>  int i = 1 ;<br>  lps [ 0 ] = 0 ;<br>  while ( i < M ) {<br>    if ( pat . charAt ( i ) == pat . charAt ( len ) ) {<br>      len ++ ;<br>      lps [ i ] = len ;<br>      i ++ ;<br>    }<br>    else {<br>      if ( len != 0 ) {<br>        len = lps [ len - 1 ] ;<br>      }<br>      else {<br>        lps [ i ] = len ;<br>        i ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> static void computeLPSArray ( int [ ] pat , int M , int [ ] lps ) {<br>    int len = 0 ;<br>    lps [ 0 ] = pat . getM ( ) ;<br>    int i = 1 ;<br>    while ( i < M ){<br>        if ( pat . charAt ( i ) == pat . charAt ( len ) ) {<br>            len ++ ;<br>            lps [ i ] = len ;<br>            i ++ ;<br>        }<br>        if ( pat == null ) {<br>            if ( len != 0 ){<br>                int len = lps [ len - 1 ] ;<br>            }<br>            if ( pat == null ) {<br>                lps [ i ] = 0 ;<br>                i ++ ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_DIFFERENCE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinDiff ( int [ ] arr , int n ) {<br>  int diff = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ;<br>  return diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinDiff ( int [ ] arr , int n ) {<br>    int diff = 10 * 20 ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ){<br>                int diff = Math . abs ( arr [ i ] - arr [ j ] ) ;<br>            }<br>        }<br>    }<br>    return diff ;<br>}</td>
  </tr><tr>
    <th>PRINT_FIRST_K_DIGITS_1N_N_POSITIVE_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void print ( int n , int k ) {<br>  int rem = 1 ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    System . out . print ( ( 10 * rem ) / n ) ;<br>    rem = ( 10 * rem ) % n ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void Print ( int n , int k ) {<br>    int rem = 1 ;<br>    for ( int i = 0 ;  i <= k ;  i ++ ) {<br>        System . out . print ( Math . floor ( ( ( 10 * rem ) / n ) ) + " " ) ;<br>        rem = ( 10 * rem ) % n ;<br>    }<br>}</td>
  </tr><tr>
    <th>GROUP_MULTIPLE_OCCURRENCE_OF_ARRAY_ELEMENTS_ORDERED_BY_FIRST_OCCURRENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void groupElements ( int arr [ ] , int n ) {<br>  boolean visited [ ] = new boolean [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    visited [ i ] = false ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! visited [ i ] ) {<br>      System . out . print ( arr [ i ] + " " ) ;<br>      for ( int j = i + 1 ;<br>      j < n ;<br>      j ++ ) {<br>        if ( arr [ i ] == arr [ j ] ) {<br>          System . out . print ( arr [ i ] + " " ) ;<br>          visited [ j ] = true ;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void groupElements ( int [ ] arr , int n ) {<br>    boolean [ ] visited = new boolean [ n ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        visited [ i ] = false ;<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( visited [ i ] == false ) && ( n > 0 ) ){<br>            System . out . print ( arr [ i ] + " " ) ;<br>            for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>                if ( ( arr [ i ] == arr [ j ] ) && ( n == 1 ) ) {<br>                    System . out . print ( arr [ i ] + " " ) ;<br>                    visited [ j ] = true ;<br>                }<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkIsAP ( int arr [ ] , int n ) {<br>  if ( n == 1 ) return true ;<br>  Arrays . sort ( arr ) ;<br>  int d = arr [ 1 ] - arr [ 0 ] ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkIsAP ( int [ ] arr , int n ) {<br>    if ( ( n == 1 ) && ( arr [ 0 ] == arr [ 1 ] ) ) {<br>        return checkIsAP ( arr , n , 0 ) ;<br>    }<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int d = arr [ 1 ] - arr [ 0 ] ;<br>    for ( int i = 2 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] - arr [ i - 1 ] != d ) && ( arr [ i ] - arr [ n - 1 ] != d ) ){<br>            return false ;<br>        }<br>    }<br>    return checkIsAP ( arr , n , 0 ) ;<br>}</td>
  </tr><tr>
    <th>NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findPosition ( int k , int n ) {<br>  long f1 = 0 , f2 = 1 , f3 ;<br>  int i = 2 ;<br>  while ( i != 0 ) {<br>    f3 = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    if ( f2 % k == 0 ) {<br>      return n * i ;<br>    }<br>    i ++ ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findPosition ( int k , int n ) {<br>    int f1 = 0 ;<br>    f2 = 1 ;<br>    int i = 2 ;<br>    while ( i != 0 ){<br>        int f3 = f1 + f2 ;<br>        f1 = f2 ;<br>        f2 = f3 ;<br>        if ( f2 % k == 0 ){<br>            return n * i ;<br>        }<br>        i ++ ;<br>    }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_DIFFERENCE_EQUAL_K_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairsWithDiffK ( int arr [ ] , int n , int k ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  int l = 0 ;<br>  int r = 0 ;<br>  while ( r < n ) {<br>    if ( arr [ r ] - arr [ l ] == k ) {<br>      count ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( arr [ r ] - arr [ l ] > k ) l ++ ;<br>    else r ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairsWithDiffK ( int [ ] arr , int n , int k ) {<br>    int count = 0 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int l = 0 ;<br>    int r = 0 ;<br>    while ( r < n ) {<br>        if ( arr [ r ] - arr [ l ] == k ){<br>            count ++ ;<br>            l ++ ;<br>            r ++ ;<br>        }<br>        else if ( arr [ r ] - arr [ l ] > k ){<br>            l ++ ;<br>        }<br>        else {<br>            r ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNum ( int [ ] arr , int n ) {<br>  int count = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNum ( int [ ] arr , int n ) {<br>    int count = 0 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) || ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) ) {<br>            count += arr [ i + 1 ] - arr [ i ] - 1 ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String maximumPalinUsingKChanges ( String str , int k ) {<br>  char palin [ ] = str . toCharArray ( ) ;<br>  String ans = "" ;<br>  int l = 0 ;<br>  int r = str . length ( ) - 1 ;<br>  while ( l < r ) {<br>    if ( str . charAt ( l ) != str . charAt ( r ) ) {<br>      palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ;<br>      k -- ;<br>    }<br>    l ++ ;<br>    r -- ;<br>  }<br>  if ( k < 0 ) {<br>    return "Not possible" ;<br>  }<br>  l = 0 ;<br>  r = str . length ( ) - 1 ;<br>  while ( l <= r ) {<br>    if ( l == r ) {<br>      if ( k > 0 ) {<br>        palin [ l ] = '9' ;<br>      }<br>    }<br>    if ( palin [ l ] < '9' ) {<br>      if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) {<br>        k -= 2 ;<br>        palin [ l ] = palin [ r ] = '9' ;<br>      }<br>      else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) {<br>        k -- ;<br>        palin [ l ] = palin [ r ] = '9' ;<br>      }<br>    }<br>    l ++ ;<br>    r -- ;<br>  }<br>  for ( int i = 0 ;<br>  i < palin . length ;<br>  i ++ ) ans += palin [ i ] ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static String maximumPalinUsingKChanges ( String strr , int k ) {<br>    palin = strr ;<br>    int l = 0 ;<br>    int r = strr . length ( ) - 1 ;<br>    while ( ( l <= r ) && ( l <= k ) ) {<br>        if ( ( strr . charAt ( l ) != strr . charAt ( r ) ) && ( strr . charAt ( l ) != strr . charAt ( r ) ) ) {<br>            palin [ l ] = palin [ r ] = Math . max ( strr . charAt ( l ) , strr . charAt ( r ) ) ;<br>            k -- ;<br>        }<br>        l ++ ;<br>        r -- ;<br>    }<br>    if ( ( k < 0 ) && ( k > 0 ) ) {<br>        return "Not possible" ;<br>    }<br>    int l = 0 ;<br>    int r = strr . length ( ) - 1 ;<br>    while ( ( l <= r ) && ( l <= k ) ) {<br>        if ( ( l == r ) && ( k == 0 ) ) {<br>            if ( ( k > 0 ) && ( k < 5 ) ) {<br>                palin [ l ++ ] = '9' ;<br>            }<br>        }<br>        if ( ( palin [ l ] < '9' ) && ( palin [ l ] > '9' ) ) {<br>            if ( ( k >= 2 && palin [ l ] . equals ( strr . charAt ( l ) ) && palin [ r ] . equals ( strr . charAt ( r ) ) ) || ( k >= 2 && palin [ l ] . equals ( strr . charAt ( l ) ) && palin [ r ] . equals ( strr . charAt ( r ) ) ) ) {<br>                k -- ;<br>                palin [ l ] = palin [ r ] = '9' ;<br>            }<br>            if ( ( k >= 1 && ( palin [ l ] != strr [ l ] || palin [ r ] != strr [ r ] ) ) || ( k >= 2 && ( palin [ l ] != strr [ l ] || palin [ r ] != strr [ r ] ) ) ) {<br>                k -- ;<br>                palin [ l ] = palin [ r ] = '9' ;<br>            }<br>        }<br>        l ++ ;<br>        r -- ;<br>    }<br>    return palin ;<br>}</td>
  </tr><tr>
    <th>SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void subArray ( int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      for ( int k = i ;<br>      k <= j ;<br>      k ++ ) System . out . print ( arr [ k ] + " " ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void subArray ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            for ( int k = i ;  k <= j ;  k ++ ) {<br>                System . out . print ( arr [ k ] + " " ) ;<br>            }<br>            System . out . print ( "\n" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSum ( int a [ ] [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sort ( a , i , n ) ;<br>  int sum = a [ n - 1 ] [ M - 1 ] ;<br>  int prev = a [ n - 1 ] [ M - 1 ] ;<br>  int i , j ;<br>  for ( i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( j = M - 1 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( a [ i ] [ j ] < prev ) {<br>        prev = a [ i ] [ j ] ;<br>        sum += prev ;<br>        break ;<br>      }<br>    }<br>    if ( j == - 1 ) return 0 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSum ( int [ ] [ ] a , int n ) {<br>    M = a . length ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        a [ i ] . sort ( ) ;<br>    }<br>    int sum = a [ n - 1 ] [ M - 1 ] ;<br>    int prev = a [ n - 1 ] [ M - 1 ] ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        for ( int j = M - 1 ;  j >= 0 ;  j -- ) {<br>            if ( ( a [ i ] [ j ] < prev ) && ( a [ i ] [ j ] > prev ) ) {<br>                int prev = a [ i ] [ j ] ;<br>                sum += prev ;<br>                break ;<br>            }<br>        }<br>        if ( ( j == - 1 ) && ( a == 5 ) ) {<br>            return 0 ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int factorial ( int n ) {<br>  if ( n == 0 ) return 1 ;<br>  return n * factorial ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int factorial ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSquares ( int n ) {<br>  int square = 0 , prev_x = 0 ;<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) {<br>    square = ( square + x + prev_x ) ;<br>    System . out . print ( square + " " ) ;<br>    prev_x = x ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSquares ( int n ) {<br>    int square = 0 ;<br>    for ( int x = 0 ;  x <= n ;  x ++ ) {<br>        square = ( square + x + prevX ) ;<br>        System . out . print ( square + " " ) ;<br>        prev_x = x ;<br>    }<br>}</td>
  </tr><tr>
    <th>ROPES_DATA_STRUCTURE_FAST_STRING_CONCATENATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    c [ i ] = a [ i ] ;<br>  }<br>  for ( int j = 0 ;<br>  j < n2 ;<br>  j ++ ) {<br>    c [ i ++ ] = b [ j ] ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void concatenate ( double [ ] a , double [ ] b , double [ ] c , int n1 , int n2 ) {<br>    int i = - 1 ;<br>    for ( int i = 0 ;  i < n1 ;{<br>        c [ i ] = a [ i ] ;<br>    }<br>    for ( int j = 0 ;  j < n2 ;{<br>        c [ i ] = b [ j ] ;<br>        i ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) {<br>  int diff = Integer . MAX_VALUE ;<br>  int res_l = 0 , res_r = 0 ;<br>  int l = 0 , r = n - 1 ;<br>  while ( l < m && r >= 0 ) {<br>    if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {<br>      res_l = l ;<br>      res_r = r ;<br>      diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;<br>    }<br>    if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;<br>    else l ++ ;<br>  }<br>  System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) {<br>    double diff = Double . POSITIVE_INFINITY ;<br>    int l = 0 ;<br>    int r = n - 1 ;<br>    while ( ( l < m && r >= 0 ) || ( l < n && r >= 0 ) ) {<br>        if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ){<br>            double resL = l ;<br>            double resR = r ;<br>            int diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;<br>        }<br>        if ( ar1 [ l ] + ar2 [ r ] > x ) {<br>            r = r - 1 ;<br>        }<br>        else {<br>            l = l + 1 ;<br>        }<br>    }<br>    System . out . println ( "The closest pair is [" + ar1 [ resL ] + "," + ar2 [ resR ] + "]" ) ;<br>}</td>
  </tr><tr>
    <th>CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minRemove ( int arr [ ] , int n ) {<br>  int LIS [ ] = new int [ n ] ;<br>  int len = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) LIS [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ;<br>    }<br>    len = Math . max ( len , LIS [ i ] ) ;<br>  }<br>  return n - len ;<br>}<br></td>
    <td>translated code: <br><br> public static int minRemove ( int [ ] arr , int n ) {<br>    int [ ] LIS = new int [ n ] ;<br>    int len = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        LIS [ i ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) || ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) ){<br>                LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ;<br>            }<br>        }<br>        len = Math . max ( len , LIS [ i ] ) ;<br>    }<br>    return ( n - arr . length ) ;<br>}</td>
  </tr><tr>
    <th>TAIL_RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int fact ( int n ) {<br>  if ( n == 0 ) return 1 ;<br>  return n * fact ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long fact ( long n ) {<br>    if ( ( n == 0 ) && ( n % 2 == 0 ) ) {<br>        return 1 ;<br>    }<br>    return n * fact ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>RECURSIVE_FUNCTIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) {<br>  if ( 0 == n ) return ;<br>  tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ;<br>  System . out . printf ( "Move the disk %d from %c to %c\n" , n , sourcePole , destinationPole ) ;<br>  tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) {<br>    if ( ( 0 == n ) && ( sourcePole != null ) && ( destinationPole != null ) && ( auxiliaryPole != null ) ) {<br>        tower ( n , sourcePole , destinationPole , auxiliaryPole , null ) ;<br>    }<br>    tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ;<br>    System . out . println ( "Move the disk" + sourcePole + " from" + sourcePole + " to" + destinationPole ) ;<br>    tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ;<br>}</td>
  </tr><tr>
    <th>FIND_X_Y_SATISFYING_AX_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solution ( int a , int b , int n ) {<br>  for ( int i = 0 ;<br>  i * a <= n ;<br>  i ++ ) {<br>    if ( ( n - ( i * a ) ) % b == 0 ) {<br>      System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ;<br>      return ;<br>    }<br>  }<br>  System . out . println ( "No solution" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int solution ( int a , int b , int n ) {<br>    int i = 0 ;<br>    while ( i * a <= n ) {<br>        if ( ( n - ( i * a ) ) % b == 0 ){<br>            System . out . println ( "x = " + i + ", y = " + ( int ) ( ( n - ( i * a ) ) / b ) ) ;<br>            return 0 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    System . out . println ( "No solution" ) ;<br>}</td>
  </tr><tr>
    <th>EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long exponentiation ( long base , long exp ) {<br>  long t = 1L ;<br>  while ( exp > 0 ) {<br>    if ( exp % 2 != 0 ) t = ( t * base ) % N ;<br>    base = ( base * base ) % N ;<br>    exp /= 2 ;<br>  }<br>  return t % N ;<br>}<br></td>
    <td>translated code: <br><br> public static int exponentiation ( int bas , int exp ) {<br>    double t = 1 ;<br>    while ( ( exp > 0 ) && ( bas . isBAS ( ) ) ) {<br>        if ( ( exp % 2 != 0 ) && ( exp % 2 == 0 ) ) {<br>            t = ( t . multiply ( bas ) ) . mod ( N ) ;<br>        }<br>        bas = ( bas . multiply ( bas ) ) . mod ( N ) ;<br>        exp = ( int ) ( exp / 2 ) ;<br>    }<br>    return t % N ;<br>}</td>
  </tr><tr>
    <th>CHECK_OCCURRENCES_CHARACTER_APPEAR_TOGETHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkIfAllTogether ( String s , char c ) {<br>  boolean oneSeen = false ;<br>  int i = 0 , n = s . length ( ) ;<br>  while ( i < n ) {<br>    if ( s . charAt ( i ) == c ) {<br>      if ( oneSeen == true ) return false ;<br>      while ( i < n && s . charAt ( i ) == c ) i ++ ;<br>      oneSeen = true ;<br>    }<br>    else i ++ ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkIfAllTogether ( String s , char c ) {<br>    oneSeen = false ;<br>    int i = 0 ;<br>    int n = s . length ( ) ;<br>    while ( ( i < n ) && ( i < a ) ) {<br>        if ( ( s . charAt ( i ) == c ) && ( s . charAt ( i + 1 ) == c ) ) {<br>            if ( ( oneSeen == true ) && ( c != null ) ) {<br>                return false ;<br>            }<br>            while ( ( i < n && s . charAt ( i ) == c ) || ( i < n && s . charAt ( i ) == c ) ) {<br>                i = i + 1 ;<br>            }<br>            oneSeen = true ;<br>        }<br>        else {<br>            i = i + 1 ;<br>        }<br>    }<br>    return checkIfAllTogether ( s , c , false ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findArea ( Integer arr [ ] , int n ) {<br>  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;<br>  int [ ] dimension = {<br>    0 , 0 };<br>    for ( int i = 0 , j = 0 ;<br>    i < n - 1 && j < 2 ;<br>    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;<br>    return ( dimension [ 0 ] * dimension [ 1 ] ) ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int findArea ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int [ ] dimension = {<br>    }<br>    int i = 0 ;<br>    int j = 0 ;<br>    while ( ( i < n - 1 && j < 2 ) || ( i < n - 1 && j < 2 ) ) {<br>        if ( ( arr [ i ] == arr [ i + 1 ] ) && ( n == arr [ i ] ) ) {<br>            dimension [ j ] = arr [ i ] ;<br>            j ++ ;<br>            i ++ ;<br>        }<br>        i ++ ;<br>    }<br>    return ( dimension . x * dimension . y ) ;<br>}</td>
  </tr><tr>
    <th>PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int Circumference ( int a ) {<br>  return 4 * a ;<br>}<br></td>
    <td>translated code: <br><br> public static Circumference a ( int a ) {<br>    return ( 4 * a ) ;<br>}</td>
  </tr><tr>
    <th>CYCLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void cycleSort ( int arr [ ] , int n ) {<br>  int writes = 0 ;<br>  for ( int cycle_start = 0 ;<br>  cycle_start <= n - 2 ;<br>  cycle_start ++ ) {<br>    int item = arr [ cycle_start ] ;<br>    int pos = cycle_start ;<br>    for ( int i = cycle_start + 1 ;<br>    i < n ;<br>    i ++ ) if ( arr [ i ] < item ) pos ++ ;<br>    if ( pos == cycle_start ) continue ;<br>    while ( item == arr [ pos ] ) pos += 1 ;<br>    if ( pos != cycle_start ) {<br>      int temp = item ;<br>      item = arr [ pos ] ;<br>      arr [ pos ] = temp ;<br>      writes ++ ;<br>    }<br>    while ( pos != cycle_start ) {<br>      pos = cycle_start ;<br>      for ( int i = cycle_start + 1 ;<br>      i < n ;<br>      i ++ ) if ( arr [ i ] < item ) pos += 1 ;<br>      while ( item == arr [ pos ] ) pos += 1 ;<br>      if ( item != arr [ pos ] ) {<br>        int temp = item ;<br>        item = arr [ pos ] ;<br>        arr [ pos ] = temp ;<br>        writes ++ ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int cycleSort ( int [ ] array ) {<br>    int writes = 0 ;<br>    for ( int cycleStart = 0 ;  cycleStart <= array . length - 1 ;  cycleStart ++ ) {<br>        Object item = array [ cycleStart ] ;<br>        int pos = cycleStart ;<br>        for ( int i = cycleStart + 1 ;  i < array . length ;  i ++ ) {<br>            if ( array [ i ] < item ){<br>                pos ++ ;<br>            }<br>        }<br>        if ( pos == cycleStart ) {<br>            continue ;<br>        }<br>        while ( item == array [ pos ++ ] ){<br>            pos ++ ;<br>        }<br>        array [ pos ] = item ;<br>        writes ++ ;<br>        while ( pos != cycleStart ) {<br>            int pos = cycleStart ;<br>            for ( int i = cycleStart + 1 ;  i < array . length ;  i ++ ) {<br>                if ( array [ i ] < item ){<br>                    pos ++ ;<br>                }<br>            }<br>            while ( item == array [ pos ++ ] ){<br>                pos ++ ;<br>            }<br>            array [ pos ] = item ;<br>            writes ++ ;<br>        }<br>    }<br>    writes ++ ;<br>}</td>
  </tr><tr>
    <th>SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int selectRandom ( int x ) {<br>  count ++ ;<br>  if ( count == 1 ) res = x ;<br>  else {<br>    Random r = new Random ( ) ;<br>    int i = r . nextInt ( count ) ;<br>    if ( i == count - 1 ) res = x ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int selectRandom ( int x ) {<br>    int res = 0 ;<br>    int count = 0 ;<br>    count ++ ;<br>    if ( ( count == 1 ) && ( x == 5 ) ) {<br>        res = x ;<br>    }<br>    else {<br>        int i = random . nextInt ( count ) ;<br>        if ( ( i == count - 1 ) && ( x == 0 ) ){<br>            res = x ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>HOSOYAS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printHosoya ( int n ) {<br>  int dp [ ] [ ] = new int [ N ] [ N ] ;<br>  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ;<br>  dp [ 1 ] [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ;<br>      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= i ;<br>    j ++ ) System . out . print ( dp [ i ] [ j ] + "" ) ;<br>    System . out . println ( "" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printHosoya ( int n ) {<br>    int [ ] [ ] dp = new int [ N ] [ N ] ;<br>    dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( i > j ) && ( i < n ) ) {<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) ;<br>            }<br>            if ( n > 0 ) {<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i + 1 ;  j ++ ) {<br>            System . out . print ( dp [ i ] [ j ] + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lastPosition ( int n , int m , int k ) {<br>  if ( m <= n - k + 1 ) return m + k - 1 ;<br>  m = m - ( n - k + 1 ) ;<br>  return ( m % n == 0 ) ? n : ( m % n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lastPosition ( int n , int m , int k ) {<br>    if ( ( m <= n - k + 1 ) && ( m > n - k ) ) {<br>        return m + k - 1 ;<br>    }<br>    m = m - ( n - k + 1 ) ;<br>    if ( ( m % n == 0 ) && ( k % n == 0 ) ) {<br>        return n ;<br>    }<br>    else{<br>        return m % n ;<br>    }<br>}</td>
  </tr><tr>
    <th>PRINTING_LONGEST_INCREASING_CONSECUTIVE_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void longestSubsequence ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;<br>  int [ ] dp = new int [ n ] ;<br>  int maximum = Integer . MIN_VALUE ;<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mp . get ( a [ i ] - 1 ) != null ) {<br>      int lastIndex = mp . get ( a [ i ] - 1 ) - 1 ;<br>      dp [ i ] = 1 + dp [ lastIndex ] ;<br>    }<br>    else dp [ i ] = 1 ;<br>    mp . put ( a [ i ] , i + 1 ) ;<br>    if ( maximum < dp [ i ] ) {<br>      maximum = dp [ i ] ;<br>      index = i ;<br>    }<br>  }<br>  for ( int curr = a [ index ] - maximum + 1 ;<br>  curr <= a [ index ] ;<br>  curr ++ ) System . out . print ( curr + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longestSubsequence ( int [ ] a , int n ) {<br>    int [ ] mp = new int [ 13 ] ;<br>    int [ ] dp = new int [ n ] ;<br>    int maximum = - Integer . MAX_VALUE - 1 ;<br>    int index = - 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( ( a [ i ] - 1 ) < mp ) && ( ( a [ i ] - 1 ) > mp ) ) a [ i ] = 5 ;<br>            lastIndex = mp [ a [ i ] - 1 ] - 1 ;<br>            dp [ i ] = 1 + dp [ lastIndex ] ;<br>        else{<br>            dp [ i ] = 1 ;<br>        }<br>        mp [ a [ i ] ] = i + 1 ;<br>        if ( ( maximum < dp [ i ] ) && ( maximum < dp [ n ] ) ){<br>            int maximum = dp [ i ] ;<br>            int index = i ;<br>        }<br>    }<br>    for ( int curr = a [ index ] - maximum + 1 ;<br>        System . out . print ( curr + " " ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countTriangle ( int graph [ ] [ ] , boolean isDirected ) {<br>  int count_Triangle = 0 ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < V ;<br>    j ++ ) {<br>      for ( int k = 0 ;<br>      k < V ;<br>      k ++ ) {<br>        if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 && graph [ k ] [ i ] == 1 ) count_Triangle ++ ;<br>      }<br>    }<br>  }<br>  if ( isDirected == true ) {<br>    count_Triangle /= 3 ;<br>  }<br>  else {<br>    count_Triangle /= 6 ;<br>  }<br>  return count_Triangle ;<br>}<br></td>
    <td>translated code: <br><br> public static int countTriangle ( int [ ] [ ] g , boolean isDirected ) {<br>    int nodes = g . getNodes ( ) . size ( ) ;<br>    count_Triangle = 0 ;<br>    for ( int i = 0 ;  i < nodes ;  i ++ ) {<br>        for ( int j = 0 ;  j < nodes ;  j ++ ) {<br>            for ( int k = 0 ;  k < nodes ;  k ++ ) {<br>                if ( ( i != j && i != k && j != k && g [ i ] [ j ] && g [ j ] [ k ] && g [ k ] [ i ] ) || ( i != j && i != k && g [ i ] [ j ] && g [ j ] [ k ] && g [ k ] [ i ] ) ) {<br>                    count_Triangle ++ ;<br>                }<br>            }<br>        }<br>    }<br>    return isDirected ? count_Triangle / 3 : count_Triangle / 6 ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) {<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( set . contains ( arr [ i ] ) ) return true ;<br>    set . add ( arr [ i ] ) ;<br>    if ( i >= k ) set . remove ( arr [ i - k ] ) ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkDuplicatesWithinK ( int [ ] arr , int n , int k ) {<br>    Set < Integer > myset = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == myset ) {<br>            return checkDuplicatesWithinK ( arr , n , k , 0 ) ;<br>        }<br>        myset . add ( arr [ i ] ) ;<br>        if ( ( i >= k ) && ( i < n ) ) {<br>            mySet . remove ( arr [ i - k ] ) ;<br>        }<br>    }<br>    return checkDuplicatesWithinK ( arr , n , k , false ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_INSERTIONS_SORT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInsertionStepToSortArray ( int arr [ ] , int N ) {<br>  int [ ] lis = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  int max = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;<br>  return ( N - max ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInsertionStepToSortArray ( int [ ] arr , int N ) {<br>    int [ ] lis = new int [ N ] ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        lis [ i ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i < N ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) || ( arr [ i ] >= arr [ j ] && lis [ i ] > lis [ j ] + 1 ) ){<br>                lis [ i ] = lis [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    int max = 0 ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        if ( ( max < lis [ i ] ) && ( max > lis [ i ] ) ){<br>            int max = lis [ i ] ;<br>        }<br>    }<br>    return ( N - max ) ;<br>}</td>
  </tr><tr>
    <th>GENERATE_TWO_OUTPUT_STRINGS_DEPENDING_UPON_OCCURRENCE_CHARACTER_INPUT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDuo ( String str ) {<br>  int countChar [ ] = new int [ MAX_CHAR ] ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    countChar [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  String str1 = "" , str2 = "" ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    if ( countChar [ i ] > 1 ) {<br>      str2 = str2 + ( char ) ( i + 'a' ) ;<br>    }<br>    else if ( countChar [ i ] == 1 ) {<br>      str1 = str1 + ( char ) ( i + 'a' ) ;<br>    }<br>  }<br>  System . out . print ( "String with characters occurring " + "once:\n" ) ;<br>  System . out . print ( str1 + "\n" ) ;<br>  System . out . print ( "String with characters occurring " + "multiple times:\n" ) ;<br>  System . out . print ( str2 + "\n" ) ;<br>  System . out . print ( "" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDuo ( String string ) {<br>    int [ ] countChar = new int [ MAX_CHAR ] ;<br>    int n = string . length ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        countChar [ ( int ) string . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    String str1 = "" ;<br>    String str2 = "" ;<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        if ( ( countChar [ i ] > 1 ) && ( countChar [ i ] > 2 ) ) {<br>            str2 = str2 + ( char ) ( i + Character . MIN_VALUE ) ;<br>        }<br>        else if ( ( countChar [ i ] == 1 ) && ( countChar [ i ] == 2 ) ) {<br>            str1 = str1 + ( char ) ( i + Character . MIN_VALUE ) ;<br>        }<br>    }<br>    System . out . println ( "String with characters occurring once:" + " " + " \ n " + str1 ) ;<br>    System . out . println ( "String with characters occurring" + "multiple times:" + " SPACETOKEN , SPACETOKEN \ " \ n " + str2 ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countDigits ( int a , int b ) {<br>  if ( a == 0 || b == 0 ) return 1 ;<br>  return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDigits ( int a , int b ) {<br>    if ( ( a == 0 || b == 0 ) && ( a > b ) ) {<br>        return 1 ;<br>    }<br>    return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ;<br>}</td>
  </tr><tr>
    <th>TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countNonDecreasing ( int n ) {<br>  int N = 10 ;<br>  long count = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    count *= ( N + i - 1 ) ;<br>    count /= i ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonDecreasing ( int n ) {<br>    int N = 10 ;<br>    count = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        count = ( int ) ( count * ( N + i - 1 ) ) ;<br>        int count = ( int ) ( count / i ) ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_STRINGS_ADJACENT_CHARACTERS_DIFFERENCE_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long countStrs ( int n ) {<br>  long [ ] [ ] dp = new long [ n + 1 ] [ 27 ] ;<br>  for ( int i = 0 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < 27 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= 25 ;<br>  i ++ ) {<br>    dp [ 1 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= 25 ;<br>    j ++ ) {<br>      if ( j == 0 ) {<br>        dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;<br>      }<br>    }<br>  }<br>  long sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= 25 ;<br>  i ++ ) {<br>    sum = ( sum + dp [ n ] [ i ] ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrs ( int n ) {<br>    int [ ] [ ] dp = new int [ 27 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i <= 26 ;  i ++ ) {<br>        dp [ 1 ] [ i ] = 1 ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= 26 ;  j ++ ) {<br>            if ( ( j == 0 ) && ( n > 0 ) ) {<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>            }<br>            }<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= 26 ;  i ++ ) {<br>        sum = sum + dp [ n ] [ i ] ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_EFFICIENTLY_CALCULATE_EX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float exponential ( int n , float x ) {<br>  float sum = 1 ;<br>  for ( int i = n - 1 ;<br>  i > 0 ;<br>  -- i ) sum = 1 + x * sum / i ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static void exponential ( int n , double x ) {<br>    double sum = 1.0 ;<br>    for ( int i = n ;  i > 0 ;  i -- ) {<br>        double sum = 1 + x * sum / i ;<br>    }<br>    System . out . println ( "e^x =" + sum ) ;<br>}</td>
  </tr><tr>
    <th>EFFICIENTLY_COMPUTE_SUMS_OF_DIAGONALS_OF_A_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>  int principal = 0 , secondary = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    principal += mat [ i ] [ i ] ;<br>    secondary += mat [ i ] [ n - i - 1 ] ;<br>  }<br>  System . out . println ( "Principal Diagonal:" + principal ) ;<br>  System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDiagonalSums ( int [ ] [ ] mat , int n ) {<br>    int principal = 0 ;<br>    int secondary = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        principal += mat [ i ] [ i ] ;<br>        secondary += mat [ i ] [ n - i - 1 ] ;<br>    }<br>    System . out . println ( "Principal Diagonal:" + principal ) ;<br>    System . out . println ( "Secondary Diagonal:" + secondary ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_WAYS_BREAK_STRING_BRACKET_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findCombinations ( String str , int index , String out ) {<br>  if ( index == str . length ( ) ) System . out . println ( out ) ;<br>  for ( int i = index ;<br>  i < str . length ( ) ;<br>  i ++ ) findCombinations ( str , i + 1 , out + "(" + str . substring ( index , i + 1 ) + ")" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findCombinations ( String string , int index , String out ) {<br>    if ( index == string . length ( ) ) {<br>        System . out . println ( out ) ;<br>    }<br>    for ( int i = index ;  i < string . length ( ) ;  i += 1 ) {<br>        findCombinations ( string , i + 1 , out . append ( "(" ) . append ( string . substring ( index , i + 1 ) ) . append ( ")" ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>LINEAR_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int search ( int arr [ ] , int x ) {<br>  int n = arr . length ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) return i ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int n , int x ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] == x ) && ( n > 0 ) ) {<br>            return i ++ ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int singleNumber ( int a [ ] , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i : a ) {<br>    s . add ( i ) ;<br>  }<br>  int arr_sum = 0 ;<br>  for ( int i : a ) {<br>    arr_sum += i ;<br>  }<br>  int set_sum = 0 ;<br>  for ( int i : s ) {<br>    set_sum += i ;<br>  }<br>  return ( 3 * set_sum - arr_sum ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int singleNumber ( List < Integer > nums ) {<br>    return ( 3 * sum ( Sets . newHashSet ( nums ) ) . size ( ) - sum ( nums ) ) / 2 ;<br>}</td>
  </tr><tr>
    <th>SEARCH_ALMOST_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int binarySearch ( int arr [ ] , int l , int r , int x ) {<br>  if ( r >= l ) {<br>    int mid = l + ( r - l ) / 2 ;<br>    if ( arr [ mid ] == x ) return mid ;<br>    if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ;<br>    if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ;<br>    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ;<br>    return binarySearch ( arr , mid + 2 , r , x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int l , int r , int x ) {<br>    if ( ( r >= l ) && ( r < r ) ){<br>        int mid = ( int ) ( l + ( r - l ) / 2 ) ;<br>        if ( ( arr [ mid ] == x ) && ( arr [ l ] == x ) && ( arr [ r ] == x ) ) {<br>            return mid ;<br>        }<br>        if ( ( mid > l && arr [ mid - 1 ] == x ) || ( mid > r && arr [ mid ] == x ) ){<br>            return ( mid - 1 ) ;<br>        }<br>        if ( ( mid < r ) && arr [ mid + 1 ] == x ){<br>            return ( mid + 1 ) < arr . length ? mid + 1 : arr . length ;<br>        }<br>        if ( ( arr [ mid ] > x ) && ( arr [ mid + 1 ] > x ) ){<br>            return binarySearch ( arr , l , mid - 2 , x ) ;<br>        }<br>        return binarySearch ( arr , mid + 2 , r , x ) ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>EULERS_TOTIENT_FUNCTION_FOR_ALL_NUMBERS_SMALLER_THAN_OR_EQUAL_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void computeTotient ( int n ) {<br>  long phi [ ] = new long [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) phi [ i ] = i ;<br>  for ( int p = 2 ;<br>  p <= n ;<br>  p ++ ) {<br>    if ( phi [ p ] == p ) {<br>      phi [ p ] = p - 1 ;<br>      for ( int i = 2 * p ;<br>      i <= n ;<br>      i += p ) {<br>        phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void computeTotient ( int n ) {<br>    phi = new int [ n ] ;<br>    for ( int i = 0 ;  i < n + 2 ;  i ++ ) {<br>        phi . add ( 0 ) ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        phi [ i ] = i ;<br>    }<br>    for ( int p = 2 ;  p <= n ;  p ++ ) {<br>        if ( ( phi [ p ] == p ) && ( phi [ n ] == n ) ){<br>            phi [ p ] = p - 1 ;<br>            for ( int i = 2 * p ;  i <= n ;  i += p ) {<br>                phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ;<br>            }<br>        }<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        System . out . println ( "Totient of " + i + " is " + phi [ i ] ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinNumber ( int n ) {<br>  int count = 0 , ans = 1 ;<br>  while ( n % 2 == 0 ) {<br>    count ++ ;<br>    n /= 2 ;<br>  }<br>  if ( count % 2 == 1 ) ans *= 2 ;<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i += 2 ) {<br>    count = 0 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n /= i ;<br>    }<br>    if ( count % 2 == 1 ) ans *= i ;<br>  }<br>  if ( n > 2 ) ans *= n ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinNumber ( int n ) {<br>    int count = 0 ;<br>    int ans = 1 ;<br>    while ( n % 2 == 0 ) {<br>        count ++ ;<br>        n /= 2 ;<br>    }<br>    if ( count % 2 != 0 ){<br>        ans *= 2 ;<br>    }<br>    for ( int i = 3 ;  i < ( int ) ( Math . sqrt ( n ) ) + 1 ;  i += 2 ) {<br>        int count = 0 ;<br>        while ( n % i == 0 ){<br>            count ++ ;<br>            n /= i ;<br>        }<br>        if ( count % 2 != 0 ){<br>            ans *= i ;<br>        }<br>    }<br>    if ( n > 2 ) {<br>        ans *= n ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_JUMP_REACH_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countWaysToJump ( int arr [ ] , int n ) {<br>  int count_jump [ ] = new int [ n ] ;<br>  Arrays . fill ( count_jump , 0 ) ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;<br>    for ( int j = i + 1 ;<br>    j < n - 1 && j <= arr [ i ] + i ;<br>    j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ;<br>    if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( count_jump [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void countWaysToJump ( int [ ] arr , int n ) {<br>    int [ ] countJump = new int [ n ] ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( arr [ i ] >= n - i - 1 ) && ( arr [ i ] <= n - i - 2 ) ) {<br>            countJump [ i ] ++ ;<br>        }<br>        int j = i + 1 ;<br>        while ( ( j < n - 1 && j <= arr [ i ] + i ) || ( j > arr [ i ] && j < arr [ i + 1 ] ) ) {<br>            if ( ( count_jump [ j ] != - 1 ) && ( count_jump [ j ] != 0 ) ) {<br>                countJump [ i ] += countJump [ j ] ;<br>            }<br>            j ++ ;<br>        }<br>        if ( ( countJump [ i ] == 0 ) && ( n > 0 ) ) {<br>            countJump [ i ] = - 1 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( countJump [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void substringConversions ( String str , int k , int b ) {<br>  int i = 0 , sum = 0 , counter = k - 1 ;<br>  for ( i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Math . pow ( b , counter ) ) ) ;<br>    counter -- ;<br>  }<br>  System . out . print ( sum + " " ) ;<br>  int prev = sum ;<br>  sum = 0 ;<br>  counter = 0 ;<br>  for ( ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) * Math . pow ( b , k - 1 ) ) ) ;<br>    sum = sum * b ;<br>    sum = sum + ( str . charAt ( i ) - '0' ) ;<br>    System . out . print ( sum + " " ) ;<br>    prev = sum ;<br>    counter ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void substringConversions ( String str1 , int k , int b ) {<br>    for ( int i = 0 ;  i <= str1 . length ( ) - k + 1 ;  i ++ ) {<br>        String sub = str1 . substring ( i , k + i ) ;<br>        int Sum = 0 ;<br>        int counter = 0 ;<br>        for ( int i = sub . length - 1 ;  i >= 0 ;  i -- ) {<br>            Sum = ( Sum + ( ( Character . digit ( sub [ i ] , k ) - '0' ) * Math . pow ( b , counter ) ) ) ;<br>            counter ++ ;<br>        }<br>        System . out . print ( Sum . class . getSimpleName ( ) + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>TWO_ELEMENTS_WHOSE_SUM_IS_CLOSEST_TO_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minAbsSumPair ( int arr [ ] , int arr_size ) {<br>  int inv_count = 0 ;<br>  int l , r , min_sum , sum , min_l , min_r ;<br>  if ( arr_size < 2 ) {<br>    System . out . println ( "Invalid Input" ) ;<br>    return ;<br>  }<br>  min_l = 0 ;<br>  min_r = 1 ;<br>  min_sum = arr [ 0 ] + arr [ 1 ] ;<br>  for ( l = 0 ;<br>  l < arr_size - 1 ;<br>  l ++ ) {<br>    for ( r = l + 1 ;<br>    r < arr_size ;<br>    r ++ ) {<br>      sum = arr [ l ] + arr [ r ] ;<br>      if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) {<br>        min_sum = sum ;<br>        min_l = l ;<br>        min_r = r ;<br>      }<br>    }<br>  }<br>  System . out . println ( " The two elements whose " + "sum is minimum are " + arr [ min_l ] + " and " + arr [ min_r ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void minAbsSumPair ( int [ ] arr , int arrSize ) {<br>    int invCount = 0 ;<br>    if ( arrSize < 2 ) {<br>        System . out . println ( "Invalid Input" ) ;<br>        }<br>    }<br>    int min_l = 0 ;<br>    int minR = 1 ;<br>    int minSum = arr [ 0 ] + arr [ 1 ] ;<br>    for ( int l = 0 ;  l <= arrSize - 1 ;  l ++ ) {<br>        for ( int r = l + 1 ;  r < arrSize ;  r ++ ) {<br>            int sum = arr [ l ] + arr [ r ] ;<br>            if ( Math . abs ( minSum ) > Math . abs ( sum ) ) {<br>                minSum = sum ;<br>                minL = l ;<br>                minR = r ;<br>            }<br>        }<br>    }<br>    System . out . println ( "The two elements whose sum is minimum are" + arr [ minL ] + " and " + arr [ minR ] ) ;<br>}</td>
  </tr><tr>
    <th>HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findoptimal ( int N ) {<br>  if ( N <= 6 ) return N ;<br>  int [ ] screen = new int [ N ] ;<br>  int b ;<br>  int n ;<br>  for ( n = 1 ;<br>  n <= 6 ;<br>  n ++ ) screen [ n - 1 ] = n ;<br>  for ( n = 7 ;<br>  n <= N ;<br>  n ++ ) {<br>    screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ;<br>  }<br>  return screen [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findoptimal ( int N ) {<br>    if ( ( N <= 6 ) && ( N > 0 ) ){<br>        return N ;<br>    }<br>    screen = new int [ N ] ;<br>    for ( int n = 1 ;  n <= 7 ;  n ++ ) {<br>        screen [ n - 1 ] = n ;<br>    }<br>    for ( int n = 7 ;  n <= N ;  n ++ ) {<br>        screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ;<br>    }<br>    return screen [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_BINARY_CONVERSION_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int decimalToBinary ( int N ) {<br>  int B_Number = 0 ;<br>  int cnt = 0 ;<br>  while ( N != 0 ) {<br>    int rem = N % 2 ;<br>    double c = Math . pow ( 10 , cnt ) ;<br>    B_Number += rem * c ;<br>    N /= 2 ;<br>    cnt ++ ;<br>  }<br>  return B_Number ;<br>}<br></td>
    <td>translated code: <br><br> public static int decimalToBinary ( int N ) {<br>    B_Number = 0 ;<br>    int cnt = 0 ;<br>    while ( ( N -- != 0 ) && ( N != 0 ) ) {<br>        int rem = N % 2 ;<br>        int c = Math . pow ( 10 , cnt ) ;<br>        B_Number += rem * c ;<br>        N /= 2 ;<br>        cnt ++ ;<br>    }<br>    return B_Number ;<br>}</td>
  </tr><tr>
    <th>COUNTS_PATHS_POINT_REACH_ORIGIN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPaths ( int n , int m ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) dp [ 0 ] [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= m ;<br>  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ;<br>  return dp [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPaths ( int n , int m ) {<br>    if ( ( n == 0 || m == 0 ) && ( n > 0 || m > 0 ) ) {<br>        return 1 ;<br>    }<br>    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) {<br>  Arrays . sort ( arr ) ;<br>  int result = 0 ;<br>  for ( int i = k1 ;<br>  i < k2 - 1 ;<br>  i ++ ) result += arr [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumBetweenTwoKth ( int [ ] arr , int n , int k1 , int k2 ) {<br>    Arrays . sort ( arr , k1 , k2 ) ;<br>    int result = 0 ;<br>    for ( int i = k1 ;  i <= k2 - 1 ;  i ++ ) {<br>        result += arr [ i ] ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void minRange ( int arr [ ] , int n , int k ) {<br>  int l = 0 , r = n ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    int j ;<br>    for ( j = i ;<br>    j < n ;<br>    j ++ ) {<br>      s . add ( arr [ j ] ) ;<br>      if ( s . size ( ) == k ) {<br>        if ( ( j - i ) < ( r - l ) ) {<br>          r = j ;<br>          l = i ;<br>        }<br>        break ;<br>      }<br>    }<br>    if ( j == n ) break ;<br>  }<br>  if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ;<br>  else System . out . println ( l + " " + r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void minRange ( int [ ] arr , int n , int k ) {<br>    int l = 0 ;<br>    int r = n ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int [ ] s = new int [ k ] ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            s . add ( arr [ j ] ) ;<br>            if ( ( s . length == k ) && ( s [ 0 ] == 0 ) ) {<br>                if ( ( ( j - i ) < ( r - l ) ) && ( ( j - i ) > ( r - l ) ) ){<br>                    int r = j ;<br>                    int l = i ;<br>                }<br>                break ;<br>            }<br>        }<br>        if ( ( j == n ) && ( k == n ) ) {<br>            break ;<br>        }<br>    }<br>    if ( ( l == 0 && r == n ) || ( l == k && r == k ) ) {<br>        System . out . println ( "Invalid k" ) ;<br>    }<br>    else {<br>        System . out . println ( l + " " + r ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>AREA_OF_A_HEXAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static double hexagonArea ( double s ) {<br>  return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double hexagonArea ( double s ) {<br>    return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  n -- ;<br>  n |= n >> 1 ;<br>  n |= n >> 2 ;<br>  n |= n >> 4 ;<br>  n |= n >> 8 ;<br>  n |= n >> 16 ;<br>  n ++ ;<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>    n -- ;<br>    n |= n >> 1 ;<br>    n |= n >>> 2 ;<br>    n |= n >>> 4 ;<br>    n |= n >> 8 ;<br>    n |= n >>> 16 ;<br>    n ++ ;<br>    return n ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOfSubstringWithKOnes ( String s , int K ) {<br>  int N = s . length ( ) ;<br>  int res = 0 ;<br>  int countOfOne = 0 ;<br>  int [ ] freq = new int [ N + 1 ] ;<br>  freq [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    countOfOne += ( s . charAt ( i ) - '0' ) ;<br>    if ( countOfOne >= K ) {<br>      res += freq [ countOfOne - K ] ;<br>    }<br>    freq [ countOfOne ] ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfSubstringWithKOnes ( String s , int K ) {<br>    int N = s . length ( ) ;<br>    int res = 0 ;<br>    int countOfOne = 0 ;<br>    int [ ] freq = new int [ N + 1 ] ;<br>    freq [ 0 ] = 1 ;<br>    for ( int i = 0 ;  i < N ;  i += 1 ) {<br>        countOfOne += ( char ) s . charAt ( i ++ ) - '0' ;<br>        if ( ( countOfOne >= K ) && ( countOfOne <= 1 ) ) {<br>            res += freq [ countOfOne - K ] ;<br>        }<br>        freq [ countOfOne ] ++ ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int answer_query ( int a [ ] , int n , int l , int r ) {<br>  int count = 0 ;<br>  for ( int i = l ;<br>  i < r ;<br>  i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int answerQuery ( int [ ] a , int n , int l , int r ) {<br>    int count = 0 ;<br>    for ( int i = l ;  i < r ;  i ++ ) {<br>        if ( ( a [ i ] == a [ i + 1 ] ) && ( n == a [ i + 2 ] ) ) {<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_NUMBER_DUCK_NUMBER_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int check_duck ( String num ) {<br>  int len = num . length ( ) ;<br>  int count_zero = 0 ;<br>  char ch ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    ch = num . charAt ( i ) ;<br>    if ( ch == '0' ) count_zero ++ ;<br>  }<br>  return count_zero ;<br>}<br></td>
    <td>translated code: <br><br> public static int checkDuck ( String num ) {<br>    int l = num . length ( ) ;<br>    int countZero = 0 ;<br>    int i = 1 ;<br>    while ( i < l ) {<br>        char ch = num [ i ++ ] ;<br>        if ( ( ch == "0" ) || ( ch == "1" ) ) {<br>            countZero = countZero + 1 ;<br>        }<br>        i = i + 1 ;<br>    }<br>    return countZero ;<br>}</td>
  </tr><tr>
    <th>NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIntegralSolutions ( int n ) {<br>  return ( ( n + 1 ) * ( n + 2 ) ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIntegralSolutions ( int n ) {<br>    return ( int ) ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_K_TIMES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProfit ( int price [ ] , int n , int k ) {<br>  int profit [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) profit [ i ] [ 0 ] = 0 ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) profit [ 0 ] [ j ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= k ;<br>  i ++ ) {<br>    int prevDiff = Integer . MIN_VALUE ;<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ;<br>      profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ;<br>    }<br>  }<br>  return profit [ k ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProfit ( int [ ] price , int n , int k ) {<br>    double [ ] profit = new double [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= k ;  i ++ ) {<br>        double prevDiff = Double . MAX_VALUE ;<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ;<br>            profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ;<br>        }<br>    }<br>    return profit [ k ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_CHARACTERS_POSITION_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findCount ( String str ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) {<br>      result ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int findCount ( String str ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( ( ( i == Character . MAX_VALUE ) || ( i == Character . MIN_VALUE ) ) && ( str . length ( ) == 0 ) ) {<br>            result ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_GFG_SUBSEQUENCES_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countSubsequence ( String s , int n ) {<br>  int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    switch ( s . charAt ( i ) ) {<br>      case 'G' : cntG ++ ;<br>      result += C ;<br>      break ;<br>      case 'F' : cntF ++ ;<br>      C += cntG ;<br>      break ;<br>      default : continue ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void countSubsequence ( String s , int n ) {<br>    cntG = 0 ;<br>    cntF = 0 ;<br>    int result = 0 ;<br>    int C = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( s . charAt ( i ++ ) == 'G' ) && ( s . charAt ( i ++ ) == 'C' ) ) {<br>            cntG ++ ;<br>            result += C ;<br>            continue ;<br>        }<br>        if ( ( s . charAt ( i ++ ) == 'F' ) && ( s . charAt ( i ++ ) == 'A' ) ) {<br>            cntF ++ ;<br>            C += cntG ;<br>            continue ;<br>        }<br>        else {<br>            continue ;<br>        }<br>    }<br>    System . out . println ( result ) ;<br>}</td>
  </tr><tr>
    <th>FIND_SMALLEST_VALUE_REPRESENTED_SUM_SUBSET_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findSmallest ( int arr [ ] , int n ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < n && arr [ i ] <= res ;<br>  i ++ ) res = res + arr [ i ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSmallest ( int [ ] arr , int n ) {<br>    int res = 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( arr [ i ] <= res ){<br>            int res = 0 ;<br>        }<br>        if ( n < 0 ) {<br>            break ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_POINTS_COLLECTED_BY_TWO_PERSONS_ALLOWED_TO_MEET_ONCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxPoints ( int A [ ] [ ] ) {<br>  int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ;<br>  int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= M ;<br>  j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) for ( int j = M ;<br>  j >= 1 ;<br>  j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) for ( int j = 1 ;<br>  j <= M ;<br>  j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = M ;<br>  j >= 1 ;<br>  j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>  int ans = 0 ;<br>  for ( int i = 2 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 2 ;<br>    j < M ;<br>    j ++ ) {<br>      int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ;<br>      int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ;<br>      ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxPoints ( int [ ] A ) {<br>    P1S = new int [ N + 2 ] ;<br>    P1E = new int [ N + 2 ] ;<br>    P2S = new int [ N + 2 ] ;<br>    P2E = new int [ N + 2 ] ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        for ( int j = 1 ;  j <= M ;  j ++ ) {<br>            P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>        }<br>    }<br>    for ( int i = N ;  i > 0 ;  i -- ) {<br>        for ( int j = M ;  j > 0 ;  j -- ) {<br>            P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>        }<br>    }<br>    for ( int i = N ;  i > 0 ;  i -- ) {<br>        for ( int j = 1 ;  j <= M ;  j ++ ) {<br>            P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>        }<br>    }<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        for ( int j = M ;  j > 0 ;  j -- ) {<br>            P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ;<br>        }<br>    }<br>    int ans = 0 ;<br>    for ( int i = 2 ;  i <= N ;  i ++ ) {<br>        for ( int j = 2 ;  j <= M ;  j ++ ) {<br>            op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \<br>                return P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ;<br>            op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \<br>                return P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ;<br>            ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_CIRCUMFERENCE_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double circumference ( double r ) {<br>  double PI = 3.1415 ;<br>  double cir = 2 * PI * r ;<br>  return cir ;<br>}<br></td>
    <td>translated code: <br><br> public static double circumference ( double r ) {<br>    return ( 2 * PI * r ) ;<br>}</td>
  </tr><tr>
    <th>QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void leftRotate ( int arr [ ] , int n , int k ) {<br>  for ( int i = k ;<br>  i < k + n ;<br>  i ++ ) System . out . print ( arr [ i % n ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void leftRotate ( int [ ] arr , int n , int k ) {<br>    for ( int i = k ;  i < k + n ;  i ++ ) {<br>        System . out . print ( Integer . toString ( arr [ i % n ] ) + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int [ ] A , int n ) {<br>  int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ;<br>  return ( min_val * ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int minSum ( int [ ] A ) {<br>    int minVal = Math . min ( A ) ;<br>    return min_val * ( A . length - 1 ) ;<br>}</td>
  </tr><tr>
    <th>RECURSIVE_PROGRAM_PRIME_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n , int i ) {<br>  if ( n <= 2 ) return ( n == 2 ) ? true : false ;<br>  if ( n % i == 0 ) return false ;<br>  if ( i * i > n ) return true ;<br>  return isPrime ( n , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n , int i ) {<br>    if ( ( n <= 2 ) && ( i < n ) ) {<br>        return i == 2 ? ( n == 2 ) : false ;<br>    }<br>    if ( ( n % i == 0 ) && ( n % i == 1 ) ) {<br>        return false ;<br>    }<br>    if ( ( i * i > n ) && ( i * i > n ) ) {<br>        return true ;<br>    }<br>    return isPrime ( n , i + 1 ) ;<br>}</td>
  </tr><tr>
    <th>SPARSE_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sparseSearch ( String arr [ ] , String x , int n ) {<br>  return binarySearch ( arr , 0 , n - 1 , x ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int sparseSearch ( String arr , int key , int low , int high ) {<br>    int left = 0 ;<br>    while ( low <= high ) {<br>        int mid = ( low + high ) / 2 ;<br>        if ( arr . charAt ( mid ) == '\0' ) {<br>            int left = mid - 1 ;<br>            int right = mid + 1 ;<br>            if ( left < low && right > high ) {<br>                return - 1 ;<br>            }<br>            else if ( right <= high && arr [ right ] != null ) {<br>                int mid = right ;<br>            }<br>            else if ( left >= low && arr [ left ] != null ) {<br>                int mid = left ;<br>            }<br>        }<br>        if ( arr [ mid ] == key ) {<br>            System . out . println ( "Found string {<br>            }<br>            }<br>        }<br>        else if ( arr [ mid ] > key ){<br>            high = mid - 1 ;<br>        }<br>        else if ( arr [ mid ] < key ){<br>            low = mid + 1 ;<br>        }<br>        left -- ;<br>        right ++ ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( String a , String b , int m , int n ) {<br>  if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;<br>  if ( m == 0 ) return 0 ;<br>  if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ;<br>  else return count ( a , b , m - 1 , n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int [ ] a , int [ ] b , int m , int n ) {<br>    if ( ( ( m == 0 && n == 0 ) || n == 0 ) ){<br>        return 1 ;<br>    }<br>    if ( ( m == 0 ) && ( n == 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( a [ m - 1 ] == b [ n - 1 ] ) && ( a [ m ] == b [ n ] ) ) {<br>        return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) ;<br>    }<br>    }<br>        return count ( a , b , m - 1 , n ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean arraySortedOrNot ( int arr [ ] , int n ) {<br>  if ( n == 0 || n == 1 ) return true ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arraySortedOrNot ( int [ ] arr , int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( arr != null ) ) {<br>        return arraySortedOrNot ( arr , n , false ) ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] > arr [ n - 1 ] ) ) {<br>            return false ;<br>        }<br>    }<br>    return arraySortedOrNot ( arr , n , false ) ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_0_REPLACED_1_GET_LONGEST_CONTINUOUS_SEQUENCE_1S_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxOnesIndex ( int arr [ ] , int n ) {<br>  int max_count = 0 ;<br>  int max_index = 0 ;<br>  int prev_zero = - 1 ;<br>  int prev_prev_zero = - 1 ;<br>  for ( int curr = 0 ;<br>  curr < n ;<br>  ++ curr ) {<br>    if ( arr [ curr ] == 0 ) {<br>      if ( curr - prev_prev_zero > max_count ) {<br>        max_count = curr - prev_prev_zero ;<br>        max_index = prev_zero ;<br>      }<br>      prev_prev_zero = prev_zero ;<br>      prev_zero = curr ;<br>    }<br>  }<br>  if ( n - prev_prev_zero > max_count ) max_index = prev_zero ;<br>  return max_index ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxOnesIndex ( int [ ] arr , int n ) {<br>    int maxCount = 0 ;<br>    int maxIndex = 0 ;<br>    prevZero = - 1 ;<br>    prevPrevZero = - 1 ;<br>    for ( int curr = 0 ;  curr < n ;  curr ++ ) {<br>        if ( ( arr [ curr ] == 0 ) && ( n > 0 ) ) {<br>            if ( ( curr - prevPrevZero > maxCount ) && ( n - prevCount > 0 ) ) {<br>                int maxCount = curr - prevPrevZero ;<br>                maxIndex = prevZero ;<br>            }<br>            prevPrevZero = prevZero ;<br>            prevZero = curr ;<br>        }<br>    }<br>    if ( ( n - prevPrevZero > maxCount ) && ( n - prevPrevZero < maxCount ) ) {<br>        maxIndex = prevZero ;<br>    }<br>    return maxIndex ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProduct ( int arr [ ] , int n ) {<br>  if ( n < 3 ) {<br>    return - 1 ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProduct ( int [ ] arr , int n ) {<br>    if ( n < 3 ) {<br>        return - 1 ;<br>    }<br>    Arrays . sort ( arr , 0 , n ) ;<br>    return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ;<br>}</td>
  </tr><tr>
    <th>COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printRect ( Integer X [ ] , Integer Y [ ] , int n ) {<br>  int Xmax = Collections . max ( Arrays . asList ( X ) ) ;<br>  int Xmin = Collections . min ( Arrays . asList ( X ) ) ;<br>  int Ymax = Collections . max ( Arrays . asList ( Y ) ) ;<br>  int Ymin = Collections . min ( Arrays . asList ( Y ) ) ;<br>  System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ;<br>  System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ;<br>  System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ;<br>  System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printRect ( int X , int Y , int n ) {<br>    int Xmax = Math . max ( X , Y ) ;<br>    int Xmin = Math . min ( X , Y ) ;<br>    int Ymax = Math . max ( Y ) ;<br>    int Ymin = Math . min ( Y ) ;<br>    System . out . print ( "{" + Xmin + ", " + Ymin + "}" + " " + n ) ;<br>    System . out . print ( "{" + Xmin + ", " + Ymax + "}" + " " + n ) ;<br>    System . out . print ( "{" + Xmax + ", " + Ymax + "}" + " " + X + ", " + Y + " " + n + " " ) ;<br>    System . out . print ( "{" + Xmax + ", " + Ymin + "}" + " " + n ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOfBinaryNumberLessThanN ( int N ) {<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  q . add ( 1 ) ;<br>  int cnt = 0 ;<br>  int t ;<br>  while ( q . size ( ) > 0 ) {<br>    t = q . peek ( ) ;<br>    q . remove ( ) ;<br>    if ( t <= N ) {<br>      cnt ++ ;<br>      q . add ( t * 10 ) ;<br>      q . add ( t * 10 + 1 ) ;<br>    }<br>  }<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOfBinaryNumberLessThanN ( int N ) {<br>    Deque < Integer > q = new LinkedList < > ( ) ;<br>    q . add ( 1 ) ;<br>    int cnt = 0 ;<br>    while ( ( q = N ) != 0 ) {<br>        int t = q . poll ( ) ;<br>        if ( ( t <= N ) && ( t <= N ) ) {<br>            cnt = cnt + 1 ;<br>            q . add ( t * 10 ) ;<br>            q . add ( t * 10 + 1 ) ;<br>        }<br>    }<br>    return cnt ;<br>}</td>
  </tr><tr>
    <th>CONVERT_DECIMAL_FRACTION_BINARY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String decimalToBinary ( double num , int k_prec ) {<br>  String binary = "" ;<br>  int Integral = ( int ) num ;<br>  double fractional = num - Integral ;<br>  while ( Integral > 0 ) {<br>    int rem = Integral % 2 ;<br>    binary += ( ( char ) ( rem + '0' ) ) ;<br>    Integral /= 2 ;<br>  }<br>  binary = reverse ( binary ) ;<br>  binary += ( '.' ) ;<br>  while ( k_prec -- > 0 ) {<br>    fractional *= 2 ;<br>    int fract_bit = ( int ) fractional ;<br>    if ( fract_bit == 1 ) {<br>      fractional -= fract_bit ;<br>      binary += ( char ) ( 1 + '0' ) ;<br>    }<br>    else {<br>      binary += ( char ) ( 0 + '0' ) ;<br>    }<br>  }<br>  return binary ;<br>}<br></td>
    <td>translated code: <br><br> public static String decimalToBinary ( int num , int k_prec ) {<br>    String binary = "" ;<br>    Integral = ( int ) num ;<br>    fractional = num . subtract ( Integral . ZERO ) ;<br>    while ( ( Integral ) num ) {<br>        int rem = Integral % 2 ;<br>        binary += String . valueOf ( rem ) ;<br>        Integral /= 2 ;<br>    }<br>    binary = new byte [ k_prec ] ;<br>    binary += "." ;<br>    while ( ( k_prec -- ) > 0 ) {<br>        fractional *= 2 ;<br>        int fractBit = ( int ) fractional ;<br>        if ( ( fractBit == 1 ) && ( num > 0 ) ) {<br>            fractional -= fractBit ;<br>            binary += "1" ;<br>        }<br>        else {<br>            binary += '0' ;<br>        }<br>        k_prec -- ;<br>    }<br>    return binary ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSETS_OF_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumZeros ( int arr [ ] , int n , int k ) {<br>  int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ;<br>  for ( int [ ] row : subset ) {<br>    Arrays . fill ( row , - 1 ) ;<br>  }<br>  subset [ 0 ] [ 0 ] = 0 ;<br>  for ( int p = 0 ;<br>  p < n ;<br>  p ++ ) {<br>    int pw2 = 0 , pw5 = 0 ;<br>    while ( arr [ p ] % 2 == 0 ) {<br>      pw2 ++ ;<br>      arr [ p ] /= 2 ;<br>    }<br>    while ( arr [ p ] % 5 == 0 ) {<br>      pw5 ++ ;<br>      arr [ p ] /= 5 ;<br>    }<br>    for ( int i = k - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      for ( int j = 0 ;<br>      j < MAX5 ;<br>      j ++ ) {<br>        if ( subset [ i ] [ j ] != - 1 ) {<br>          subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ;<br>        }<br>      }<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < MAX5 ;<br>  i ++ ) {<br>    ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumZeros ( int [ ] arr , int n , int k ) {<br>    MAX5 = 5 ;<br>    int [ ] subset = new int [ k + 1 ] ;<br>    subset [ 0 ] [ 0 ] = 0 ;<br>    for ( int p = 0 ;  p < arr . length ;  p ++ ) {<br>        int pw2 = 0 , pw5 = 0 ;<br>        while ( ! p % 2 ){<br>            pw2 ++ ;<br>            p /= 2 ;<br>        }<br>        while ( ! p % 5 ){<br>            pw5 ++ ;<br>            p /= 5 ;<br>        }<br>        for ( int i = k - 1 ;  i >= 0 ;  i -- ) {<br>            for ( int j = 0 ;  j < MAX5 ;  j ++ ) {<br>                if ( subset [ i ] [ j ] != - 1 ){<br>                    subset [ i + 1 ] [ j + pw5 ] = ( Math . max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) ;<br>                }<br>            }<br>        }<br>    }<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < MAX5 ;  i ++ ) {<br>        ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int l , int h , int key ) {<br>  if ( l > h ) return - 1 ;<br>  int mid = ( l + h ) / 2 ;<br>  if ( arr [ mid ] == key ) return mid ;<br>  if ( arr [ l ] <= arr [ mid ] ) {<br>    if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;<br>    return search ( arr , mid + 1 , h , key ) ;<br>  }<br>  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ;<br>  return search ( arr , l , mid - 1 , key ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int l , int h , int key ) {<br>    if ( l > h ) {<br>        return - 1 ;<br>    }<br>    int mid = ( l + h ) / 2 ;<br>    if ( arr [ mid ] == key ){<br>        return mid ;<br>    }<br>    if ( arr [ l ] <= arr [ mid ] ){<br>        if ( key >= arr [ l ] && key <= arr [ mid ] ){<br>            return search ( arr , l , mid - 1 , key ) ;<br>        }<br>        return search ( arr , mid + 1 , h , key ) ;<br>    }<br>    if ( key >= arr [ mid ] && key <= arr [ h ] ){<br>        return search ( a , mid + 1 , h , key ) ;<br>    }<br>    return search ( arr , l , mid - 1 , key ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_AREA_CIRCULAR_SEGMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float area_of_segment ( float radius , float angle ) {<br>  float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ;<br>  float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ;<br>  return area_of_sector - area_of_triangle ;<br>}<br></td>
    <td>translated code: <br><br> public static double areaOfSegment ( double radius , double angle ) {<br>    areaOfSector = Math . PI * 2 ;<br>        return ( radius * radius ) ;<br>        return radius * ( angle / 360 ) ;<br>    areaOfTriangle = 1 / 2 * radius ;<br>        return ( radius * radius ) * angle ;<br>        return Math . sin ( ( angle * Math . PI ) / 180 ) ;<br>    return areaOfSector - areaOfTriangle ;<br>}</td>
  </tr><tr>
    <th>K_SMALLEST_ELEMENTS_ORDER_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void printSmall ( int arr [ ] , int n , int k ) {<br>  for ( int i = k ;<br>  i < n ;<br>  ++ i ) {<br>    int max_var = arr [ k - 1 ] ;<br>    int pos = k - 1 ;<br>    for ( int j = k - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( arr [ j ] > max_var ) {<br>        max_var = arr [ j ] ;<br>        pos = j ;<br>      }<br>    }<br>    if ( max_var > arr [ i ] ) {<br>      int j = pos ;<br>      while ( j < k - 1 ) {<br>        arr [ j ] = arr [ j + 1 ] ;<br>        j ++ ;<br>      }<br>      arr [ k - 1 ] = arr [ i ] ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) System . out . print ( arr [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSmall ( int [ ] arr , int n , int k ) {<br>    for ( int i = k ;  i < n ;  i ++ ) {<br>        int maxVar = arr [ k - 1 ] ;<br>        int pos = k - 1 ;<br>        for ( int j = k - 2 ;  j >= 0 ;  j -- ) {<br>            if ( ( arr [ j ] > maxVar ) && ( arr [ k ] > maxVar ) ) {<br>                int maxVar = arr [ j ] ;<br>                pos = j ;<br>            }<br>        }<br>        if ( ( maxVar > arr [ i ] ) && ( maxVar < arr [ k ] ) ) {<br>            int j = pos ;<br>            while ( ( j < k - 1 ) && ( j < n ) ) {<br>                arr [ j ] = arr [ j + 1 ] ;<br>                j ++ ;<br>            }<br>            arr [ k - 1 ] = arr [ i ] ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= k ;  i ++ ) {<br>        System . out . print ( arr [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>NTH_NON_FIBONACCI_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nonFibonacci ( int n ) {<br>  int prevPrev = 1 , prev = 2 , curr = 3 ;<br>  while ( n > 0 ) {<br>    prevPrev = prev ;<br>    prev = curr ;<br>    curr = prevPrev + prev ;<br>    n = n - ( curr - prev - 1 ) ;<br>  }<br>  n = n + ( curr - prev - 1 ) ;<br>  return prev + n ;<br>}<br></td>
    <td>translated code: <br><br> public static int nonFibonacci ( int n ) {<br>    prevPrev = 1 ;<br>    prev = 2 ;<br>    int curr = 3 ;<br>    while ( n -- > 0 ) {<br>        prevPrev = prev ;<br>        prev = curr ;<br>        curr = prevPrev + prev ;<br>        n = n - ( curr - prev - 1 ) ;<br>    }<br>    n = n + ( curr - prev - 1 ) ;<br>    return prev + n ;<br>}</td>
  </tr><tr>
    <th>ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) {<br>      return i ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int arr [ ] , int n , int x ) {<br>    int i = 0 ;<br>    for ( int i = i ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] == x ) && ( n > 0 ) ) {<br>            return i ++ ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int nearestSmallerEqFib ( int n ) {<br>  if ( n == 0 || n == 1 ) return n ;<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  while ( f3 <= n ) {<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return f2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int nearestSmallerEqFib ( int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) {<br>        return n ;<br>    }<br>    int f1 = 0 , f2 = 1 , f3 = 1 ;<br>    while ( ( f3 <= n ) && ( f3 <= n ) ) {<br>        f1 = f2 ;<br>        f2 = f3 ;<br>        int f3 = f1 + f2 ;<br>    }<br>    return f2 ;<br>}</td>
  </tr><tr>
    <th>PRINT_MAXIMUM_SHORTEST_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int find_maximum ( int a [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    int d = Math . min ( 1 + i , n - i ) ;<br>    if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;<br>    else {<br>      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;<br>    }<br>  }<br>  int ans = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaximum ( int [ ] a , int n , int k ) {<br>    Map < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;{<br>        double x = a [ i ] ;<br>        int d = Math . min ( 1 + i , n - i ) ;<br>        if ( x != b . keySet ( ) . get ( k ) ){<br>            b [ x ] = d ;<br>        }<br>        if ( n > k ) {<br>            b [ x ] = Math . min ( d , b [ x ] ) ;<br>        }<br>    }<br>    int ans = 10 * 9 ;<br>    for ( int i = 0 ;  i < n ;{<br>        double x = a [ i ] ;<br>        if ( ( x != ( k - x ) && ( k - x ) < b . length ) || ( k - x ) < n ){<br>            ans = Math . min ( Math . max ( b [ x ] , b [ k - x ] ) , ans ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOGRAPHIC_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void generate ( Set < String > st , String s ) {<br>  if ( s . length ( ) == 0 ) {<br>    return ;<br>  }<br>  if ( ! st . contains ( s ) ) {<br>    st . add ( s ) ;<br>    for ( int i = 0 ;<br>    i < s . length ( ) ;<br>    i ++ ) {<br>      String t = s ;<br>      t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ;<br>      generate ( st , t ) ;<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void generate ( Set < String > st , String s ) {<br>    if ( s . length ( ) == 0 ) {<br>        generate ( st , s , null ) ;<br>    }<br>    if ( s != null ) {<br>        st . add ( s ) ;<br>        for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>            List < String > t = Arrays . asList ( s ) . stream ( ) . map ( s :: length ) . collect ( Collectors . toList ( ) ) ;<br>            t . remove ( s [ i ] ) ;<br>            String t = "" ;<br>            generate ( st , t -> t . append ( s ) ) ;<br>        }<br>    }<br>    generate ( st , s , null ) ;<br>}</td>
  </tr><tr>
    <th>WRITE_YOU_OWN_POWER_WITHOUT_USING_MULTIPLICATION_AND_DIVISION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int pow ( int a , int b ) {<br>  if ( b == 0 ) return 1 ;<br>  int answer = a ;<br>  int increment = a ;<br>  int i , j ;<br>  for ( i = 1 ;<br>  i < b ;<br>  i ++ ) {<br>    for ( j = 1 ;<br>    j < a ;<br>    j ++ ) {<br>      answer += increment ;<br>    }<br>    increment = answer ;<br>  }<br>  return answer ;<br>}<br></td>
    <td>translated code: <br><br> public static double pow ( double a , int b ) {<br>    if ( ( b == 0 ) && ( a == 5 ) ) {<br>        return 1 ;<br>    }<br>    double answer = a ;<br>    increment = a ;<br>    for ( int i = 1 ;  i <= b ;  i ++ ) {<br>        for ( int j = 1 ;  j < a ;  j ++ ) {<br>            answer += increment ;<br>        }<br>        increment = answer ;<br>    }<br>    return answer ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxvolume ( int s ) {<br>  int length = s / 3 ;<br>  s -= length ;<br>  int breadth = s / 2 ;<br>  int height = s - breadth ;<br>  return length * breadth * height ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxvolume ( int s ) {<br>    int length = ( int ) ( s / 3 ) ;<br>    s -= length ;<br>    breadth = s / 2 ;<br>    height = s - breadth ;<br>    return ( int ) ( length * breadth * height ) ;<br>}</td>
  </tr><tr>
    <th>HORNERS_METHOD_POLYNOMIAL_EVALUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int horner ( int poly [ ] , int n , int x ) {<br>  int result = poly [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) result = result * x + poly [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static double horner ( double [ ] poly , int n , double x ) {<br>    int [ ] result = new int [ n ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        result = result * x + poly [ i ] ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minTime ( int [ ] arr , int n , int m ) {<br>  int t = 0 ;<br>  while ( true ) {<br>    int items = 0 ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) items += ( t / arr [ i ] ) ;<br>    if ( items >= m ) return t ;<br>    t ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int minTime ( int [ ] arr , int n , int m ) {<br>    int t = 0 ;<br>    while ( ( 1 ) ) {<br>        int items = 0 ;<br>        for ( int i = 0 ;  i < n ;  i ++ ) {<br>            items += ( t / arr [ i ] ) ;<br>        }<br>        if ( ( items >= m ) && ( items < n ) ){<br>            return t ;<br>        }<br>        t ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_DIFFERENCE_BETWEEN_SUMS_OF_TWO_DIAGONALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int difference ( int arr [ ] [ ] , int n ) {<br>  int d1 = 0 , d2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) d1 += arr [ i ] [ j ] ;<br>      if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ;<br>    }<br>  }<br>  return Math . abs ( d1 - d2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int difference ( int [ ] [ ] arr , int n ) {<br>    int d1 = 0 ;<br>    int d2 = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( i == j ) && ( n == i ) ) {<br>                d1 += arr [ i ] [ j ] ;<br>            }<br>            if ( ( i == n - j - 1 ) && ( i == n - j - 1 ) ) {<br>                d2 += arr [ i ] [ j ] ;<br>            }<br>        }<br>    }<br>    return Math . abs ( d1 - d2 ) ;<br>}</td>
  </tr><tr>
    <th>SHORTEST_UNCOMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int shortestSeq ( char [ ] S , char [ ] T ) {<br>  int m = S . length , n = T . length ;<br>  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    dp [ i ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = MAX ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      char ch = S [ i - 1 ] ;<br>      int k ;<br>      for ( k = j - 1 ;<br>      k >= 0 ;<br>      k -- ) {<br>        if ( T [ k ] == ch ) {<br>          break ;<br>        }<br>      }<br>      if ( k == - 1 ) {<br>        dp [ i ] [ j ] = 1 ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ;<br>      }<br>    }<br>  }<br>  int ans = dp [ m ] [ n ] ;<br>  if ( ans >= MAX ) {<br>    ans = - 1 ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestSeq ( String S , String T ) {<br>    int m = S . size ( ) ;<br>    int n = T . size ( ) ;<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        dp [ i ] [ 0 ] = 1 ;<br>    }<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        dp [ 0 ] [ i ] = MAX ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            int ch = S . get ( i - 1 ) ;<br>            int k = j - 1 ;<br>            while ( k >= 0 ) {<br>                if ( T . get ( k ) . equals ( ch ) ) {<br>                    break ;<br>                }<br>                k -- ;<br>            }<br>            if ( k == - 1 ) {<br>                dp [ i ] [ j ] = 1 ;<br>            }<br>            else {<br>                dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ;<br>            }<br>        }<br>    }<br>    int ans = dp [ m ] [ n ] ;<br>    if ( ans >= MAX ) {<br>        int ans = - 1 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MIN_FLIPS_OF_CONTINUOUS_CHARACTERS_TO_MAKE_ALL_CHARACTERS_SAME_IN_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findFlips ( String str , int n ) {<br>  char last = ' ' ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( last != str . charAt ( i ) ) res ++ ;<br>    last = str . charAt ( i ) ;<br>  }<br>  return res / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFlips ( String str , int n ) {<br>    last = " " ;<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( last != str . charAt ( i ) ) && ( last != str . charAt ( i + 1 ) ) ) {<br>            res ++ ;<br>        }<br>        last = str . charAt ( i ) ;<br>    }<br>    return res / 2 ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMinInsertions ( char str [ ] , int l , int h ) {<br>  if ( l > h ) return Integer . MAX_VALUE ;<br>  if ( l == h ) return 0 ;<br>  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ;<br>  return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinInsertions ( String str , int l , int h ) {<br>    if ( ( l > h ) && ( l < h ) ) {<br>        return Integer . MAX_VALUE ;<br>    }<br>    if ( ( l == h ) && ( l != 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( l == h - 1 ) && ( str . length ( ) > 0 ) ) {<br>        return 0 < ( str . charAt ( l ) == str . charAt ( h ) ) ? 1 : - 1 ;<br>    }<br>    if ( ( str . charAt ( l ) == str . charAt ( h ) ) && ( str . charAt ( l + 1 ) == str . charAt ( h + 1 ) ) ) {<br>        return findMinInsertions ( str , l + 1 , h - 1 ) ;<br>    }<br>    if ( l > h ) {<br>        return ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( String str ) {<br>  int result = 0 ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( String str1 ) {<br>    int result = 0 ;<br>    int n = str1 . length ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( Math . abs ( ( char ) str1 . charAt ( i ) - ( char ) str1 . charAt ( j ) ) ) == Math . abs ( i - j ) ) {<br>                result ++ ;<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MULTISTAGE_GRAPH_SHORTEST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int shortestDist ( int [ ] [ ] graph ) {<br>  int [ ] dist = new int [ N ] ;<br>  dist [ N - 1 ] = 0 ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    dist [ i ] = INF ;<br>    for ( int j = i ;<br>    j < N ;<br>    j ++ ) {<br>      if ( graph [ i ] [ j ] == INF ) {<br>        continue ;<br>      }<br>      dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ;<br>    }<br>  }<br>  return dist [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestDist ( int [ ] [ ] graph ) {<br>    return INF ;<br>    int [ ] dist = new int [ N ] ;<br>    dist [ N - 1 ] = 0 ;<br>    for ( int i = N - 2 ;  i >= 0 ;  i -- ) {<br>        dist [ i ] = INF ;<br>        for ( int j = 0 ;  j < N ;  j ++ ) {<br>            if ( graph [ i ] [ j ] == INF ) {<br>                continue ;<br>            }<br>            dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ;<br>        }<br>    }<br>    return dist [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SIZE_SUB_MATRIX_WITH_ALL_1S_IN_A_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMaxSubSquare ( int M [ ] [ ] ) {<br>  int i , j ;<br>  int R = M . length ;<br>  int C = M [ 0 ] . length ;<br>  int S [ ] [ ] = new int [ R ] [ C ] ;<br>  int max_of_s , max_i , max_j ;<br>  for ( i = 0 ;<br>  i < R ;<br>  i ++ ) S [ i ] [ 0 ] = M [ i ] [ 0 ] ;<br>  for ( j = 0 ;<br>  j < C ;<br>  j ++ ) S [ 0 ] [ j ] = M [ 0 ] [ j ] ;<br>  for ( i = 1 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( j = 1 ;<br>    j < C ;<br>    j ++ ) {<br>      if ( M [ i ] [ j ] == 1 ) S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , Math . min ( S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) ) + 1 ;<br>      else S [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  max_of_s = S [ 0 ] [ 0 ] ;<br>  max_i = 0 ;<br>  max_j = 0 ;<br>  for ( i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      if ( max_of_s < S [ i ] [ j ] ) {<br>        max_of_s = S [ i ] [ j ] ;<br>        max_i = i ;<br>        max_j = j ;<br>      }<br>    }<br>  }<br>  System . out . println ( "Maximum size sub-matrix is: " ) ;<br>  for ( i = max_i ;<br>  i > max_i - max_of_s ;<br>  i -- ) {<br>    for ( j = max_j ;<br>    j > max_j - max_of_s ;<br>    j -- ) {<br>      System . out . print ( M [ i ] [ j ] + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printMaxSubSquare ( int [ ] [ ] M ) {<br>    int R = M . length ;<br>    int C = M [ 0 ] . length ;<br>    S = new int [ C ] [ R ] ;<br>    for ( int i = 1 ;  i <= R ;  i ++ ) {<br>        for ( int j = 1 ;  j <= C ;  j ++ ) {<br>            if ( ( M [ i ] [ j ] == 1 ) && ( M [ i ] [ j ] == 2 ) ) {<br>                S [ i ] [ j ] = Math . min ( S [ i ] [ j - 1 ] , S [ i - 1 ] [ j ] , S [ i - 1 ] [ j - 1 ] ) + 1 ;<br>            }<br>            if ( M > 0 ) {<br>                S [ i ] [ j ] = 0 ;<br>            }<br>        }<br>    }<br>    int maxOfS = S [ 0 ] [ 0 ] ;<br>    int max_i = 0 ;<br>    int max_j = 0 ;<br>    for ( int i = 0 ;  i < R ;  i ++ ) {<br>        for ( int j = 0 ;  j < C ;  j ++ ) {<br>            if ( ( maxOfS < S [ i ] [ j ] ) && ( maxOfS < S [ i ] [ j ] ) ){<br>                int maxOfS = S [ i ] [ j ] ;<br>                maxI = i ;<br>                int maxJ = j ;<br>            }<br>        }<br>    }<br>    System . out . println ( "Maximum size sub-matrix is:" ) ;<br>    for ( int i = maxI ;  i <= maxI - maxOfS ;  i ++ ) {<br>        for ( int j = maxJ ;  j <= maxJ - maxOfS ;  j ++ ) {<br>            System . out . print ( M [ i ] [ j ] + " " ) ;<br>        }<br>        System . out . println ( "" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printClosest ( int arr [ ] , int n , int x ) {<br>  int res_l = 0 , res_r = 0 ;<br>  int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ;<br>  while ( r > l ) {<br>    if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) {<br>      res_l = l ;<br>      res_r = r ;<br>      diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;<br>    }<br>    if ( arr [ l ] + arr [ r ] > x ) r -- ;<br>    else l ++ ;<br>  }<br>  System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printClosest ( int [ ] arr , int n , int x ) {<br>    int resL = 0 , resR = 0 ;<br>    int l = 0 , r = n - 1 , diff = MAX_VAL ;<br>    while ( r > l ){<br>        if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ){<br>            int resL = l ;<br>            int resR = r ;<br>            int diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;<br>        }<br>        if ( arr [ l ] + arr [ r ] > x ) {<br>            r -- ;<br>        }<br>        if ( n > 0 ) {<br>            l ++ ;<br>        }<br>    }<br>    System . out . println ( "The closest pair is {<br>    }<br>}</td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>  int t = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( B [ i ] != 0 ) {<br>      if ( A [ i ] != i + 1 ) t = A [ i ] ;<br>      A [ i ] = A [ i + 1 ] ;<br>      A [ i + 1 ] = t ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( A [ i ] != i + 1 ) return 0 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( B [ i ] > 0 ){<br>            if ( A [ i ] != i + 1 ){<br>                A [ i ] = A [ i + 1 ] ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( A [ i ] != i + 1 ){<br>            return false ;<br>        }<br>    }<br>    return sortedAfterSwap ( A , B , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>TILE_STACKING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int possibleWays ( int n , int m , int k ) {<br>  int [ ] [ ] dp = new int [ N ] [ N ] ;<br>  int [ ] [ ] presum = new int [ N ] [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>      presum [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n + 1 ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 0 ;<br>    presum [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    presum [ i ] [ 0 ] = dp [ i ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i < m + 1 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ;<br>      if ( j > k ) {<br>        dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ;<br>      }<br>    }<br>    for ( int j = 1 ;<br>    j < n + 1 ;<br>    j ++ ) {<br>      presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int possibleWays ( int n , int m , int k ) {<br>    int [ ] [ ] dp = new int [ 10 ] [ 10 ] ;<br>    int [ ] presum = new int [ 10 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        dp [ 0 ] [ i ] = 0 ;<br>        presum [ 0 ] [ i ] = 1 ;<br>    }<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        presum [ i ] [ 0 ] = 1 ;<br>        dp [ i ] [ 0 ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            dp [ i ] [ j ] = presum [ i - 1 ] [ j ] ;<br>            if ( j > k ) {<br>                dp [ i ] [ j ] -= presum [ i - 1 ] [ j - k - 1 ] ;<br>            }<br>        }<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            presum [ i ] [ j ] = dp [ i ] [ j ] + presum [ i ] [ j - 1 ] ;<br>        }<br>    }<br>    return dp [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumEqualProduct ( int a [ ] , int n ) {<br>  int zero = 0 , two = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] == 0 ) {<br>      zero ++ ;<br>    }<br>    if ( a [ i ] == 2 ) {<br>      two ++ ;<br>    }<br>  }<br>  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ;<br>  return cnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumEqualProduct ( int [ ] a , int n ) {<br>    int zero = 0 ;<br>    int two = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( a [ i ] == 0 ) a [ i ] = 5 ;<br>            zero ++ ;<br>        if ( a [ i ] == 2 ) a [ i ] = 5 ;<br>            two ++ ;<br>    }<br>    int cnt = ( zero * ( zero - 1 ) ) / 2 + \<br>        return ( two * ( two - 1 ) ) / 2 ;<br>    return cnt ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minPalPartion ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] C = new int [ n ] [ n ] ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  int i , j , k , L ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    P [ i ] [ i ] = true ;<br>    C [ i ] [ i ] = 0 ;<br>  }<br>  for ( L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>      else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ;<br>      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;<br>      else {<br>        C [ i ] [ j ] = Integer . MAX_VALUE ;<br>        for ( k = i ;<br>        k <= j - 1 ;<br>        k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ;<br>      }<br>    }<br>  }<br>  return C [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minPalPartion ( String str ) {<br>    int n = str . length ( ) ;<br>    int [ ] C = new int [ n ] ;<br>    P = new boolean [ n ] ;<br>    int j = 0 ;<br>    int k = 0 ;<br>    L = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        P [ i ] [ i ] = true ;<br>        C [ i ] [ i ] = 0 ;<br>    }<br>    for ( int L = 2 ;  L <= n ;  L ++ ) {<br>        for ( int i = 0 ;  i < n - L + 1 ;  i ++ ) {<br>            int j = i + L - 1 ;<br>            if ( L == 2 ) {<br>                P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>            }<br>            else {<br>                P [ i ] [ j ] = ( ( str . charAt ( i ) == str . charAt ( j ) ) ? P [ i + 1 ] [ j - 1 ] : null ) ;<br>            }<br>            if ( P [ i ] [ j ] == true ){<br>                C [ i ] [ j ] = 0 ;<br>            }<br>            else {<br>                C [ i ] [ j ] = 100000000 ;<br>                for ( int k = i ;  k < j ;  k ++ ) {<br>                    C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ;<br>                }<br>            }<br>        }<br>    }<br>    return C [ 0 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeatingNumber ( int [ ] arr , int n ) {<br>  int sq = ( int ) Math . sqrt ( n ) ;<br>  int range = ( n / sq ) + 1 ;<br>  int [ ] count = new int [ range ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    count [ ( arr [ i ] - 1 ) / sq ] ++ ;<br>  }<br>  int selected_block = range - 1 ;<br>  for ( int i = 0 ;<br>  i < range - 1 ;<br>  i ++ ) {<br>    if ( count [ i ] > sq ) {<br>      selected_block = i ;<br>      break ;<br>    }<br>  }<br>  HashMap < Integer , Integer > m = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) {<br>      m . put ( arr [ i ] , 1 ) ;<br>      if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeatingNumber ( int [ ] arr , int n ) {<br>    double sq = Math . sqrt ( n ) ;<br>    range__ = ( int ) ( ( n / sq ) + 1 ) ;<br>    int [ ] count = new int [ range__ ] ;<br>    for ( int i = 0 ;  i <= n ;  i += 1 ) {<br>        count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ;<br>    }<br>    int selectedBlock = range__ - 1 ;<br>    for ( int i = 0 ;  i < range__ - 1 ;  i += 1 ) {<br>        if ( ( count [ i ] > sq ) && ( count [ i ] < n ) ){<br>            selectedBlock = i ;<br>            break ;<br>        }<br>    }<br>    Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i += 1 ) {<br>        if ( ( ( ( selectedBlock * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selectedBlock + 1 ) * sq ) ) ) ) {<br>            m [ arr [ i ] ] ++ ;<br>            if ( ( m [ arr [ i ] ] > 1 ) && ( m [ arr [ i ] ] > 2 ) ) {<br>                return arr [ i ++ ] ;<br>            }<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_PATH_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSumPath ( ) {<br>  int [ ] memo = new int [ A . length ] ;<br>  int n = A . length - 1 ;<br>  for ( int i = 0 ;<br>  i < A [ n ] . length ;<br>  i ++ ) memo [ i ] = A [ n ] [ i ] ;<br>  for ( int i = A . length - 2 ;<br>  i >= 0 ;<br>  i -- ) for ( int j = 0 ;<br>  j < A [ i ] . length ;<br>  j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( memo [ j ] , memo [ j + 1 ] ) ;<br>  return memo [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSumPath ( int [ ] [ ] A ) {<br>    int [ ] memo = new int [ A . length ] ;<br>    int n = A . length - 1 ;<br>    for ( int i = 0 ;  i < A [ n ] . length ;  i ++ ) {<br>        memo [ i ] = A [ n ] [ i ] ;<br>    }<br>    for ( int i = A . length - 2 ;  i >= 0 ;  i -- ) {<br>        for ( int j = 0 ;  j < A [ i ] . length ;  j ++ ) {<br>            memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ;<br>        }<br>    }<br>    return memo [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSum ( int n ) {<br>  int sum ;<br>  for ( sum = 0 ;<br>  n > 0 ;<br>  sum += n % 10 , n /= 10 ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int getSum ( int n ) {<br>    int sum = 0 ;<br>    while ( ( n > 0 ) && ( n % 2 == 0 ) ) {<br>        sum += ( int ) ( n % 10 ) ;<br>        n = ( int ) ( n / 10 ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>RECURSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFun ( int test ) {<br>  if ( test < 1 ) return ;<br>  else {<br>    System . out . printf ( "%d " , test ) ;<br>    printFun ( test - 1 ) ;<br>    System . out . printf ( "%d " , test ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> static void printFun ( int test ) {<br>    if ( ( test < 1 ) && ( test > 0 ) ) {<br>        }<br>    }<br>    }<br>        System . out . print ( test + " " ) ;<br>        printFun ( test - 1 ) ;<br>        System . out . print ( test + " " ) ;<br>        }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_TRIPLET_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxTripletSum ( int arr [ ] , int n ) {<br>  int sum = - 1000000 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) for ( int k = j + 1 ;<br>  k < n ;<br>  k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxTripletSum ( int [ ] arr , int n ) {<br>    int sm = - 1000000 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                if ( ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) && ( sm > ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ){<br>                    int sm = arr [ i ] + arr [ j ] + arr [ k ] ;<br>                }<br>            }<br>        }<br>    }<br>    return sm ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int minJumps ( int [ ] arr , int n ) {<br>  int jumps [ ] = new int [ n ] ;<br>  int i , j ;<br>  if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ;<br>  jumps [ 0 ] = 0 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    jumps [ i ] = Integer . MAX_VALUE ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) {<br>        jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ;<br>        break ;<br>      }<br>    }<br>  }<br>  return jumps [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static double minJumps ( int [ ] arr , int n ) {<br>    int [ ] jumps = new int [ n ] ;<br>    if ( ( n == 0 ) || ( arr [ 0 ] == 0 ) ) {<br>        return minJumps ( arr , 0 , n ) ;<br>    }<br>    jumps [ 0 ] = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        jumps [ i ] = Double . POSITIVE_INFINITY ;<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( i <= j + arr [ j ] ) && ( jumps [ j ] != Integer . MAX_VALUE ) ) {<br>                jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ;<br>                break ;<br>            }<br>        }<br>    }<br>    return jumps [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) {<br>  int ind ;<br>  int val ;<br>  int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ;<br>  for ( ind = 0 ;<br>  ind < n ;<br>  ind ++ ) {<br>    for ( val = 0 ;<br>    val <= maxLimit ;<br>    val ++ ) {<br>      if ( ind == 0 ) {<br>        if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) {<br>          dp [ ind ] [ val ] = 1 ;<br>        }<br>        else {<br>          dp [ ind ] [ val ] = 0 ;<br>        }<br>      }<br>      else {<br>        if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) {<br>          if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ;<br>        }<br>        else if ( val - arr [ ind ] >= 0 ) {<br>          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ;<br>        }<br>        else if ( val + arr [ ind ] <= maxLimit ) {<br>          dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ;<br>        }<br>        else {<br>          dp [ ind ] [ val ] = 0 ;<br>        }<br>      }<br>    }<br>  }<br>  for ( val = maxLimit ;<br>  val >= 0 ;<br>  val -- ) {<br>    if ( dp [ n - 1 ] [ val ] == 1 ) {<br>      return val ;<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) {<br>    int ind = - 1 ;<br>    int val = - 1 ;<br>    int [ ] dp = new int [ maxLimit + 1 ] ;<br>    for ( int ind = 0 ;  ind < n ;  ind ++ ) {<br>        for ( int val = 0 ;  val < maxLimit + 1 ;  val ++ ) {<br>            if ( ( ind == 0 ) && ( num > maxLimit ) ) {<br>                if ( ( num - arr [ ind ] == val || num + arr [ ind ] == val ) && ( maxLimit > 0 ) ) {<br>                    dp [ ind ] [ val ] = 1 ;<br>                }<br>                if ( arr . length > n ) {<br>                    dp [ ind ] [ val ] = 0 ;<br>                }<br>            }<br>            if ( arr . length > n ) {<br>                if ( ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) && ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) ){<br>                    if ( ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) && ( maxLimit > 0 ) ) {<br>                        dp [ ind ] [ val ] = 1 ;<br>                    }<br>                }<br>                else if ( ( val - arr [ ind ] >= 0 ) && ( val - arr [ ind ] <= maxLimit ) ){<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ;<br>                }<br>                if ( ( val + arr [ ind ] <= maxLimit ) && ( val + arr [ ind ] > maxLimit ) ) {<br>                    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ;<br>                }<br>                if ( arr . length > n ) {<br>                    dp [ ind ] [ val ] = 0 ;<br>                }<br>            }<br>        }<br>    }<br>    for ( int val = maxLimit ;  val >= 0 ;  val -- ) {<br>        if ( ( dp [ n - 1 ] [ val ] == 1 ) && ( dp [ n - 1 ] [ num ] == maxLimit ) ) {<br>            return val ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Resources ( int process , int need ) {<br>  int minResources = 0 ;<br>  minResources = process * ( need - 1 ) + 1 ;<br>  return minResources ;<br>}<br></td>
    <td>translated code: <br><br> public static int Resources ( int process , int need ) {<br>    minResources = 0 ;<br>    minResources = process * ( need - 1 ) + 1 ;<br>    return minResources ;<br>}</td>
  </tr><tr>
    <th>NUMBER_DIGITS_PRODUCT_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDigits ( int a , int b ) {<br>  int count = 0 ;<br>  int p = Math . abs ( a * b ) ;<br>  if ( p == 0 ) return 1 ;<br>  while ( p > 0 ) {<br>    count ++ ;<br>    p = p / 10 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDigits ( int a , int b ) {<br>    int count = 0 ;<br>    int p = Math . abs ( a * b ) ;<br>    if ( ( p == 0 ) && ( b == 0 ) ) {<br>        return 1 ;<br>    }<br>    while ( ( p = a + b ) > 0 ) {<br>        count = count + 1 ;<br>        p = p / 10 ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>FLOOR_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int floorSearch ( int arr [ ] , int n , int x ) {<br>  if ( x >= arr [ n - 1 ] ) return n - 1 ;<br>  if ( x < arr [ 0 ] ) return - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int floorSearch ( int [ ] arr , int low , int high , int x ) {<br>    if ( ( low > high ) && ( x < 0 ) ) {<br>        return - 1 ;<br>    }<br>    if ( ( x >= arr [ high ] ) && ( x <= arr [ low ] ) ) {<br>        return high ;<br>    }<br>    int mid = ( int ) ( ( low + high ) / 2 ) ;<br>    if ( ( arr [ mid ] == x ) && ( arr [ high ] == x ) ) {<br>        return mid ;<br>    }<br>    if ( ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) || ( mid > 0 && arr [ mid ] > x && x < arr [ mid ] ) ){<br>        return mid - 1 ;<br>    }<br>    if ( ( x < arr [ mid ] ) && ( x > arr [ high ] ) ) {<br>        return floorSearch ( arr , low , mid - 1 , x ) ;<br>    }<br>    return floorSearch ( arr , mid + 1 , high , x ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int checkValidity ( int a , int b , int c ) {<br>  if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ;<br>  else return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkValidity ( int a , int b , int c ) {<br>    if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) {<br>        return false ;<br>    }<br>    if ( a > b ) {<br>        return true ;<br>    }<br>}</td>
  </tr><tr>
    <th>PRINT_N_X_N_SPIRAL_MATRIX_USING_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSpiral ( int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      int x ;<br>      x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ;<br>      if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) ;<br>      else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + "\t" ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSpiral ( int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            int x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ;<br>            if ( ( i <= j ) && ( i < n ) ){<br>                System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + "\t" ) ;<br>            }<br>            if ( n > 0 ) {<br>                System . out . print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) + "\t" ) ;<br>            }<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>POSITION_ELEMENT_STABLE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getIndexInSortedArray ( int arr [ ] , int n , int idx ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < arr [ idx ] ) result ++ ;<br>    if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int getIndexInSortedArray ( int [ ] arr , int n , int idx ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] < arr [ idx ] ) && ( arr [ i ] > arr [ idx ] ) ) {<br>            result ++ ;<br>        }<br>        if ( ( arr [ i ] == arr [ idx ] && i < idx ) || ( arr [ i ] == arr [ idx ] && i < n ) ) {<br>            result ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SEGMENT_VALUE_PUTTING_K_BREAKPOINTS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxSegment ( String s , int k ) {<br>  int seg_len = s . length ( ) - k ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < seg_len ;<br>  i ++ ) res = res * 10 + ( s . charAt ( i ) - '0' ) ;<br>  int seg_len_pow = ( int ) Math . pow ( 10 , seg_len - 1 ) ;<br>  int curr_val = res ;<br>  for ( int i = 1 ;<br>  i <= ( s . length ( ) - seg_len ) ;<br>  i ++ ) {<br>    curr_val = curr_val - ( s . charAt ( i - 1 ) - '0' ) * seg_len_pow ;<br>    curr_val = curr_val * 10 + ( s . charAt ( i + seg_len - 1 ) - '0' ) ;<br>    res = Math . max ( res , curr_val ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxSegment ( String s , int k ) {<br>    int segLen = s . length ( ) - k ;<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < segLen ;  i ++ ) {<br>        res = res * 10 + ( ( int ) s . charAt ( i ++ ) - '0' ) ;<br>    }<br>    int segLenPow = Math . pow ( 10 , segLen - 1 ) ;<br>    currVal = res ;<br>    for ( int i = 1 ;  i < s . length ( ) - segLen ;  i ++ ) {<br>        currVal = currVal - ( Character . digit ( s . charAt ( i - 1 ) , 10 ) - '0' ) * segLenPow ;<br>        currVal = ( currVal * 10 + ( ( char ) s . charAt ( i + segLen - 1 ) - ( char ) '0' ) ) ;<br>        res = Math . max ( res , currVal ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PowerOFPINnfactorial ( int n , int p ) {<br>  int ans = 0 ;<br>  int temp = p ;<br>  while ( temp <= n ) {<br>    ans += n / temp ;<br>    temp = temp * p ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int PowerOFPINnfactorial ( int n , int p ) {<br>    int ans = 0 ;<br>    int temp = p ;<br>    while ( ( temp <= n ) && ( temp <= p ) ) {<br>        ans += n / temp ;<br>        temp = temp * p ;<br>    }<br>    return ( int ) ans ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int identity ( int num ) {<br>  int row , col ;<br>  for ( row = 0 ;<br>  row < num ;<br>  row ++ ) {<br>    for ( col = 0 ;<br>    col < num ;<br>    col ++ ) {<br>      if ( row == col ) System . out . print ( 1 + " " ) ;<br>      else System . out . print ( 0 + " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void Identity ( int size ) {<br>    for ( int row = 0 ;  row <= size ;  row ++ ) {<br>        for ( int col = 0 ;  col <= size ;  col ++ ) {<br>            if ( ( row == col ) && ( row == col ) ){<br>                System . out . print ( "1 " ) ;<br>            }<br>            }<br>                System . out . print ( "0 " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) ans += ( i / j ) ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int N ) {<br>    int ans = 0 ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        for ( int j = 1 ;  j <= N ;  j ++ ) {<br>            ans += i / j ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>TILING_WITH_DOMINOES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n ) {<br>  int [ ] A = new int [ n + 1 ] ;<br>  int [ ] B = new int [ n + 1 ] ;<br>  A [ 0 ] = 1 ;<br>  A [ 1 ] = 0 ;<br>  B [ 0 ] = 0 ;<br>  B [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;<br>    B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;<br>  }<br>  return A [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>    int [ ] A = new int [ n + 1 ] ;<br>    B = new int [ n + 1 ] ;<br>    A [ 0 ] = 1 ;<br>    A [ 1 ] = 0 ;<br>    B [ 0 ] = 0 ;<br>    B [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;<br>        B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;<br>    }<br>    return A [ n ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDer ( int n ) {<br>  if ( n == 1 ) return 0 ;<br>  if ( n == 0 ) return 1 ;<br>  if ( n == 2 ) return 1 ;<br>  return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDer ( int n ) {<br>    if ( ( n == 1 ) || ( n == 2 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n == 0 ) && ( n % 2 == 0 ) ) {<br>        return 1 ;<br>    }<br>    if ( ( n == 2 ) && ( n == 3 ) ) {<br>        return 1 ;<br>    }<br>    return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countFreq ( int a [ ] , int n ) {<br>  int hm [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) hm [ a [ i ] ] ++ ;<br>  int cumul = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    cumul += hm [ a [ i ] ] ;<br>    if ( hm [ a [ i ] ] != 0 ) {<br>      System . out . println ( a [ i ] + "->" + cumul ) ;<br>    }<br>    hm [ a [ i ] ] = 0 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void countFreq ( int [ ] a , int n ) {<br>    HashMap hm = new HashMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ;<br>    }<br>    long cumul = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        cumul += hm [ a [ i ] ] ;<br>        if ( ( hm [ a [ i ] ] > 0 ) && ( hm [ a [ i ] ] < n ) ) a [ i ] = 5 ;<br>            System . out . println ( a [ i ] + "->" + cumul ) ;<br>        hm . put ( a [ i ] , 0 ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minSum ( int n ) {<br>  int sum = 0 ;<br>  while ( n > 0 ) {<br>    sum += ( n % 10 ) ;<br>    n /= 10 ;<br>  }<br>  if ( sum == 1 ) return 10 ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int minSum ( int n ) {<br>    int sum = 0 ;<br>    while ( ( n > 0 ) && ( n % 2 == 0 ) ) {<br>        sum += ( n % 10 ) ;<br>        n /= 10 ;<br>    }<br>    if ( ( sum == 1 ) && ( n > 1 ) ) {<br>        return 10 ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maximizecube ( int l , int b , int h ) {<br>  int side = gcd ( l , gcd ( b , h ) ) ;<br>  int num = l / side ;<br>  num = ( num * b / side ) ;<br>  num = ( num * h / side ) ;<br>  System . out . println ( side + " " + num ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maximizecube ( int l , int b , int h ) {<br>    side = gcd ( l , gcd ( b , h ) ) ;<br>    int num = ( int ) ( l / side ) ;<br>    num = ( int ) ( num * b / side ) ;<br>    num = ( int ) ( num * h / side ) ;<br>    System . out . println ( side + " " + num ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_NUMBER_POWER_K_USING_BASE_CHANGING_METHOD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPowerOfK ( int n , int k ) {<br>  boolean oneSeen = false ;<br>  while ( n > 0 ) {<br>    int digit = n % k ;<br>    if ( digit > 1 ) return false ;<br>    if ( digit == 1 ) {<br>      if ( oneSeen ) return false ;<br>      oneSeen = true ;<br>    }<br>    n /= k ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfK ( int n , int k ) {<br>    oneSeen = false ;<br>    while ( ( n > 0 ) && ( n % k == 0 ) ) {<br>        digit = n % k ;<br>        if ( ( digit > 1 ) && ( digit < k ) ){<br>            return false ;<br>        }<br>        if ( ( digit == 1 ) && ( k == 1 ) ) {<br>            if ( ( oneSeen ) && ( n > k ) ) {<br>                return false ;<br>            }<br>            oneSeen = true ;<br>        }<br>        n /= k ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PositionRightmostSetbit ( int n ) {<br>  int position = 1 ;<br>  int m = 1 ;<br>  while ( ( n & m ) == 0 ) {<br>    m = m << 1 ;<br>    position ++ ;<br>  }<br>  return position ;<br>}<br></td>
    <td>translated code: <br><br> public static int PositionRightmostSetbit ( int n ) {<br>    position = 1 ;<br>    int m = 1 ;<br>    while ( ( ! ( n & m ) ) && ( n & m > 0 ) ){<br>        m = m << 1 ;<br>        position ++ ;<br>    }<br>    return position ;<br>}</td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int insertSorted ( int arr [ ] , int n , int key , int capacity ) {<br>  if ( n >= capacity ) return n ;<br>  int i ;<br>  for ( i = n - 1 ;<br>  ( i >= 0 && arr [ i ] > key ) ;<br>  i -- ) arr [ i + 1 ] = arr [ i ] ;<br>  arr [ i + 1 ] = key ;<br>  return ( n + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int insertSorted ( int [ ] arr , int n , int key , int capacity ) {<br>    if ( ( n >= capacity ) && ( arr != null ) ) {<br>        return insertSorted ( arr , n , key , capacity , null ) ;<br>    }<br>    int i = n - 1 ;<br>    while ( i >= 0 && arr [ i ] > key ) {<br>        insertSorted ( arr , i + 1 , key , capacity ) ;<br>        i -- ;<br>    }<br>    arr [ i + 1 ] = key ;<br>    return ( n + 1 ) < capacity ? n + 1 : capacity ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMaxOfMin ( int n ) {<br>  Stack < Integer > s = new Stack < > ( ) ;<br>  int left [ ] = new int [ n + 1 ] ;<br>  int right [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    left [ i ] = - 1 ;<br>    right [ i ] = n ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ;<br>    if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ;<br>    s . push ( i ) ;<br>  }<br>  while ( ! s . empty ( ) ) s . pop ( ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ;<br>    if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ;<br>    s . push ( i ) ;<br>  }<br>  int ans [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) ans [ i ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = right [ i ] - left [ i ] - 1 ;<br>    ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 1 ;<br>  i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) System . out . print ( ans [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printMaxOfMin ( int [ ] arr , int n ) {<br>    StringBuilder sb = new StringBuilder ( ) ;<br>    int [ ] left = new int [ n + 1 ] ;<br>    int [ ] right = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        while ( ( s . length != 0 ) && arr [ s . length - 1 ] >= arr [ i ] ) {<br>            s . remove ( ) ;<br>        }<br>        if ( ( s . length != 0 ) && ( s [ 0 ] != 0 ) ) {<br>            left [ i ++ ] = s . charAt ( s . length - 1 ) ;<br>        }<br>        s . add ( i ++ ) ;<br>    }<br>    while ( ( s = arr [ n - 1 ] ) != null ) {<br>        s . remove ( ) ;<br>    }<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        while ( ( s . length != 0 ) && arr [ s . length - 1 ] >= arr [ i ] ) {<br>            s . remove ( ) ;<br>        }<br>        if ( ( s . length != 0 ) && ( s [ 0 ] != 0 ) ) {<br>            right [ i ] = s . length - 1 ;<br>        }<br>        s . add ( i ++ ) ;<br>    }<br>    int [ ] ans = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        ans [ i ] = 0 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int Len = right [ i ] - left [ i ] - 1 ;<br>        ans [ Len ] = Math . max ( ans [ Len ] , arr [ i ] ) ;<br>    }<br>    for ( int i = n - 1 ;  i > 0 ;  i -- ) {<br>        ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        System . out . print ( ans [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  if ( mat [ 0 ] [ 0 ] == 1 ) {<br>    dp [ 0 ] [ 0 ] = 1 ;<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mat [ 0 ] [ i ] == 1 ) {<br>      dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ;<br>    }<br>    else {<br>      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( mat [ i ] [ 0 ] == 1 ) {<br>      dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ;<br>    }<br>    else {<br>      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( mat [ i ] [ j ] == 1 ) {<br>        dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ n - 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumDecimalValue ( int [ ] [ ] mat , int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    if ( ( mat [ 0 ] [ 0 ] == 1 ) && ( mat [ 0 ] [ 1 ] == 1 ) ) {<br>        dp [ 0 ] [ 0 ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( mat [ 0 ] [ i ] == 1 ) && ( mat [ 1 ] [ i ] == 1 ) ) {<br>            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 * i ;<br>        }<br>        if ( n > 0 ) {<br>            dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;<br>        }<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( mat [ i ] [ 0 ] == 1 ) && ( mat [ i ] [ 1 ] == 1 ) ) {<br>            dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 * i ;<br>        }<br>    }<br>    if ( n > 0 ) {<br>        dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 1 ;  j < n ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] == 1 ) && ( mat [ j ] [ i ] == 1 ) ) {<br>                dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 * ( i + j ) ) ;<br>            }<br>            if ( n > 0 ) {<br>                dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ n - 1 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printCountRec ( int dist ) {<br>  if ( dist < 0 ) return 0 ;<br>  if ( dist == 0 ) return 1 ;<br>  return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int printCountRec ( int dist ) {<br>    if ( dist < 0 ) {<br>        return 0 ;<br>    }<br>    if ( dist == 0 ) {<br>        return 1 ;<br>    }<br>    return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) ;<br>}</td>
  </tr><tr>
    <th>MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void segregateElements ( int arr [ ] , int n ) {<br>  int temp [ ] = new int [ n ] ;<br>  int j = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;<br>  if ( j == n || j == 0 ) return ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = temp [ i ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void segregateElements ( int [ ] arr , int n ) {<br>    int [ ] temp = new int [ n ] ;<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] >= 0 ) && ( arr [ i ] < n ) ) {<br>            temp [ j ] = arr [ i ] ;<br>            j ++ ;<br>        }<br>    }<br>    if ( ( j == n || j == 0 ) && ( j == 0 ) ) {<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] < 0 ) && ( arr [ i ] > n ) ) {<br>            temp [ j ] = arr [ i ] ;<br>            j ++ ;<br>        }<br>    }<br>    for ( int k = 0 ;  k < n ;  k ++ ) {<br>        arr [ k ] = temp [ k ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_PERIMETER_N_BLOCKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long minPerimeter ( int n ) {<br>  int l = ( int ) Math . sqrt ( n ) ;<br>  int sq = l * l ;<br>  if ( sq == n ) return l * 4 ;<br>  else {<br>    long row = n / l ;<br>    long perimeter = 2 * ( l + row ) ;<br>    if ( n % l != 0 ) perimeter += 2 ;<br>    return perimeter ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int minPerimeter ( int n ) {<br>    double l = Math . sqrt ( n ) ;<br>    double sq = l * l ;<br>    if ( ( sq == n ) && ( sq == n ) ){<br>        return l * 4 ;<br>    }<br>    else{<br>        int row = n / l ;<br>        perimeter = 2 * ( l + row ) ;<br>        if ( ( n % l != 0 ) && ( n % l != 0 ) ){<br>            perimeter += 2 ;<br>        }<br>        return perimeter ;<br>    }<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProd ( int n ) {<br>  if ( n == 0 || n == 1 ) return 0 ;<br>  int max_val = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ;<br>  return max_val ;<br>}<br></td>
    <td>translated code: <br><br> static int maxProd ( int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) {<br>        return 0 ;<br>    }<br>    maxVal = 0 ;<br>    for ( int i = 1 ;  i <= n - 1 ;  i ++ ) {<br>        maxVal = Math . max ( maxVal , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ;<br>    }<br>    return max_val ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING_SPACE_OPTIMIZED_DP_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCSubStr ( String X , String Y ) {<br>  int m = X . length ( ) ;<br>  int n = Y . length ( ) ;<br>  int result = 0 ;<br>  int [ ] [ ] len = new int [ 2 ] [ n ] ;<br>  int currRow = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) {<br>        len [ currRow ] [ j ] = 0 ;<br>      }<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) {<br>        len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ;<br>        result = Math . max ( result , len [ currRow ] [ j ] ) ;<br>      }<br>      else {<br>        len [ currRow ] [ j ] = 0 ;<br>      }<br>    }<br>    currRow = 1 - currRow ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCSubStr ( String X , String Y ) {<br>    int m = X . length ( ) ;<br>    int n = Y . length ( ) ;<br>    LCSubStr result = 0 ;<br>    int [ ] lenMat = new int [ 2 ] ;<br>    currRow = 0 ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( i == 0 | j == 0 ) && ( i == 1 || j == 1 ) ){<br>                lenMat [ currRow ] [ j ] = 0 ;<br>            }<br>            else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ) {<br>                lenMat [ currRow ] [ j ] = lenMat [ 1 - currRow ] [ j - 1 ] + 1 ;<br>                result = Math . max ( result , lenMat [ currRow ] [ j ] ) ;<br>            }<br>            else {<br>                lenMat [ currRow ] [ j ] = 0 ;<br>            }<br>        }<br>        currRow = 1 - currRow ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_STRING_ROTATION_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPalindrome ( String str ) {<br>  int l = 0 ;<br>  int h = str . length ( ) - 1 ;<br>  while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPalindrome ( String string ) {<br>    int l = 0 ;<br>    int h = string . length ( ) - 1 ;<br>    while ( h > l ){<br>        l ++ ;<br>        h -- ;<br>        if ( string . charAt ( l - 1 ) != string . charAt ( h + 1 ) ) {<br>            return false ;<br>        }<br>    }<br>    return isPalindrome ( string , false ) ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSol ( int coeff [ ] , int n , int rhs ) {<br>  int dp [ ] = new int [ rhs + 1 ] ;<br>  Arrays . fill ( dp , 0 ) ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = coeff [ i ] ;<br>  j <= rhs ;<br>  j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;<br>  return dp [ rhs ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSol ( int [ ] coeff , int n , int rhs ) {<br>    int [ ] dp = new int [ rhs + 1 ] ;<br>    dp [ 0 ] = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = coeff [ i ] ;  j <= rhs ;  j ++ ) {<br>            dp [ j ] += dp [ j - coeff [ i ] ] ;<br>        }<br>    }<br>    return dp [ rhs ] ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_LARGEST_PAIR_SUM_IN_AN_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLargestSumPair ( ) {<br>  int first , second ;<br>  if ( arr [ 0 ] > arr [ 1 ] ) {<br>    first = arr [ 0 ] ;<br>    second = arr [ 1 ] ;<br>  }<br>  else {<br>    first = arr [ 1 ] ;<br>    second = arr [ 0 ] ;<br>  }<br>  for ( int i = 2 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( arr [ i ] > first ) {<br>      second = first ;<br>      first = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ;<br>  }<br>  return ( first + second ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLargestSumPair ( int [ ] arr , int n ) {<br>    if ( arr [ 0 ] > arr [ 1 ] ) {<br>        int first = arr [ 0 ] ;<br>        int second = arr [ 1 ] ;<br>    }<br>    else {<br>        int first = arr [ 1 ] ;<br>        int second = arr [ 0 ] ;<br>    }<br>    for ( int i = 2 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] > first ) {<br>            int second = first ;<br>            int first = arr [ i ++ ] ;<br>        }<br>        else if ( arr [ i ] > second && arr [ i ] != first ) {<br>            int second = arr [ i ++ ] ;<br>        }<br>    }<br>    return ( first + second ) ;<br>}</td>
  </tr><tr>
    <th>FIND_BITONIC_POINT_GIVEN_BITONIC_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binarySearch ( int arr [ ] , int left , int right ) {<br>  if ( left <= right ) {<br>    int mid = ( left + right ) / 2 ;<br>    if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ;<br>    if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ;<br>    else return binarySearch ( arr , left , mid - 1 ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int left , int right ) {<br>    if ( ( left <= right ) && ( left <= arr . length ) ) {<br>        int mid = ( left + right ) / 2 ;<br>        if ( ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) || ( arr [ mid ] < arr [ right ] && arr [ right + 1 ] > arr [ mid ] ) ) {<br>            return mid ;<br>        }<br>        if ( ( arr [ mid ] < arr [ mid + 1 ] ) && ( arr [ mid + 1 ] > arr [ right ] ) ) {<br>            return binarySearch ( arr , mid + 1 , right , left ) ;<br>        }<br>        else {<br>            return binarySearch ( arr , left , mid - 1 ) ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>PRINT_ALL_DISTINCT_CHARACTERS_OF_A_STRING_IN_ORDER_3_METHODS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printDistinct ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] count = new int [ MAX_CHAR ] ;<br>  int [ ] index = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>    index [ i ] = n ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    char x = str . charAt ( i ) ;<br>    ++ count [ x ] ;<br>    if ( count [ x ] == 1 && x != ' ' ) index [ x ] = i ;<br>    if ( count [ x ] == 2 ) index [ x ] = n ;<br>  }<br>  Arrays . sort ( index ) ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR && index [ i ] != n ;<br>  i ++ ) System . out . print ( str . charAt ( index [ i ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printDistinct ( String Str ) {<br>    int n = Str . length ( ) ;<br>    int [ ] count = new int [ MAX_CHAR ] ;<br>    int [ ] index = new int [ MAX_CHAR ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        char x = ( char ) Str . charAt ( i ++ ) ;<br>        count [ x ] ++ ;<br>        if ( ( count [ x ] == 1 && x != ' ' ) || ( count [ x ] == 2 && x != ' ' ) ) {<br>            index [ x ] = i ++ ;<br>        }<br>        if ( ( count [ x ] == 2 ) && ( count [ x ] == 3 ) ) {<br>            index [ x ] = n ;<br>        }<br>    }<br>    int [ ] index = new int [ 2 ] ;<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        if ( index [ i ] == n ){<br>            break ;<br>        }<br>        System . out . print ( Str . charAt ( index [ i ] ) + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printOtherSides ( int n ) {<br>  if ( n % 2 != 0 ) {<br>    if ( n == 1 ) System . out . println ( "-1" ) ;<br>    else {<br>      int b = ( n * n - 1 ) / 2 ;<br>      int c = ( n * n + 1 ) / 2 ;<br>      System . out . println ( "b = " + b + ", c = " + c ) ;<br>    }<br>  }<br>  else {<br>    if ( n == 2 ) System . out . println ( "-1" ) ;<br>    else {<br>      int b = n * n / 4 - 1 ;<br>      int c = n * n / 4 + 1 ;<br>      System . out . println ( "b = " + b + ", c = " + c ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printOtherSides ( int n ) {<br>    if ( ( n & 1 ) != 0 ){<br>        if ( ( n == 1 ) || ( n == 2 ) ) {<br>            System . out . println ( - 1 ) ;<br>        }<br>        else {<br>            int b = ( n * n - 1 ) / 2 ;<br>            int c = ( n * n + 1 ) / 2 ;<br>            System . out . println ( "b =" + b + ", c =" + c ) ;<br>        }<br>    }<br>    else {<br>        if ( ( n == 2 ) || ( n == 3 ) ) {<br>            System . out . println ( - 1 ) ;<br>        }<br>        else {<br>            int b = n * n / 4 - 1 ;<br>            int c = n * n / 4 + 1 ;<br>            System . out . println ( "b =" + b + " c =" + c ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int possibleStrings ( int n , int r , int b , int g ) {<br>  int fact [ ] = new int [ n + 1 ] ;<br>  fact [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) fact [ i ] = fact [ i - 1 ] * i ;<br>  int left = n - ( r + g + b ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= left ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= left - i ;<br>    j ++ ) {<br>      int k = left - ( i + j ) ;<br>      sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int possibleStrings ( int n , int r , int b , int g ) {<br>    int [ ] fact = new int [ n + 1 ] ;<br>    fact [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i += 1 ) {<br>        fact [ i ] = fact [ i - 1 ] * i ;<br>    }<br>    int left = n - ( r + g + b ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= left ;  i += 1 ) {<br>        for ( int j = 0 ;  j <= left - i ;  j += 1 ) {<br>            int k = left - ( i + j ) ;<br>            sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void rearrange ( int arr [ ] , int n ) {<br>  int max_ele = arr [ n - 1 ] ;<br>  int min_ele = arr [ 0 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) {<br>      arr [ i ] = max_ele ;<br>      max_ele -= 1 ;<br>    }<br>    else {<br>      arr [ i ] = min_ele ;<br>      min_ele += 1 ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] arr , int n ) {<br>    int maxEle = arr [ n - 1 ] ;<br>    int minEle = arr [ 0 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( i % 2 == 0 ) {<br>            arr [ i ++ ] = maxEle ;<br>            maxEele -- ;<br>        }<br>        else {<br>            arr [ i ] = minEle ;<br>            minEele ++ ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int calculateSum ( String arr [ ] , int n ) {<br>  if ( n == 0 ) return 0 ;<br>  String s = arr [ 0 ] ;<br>  int value = Integer . parseInt ( s ) ;<br>  int sum = value ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i = i + 2 ) {<br>    s = arr [ i ] ;<br>    value = Integer . parseInt ( s ) ;<br>    char operation = arr [ i - 1 ] . charAt ( 0 ) ;<br>    if ( operation == '+' ) sum += value ;<br>    else sum -= value ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int [ ] arr , int n ) {<br>    if ( ( n == 0 ) && ( arr != null ) ) {<br>        return 0 ;<br>    }<br>    int s = arr [ 0 ] ;<br>    int value = Integer . parseInt ( s ) ;<br>    sum = value ;<br>    for ( int i = 2 ;  i < n ;  i += 2 ) {<br>        int s = arr [ i ] ;<br>        int value = Integer . parseInt ( s ) ;<br>        int operation = arr [ i - 1 ] . charAt ( 0 ) ;<br>        if ( ( operation == '+' ) && ( n > 0 ) ) {<br>            sum += value ;<br>        }<br>        if ( n > 0 ) {<br>            sum -= value ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int ans = 0 , temp = 0 , num ;<br>  for ( int i = 1 ;<br>  i <= n && temp < n ;<br>  i ++ ) {<br>    temp = i - 1 ;<br>    num = 1 ;<br>    while ( temp < n ) {<br>      if ( temp + i <= n ) ans += ( i * num ) ;<br>      else ans += ( ( n - temp ) * num ) ;<br>      temp += i ;<br>      num ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int n ) {<br>    int ans = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( temp < n ){<br>            int temp = i - 1 ;<br>            int num = 1 ;<br>            while ( temp < n ) {<br>                if ( temp + i <= n ){<br>                    ans += i * num ;<br>                }<br>                if ( n > 0 ) {<br>                    ans += ( n - temp ) * num ;<br>                }<br>                temp += i ;<br>                num ++ ;<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SHUFFLE_A_DECK_OF_CARDS_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void shuffle ( int card [ ] , int n ) {<br>  Random rand = new Random ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int r = i + rand . nextInt ( 52 - i ) ;<br>    int temp = card [ r ] ;<br>    card [ r ] = card [ i ] ;<br>    card [ i ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shuffle ( int [ ] card , int n ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int r = i + ( rand . nextInt ( 55 ) % ( 52 - i ) ) ;<br>        int tmp = card [ i ] ;<br>        card [ i ] = card [ r ] ;<br>        card [ r ] = tmp ;<br>    }<br>}</td>
  </tr><tr>
    <th>DOOLITTLE_ALGORITHM_LU_DECOMPOSITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void luDecomposition ( int [ ] [ ] mat , int n ) {<br>  int [ ] [ ] lower = new int [ n ] [ n ] ;<br>  int [ ] [ ] upper = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      int sum = 0 ;<br>      for ( int j = 0 ;<br>      j < i ;<br>      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;<br>      upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;<br>    }<br>    for ( int k = i ;<br>    k < n ;<br>    k ++ ) {<br>      if ( i == k ) lower [ i ] [ i ] = 1 ;<br>      else {<br>        int sum = 0 ;<br>        for ( int j = 0 ;<br>        j < i ;<br>        j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;<br>        lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ;<br>      }<br>    }<br>  }<br>  System . out . println ( setw ( 2 ) + "     Lower Triangular" + setw ( 10 ) + "Upper Triangular" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [ j ] + "\t" ) ;<br>    System . out . print ( "\t" ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [ j ] + "\t" ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void luDecomposition ( int [ ] [ ] mat , int n ) {<br>    double [ ] [ ] lower = new double [ n ] [ n ] ;<br>    double [ ] [ ] upper = new double [ n ] [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int k = i ;  k < n ;  k ++ ) {<br>            double sum = 0 ;<br>            for ( int j = 0 ;  j < i ;  j ++ ) {<br>                sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;<br>            }<br>            upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;<br>        }<br>        for ( int k = i ;  k < n ;  k ++ ) {<br>            if ( ( i == k ) && ( n > 0 ) ){<br>                lower [ i ] [ i ] = 1 ;<br>            }<br>            else {<br>                double sum = 0 ;<br>                for ( int j = 0 ;  j < i ;  j ++ ) {<br>                    sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;<br>                }<br>                lower [ k ] [ i ] = ( int ) ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ;<br>            }<br>        }<br>    }<br>    System . out . println ( "Lower Triangular\t\tUpper Triangular" ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            System . out . print ( lower [ i ] [ j ] + "\t" ) ;<br>        }<br>        System . out . print ( "" ) ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            System . out . print ( upper [ i ] [ j ] + "\t" ) ;<br>        }<br>        System . out . println ( "" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_NTH_CATALAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int catalan ( int n ) {<br>  int res = 0 ;<br>  if ( n <= 1 ) {<br>    return 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    res += catalan ( i ) * catalan ( n - i - 1 ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double catalan ( int n ) {<br>    if ( n <= 1 ) {<br>        return 1 ;<br>    }<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        res += catalan ( i ) * catalan ( n - i - 1 ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int divisible ( String num ) {<br>  int n = num . length ( ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += ( int ) ( num . charAt ( i ) ) ;<br>  if ( sum % 3 == 0 ) return 0 ;<br>  if ( n == 1 ) return - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ;<br>  if ( n == 2 ) return - 1 ;<br>  return 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int divisible ( String num ) {<br>    int n = num . length ( ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        sum += ( int ) num [ i ] ;<br>    }<br>    if ( ( sum % 3 == 0 ) && ( sum % 5 == 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n == 1 ) && ( num == 2 ) ) {<br>        return - 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( sum % 3 == Integer . MIN_VALUE ) && ( sum % 3 == Integer . MAX_VALUE ) ) {<br>            return 1 ;<br>        }<br>    }<br>    if ( ( n == 2 ) && ( num == 1 ) ) {<br>        return - 1 ;<br>    }<br>    return 2 ;<br>}</td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPower ( int x , int y ) {<br>  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ;<br>  double res2 = Math . log ( y ) / Math . log ( x ) ;<br>  return ( res1 == res2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int isPower ( double x , double y ) {<br>    double res1 = Math . log ( y ) / Math . log ( x ) ;<br>    double res2 = Math . log ( y ) / Math . log ( x ) ;<br>    return 1 == ( res1 == res2 ) ? 0 : 1 ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUBSEQUENCE_GCD_GREATER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int largestGCDSubsequence ( int arr [ ] , int n ) {<br>  int ans = 0 ;<br>  int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;<br>  ;<br>  for ( int i = 2 ;<br>  i <= maxele ;<br>  ++ i ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( arr [ j ] % i == 0 ) ++ count ;<br>    }<br>    ans = Math . max ( ans , count ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int largestGCDSubsequence ( int [ ] arr , int n ) {<br>    int ans = 0 ;<br>    int maxele = Math . max ( arr , arr [ n - 1 ] ) ;<br>    for ( int i = 2 ;  i <= maxele ;  i ++ ) {<br>        int count = 0 ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ j ] % i == 0 ) && ( arr [ j ] % i == 0 ) ) {<br>                count ++ ;<br>            }<br>        }<br>        ans = Math . max ( ans , count ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>FIND_COMMON_ELEMENT_ROWS_ROW_WISE_SORTED_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findCommon ( int mat [ ] [ ] ) {<br>  int column [ ] = new int [ M ] ;<br>  int min_row ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < M ;<br>  i ++ ) column [ i ] = N - 1 ;<br>  min_row = 0 ;<br>  while ( column [ min_row ] >= 0 ) {<br>    for ( i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ;<br>    }<br>    int eq_count = 0 ;<br>    for ( i = 0 ;<br>    i < M ;<br>    i ++ ) {<br>      if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) {<br>        if ( column [ i ] == 0 ) return - 1 ;<br>        column [ i ] -= 1 ;<br>      }<br>      else eq_count ++ ;<br>    }<br>    if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findCommon ( int [ ] [ ] mat ) {<br>    int [ ] column = new int [ N - 1 ] ;<br>    int minRow = 0 ;<br>    while ( ( column [ minRow ] >= 0 ) && ( column [ minRow ] < mat . length ) ){<br>        for ( int i = 0 ;  i < M ;  i ++ ) {<br>            if ( ( mat [ i ] [ column [ i ] ] < mat [ minRow ] [ column [ minRow ] ] ) && ( mat [ minRow ] [ column [ minRow ] ] < mat [ maxRow ] [ column [ maxRow ] ] ) ) {<br>                min_row = i ;<br>            }<br>        }<br>        eq_count = 0 ;<br>        for ( int i = 0 ;  i < M ;  i ++ ) {<br>            if ( ( mat [ i ] [ column [ i ] ] > mat [ minRow ] [ column [ minRow ] ] ) && ( mat [ minRow ] [ column [ minRow ] ] > mat [ minCol ] [ column [ minCol ] ] ) ) {<br>                if ( ( column [ i ] == 0 ) && ( column [ i ] != 1 ) ){<br>                    return - 1 ;<br>                }<br>                column [ i ] -- ;<br>            }<br>            else {<br>                eqCount ++ ;<br>            }<br>        }<br>        if ( ( eq_count == M ) && ( mat [ 0 ] == 0 ) ){<br>            return mat [ minRow ] [ column [ minRow ] ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CONCENTRIC_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) {<br>  int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;<br>  return ( dis - r1 >= R && dis + r1 <= r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) {<br>    int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;<br>    return ( dis - r1 >= R && dis + r1 <= r ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSetBits ( int n ) {<br>  int i = 0 ;<br>  int ans = 0 ;<br>  while ( ( 1 << i ) <= n ) {<br>    boolean k = false ;<br>    int change = 1 << i ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( k == true ) ans += 1 ;<br>      else ans += 0 ;<br>      if ( change == 1 ) {<br>        k = ! k ;<br>        change = 1 << i ;<br>      }<br>      else {<br>        change -- ;<br>      }<br>    }<br>    i ++ ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSetBits ( int n ) {<br>    int i ;<br>    int ans = 0 ;<br>    while ( ( ( 1 << i ) <= n ) && ( i < n ) ){<br>        int k = 0 ;<br>        change = 1 << i ;<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            ans += k ;<br>            if ( change == 1 ){<br>                boolean k = ! k ;<br>                change = 1 << i ;<br>            }<br>            }<br>                change -- ;<br>        }<br>        i ++ ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>LONGEST_REPEATING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestRepeatingSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>    }<br>  }<br>  return dp [ n ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestRepeatingSubSeq ( String str ) {<br>    int n = str . length ( ) ;<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) || ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) ) {<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>            }<br>            else {<br>                dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ n ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_FIRST_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findFirstMissing ( int array [ ] , int start , int end ) {<br>  if ( start > end ) return end + 1 ;<br>  if ( start != array [ start ] ) return start ;<br>  int mid = ( start + end ) / 2 ;<br>  if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ;<br>  return findFirstMissing ( array , start , mid ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findFirstMissing ( int [ ] array , int start , int end ) {<br>    if ( ( start > end ) && ( start < array . length ) ) {<br>        return end + 1 ;<br>    }<br>    if ( ( start != array [ start ] ) && ( end != array [ end ] ) ) {<br>        return findFirstMissing ( array , start , end , 0 ) ;<br>    }<br>    int mid = ( int ) ( ( start + end ) / 2 ) ;<br>    if ( ( array [ mid ] == mid ) && ( start == end ) ) {<br>        return findFirstMissing ( array , mid + 1 , end ) ;<br>    }<br>    return findFirstMissing ( array , start , mid -> end - mid ) ;<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void sortSquares ( int arr [ ] ) {<br>  int n = arr . length ;<br>  int k ;<br>  for ( k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    if ( arr [ k ] >= 0 ) break ;<br>  }<br>  int i = k - 1 ;<br>  int j = k ;<br>  int ind = 0 ;<br>  int [ ] temp = new int [ n ] ;<br>  while ( i >= 0 && j < n ) {<br>    if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {<br>      temp [ ind ] = arr [ i ] * arr [ i ] ;<br>      i -- ;<br>    }<br>    else {<br>      temp [ ind ] = arr [ j ] * arr [ j ] ;<br>      j ++ ;<br>    }<br>    ind ++ ;<br>  }<br>  while ( i >= 0 ) {<br>    temp [ ind ++ ] = arr [ i ] * arr [ i ] ;<br>    i -- ;<br>  }<br>  while ( j < n ) {<br>    temp [ ind ++ ] = arr [ j ] * arr [ j ] ;<br>    j ++ ;<br>  }<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) arr [ x ] = temp [ x ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void sortSquares ( int [ ] arr , int n ) {<br>    int K = 0 ;<br>    for ( int K = 0 ;  K < n ;  K ++ ) {<br>        if ( ( arr [ K ] >= 0 ) && ( arr [ K ] < n ) ){<br>            break ;<br>        }<br>    }<br>    int i = K - 1 ;<br>    int j = K ;<br>    int ind = 0 ;<br>    int [ ] temp = new int [ n ] ;<br>    while ( ( i >= 0 && j < n ) || ( i < 0 && j < n ) ) {<br>        if ( ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) && ( arr [ i ] * arr [ j ] > arr [ i ] * arr [ j ] ) ) {<br>            temp [ ind ++ ] = arr [ i ] * arr [ i ] ;<br>            i -- ;<br>        }<br>        if ( n > 0 ) {<br>            temp [ ind ++ ] = arr [ j ] * arr [ j ] ;<br>            j ++ ;<br>        }<br>        ind ++ ;<br>    }<br>    while ( ( i >= 0 ) && ( i < n ) ) {<br>        temp [ ind ++ ] = arr [ i ] * arr [ i ] ;<br>        i -- ;<br>        ind ++ ;<br>    }<br>    while ( ( j < n ) && ( j < arr . length ) ) {<br>        temp [ ind ++ ] = arr [ j ] * arr [ j ] ;<br>        j ++ ;<br>        ind ++ ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = temp [ i ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  return ( num - divisor * ( num / divisor ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static long getRemainder ( long num , long divisor ) {<br>    return ( num - divisor * ( num / divisor ) ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int MinimumCost ( int cost [ ] , int n , int W ) {<br>  Vector < Integer > val = new Vector < Integer > ( ) ;<br>  Vector < Integer > wt = new Vector < Integer > ( ) ;<br>  int size = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( cost [ i ] != - 1 ) {<br>      val . add ( cost [ i ] ) ;<br>      wt . add ( i + 1 ) ;<br>      size ++ ;<br>    }<br>  }<br>  n = size ;<br>  int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= W ;<br>  i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) min_cost [ i ] [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= W ;<br>    j ++ ) {<br>      if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ;<br>      else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ;<br>    }<br>  }<br>  return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MinimumCost ( int [ ] cost , int n , int W ) {<br>    int [ ] val = Arrays . copyOf ( cost , n ) ;<br>    double [ ] wt = Arrays . copyOf ( W , n ) ;<br>    int size = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( cost [ i ] != - 1 ) && ( cost [ i ] != n ) ) {<br>            val . add ( cost [ i ] ) ;<br>            wt . add ( i + 1 ) ;<br>            size ++ ;<br>        }<br>    }<br>    n [ 0 ] = size ;<br>    int [ ] minCost = new int [ W + 1 ] ;<br>    for ( int i = 0 ;  i < W + 1 ;  i ++ ) {<br>        minCost [ 0 ] [ i ] = INF ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        minCost [ i ] [ 0 ] = 0 ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= W ;  j ++ ) {<br>            if ( ( wt [ i - 1 ] > j ) && ( wt [ i ] > w [ i - 1 ] ) ){<br>                minCost [ i ] [ j ] = minCost [ i - 1 ] [ j ] ;<br>            }<br>            else {<br>                min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ;<br>            }<br>        }<br>    }<br>    if ( ( minCost [ n ] [ W ] == INF ) && ( cost [ n ] [ W ] == 0 ) ) {<br>        return - 1 ;<br>    }<br>    else {<br>        return minCost [ n ] [ W ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( String str ) {<br>  int result = 0 ;<br>  int n = str . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 1 ;<br>  ( i + j ) < n && j <= MAX_CHAR ;<br>  j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( String str1 ) {<br>    int result = 0 ;<br>    int n = str1 . length ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= MAX_CHAR ;  j ++ ) {<br>            if ( ( ( i + j ) < n ) && ( ( i + j ) < n ) ){<br>                if ( ( ( Math . abs ( ( char ) str1 . charAt ( i + j ) - ( char ) str1 . charAt ( i ) ) ) == j ) && ( ( Math . abs ( ( char ) str1 . charAt ( i ) - ( char ) str1 . charAt ( i + j ) ) ) == j ) ) {<br>                    result ++ ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>A_PRODUCT_ARRAY_PUZZLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void productArray ( int arr [ ] , int n ) {<br>  if ( n == 1 ) {<br>    System . out . print ( 0 ) ;<br>    return ;<br>  }<br>  int left [ ] = new int [ n ] ;<br>  int right [ ] = new int [ n ] ;<br>  int prod [ ] = new int [ n ] ;<br>  int i , j ;<br>  left [ 0 ] = 1 ;<br>  right [ n - 1 ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ;<br>  for ( j = n - 2 ;<br>  j >= 0 ;<br>  j -- ) right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) prod [ i ] = left [ i ] * right [ i ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( prod [ i ] + " " ) ;<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static void productArray ( int [ ] arr , int n ) {<br>    if ( ( n == 1 ) && ( arr != null ) ) {<br>        System . out . println ( 0 ) ;<br>        }<br>    }<br>    int [ ] left = new int [ n ] ;<br>    int [ ] right = new int [ n ] ;<br>    int [ ] prod = new int [ n ] ;<br>    left [ 0 ] = 1 ;<br>    right [ n - 1 ] = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        left [ i ] = arr [ i - 1 ] * left [ i - 1 ] ;<br>    }<br>    for ( int j = n - 2 ;  j >= 0 ;  j -- ) {<br>        right [ j ] = arr [ j + 1 ] * right [ j + 1 ] ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        prod [ i ] = left [ i ] * right [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( prod [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FREQUENT_ELEMENT_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int mostFrequent ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int key = arr [ i ] ;<br>    if ( hp . containsKey ( key ) ) {<br>      int freq = hp . get ( key ) ;<br>      freq ++ ;<br>      hp . put ( key , freq ) ;<br>    }<br>    else {<br>      hp . put ( key , 1 ) ;<br>    }<br>  }<br>  int max_count = 0 , res = - 1 ;<br>  for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) {<br>    if ( max_count < val . getValue ( ) ) {<br>      res = val . getKey ( ) ;<br>      max_count = val . getValue ( ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int mostFrequent ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > Hash = new HashMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == Hash . keySet ( ) . stream ( ) . anyMatch ( a -> a < n ) ) {<br>            Hash [ arr [ i ] ] ++ ;<br>        }<br>        else {<br>            Hash [ arr [ i ] ] = 1 ;<br>        }<br>    }<br>    int maxCount = 0 ;<br>    int res = - 1 ;<br>    for ( int i = 0 ;  i < Hash . length ;  i ++ ) {<br>        if ( ( maxCount < Hash [ i ] ) && ( maxCount < Hash [ i + 1 ] ) ) {<br>            int res = i ;<br>            int maxCount = Hash [ i ] ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PRINT_UNIQUE_ROWS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void printArray ( int arr [ ] [ ] , int row , int col ) {<br>  HashSet < String > set = new HashSet < String > ( ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    String s = "" ;<br>    for ( int j = 0 ;<br>    j < col ;<br>    j ++ ) s += String . valueOf ( arr [ i ] [ j ] ) ;<br>    if ( ! set . contains ( s ) ) {<br>      set . add ( s ) ;<br>      System . out . println ( s ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printArray ( double [ ] [ ] matrix ) {<br>    int rowCount = matrix . length ;<br>    if ( rowCount == 0 ) {<br>        }<br>    }<br>    int columnCount = matrix [ 0 ] . length ;<br>    if ( columnCount == 0 ) {<br>        }<br>    }<br>    String rowOutputFormat = " " ;<br>    printed . clear ( ) ;<br>    for ( int row : matrix ) {<br>        String routput = rowOutputFormat + Arrays . toString ( matrix ) ;<br>        if ( routput != 0 ) {<br>            printed [ routput ] = true ;<br>            System . out . println ( routput ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_1S_SORTED_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countOnes ( int arr [ ] , int low , int high ) {<br>  if ( high >= low ) {<br>    int mid = low + ( high - low ) / 2 ;<br>    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ;<br>    if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ;<br>    return countOnes ( arr , low , ( mid - 1 ) ) ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOnes ( int [ ] arr , int low , int high ) {<br>    if ( high >= low ) {<br>        int mid = low + ( high - low ) / 2 ;<br>        if ( ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) || ( ( mid == low || arr [ mid ] == 0 ) && ( arr [ mid + 1 ] == 1 ) ) ) {<br>            return mid + 1 ;<br>        }<br>        if ( arr [ mid ] == 1 ) {<br>            return countOnes ( arr , ( mid + 1 ) , high ) ;<br>        }<br>        return countOnes ( arr , low , mid - 1 ) ;<br>    }<br>    return 0 ;<br>}</td>
  </tr><tr>
    <th>POSSIBLE_MOVES_KNIGHT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) {<br>  int X [ ] = {<br>    2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 };<br>    int Y [ ] = {<br>      1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 };<br>      int count = 0 ;<br>      for ( int i = 0 ;<br>      i < 8 ;<br>      i ++ ) {<br>        int x = p + X [ i ] ;<br>        int y = q + Y [ i ] ;<br>        if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ;<br>      }<br>      return count ;<br>    }<br>    </td>
    <td>translated code: <br><br> public static int findPossibleMoves ( int [ ] [ ] mat , int p , int q ) {<br>    n = mat . length ;<br>    int [ ] X = {<br>    }<br>    int [ ] Y = {<br>    }<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < 8 ;  i ++ ) {<br>        int x = p + X [ i ] ;<br>        int y = q + Y [ i ] ;<br>        if ( ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) || ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>ROTATE_MATRIX_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rotatematrix ( int m , int n , int mat [ ] [ ] ) {<br>  int row = 0 , col = 0 ;<br>  int prev , curr ;<br>  while ( row < m && col < n ) {<br>    if ( row + 1 == m || col + 1 == n ) break ;<br>    prev = mat [ row + 1 ] [ col ] ;<br>    for ( int i = col ;<br>    i < n ;<br>    i ++ ) {<br>      curr = mat [ row ] [ i ] ;<br>      mat [ row ] [ i ] = prev ;<br>      prev = curr ;<br>    }<br>    row ++ ;<br>    for ( int i = row ;<br>    i < m ;<br>    i ++ ) {<br>      curr = mat [ i ] [ n - 1 ] ;<br>      mat [ i ] [ n - 1 ] = prev ;<br>      prev = curr ;<br>    }<br>    n -- ;<br>    if ( row < m ) {<br>      for ( int i = n - 1 ;<br>      i >= col ;<br>      i -- ) {<br>        curr = mat [ m - 1 ] [ i ] ;<br>        mat [ m - 1 ] [ i ] = prev ;<br>        prev = curr ;<br>      }<br>    }<br>    m -- ;<br>    if ( col < n ) {<br>      for ( int i = m - 1 ;<br>      i >= row ;<br>      i -- ) {<br>        curr = mat [ i ] [ col ] ;<br>        mat [ i ] [ col ] = prev ;<br>        prev = curr ;<br>      }<br>    }<br>    col ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rotateMatrix ( int [ ] [ ] mat ) {<br>    if ( ! mat . length ){<br>        rotateMatrix ( mat , 0 , 0 ) ;<br>    }<br>    top = 0 ;<br>    int bottom = mat . length - 1 ;<br>    int left = 0 ;<br>    int right = mat [ 0 ] . length - 1 ;<br>    while ( left < right && top < bottom ) {<br>        double prev = mat [ top + 1 ] [ left ] ;<br>        for ( int i = left ;  i <= right ;  i ++ ) {<br>            curr = mat [ top ] [ i ] ;<br>            mat [ top ] [ i ] = prev ;<br>            prev = curr ;<br>        }<br>        top ++ ;<br>        for ( int i = top ;  i <= bottom ;  i ++ ) {<br>            curr = mat [ i ] [ right ] ;<br>            mat [ i ] [ right ] = prev ;<br>            prev = curr ;<br>        }<br>        right -- ;<br>        for ( int i = right ;  i >= left ;  i -- ) {<br>            curr = mat [ bottom ] [ i ] ;<br>            mat [ bottom ] [ i ] = prev ;<br>            prev = curr ;<br>        }<br>        bottom -- ;<br>        for ( int i = bottom ;  i >= top - 1 ;  i -- ) {<br>            curr = mat [ i ] [ left ] ;<br>            mat [ i ] [ left ] = prev ;<br>            prev = curr ;<br>        }<br>        left ++ ;<br>    }<br>    return mat ;<br>}</td>
  </tr><tr>
    <th>FIND_KTH_CHARACTER_OF_DECRYPTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char encodedChar ( String str , int k ) {<br>  String expand = "" ;<br>  String temp = "" ;<br>  int freq = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ) {<br>    temp = "" ;<br>    freq = 0 ;<br>    while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) {<br>      temp += str . charAt ( i ) ;<br>      i ++ ;<br>    }<br>    while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) {<br>      freq = freq * 10 + str . charAt ( i ) - '0' ;<br>      i ++ ;<br>    }<br>    for ( int j = 1 ;<br>    j <= freq ;<br>    j ++ ) expand += temp ;<br>  }<br>  if ( freq == 0 ) expand += temp ;<br>  return expand . charAt ( k - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String encodedChar ( String str , int k ) {<br>    String expand = "" ;<br>    int freq = 0 ;<br>    int i = 0 ;<br>    while ( ( i = str . indexOf ( ' ' , k ) ) != - 1 ) {<br>        String temp = "" ;<br>        int freq = 0 ;<br>        while ( ( i < str . length ( ) ) && ( char ) str . charAt ( i ) >= 'a' && ( char ) str . charAt ( i ) <= 'z' ) ) {<br>            temp += str . charAt ( i ++ ) ;<br>            i ++ ;<br>        }<br>        while ( ( i < str . length ( ) ) && ( Character . digit ( str . charAt ( i ) , 10 ) >= '1' && Character . digit ( str . charAt ( i ) , 10 ) <= '9' ) ) {<br>            freq = freq * 10 + ( char ) str . charAt ( i ++ ) - '0' ;<br>            i ++ ;<br>        }<br>        for ( int j = 1 ;  j <= freq ;  j += 1 ) {<br>            expand += temp ;<br>        }<br>    }<br>    if ( ( freq == 0 ) && ( k > 0 ) ) {<br>        expand += temp ;<br>    }<br>    return expand [ k - 1 ] ;<br>}</td>
  </tr><tr>
    <th>EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_IS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  int i = 0 ;<br>  while ( i <= n - 1 ) {<br>    if ( arr [ i ] == x ) return i ;<br>    i += Math . abs ( arr [ i ] - x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int n , int x ) {<br>    int i = 0 ;<br>    while ( ( i <= n - 1 ) && ( i >= 0 ) ) {<br>        if ( ( arr [ i ] == x ) && ( n > 0 ) ) {<br>            return i ++ ;<br>        }<br>        i += Math . abs ( arr [ i ] - x ) ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int returnMaxSum ( int A [ ] , int B [ ] , int n ) {<br>  Set < Integer > mp = new HashSet < Integer > ( ) ;<br>  int result = 0 ;<br>  int curr_sum = 0 , curr_begin = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    while ( mp . contains ( A [ i ] ) ) {<br>      mp . remove ( A [ curr_begin ] ) ;<br>      curr_sum -= B [ curr_begin ] ;<br>      curr_begin ++ ;<br>    }<br>    mp . add ( A [ i ] ) ;<br>    curr_sum += B [ i ] ;<br>    result = Integer . max ( result , curr_sum ) ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int returnMaxSum ( int [ ] A , int [ ] B , int n ) {<br>    Set < Integer > mp = new HashSet < Integer > ( ) ;<br>    int result = 0 ;<br>    currSum = currBegin = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        while ( A [ i ] == mp ){<br>            mp . remove ( A [ currBegin ] ) ;<br>            currSum -= B [ currBegin ++ ] ;<br>            currBegin ++ ;<br>        }<br>        mp . add ( A [ i ] ) ;<br>        currSum += B [ i ] ;<br>        result = Math . max ( result , currSum ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isMultipleOf3 ( int n ) {<br>  int odd_count = 0 ;<br>  int even_count = 0 ;<br>  if ( n < 0 ) n = - n ;<br>  if ( n == 0 ) return 1 ;<br>  if ( n == 1 ) return 0 ;<br>  while ( n != 0 ) {<br>    if ( ( n & 1 ) != 0 ) odd_count ++ ;<br>    if ( ( n & 2 ) != 0 ) even_count ++ ;<br>    n = n >> 2 ;<br>  }<br>  return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMultipleOf3 ( int n ) {<br>    oddCount = 0 ;<br>    evenCount = 0 ;<br>    if ( ( n < 0 ) && ( n > 5 ) ) {<br>        n = - n ;<br>    }<br>    if ( ( n == 0 ) && ( n % 2 == 0 ) ) {<br>        return 1 ;<br>    }<br>    if ( ( n == 1 ) && ( n == 2 ) ) {<br>        return 0 ;<br>    }<br>    while ( ( n -- ) > 0 ) {<br>        if ( ( n & 1 ) != 0 ) {<br>            oddCount ++ ;<br>        }<br>        if ( ( n & 2 ) != 0 ) {<br>            evenCount ++ ;<br>        }<br>        n = n >> 2 ;<br>    }<br>    return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( int arr [ ] , int n ) {<br>  int cum_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) cum_sum += arr [ i ] ;<br>  int curr_val = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) curr_val += i * arr [ i ] ;<br>  int res = curr_val ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ;<br>    curr_val = next_val ;<br>    res = Math . max ( res , next_val ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr , int n ) {<br>    cumSum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        cumSum += arr [ i ] ;<br>    }<br>    int currVal = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        currVal += i * arr [ i ] ;<br>    }<br>    int res = currVal ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        int nextVal = ( currVal - ( cumSum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) ;<br>        currVal = nextVal ;<br>        res = Math . max ( res , nextVal ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) {<br>  int T1 [ ] = new int [ NUM_STATION ] ;<br>  int T2 [ ] = new int [ NUM_STATION ] ;<br>  int i ;<br>  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;<br>  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;<br>  for ( i = 1 ;<br>  i < NUM_STATION ;<br>  ++ i ) {<br>    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ;<br>    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ;<br>  }<br>  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int carAssembly ( int [ ] a , int [ ] t , int [ ] e , int [ ] x ) {<br>    NUM_STATION = a [ 0 ] ;<br>    int [ ] T1 = new int [ NUM_STATION ] ;<br>    int [ ] T2 = new int [ NUM_STATION ] ;<br>    T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;<br>    T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;<br>    for ( int i = 1 ;  i <= NUM_STATION ;{<br>        T1 [ i ] = Math . min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ;<br>        T2 [ i ] = Math . min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ;<br>    }<br>    return Math . min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSpiral ( int [ ] [ ] mat , int r , int c ) {<br>  int i , a = 0 , b = 2 ;<br>  int low_row = ( 0 > a ) ? 0 : a ;<br>  int low_column = ( 0 > b ) ? 0 : b - 1 ;<br>  int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;<br>  int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;<br>  while ( ( low_row > 0 - r && low_column > 0 - c ) ) {<br>    for ( i = low_column + 1 ;<br>    i <= high_column && i < c && low_row >= 0 ;<br>    ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " ) ;<br>    low_row -= 1 ;<br>    for ( i = low_row + 2 ;<br>    i <= high_row && i < r && high_column < c ;<br>    ++ i ) System . out . print ( mat [ i ] [ high_column ] + " " ) ;<br>    high_column += 1 ;<br>    for ( i = high_column - 2 ;<br>    i >= low_column && i >= 0 && high_row < r ;<br>    -- i ) System . out . print ( mat [ high_row ] [ i ] + " " ) ;<br>    high_row += 1 ;<br>    for ( i = high_row - 2 ;<br>    i > low_row && i >= 0 && low_column >= 0 ;<br>    -- i ) System . out . print ( mat [ i ] [ low_column ] + " " ) ;<br>    low_column -= 1 ;<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSpiral ( int [ ] [ ] mat , int r , int c ) {<br>    int a = 0 ;<br>    int b = 2 ;<br>    int lowRow = 0 < ( 0 > a ) ? a : 0 ;<br>    int lowColumn = 0 < ( 0 > b ) ? b - 1 : c ;<br>    int highRow = r - 1 == c ? ( ( a + 1 ) >= r ) ? a + 1 : c ;<br>    int highColumn = c - 1 == 0 ? ( ( b + 1 ) >= c ) ? b + 1 : c - 1 ;<br>    while ( ( ( lowRow > 0 - r && lowColumn > 0 - c ) || ( highRow > 0 - r && highColumn > 0 - c ) ) && ( ( lowRow > 0 - r && lowColumn > 0 - c ) || ( highRow > 0 - r && highColumn > 0 - c ) ) ) {<br>        int i = lowColumn + 1 ;<br>        while ( ( i <= highColumn && i < c && lowRow >= 0 ) || ( i == highColumn && i < c && lowRow >= 0 ) ) {<br>            System . out . print ( mat [ lowRow ] [ i ] + " " ) ;<br>            i ++ ;<br>        }<br>        lowRow -- ;<br>        int i = lowRow + 2 ;<br>        while ( ( i <= highRow && i < r && highColumn < c ) || ( i >= highRow && i < highColumn && i < highColumn ) ) {<br>            System . out . print ( mat [ i ] [ highColumn ] + " " ) ;<br>            i ++ ;<br>        }<br>        highColumn ++ ;<br>        int i = highColumn - 2 ;<br>        while ( ( i >= lowColumn && i >= 0 && highRow < r ) || ( i >= highColumn && i >= lowColumn && i < highRow ) ) {<br>            System . out . print ( mat [ highRow ] [ i ] + " " ) ;<br>            i -- ;<br>        }<br>        highRow ++ ;<br>        int i = highRow - 2 ;<br>        while ( ( i > lowRow && i >= 0 && lowColumn >= 0 ) || ( i > highRow && i >= 0 && highColumn >= 0 ) ) {<br>            System . out . print ( mat [ i ] [ lowColumn ] + " " ) ;<br>            i -- ;<br>        }<br>        lowColumn -- ;<br>    }<br>    System . out . println ( ) ;<br>}</td>
  </tr><tr>
    <th>MID_POINT_CIRCLE_DRAWING_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void midPointCircleDraw ( int x_centre , int y_centre , int r ) {<br>  int x = r , y = 0 ;<br>  System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>  if ( r > 0 ) {<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>    System . out . println ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>  }<br>  int P = 1 - r ;<br>  while ( x > y ) {<br>    y ++ ;<br>    if ( P <= 0 ) P = P + 2 * y + 1 ;<br>    else {<br>      x -- ;<br>      P = P + 2 * y - 2 * x + 1 ;<br>    }<br>    if ( x < y ) break ;<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( - x + x_centre ) + ", " + ( y + y_centre ) + ")" ) ;<br>    System . out . print ( "(" + ( x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    System . out . println ( "(" + ( - x + x_centre ) + ", " + ( - y + y_centre ) + ")" ) ;<br>    if ( x != y ) {<br>      System . out . print ( "(" + ( y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>      System . out . print ( "(" + ( - y + x_centre ) + ", " + ( x + y_centre ) + ")" ) ;<br>      System . out . print ( "(" + ( y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ;<br>      System . out . println ( "(" + ( - y + x_centre ) + ", " + ( - x + y_centre ) + ")" ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void midPointCircleDraw ( int xCentre , int yCentre , int r ) {<br>    x = r ;<br>    int y = 0 ;<br>    System . out . print ( "(" + x + xCentre + ", " + y + yCentre + ")" + ", " + r ) ;<br>    if ( ( r > 0 ) && ( xCentre > 0 ) && ( yCentre > 0 ) ) {<br>        System . out . print ( "(" + x + xCentre + ", " + - y + yCentre + ")" ) ;<br>        System . out . print ( "(" + y + xCentre + ", " + x + yCentre + ")" + ", " + r ) ;<br>        System . out . print ( "(" + - y + xCentre + ", " + x + yCentre + ")" + " " ) ;<br>    }<br>    P = 1 - r ;<br>    while ( ( x > y ) && ( x < xCentre ) ) {<br>        y ++ ;<br>        if ( ( P <= 0 ) && ( P >= 0 ) ){<br>            P = P + 2 * y + 1 ;<br>        }<br>        else {<br>            x -- ;<br>            P = P + 2 * y - 2 * x + 1 ;<br>        }<br>        if ( ( x < y ) && ( x > yCentre ) ) {<br>            break ;<br>        }<br>        System . out . print ( "(" + x + xCentre + ", " + y + yCentre + ")" + ", " + r ) ;<br>        System . out . print ( "(" + - x + xCentre + ", " + y + yCentre + ")" + ", " + r + ")" ) ;<br>        System . out . print ( "(" + x + xCentre + ", " + - y + yCentre + ")" ) ;<br>        System . out . print ( "(" + - x + xCentre + ", " + - y + yCentre + ")" + " " ) ;<br>        if ( ( x != y ) && ( x < yCentre ) ) {<br>            System . out . print ( "(" + y + xCentre + ", " + x + yCentre + ")" + ", " + r ) ;<br>            System . out . print ( "(" + - y + xCentre + ", " + x + yCentre + ")" + ", " + r + ")" ) ;<br>            System . out . print ( "(" + y + xCentre + ", " + - x + yCentre + ")" ) ;<br>            System . out . print ( "(" + - y + xCentre + ", " + - x + yCentre + ")" + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>SMALLEST_ELEMENT_REPEATED_EXACTLY_K_TIMES_NOT_LIMITED_SMALL_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int smallestKFreq ( int a [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ;<br>  else m . put ( a [ i ] , 1 ) ;<br>  int res = Integer . MAX_VALUE ;<br>  Set < Integer > s = m . keySet ( ) ;<br>  for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ;<br>  return ( res != Integer . MAX_VALUE ) ? res : - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallestKFreq ( int [ ] arr , int n , int k ) {<br>    TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        mp [ arr [ i ] ] ++ ;<br>    }<br>    int res = Integer . MAX_VALUE ;<br>    int res1 = Integer . MAX_VALUE ;<br>    for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) {<br>        if ( values == k ) {<br>            res = Math . min ( res , key ) ;<br>        }<br>    }<br>    return res == res1 ? - 1 : res ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_XOR_VALUE_PAIR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minXOR ( int arr [ ] , int n ) {<br>  int min_xor = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ;<br>  return min_xor ;<br>}<br></td>
    <td>translated code: <br><br> public static int minXOR ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int min_xor = 999999 ;<br>    int val = 0 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j <= n - 1 ;  j ++ ) {<br>            int val = arr [ i ] ^ arr [ j ] ;<br>            minXor = Math . min ( minXor , val ) ;<br>        }<br>    }<br>    return minXOR ;<br>}</td>
  </tr><tr>
    <th>MIRROR_CHARACTERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String compute ( String str , int n ) {<br>  String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;<br>  int l = str . length ( ) ;<br>  String answer = "" ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) answer = answer + str . charAt ( i ) ;<br>  for ( int i = n ;<br>  i < l ;<br>  i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - 'a' ) ;<br>  return answer ;<br>}<br></td>
    <td>translated code: <br><br> public static String compute ( String st , int n ) {<br>    String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;<br>    int l = st . length ( ) ;<br>    String answer = "" ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        answer = answer + st [ i ] ;<br>    }<br>    for ( int i = n ;  i < l ;  i ++ ) {<br>        answer = ( answer + reverseAlphabet [ ( char ) st . charAt ( i ) - 'a' ] ) ;<br>    }<br>    return answer ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CHECK_PLUS_PERFECT_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkplusperfect ( int x ) {<br>  int temp = x ;<br>  int n = 0 ;<br>  while ( x != 0 ) {<br>    x /= 10 ;<br>    n ++ ;<br>  }<br>  x = temp ;<br>  int sum = 0 ;<br>  while ( x != 0 ) {<br>    sum += Math . pow ( x % 10 , n ) ;<br>    x /= 10 ;<br>  }<br>  return ( sum == temp ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkplusperfect ( int x ) {<br>    int temp = x ;<br>    int n = 0 ;<br>    while ( ( x != 0 ) && ( x != 1 ) ) {<br>        x = x / 10 ;<br>        n = n + 1 ;<br>    }<br>    x = temp ;<br>    sm = 0 ;<br>    while ( ( x != 0 ) && ( x != 1 ) ) {<br>        sm = sm + ( int ) ( Math . pow ( x % 10 , n ) ) ;<br>        x = x / 10 ;<br>    }<br>    return ( sm == temp ) ;<br>}</td>
  </tr><tr>
    <th>ARC_LENGTH_ANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double arcLength ( double diameter , double angle ) {<br>  double pi = 22.0 / 7.0 ;<br>  double arc ;<br>  if ( angle >= 360 ) {<br>    System . out . println ( "Angle cannot" + " be formed" ) ;<br>    return 0 ;<br>  }<br>  else {<br>    arc = ( pi * diameter ) * ( angle / 360.0 ) ;<br>    return arc ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static double arcLength ( double diameter , double angle ) {<br>    if ( angle >= 360 ) {<br>        System . out . println ( "Angle cannot be formed" ) ;<br>        return 0 ;<br>    }<br>    if ( diameter > 0 ) {<br>        double arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ;<br>        return arc ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLastIndex ( String str , Character x ) {<br>  int index = - 1 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) if ( str . charAt ( i ) == x ) index = i ;<br>  return index ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLastIndex ( String str , char x ) {<br>    int index = - 1 ;<br>    for ( int i = 0 ;  i <= str . length ( ) ;  i ++ ) {<br>        if ( str . charAt ( i ++ ) == x ) {<br>            index = i ;<br>        }<br>    }<br>    return index ;<br>}</td>
  </tr><tr>
    <th>COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findTrailingZeros ( int n ) {<br>  int count = 0 ;<br>  for ( int i = 5 ;<br>  n / i >= 1 ;<br>  i *= 5 ) count += n / i ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int findTrailingZeros ( long n ) {<br>    int count = 0 ;<br>    int i = 5 ;<br>    while ( ( n / i >= 1 ) && ( n % i == 0 ) ) {<br>        count += ( int ) ( n / i ) ;<br>        i *= 5 ;<br>    }<br>    return ( int ) count ;<br>}</td>
  </tr><tr>
    <th>ROTATE_MATRIX_180_DEGREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rotateMatrix ( int mat [ ] [ ] ) {<br>  for ( int i = N - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = N - 1 ;<br>    j >= 0 ;<br>    j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rotateMatrix ( int [ ] [ ] mat ) {<br>    int i = N - 1 ;<br>    while ( ( i >= 0 ) && ( i < mat . length ) ){<br>        int j = N - 1 ;<br>        while ( ( j >= 0 ) && ( j < mat . length ) ){<br>            System . out . print ( mat [ i ] [ j ] + " " ) ;<br>            j = j - 1 ;<br>        }<br>        System . out . println ( ) ;<br>        i = i - 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>SUM_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int calculateSum ( int n ) {<br>  if ( n <= 0 ) return 0 ;<br>  int fibo [ ] = new int [ n + 1 ] ;<br>  fibo [ 0 ] = 0 ;<br>  fibo [ 1 ] = 1 ;<br>  int sum = fibo [ 0 ] + fibo [ 1 ] ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;<br>    sum += fibo [ i ] ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int n ) {<br>    if ( ( n <= 0 ) && ( n > 1 ) ) {<br>        return 0 ;<br>    }<br>    int [ ] fibo = new int [ n + 1 ] ;<br>    fibo [ 1 ] = 1 ;<br>    int sm = fibo [ 0 ] + fibo [ 1 ] ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;<br>        sm = sm + fibo [ i ] ;<br>    }<br>    return sm ;<br>}</td>
  </tr><tr>
    <th>LARGEST_LEXICOGRAPHIC_ARRAY_WITH_AT_MOST_K_CONSECUTIVE_SWAPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KSwapMaximum ( int [ ] arr , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < n - 1 && k > 0 ;<br>  ++ i ) {<br>    int indexPosition = i ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( k <= j - i ) break ;<br>      if ( arr [ j ] > arr [ indexPosition ] ) indexPosition = j ;<br>    }<br>    for ( int j = indexPosition ;<br>    j > i ;<br>    -- j ) SwapInts ( arr , j , j - 1 ) ;<br>    k -= indexPosition - i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void KSwapMaximum ( int n , int k ) {<br>    arr = new int [ n ] ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( k > 0 ) && ( n > k ) ){<br>            indexPosition = i ;<br>            for ( int j = i + 1 ;  j < n ;{<br>                if ( ( k <= j - i ) && ( k <= k + j ) ){<br>                    break ;<br>                }<br>                if ( ( arr [ j ] > arr [ indexPosition ] ) && ( arr [ j ] > arr [ indexPosition + 1 ] ) ){<br>                    indexPosition = j ;<br>                }<br>            }<br>            for ( int j = indexPosition ;  j < i ;  j ++ ) {<br>                int t = arr [ j ] ;<br>                arr [ j ] = arr [ j - 1 ] ;<br>                arr [ j - 1 ] = t ;<br>            }<br>            k [ 0 ] = k [ indexPosition - i ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( int n ) {<br>  return 1162261467 % n == 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int n ) {<br>    return 1162261467 % n == 0 ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int i , j ;<br>  System . out . println ( "Repeated Elements are :" ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < size ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " " ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>    System . out . print ( "Repeating elements are " ) ;<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < size ;  j ++ ) {<br>            if ( arr [ i ] == arr [ j ] ) {<br>                System . out . print ( arr [ i ++ ] + " " ) ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FIND_AREA_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float findArea ( float a , float b , float c ) {<br>  if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) {<br>    System . out . println ( "Not a valid triangle" ) ;<br>    System . exit ( 0 ) ;<br>  }<br>  float s = ( a + b + c ) / 2 ;<br>  return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findArea ( int a , int b , int c ) {<br>    if ( ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) && ( a + b <= c ) ){<br>        System . out . println ( "Not a valid trianglen" ) ;<br>        }<br>    }<br>    int s = ( a + b + c ) / 2 ;<br>    double area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) * 0.5 ;<br>    System . out . println ( "Area of a traingle is " + area ) ;<br>}</td>
  </tr><tr>
    <th>GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubSeqDivisible ( String str ) {<br>  int n = str . length ( ) ;<br>  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;<br>  int arr [ ] = new int [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] [ arr [ i ] % 8 ] = 1 ;<br>    for ( int j = 0 ;<br>    j < 8 ;<br>    j ++ ) {<br>      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;<br>      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( dp [ i ] [ 0 ] == 1 ) return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubSeqDivisible ( String str ) {<br>    int n = str . length ( ) ;<br>    int [ ] dp = new int [ 10 ] ;<br>    int [ ] arr = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        arr [ i ++ ] = Integer . parseInt ( str . substring ( i - 1 , i ) ) ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        dp [ i ] [ arr [ i ] % 8 ] = 1 ;<br>        for ( int j = 0 ;  j < 8 ;  j ++ ) {<br>            if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) && ( dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) ){<br>                dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;<br>            }<br>            if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) && ( dp [ i ] [ j ] > dp [ i ] [ j ] ) ){<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;<br>            }<br>        }<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( ( dp [ i ] [ 0 ] == 1 ) && ( dp [ i ] [ 1 ] == 1 ) ) {<br>            return isSubSeqDivisible ( str , false ) ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int smallestSubWithSum ( int arr [ ] , int n , int x ) {<br>  int curr_sum = 0 , min_len = n + 1 ;<br>  int start = 0 , end = 0 ;<br>  while ( end < n ) {<br>    while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ;<br>    while ( curr_sum > x && start < n ) {<br>      if ( end - start < min_len ) min_len = end - start ;<br>      curr_sum -= arr [ start ++ ] ;<br>    }<br>  }<br>  return min_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallestSubWithSum ( int [ ] arr , int n , int x ) {<br>    int currSum = 0 ;<br>    int minLen = n + 1 ;<br>    int start = 0 ;<br>    int end = 0 ;<br>    while ( ( end < n ) && ( end < arr . length ) ) {<br>        while ( ( currSum <= x && end < n ) && ( currSum <= x && end < n ) ) {<br>            currSum += arr [ end ] ;<br>            end ++ ;<br>        }<br>        while ( ( currSum > x && start < n ) || ( currSum < x && currSum > x ) ) {<br>            if ( ( end - start ) < minLen ) {<br>                int minLen = end - start ;<br>            }<br>            currSum -= arr [ start ++ ] ;<br>            start ++ ;<br>        }<br>    }<br>    return minLen ;<br>}</td>
  </tr><tr>
    <th>FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void findPair ( int [ ] arr , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( Integer i : arr ) {<br>    s . add ( i ) ;<br>  }<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int sum = arr [ i ] + arr [ j ] ;<br>      if ( s . contains ( sum ) ) {<br>        found = true ;<br>        System . out . println ( arr [ i ] + " " + arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  if ( found == false ) System . out . println ( "Not Exist " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findPair ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ;<br>    found = false ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( arr [ i ] + arr [ j ] + arr [ n ] + s . length > 0 ) {<br>                System . out . println ( arr [ i ] + " " + arr [ j ] ) ;<br>                found = true ;<br>            }<br>        }<br>    }<br>    if ( found == false ) {<br>        System . out . println ( "Not exist" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofAP ( int a [ ] , int n ) {<br>  int minarr = + 2147483647 ;<br>  int maxarr = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    minarr = Math . min ( minarr , a [ i ] ) ;<br>    maxarr = Math . max ( maxarr , a [ i ] ) ;<br>  }<br>  int dp [ ] = new int [ n ] ;<br>  int sum [ ] = new int [ MAX ] ;<br>  int ans = n + 1 ;<br>  for ( int d = ( minarr - maxarr ) ;<br>  d <= ( maxarr - minarr ) ;<br>  d ++ ) {<br>    Arrays . fill ( sum , 0 ) ;<br>    for ( int i = 0 ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ i ] = 1 ;<br>      if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ;<br>      ans += dp [ i ] - 1 ;<br>      sum [ a [ i ] ] += dp [ i ] ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofAP ( int [ ] a , int n ) {<br>    int minarr = + 2147483647 ;<br>    int maxarr = - 2147483648 ;<br>    for ( int i = 0 ;  i < n ;{<br>        int minarr = Math . min ( minarr , a [ i ] ) ;<br>        maxarr = Math . max ( maxarr , a [ i ] ) ;<br>    }<br>    int [ ] dp = new int [ n + 1 ] ;<br>    ans = n + 1 ;<br>    for ( int d = ( minarr - maxarr ) ;  d <= ( maxarr - minarr ) ;{<br>        int [ ] sum = new int [ MAX + 1 ] ;<br>        for ( int i = 0 ;  i < n ;{<br>            dp [ i ] = 1 ;<br>            if ( ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) || ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) ) a [ i ] = 5 ;<br>                dp [ i ] += sum [ a [ i ] - d ] ;<br>            ans += dp [ i ] - 1 ;<br>            sum [ a [ i ] ] += dp [ i ] ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBERS_THAT_DONT_CONTAIN_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int n ) {<br>  if ( n < 3 ) return n ;<br>  if ( n >= 3 && n < 10 ) return n - 1 ;<br>  int po = 1 ;<br>  while ( n / po > 9 ) po = po * 10 ;<br>  int msd = n / po ;<br>  if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ;<br>  else return count ( msd * po - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int n ) {<br>    if ( n < 3 ) {<br>        return n ;<br>    }<br>    }<br>        return n - 1 ;<br>    int po = 1 ;<br>    while ( n / po > 9 ) {<br>        po = po * 10 ;<br>    }<br>    msd = n / po ;<br>    if ( msd != 3 ) {<br>        return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ;<br>    }<br>    }<br>        return count ( msd * po - 1 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void transpose ( int A [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < N ;<br>  j ++ ) {<br>    int temp = A [ i ] [ j ] ;<br>    A [ i ] [ j ] = A [ j ] [ i ] ;<br>    A [ j ] [ i ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void transpose ( int [ ] [ ] A ) {<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < N ;{<br>            A [ i ] [ j ] = A [ j ] [ i ] , A [ j ] [ i ] = A [ i ] [ j ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int spiralDiaSum ( int n ) {<br>  if ( n == 1 ) return 1 ;<br>  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int spiralDiaSum ( int n ) {<br>    if ( n == 1 ) {<br>        return 1 ;<br>    }<br>    return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getInvCount ( int arr [ ] , int n ) {<br>  int invcount = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      if ( arr [ i ] > arr [ j ] ) {<br>        for ( int k = j + 1 ;<br>        k < n ;<br>        k ++ ) {<br>          if ( arr [ j ] > arr [ k ] ) invcount ++ ;<br>        }<br>      }<br>    }<br>  }<br>  return invcount ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr ) {<br>    int n = arr . length ;<br>    invcount = 0 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( arr [ i ] > arr [ j ] ) {<br>                for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                    if ( arr [ j ] > arr [ k ] ) {<br>                        invcount ++ ;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    return invcount ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumNodes ( int l ) {<br>  int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;<br>  Vector < Vector < Integer >> vec = new Vector < Vector < Integer >> ( ) ;<br>  for ( int i = 1 ;<br>  i <= l ;<br>  i ++ ) vec . add ( new Vector < Integer > ( ) ) ;<br>  for ( int i = 1 ;<br>  i <= leafNodeCount ;<br>  i ++ ) vec . get ( l - 1 ) . add ( i ) ;<br>  for ( int i = l - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int k = 0 ;<br>    while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) {<br>      vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) + vec . get ( i + 1 ) . get ( k + 1 ) ) ;<br>      k += 2 ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < vec . get ( i ) . size ( ) ;<br>    j ++ ) sum += vec . get ( i ) . get ( j ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int SumNodes ( int l ) {<br>    leafNodeCount = Math . pow ( 2 , l - 1 ) ;<br>    ArrayList < ArrayList < Integer >> vec = new ArrayList < ArrayList < Integer >> ( ) ;<br>    for ( int i = 1 ;  i <= leafNodeCount ;  i ++ ) {<br>        vec [ l - 1 ] . add ( i ) ;<br>    }<br>    for ( int i = l - 2 ;  i >= 0 ;  i -- ) {<br>        int k = 0 ;<br>        while ( ( k < vec [ i + 1 ] . length - 1 ) && ( k < l ) ){<br>            vec [ i ] . add ( vec [ i + 1 ] . get ( k ) + vec [ i + 1 ] . get ( k + 1 ) ) ;<br>            k += 2 ;<br>        }<br>    }<br>    Sum = 0 ;<br>    for ( int i = 0 ;  i < l ;  i ++ ) {<br>        for ( int j = 0 ;  j < vec [ i ] . length ;  j ++ ) {<br>            Sum += vec [ i ] [ j ] ;<br>        }<br>    }<br>    return new Sum ( l ) ;<br>}</td>
  </tr><tr>
    <th>SUM_OF_ALL_PROPER_DIVISORS_OF_A_NATURAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int divSum ( int num ) {<br>  int result = 0 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( num ) ;<br>  i ++ ) {<br>    if ( num % i == 0 ) {<br>      if ( i == ( num / i ) ) result += i ;<br>      else result += ( i + num / i ) ;<br>    }<br>  }<br>  return ( result + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int divSum ( int num ) {<br>    int result = 0 ;<br>    int i = 2 ;<br>    while ( i <= ( Math . sqrt ( num ) ) ) {<br>        if ( ( num % i == 0 ) && ( num % i == 0 ) ) {<br>            if ( ( i == ( num / i ) ) && ( i != ( num / i ) ) ) {<br>                result = result + i ;<br>            }<br>            }<br>                result = result + ( i + num / i ) ;<br>        }<br>        i = i + 1 ;<br>    }<br>    return ( result + 1 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean find3Numbers ( int A [ ] , int arr_size , int sum ) {<br>  for ( int i = 0 ;<br>  i < arr_size - 2 ;<br>  i ++ ) {<br>    HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>    int curr_sum = sum - A [ i ] ;<br>    for ( int j = i + 1 ;<br>    j < arr_size ;<br>    j ++ ) {<br>      if ( s . contains ( curr_sum - A [ j ] ) && curr_sum - A [ j ] != ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) {<br>        System . out . printf ( "Triplet is %d, %d, %d" , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ;<br>        return true ;<br>      }<br>      s . add ( A [ j ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean find3Numbers ( int [ ] A , int arrSize , int sum ) {<br>    for ( int i = 0 ;  i <= arrSize - 1 ;  i ++ ) {<br>        Set < Integer > s = new HashSet < Integer > ( ) ;<br>        int currSum = sum - A [ i ] ;<br>        for ( int j = i + 1 ;  j < arrSize ;  j ++ ) {<br>            if ( ( currSum - A [ j ] ) . contains ( s ) ){<br>                System . out . println ( "Triplet is" + A [ i ] + ", " + A [ j ] + ", " + currSum - A [ j ] ) ;<br>                return find3Numbers ( A , arrSize , sum , 0 ) ;<br>            }<br>            s . add ( A [ j ] ) ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>NTH_EVEN_LENGTH_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String evenlength ( String n ) {<br>  String res = n ;<br>  for ( int j = n . length ( ) - 1 ;<br>  j >= 0 ;<br>  -- j ) res += n . charAt ( j ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int evenLength ( int [ ] n ) {<br>    int res = n ;<br>    for ( int j = n . length ( ) - 1 ;  j >= 0 ;  j -- ) {<br>        res += n [ j ] ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FINDING_POWER_PRIME_NUMBER_P_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int PowerOFPINnfactorial ( int n , int p ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    int count = 0 , temp = i ;<br>    while ( temp % p == 0 ) {<br>      count ++ ;<br>      temp = temp / p ;<br>    }<br>    ans += count ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int PowerOFPINnfactorial ( int n , int p ) {<br>    int ans = 0 ;<br>    int temp = p ;<br>    while ( ( temp <= n ) && ( temp <= p ) ) {<br>        ans += n / temp ;<br>        temp = temp * p ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) {<br>  if ( k == 0 ) {<br>    return 0 ;<br>  }<br>  if ( l < 0 | r < 0 ) {<br>    return ( int ) 1e9 ;<br>  }<br>  if ( dp [ l ] [ r ] [ k ] != - 1 ) {<br>    return dp [ l ] [ r ] [ k ] ;<br>  }<br>  int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;<br>  return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ) , solve ( X , Y , l , r - 1 , k , dp ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( char [ ] X , char [ ] Y , int l , int r , int k , int [ ] [ ] dp ) {<br>    if ( k == 0 ){<br>        return 0 ;<br>    }<br>    if ( l < 0 || r < 0 ){<br>        return 1000000000 ;<br>    }<br>    if ( dp [ l ] [ r ] [ k ] != - 1 ){<br>        return dp [ l ] [ r ] [ k ] ;<br>    }<br>    int cost = ( ( ( int ) X [ l ] - ( int ) 'a' ) ^ ( ( int ) Y [ r ] - ( int ) 'a' ) ) ;<br>    dp [ l ] [ r ] [ k ] = Math . min ( cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ) ;<br>    return dp [ l ] [ r ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printString ( String str , char ch , int count ) {<br>  int occ = 0 , i ;<br>  if ( count == 0 ) {<br>    System . out . println ( str ) ;<br>    return ;<br>  }<br>  for ( i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == ch ) occ ++ ;<br>    if ( occ == count ) break ;<br>  }<br>  if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ;<br>  else System . out . println ( "Empty string" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printString ( String str , char ch , int count ) {<br>    int occ = 0 , i = 0 ;<br>    if ( ( count == 0 ) && ( ch == ' ' ) ) {<br>        System . out . println ( str ) ;<br>    }<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( ( str . charAt ( i ++ ) == ch ) && ( count > 0 ) ) {<br>            occ ++ ;<br>        }<br>        if ( ( occ == count ) && ( str != null ) ) {<br>            break ;<br>        }<br>    }<br>    if ( ( i < str . length ( ) - 1 ) && ( i < count ) ) {<br>        System . out . print ( str . substring ( i + 1 , str . length ( ) - i + 2 ) ) ;<br>    }<br>    if ( count > 0 ) {<br>        System . out . println ( "Empty string" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SORT_1_N_SWAPPING_ADJACENT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( B [ i ] ) {<br>      j = i ;<br>      while ( B [ j ] ) {<br>        j ++ ;<br>      }<br>      Arrays . sort ( A , i , 1 + j ) ;<br>      i = j ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( A [ i ] != i + 1 ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean sortedAfterSwap ( int [ ] A , int [ ] B , int n ) {<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( B [ i ] == 1 ) && ( A [ i ] == 2 ) ) {<br>            int j = i ;<br>            while ( ( B [ j ] == 1 ) && ( A [ j ] > B [ j ] ) ){<br>                j = j + 1 ;<br>            }<br>            A [ 0 ] = A [ 0 ] + Arrays . binarySearch ( A , i , j ) + A [ j ] ;<br>            int i = j ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( A [ i ] != i + 1 ) && ( B [ i ] != i + 1 ) ){<br>            return false ;<br>        }<br>    }<br>    return sortedAfterSwap ( A , B , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>GENERATE_PYTHAGOREAN_TRIPLETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pythagoreanTriplets ( int limit ) {<br>  int a , b , c = 0 ;<br>  int m = 2 ;<br>  while ( c < limit ) {<br>    for ( int n = 1 ;<br>    n < m ;<br>    ++ n ) {<br>      a = m * m - n * n ;<br>      b = 2 * m * n ;<br>      c = m * m + n * n ;<br>      if ( c > limit ) break ;<br>      System . out . println ( a + " " + b + " " + c ) ;<br>    }<br>    m ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void pythagoreanTriplets ( int limits ) {<br>    int c = 0 , m = 2 ;<br>    while ( c < limits ) {<br>        for ( int n = 1 ;  n <= m ;  n ++ ) {<br>            int a = m * m - n * n ;<br>            int b = 2 * m * n ;<br>            double c = m * m + n * n ;<br>            if ( c > limits ){<br>                break ;<br>            }<br>            System . out . println ( a + "," + b + "," + c ) ;<br>        }<br>        m = m + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND_SECOND_HALF_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSeq ( int n , int diff ) {<br>  if ( Math . abs ( diff ) > n ) return 0 ;<br>  if ( n == 1 && diff == 0 ) return 2 ;<br>  if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ;<br>  int res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSeq ( int n , int diff ) {<br>    if ( ( Math . abs ( diff ) > n ) && ( diff > 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n == 1 && diff == 0 ) || ( n == 2 && diff == 1 ) ) {<br>        return 2 ;<br>    }<br>    if ( ( n == 1 && Math . abs ( diff ) == 1 ) || ( diff == 0 && Math . abs ( diff ) == 0 ) ) {<br>        return 1 ;<br>    }<br>    int res = ( countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ) ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossibleTriangle ( int [ ] arr , int N ) {<br>  if ( N < 3 ) return false ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < N - 2 ;<br>  i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossibleTriangle ( int [ ] arr , int N ) {<br>    if ( N < 3 ) {<br>        return false ;<br>    }<br>    Arrays . sort ( arr , 0 , N ) ;<br>    for ( int i = 0 ;  i < N - 2 ;  i ++ ) {<br>        if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ){<br>            return true ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printInSortedOrder ( String arr [ ] , int n ) {<br>  int index [ ] = new int [ n ] ;<br>  int i , j , min ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    index [ i ] = i ;<br>  }<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    min = i ;<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) {<br>        min = j ;<br>      }<br>    }<br>    if ( min != i ) {<br>      int temp = index [ min ] ;<br>      index [ min ] = index [ i ] ;<br>      index [ i ] = temp ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( arr [ index [ i ] ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printInSortedOrder ( int [ ] arr , int n ) {<br>    int [ ] index = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        index [ i ] = i ;<br>    }<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        int min = i ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ index [ min ] ] > arr [ index [ j ] ] ) && ( arr [ index [ min ] ] < arr [ index [ j ] ] ) ) {<br>                int min = j ;<br>            }<br>        }<br>        if ( ( min != i ) && ( n != i ) ) {<br>            index [ min ] = index [ i ] = 0 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( arr [ index [ i ] ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>GAME_REPLACING_ARRAY_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int playGame ( int arr [ ] ) {<br>  HashSet < Integer > set = new HashSet < > ( ) ;<br>  for ( int i : arr ) set . add ( i ) ;<br>  return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int playGame ( int [ ] arr , int n ) {<br>    Set s = new HashSet ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        s . add ( arr [ i ] ) ;<br>    }<br>    return 1 == s . length % 2 ? 2 : 1 ;<br>}</td>
  </tr><tr>
    <th>BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int gcd ( int a , int b ) {<br>  if ( a == 0 ) return b ;<br>  return gcd ( b % a , a ) ;<br>}<br></td>
    <td>translated code: <br><br> public static long gcd ( long a , long b ) {<br>    if ( a == 0 ){<br>        return b ;<br>    }<br>    return gcd ( b % a , a ) ;<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_WAVE_FORM_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void sortInWave ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i += 2 ) {<br>    if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ;<br>    if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortInWave ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i < n ;  i += 2 ) {<br>        if ( ( i > 0 && arr [ i ] < arr [ i - 1 ] ) || ( i > 0 && arr [ i - 1 ] > arr [ i ] ) ) {<br>            arr [ i ] = arr [ i - 1 ] ;<br>        }<br>        if ( ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) || ( i < n - 1 && arr [ i + 1 ] > arr [ i + 2 ] ) ) {<br>            arr [ i ] = arr [ i + 1 ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumSumSubarray ( int arr [ ] , int n ) {<br>  int min_prefix_sum = 0 ;<br>  int res = Integer . MIN_VALUE ;<br>  int prefix_sum [ ] = new int [ n ] ;<br>  prefix_sum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ;<br>    min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumSumSubarray ( int [ ] arr , int n ) {<br>    int minPrefixSum = 0 ;<br>    double res = - Double . MAX_VALUE ;<br>    int [ ] prefixSum = new int [ n ] ;<br>    prefixSum . add ( arr [ 0 ] ) ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        prefixSum . add ( prefixSum . get ( i - 1 ) + arr [ i ] ) ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        res = Math . max ( res , prefixSum [ i ] - minPrefixSum ) ;<br>        minPrefixSum = Math . min ( minPrefixSum , prefixSum [ i ] ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String firstLetterWord ( String str ) {<br>  String result = "" ;<br>  boolean v = true ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == ' ' ) {<br>      v = true ;<br>    }<br>    else if ( str . charAt ( i ) != ' ' && v == true ) {<br>      result += ( str . charAt ( i ) ) ;<br>      v = false ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static String firstLetterWord ( String str ) {<br>    String result = "" ;<br>    boolean v = true ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == ' ' ) && ( str . charAt ( i + 1 ) == ' ' ) ) {<br>            boolean v = true ;<br>        }<br>        else if ( ( str . charAt ( i ) != ' ' && v == true ) || ( str . charAt ( i ) != ' ' && v == false ) ) {<br>            result += ( str . charAt ( i ) ) ;<br>            boolean v = false ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int n ) {<br>  int multiTerms = n * ( n + 1 ) / 2 ;<br>  int sum = multiTerms ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    multiTerms = multiTerms - ( i - 1 ) ;<br>    sum = sum + multiTerms * i ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int n ) {<br>    int multiTerms = n * ( n + 1 ) / 2 ;<br>    MultiTerms sm = multiTerms ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        multiTerms = multiTerms - ( i - 1 ) ;<br>        sm = sm + multiTerms * i ;<br>    }<br>    return sm ;<br>}</td>
  </tr><tr>
    <th>CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFERENCES_IS_MINIMUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minCost ( int a [ ] , int n , int k ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= k ;<br>  j ++ ) dp [ i ] [ j ] = inf ;<br>  dp [ 0 ] [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= k ;<br>  j ++ ) for ( int m = i - 1 ;<br>  m >= 0 ;<br>  m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ;<br>  return dp [ n ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] a , int n , int k ) {<br>    int [ ] dp = new int [ k + 1 ] ;<br>    dp [ 0 ] [ 0 ] = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= k ;  j ++ ) {<br>            for ( int m = i - 1 ;  m >= 0 ;{<br>                dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ;<br>            }<br>        }<br>    }<br>    return dp [ n ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>LEIBNIZ_HARMONIC_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void LeibnizHarmonicTriangle ( int n ) {<br>  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= i ;<br>    j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j - 1 ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void LeibnizHarmonicTriangle ( int n ) {<br>    int [ ] C = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= Math . min ( i , n ) ;  j ++ ) {<br>            if ( ( j == 0 || j == i ) && ( n == 0 || n == i ) ) {<br>                C [ i ] [ j ] = 1 ;<br>            }<br>            else{<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= i ;  j ++ ) {<br>            System . out . print ( "1/" ) ;<br>            System . out . print ( i * C [ i - 1 ] [ j - 1 ] + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COUNT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean canMakeStr2 ( String str1 , String str2 ) {<br>  int [ ] count = new int [ MAX ] ;<br>  char [ ] str3 = str1 . toCharArray ( ) ;<br>  for ( int i = 0 ;<br>  i < str3 . length ;<br>  i ++ ) count [ str3 [ i ] ] ++ ;<br>  char [ ] str4 = str2 . toCharArray ( ) ;<br>  for ( int i = 0 ;<br>  i < str4 . length ;<br>  i ++ ) {<br>    if ( count [ str4 [ i ] ] == 0 ) return false ;<br>    count [ str4 [ i ] ] -- ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canMakeStr2 ( String s1 , String s2 ) {<br>    int count = new Integer ( s1 . length ( ) ) . intValue ( ) ;<br>    for ( int i = 0 ;  i < s1 . length ( ) ;  i ++ ) {<br>        count [ s1 . charAt ( i ) ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < s2 . length ( ) ;  i ++ ) {<br>        if ( count [ s2 [ i ] ] == 0 ) {<br>            return false ;<br>        }<br>        count [ s2 [ i ] ] -- ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int SumOfKsubArray ( int arr [ ] , int k ) {<br>  int sum = 0 ;<br>  Deque < Integer > S = new LinkedList < > ( ) , G = new LinkedList < > ( ) ;<br>  int i = 0 ;<br>  for ( i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ;<br>    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ;<br>    G . addLast ( i ) ;<br>    S . addLast ( i ) ;<br>  }<br>  for ( ;<br>  i < arr . length ;<br>  i ++ ) {<br>    sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ;<br>    while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) S . removeFirst ( ) ;<br>    while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) G . removeFirst ( ) ;<br>    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >= arr [ i ] ) S . removeLast ( ) ;<br>    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <= arr [ i ] ) G . removeLast ( ) ;<br>    G . addLast ( i ) ;<br>    S . addLast ( i ) ;<br>  }<br>  sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int SumOfKsubArray ( int [ ] arr , int n , int k ) {<br>    int Sum = 0 ;<br>    Deque < Integer > S = new ArrayDeque < Integer > ( ) ;<br>    Deque < Integer > G = new ArrayDeque < Integer > ( ) ;<br>    for ( int i = 0 ;  i < k ;  i ++ ) {<br>        while ( ( S . length > 0 && arr [ S [ S . length - 1 ] ] >= arr [ i ] ) || ( S . length > 0 && arr [ S . length - 1 ] >= arr [ i ] ) ){<br>            S . remove ( ) ;<br>        }<br>        while ( ( G . length > 0 ) && arr [ G [ G . length - 1 ] ] <= arr [ i ] ) {<br>            G . pop ( ) ;<br>        }<br>        G . add ( i ) ;<br>        S . add ( i ) ;<br>    }<br>    for ( int i = k ;  i < n ;  i ++ ) {<br>        Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ;<br>        while ( ( S . length > 0 && S [ 0 ] <= i - k ) || ( S . length > 1 && S [ 1 ] <= i - k ) ){<br>            S . popLeft ( ) ;<br>        }<br>        while ( ( G . length > 0 ) && G [ 0 ] <= i - k ){<br>            G . popLeft ( ) ;<br>        }<br>        while ( ( S . length > 0 && arr [ S [ S . length - 1 ] ] >= arr [ i ] ) || ( S . length > 0 && arr [ S . length - 1 ] >= arr [ i ] ) ){<br>            S . remove ( ) ;<br>        }<br>        while ( ( G . length > 0 ) && arr [ G [ G . length - 1 ] ] <= arr [ i ] ) {<br>            G . pop ( ) ;<br>        }<br>        G . add ( i ) ;<br>        S . add ( i ) ;<br>    }<br>    Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ;<br>    return Sum ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int lcs ( char [ ] X , char [ ] Y , int m , int n ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y , int m , int n ) {<br>    if ( m == 0 || n == 0 ) {<br>        return 0 ;<br>    }<br>    else if ( X [ m - 1 ] == Y [ n - 1 ] ) {<br>        return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;<br>    }<br>    else {<br>        return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long findMinSum ( long a [ ] , long b [ ] , long n ) {<br>  Arrays . sort ( a ) ;<br>  Arrays . sort ( b ) ;<br>  long sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMinSum ( int [ ] a , int [ ] b , int n ) {<br>    Arrays . sort ( a , b , n ) ;<br>    Arrays . sort ( a , 0 , a . length ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_YY_N_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSolutions ( int n ) {<br>  int res = 0 ;<br>  for ( int x = 0 ;<br>  x * x < n ;<br>  x ++ ) for ( int y = 0 ;<br>  x * x + y * y < n ;<br>  y ++ ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSolutions ( int n ) {<br>    int res = 0 ;<br>    int x = 0 ;<br>    while ( ( x * x < n ) && ( x * x < n ) ) {<br>        int y = 0 ;<br>        while ( ( x * x + y * y < n ) && ( x * x + y * y < n ) ) {<br>            res = res + 1 ;<br>            y = y + 1 ;<br>        }<br>        x = x + 1 ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 1 ;<br>  j < m ;<br>  j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ;<br>  for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;<br>  return ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOps ( int [ ] [ ] A , int [ ] [ ] B , int m , int n ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            A [ i ] [ j ] -= B [ i ] [ j ] ;<br>        }<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            if ( ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) && ( A [ 0 ] [ j ] - A [ 0 ] [ 1 ] - A [ 0 ] [ 2 ] + A [ 0 ] [ 3 ] != 0 ) ){<br>                return - 1 ;<br>            }<br>        }<br>    }<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        result += Math . abs ( A [ i ] [ 0 ] ) ;<br>    }<br>    for ( int j = 0 ;  j < m ;  j ++ ) {<br>        result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;<br>    }<br>    return ( result ) ;<br>}</td>
  </tr><tr>
    <th>EFFICIENTLY_FIND_FIRST_REPEATED_CHARACTER_STRING_WITHOUT_USING_ADDITIONAL_DATA_STRUCTURE_ONE_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int FirstRepeated ( String str ) {<br>  int checker = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    int val = ( str . charAt ( i ) - 'a' ) ;<br>    if ( ( checker & ( 1 << val ) ) > 0 ) return i ;<br>    checker |= ( 1 << val ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int FirstRepeated ( String string ) {<br>    checker = 0 ;<br>    pos = 0 ;<br>    for ( int i = 0 ;  i < string . length ( ) ;  i ++ ) {<br>        int val = ( int ) ( i - 'a' ) ;<br>        if ( ( ( checker & ( 1 << val ) ) > 0 ) && ( ( checker & ( 1 << val ) ) > 0 ) ) {<br>            return pos ;<br>        }<br>        checker |= ( 1 << val ) ;<br>        pos ++ ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_UNIQUE_ELEMENT_EVERY_SUBARRAY_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void find_max ( int [ ] A , int N , int K ) {<br>  HashMap < Integer , Integer > Count = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < K - 1 ;<br>  i ++ ) if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ;<br>  else Count . put ( A [ i ] , 1 ) ;<br>  TreeSet < Integer > Myset = new TreeSet < Integer > ( ) ;<br>  for ( Map . Entry x : Count . entrySet ( ) ) {<br>    if ( Integer . parseInt ( String . valueOf ( x . getValue ( ) ) ) == 1 ) Myset . add ( Integer . parseInt ( String . valueOf ( x . getKey ( ) ) ) ) ;<br>  }<br>  for ( int i = K - 1 ;<br>  i < N ;<br>  i ++ ) {<br>    if ( Count . containsKey ( A [ i ] ) ) Count . put ( A [ i ] , 1 + Count . get ( A [ i ] ) ) ;<br>    else Count . put ( A [ i ] , 1 ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( A [ i ] ) ) ) == 1 ) Myset . add ( A [ i ] ) ;<br>    else Myset . remove ( A [ i ] ) ;<br>    if ( Myset . size ( ) == 0 ) System . out . println ( "Nothing" ) ;<br>    else System . out . println ( Myset . last ( ) ) ;<br>    int x = A [ i - K + 1 ] ;<br>    Count . put ( x , Count . get ( x ) - 1 ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 1 ) Myset . add ( x ) ;<br>    if ( Integer . parseInt ( String . valueOf ( Count . get ( x ) ) ) == 0 ) Myset . remove ( x ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findMax ( int [ ] A , int N , int K ) {<br>    Map < Integer , Integer > Count = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    for ( int i = 0 ;  i < K - 1 ;  i ++ ) {<br>        Count [ A [ i ] ] = Count . get ( A [ i ] ) + 1 ;<br>    }<br>    Map < Integer , Integer > Myset = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    for ( int x = Count ;  x > 0 ;  x -- ) {<br>        if ( ( Count [ x ] == 1 ) && ( A [ x ] > 0 ) ){<br>            Myset . put ( x -> 1 ) ;<br>        }<br>    }<br>    for ( int i = K - 1 ;  i < N ;  i ++ ) {<br>        Count [ A [ i ] ] = Count . get ( A [ i ] ) + 1 ;<br>        if ( ( Count [ A [ i ] ] == 1 ) && ( Count [ A [ i ] ] == 2 ) ){<br>            Myset . put ( A [ i ] , 1 ) ;<br>        }<br>        else{<br>            System . arraycopy ( Myset . get ( A [ i ] ) , 0 , A , i , N ) ;<br>        }<br>        if ( ( Myset . length == 0 ) && ( A [ 0 ] == 0 ) ) {<br>            System . out . println ( "Nothing" ) ;<br>        }<br>        else{<br>            int maxm = - 10 * 9 ;<br>            for ( int i : Myset . values ( ) ) {<br>                maxm = Math . max ( i , maxm ) ;<br>            }<br>            System . out . println ( maxm ) ;<br>        }<br>        int x = A [ i - K + 1 ] ;<br>        if ( x < Count . keySet ( ) . length ){<br>            Count [ x ] -- ;<br>            if ( ( Count [ x ] == 1 ) && ( A [ x ] > 0 ) ){<br>                Myset . put ( x -> 1 ) ;<br>            }<br>            if ( ( Count [ x ] == 0 ) && ( A [ x ] > 0 ) ){<br>                System . arraycopy ( Myset . get ( x ) , 0 , A , 0 , x ) ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int calculateEnergy ( int mat [ ] [ ] , int n ) {<br>  int i_des , j_des , q ;<br>  int tot_energy = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      q = mat [ i ] [ j ] / n ;<br>      i_des = q ;<br>      j_des = mat [ i ] [ j ] - ( n * q ) ;<br>      tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ;<br>    }<br>  }<br>  return tot_energy ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateEnergy ( int [ ] [ ] mat , int n ) {<br>    tot_energy = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            int q = mat [ i ] [ j ] / n ;<br>            int i_des = q ;<br>            double j_des = mat [ i ] [ j ] - ( n * q ) ;<br>            tot_energy += ( Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ) ;<br>        }<br>    }<br>    return tot_energy ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) {<br>  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;<br>      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {<br>        LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ;<br>        result = Integer . max ( result , LCStuff [ i ] [ j ] ) ;<br>      }<br>      else LCStuff [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int LCSubStr ( int [ ] X , int [ ] Y , int m , int n ) {<br>    int [ ] LCSuff = new int [ n + 1 ] ;<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < m + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            if ( ( i == 0 || j == 0 ) && ( i < m && j < n ) ){<br>                LCSuff [ i ] [ j ] = 0 ;<br>            }<br>            else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) ){<br>                LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ;<br>                result = Math . max ( result , LCSuff [ i ] [ j ] ) ;<br>            }<br>            else {<br>                LCSuff [ i ] [ j ] = 0 ;<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_BITONIC_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumBitonicSubArr ( int arr [ ] , int n ) {<br>  int [ ] msis = new int [ n ] ;<br>  int [ ] msds = new int [ n ] ;<br>  int max_sum = Integer . MIN_VALUE ;<br>  msis [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ;<br>  else msis [ i ] = arr [ i ] ;<br>  msds [ n - 1 ] = arr [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ;<br>  else msds [ i ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ;<br>  return max_sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumBitonicSubArr ( int [ ] arr , int n ) {<br>    int [ ] msis = new int [ n ] ;<br>    int [ ] msds = {<br>    }<br>    int maxSum = 0 ;<br>    msis [ 0 ] = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] > arr [ i - 1 ] ) && ( arr [ i - 1 ] > arr [ n ] ) ) {<br>            msis [ i ] = msis [ i - 1 ] + arr [ i ] ;<br>        }<br>        else {<br>            msis [ i ] = arr [ i ] ;<br>        }<br>    }<br>    msds [ n - 1 ] = arr [ n - 1 ] ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( arr [ i ] > arr [ i + 1 ] ) && ( arr [ i + 1 ] < arr [ n ] ) ) {<br>            msds [ i ] = msds [ i + 1 ] + arr [ i ] ;<br>        }<br>        else {<br>            msds [ i ] = arr [ i ] ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( maxSum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) && ( maxSum > ( msis [ i ] + msds [ i ] - arr [ i ] ) ) ) {<br>            maxSum = ( msis [ i ] + msds [ i ] - arr [ i ] ) ;<br>        }<br>    }<br>    return maxSum ;<br>}</td>
  </tr><tr>
    <th>NEWMAN_CONWAY_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sequence ( int n ) {<br>  if ( n == 1 || n == 2 ) return 1 ;<br>  else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int sequence ( int n ) {<br>    if ( n == 1 || n == 2 ) {<br>        return 1 ;<br>    }<br>    }<br>        return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printAllAPTriplets ( int [ ] arr , int n ) {<br>  ArrayList < Integer > s = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int diff = arr [ j ] - arr [ i ] ;<br>      boolean exists = s . contains ( arr [ i ] - diff ) ;<br>      if ( exists ) System . out . println ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] ) ;<br>    }<br>    s . add ( arr [ i ] ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printAllAPTriplets ( int [ ] arr , int n ) {<br>    String s = new String ( ) ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int diff = arr [ j ] - arr [ i ] ;<br>            if ( ( ( arr [ i ] - diff ) < arr [ i ] ) && ( ( arr [ i ] - diff ) > arr [ i ] ) ) {<br>                System . out . println ( "{}<br>            }<br>        }<br>    }<br>    s . add ( arr [ i ] ) ;<br>}</td>
  </tr><tr>
    <th>QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countInRange ( int arr [ ] , int n , int x , int y ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countInRange ( int [ ] arr , int n , int x , int y ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] >= x && arr [ i ] <= y ) || ( arr [ i ] >= x && arr [ i ] <= y ) ) {<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>HIGHWAY_BILLBOARD_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) {<br>  int [ ] maxRev = new int [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m + 1 ;<br>  i ++ ) maxRev [ i ] = 0 ;<br>  int nxtbb = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    if ( nxtbb < n ) {<br>      if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ;<br>      else {<br>        if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ;<br>        else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;<br>        nxtbb ++ ;<br>      }<br>    }<br>    else maxRev [ i ] = maxRev [ i - 1 ] ;<br>  }<br>  return maxRev [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) {<br>    int [ ] maxRev = new int [ m + 1 ] ;<br>    nxtbb = 0 ;<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        if ( ( nxtbb < n ) && ( m < x ) && ( x < revenue ) ) {<br>            if ( ( x [ nxtbb ++ ] != i ) && ( x [ nxtbb ++ ] != j ) ){<br>                maxRev [ i ] = maxRev [ i - 1 ] ;<br>            }<br>            if ( m > 0 ) {<br>                if ( ( i <= t ) && ( i <= m ) ) {<br>                    maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ;<br>                }<br>                if ( m > 0 ) {<br>                    maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ;<br>                }<br>                nxtbb ++ ;<br>            }<br>        }<br>        if ( m > 0 ) {<br>            maxRev [ i ] = maxRev [ i - 1 ] ;<br>        }<br>    }<br>    return maxRev [ m ] ;<br>}</td>
  </tr><tr>
    <th>CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printMat ( int degseq [ ] , int n ) {<br>  int [ ] [ ] mat = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {<br>        degseq [ i ] -- ;<br>        degseq [ j ] -- ;<br>        mat [ i ] [ j ] = 1 ;<br>        mat [ j ] [ i ] = 1 ;<br>      }<br>    }<br>  }<br>  System . out . print ( "\n" + setw ( 3 ) + "     " ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" ) ;<br>  System . out . print ( "\n\n" ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( setw ( 4 ) + "(" + i + ")" ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j ] ) ;<br>    System . out . print ( "\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printMat ( int [ ] degseq , int n ) {<br>    int [ ] [ ] mat = new int [ n ] [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( degseq [ i ] > 0 && degseq [ j ] > 0 ) || ( degseq [ i ] > 0 && degseq [ j ] > 0 ) ){<br>                degseq [ i ] -- ;<br>                degseq [ j ] -- ;<br>                mat [ i ] [ j ] = 1 ;<br>                mat [ j ] [ i ] = 1 ;<br>            }<br>        }<br>    }<br>    System . out . print ( "      " ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( "" ) ;<br>    }<br>    System . out . println ( ) ;<br>    System . out . println ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( "" ) ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            System . out . println ( "     " + mat [ i ] [ j ] + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean oppositeSigns ( int x , int y ) {<br>  return ( ( x ^ y ) < 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean oppositeSigns ( int x , int y ) {<br>    return ( ( x ^ y ) < 0 ) ;<br>}</td>
  </tr><tr>
    <th>TRIANGULAR_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isTriangular ( int num ) {<br>  if ( num < 0 ) return false ;<br>  int c = ( - 2 * num ) ;<br>  int b = 1 , a = 1 ;<br>  int d = ( b * b ) - ( 4 * a * c ) ;<br>  if ( d < 0 ) return false ;<br>  float root1 = ( - b + ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  float root2 = ( - b - ( float ) Math . sqrt ( d ) ) / ( 2 * a ) ;<br>  if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ;<br>  if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isTriangular ( double num ) {<br>    if ( ( num < 0 ) || ( num > 5 ) ) {<br>        return false ;<br>    }<br>    int c = ( - 2 * num ) ;<br>    int b = 1 , a = 1 ;<br>    double d = ( b * b ) - ( 4 * a * c ) ;<br>    if ( ( d < 0 ) && ( num > 0 ) ){<br>        return false ;<br>    }<br>    root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ;<br>    double root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ;<br>    if ( ( root1 > 0 ) && Math . floor ( root1 ) == root1 ) {<br>        return true ;<br>    }<br>    if ( ( root2 > 0 ) && Math . floor ( root2 ) == root2 ) {<br>        return true ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isPowerOfFour ( int n ) {<br>  if ( n == 0 ) return 0 ;<br>  while ( n != 1 ) {<br>    if ( n % 4 != 0 ) return 0 ;<br>    n = n / 4 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfFour ( int n ) {<br>    if ( ( n == 0 ) && ( n % 2 == 0 ) ) {<br>        return false ;<br>    }<br>    while ( ( n != 1 ) && ( n % 2 == 0 ) ) {<br>        if ( ( n % 4 != 0 ) && ( n % 4 != 0 ) ) {<br>            return false ;<br>        }<br>        n = n / 4 ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>LAST_NON_ZERO_DIGIT_FACTORIAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lastNon0Digit ( int n ) {<br>  if ( n < 10 ) return dig [ n ] ;<br>  if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>}<br></td>
    <td>translated code: <br><br> static int lastNon0Digit ( int n ) {<br>    if ( ( n < 10 ) && ( n > 0 ) ) {<br>        return dig [ n ] ;<br>    }<br>    if ( ( ( ( n / 10 ) % 10 ) % 2 == 0 ) && ( ( ( n / 10 ) % 10 ) % 2 == 0 ) ){<br>        return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>    }<br>    else {<br>        return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ;<br>    }<br>    return 0 ;<br>}</td>
  </tr><tr>
    <th>SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortByPattern ( char [ ] str , char [ ] pat ) {<br>  int count [ ] = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < str . length ;<br>  i ++ ) {<br>    count [ str [ i ] - 'a' ] ++ ;<br>  }<br>  int index = 0 ;<br>  for ( int i = 0 ;<br>  i < pat . length ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < count [ pat [ i ] - 'a' ] ;<br>    j ++ ) {<br>      str [ index ++ ] = pat [ i ] ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static String sortByPattern ( String str , String pat ) {<br>    MAX_CHAR = 0 ;<br>    int [ ] count = new int [ MAX_CHAR ] ;<br>    for ( int i = 0 ;  i <= str . length ( ) ;  i ++ ) {<br>        count [ ( int ) str . charAt ( i ) - 97 ] ++ ;<br>    }<br>    int index = 0 ;<br>    str = "" ;<br>    for ( int i = 0 ;  i <= pat . length ( ) ;  i ++ ) {<br>        int j = 0 ;<br>        while ( ( j < count [ ( int ) pat . charAt ( i ) - 'a' ] ) && ( j < count [ ( int ) pat . charAt ( i ) ] ) ) {<br>            str . append ( pat [ i ] ) ;<br>            j = j + 1 ;<br>            index ++ ;<br>        }<br>    }<br>    return sortByPattern ( str , pat , null ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minimumBox ( int [ ] arr , int n ) {<br>  Queue < Integer > q = new LinkedList < > ( ) ;<br>  Arrays . sort ( arr ) ;<br>  q . add ( arr [ 0 ] ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int now = q . element ( ) ;<br>    if ( arr [ i ] >= 2 * now ) q . remove ( ) ;<br>    q . add ( arr [ i ] ) ;<br>  }<br>  return q . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minimumBox ( int [ ] arr , int n ) {<br>    Queue < Double > q = new LinkedList < Double > ( ) ;<br>    Arrays . sort ( arr ) ;<br>    q . add ( arr [ 0 ] ) ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        int now = q [ 0 ] ;<br>        if ( ( arr [ i ] >= 2 * now ) && ( arr [ i ] <= 2 * now ) ){<br>            q . popFront ( ) ;<br>        }<br>        q . add ( arr [ i ] ) ;<br>    }<br>    return q . length ;<br>}</td>
  </tr><tr>
    <th>SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binarySearch ( int arr [ ] , int low , int high , int key ) {<br>  if ( high < low ) return - 1 ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( key == arr [ mid ] ) return mid ;<br>  if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ;<br>  return binarySearch ( arr , low , ( mid - 1 ) , key ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int low , int high , int key ) {<br>    if ( ( high < low ) && ( key < arr [ 0 ] ) ) {<br>        return binarySearch ( arr , low , high , key , Integer . MIN_VALUE ) ;<br>    }<br>    int mid = ( low + high ) / 2 ;<br>    if ( ( key == arr [ ( int ) mid ] ) && ( low <= high ) ) {<br>        return mid ;<br>    }<br>    if ( ( key > arr [ ( int ) mid ] ) && ( key < arr [ low ] ) ) {<br>        return binarySearch ( arr , ( mid + 1 ) , high , key ) ;<br>    }<br>    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int i ;<br>  System . out . println ( "The repeating elements are : " ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>    else System . out . print ( Math . abs ( arr [ i ] ) + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>    System . out . println ( " The repeating elements are" + size ) ;<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        if ( ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) && ( arr [ i ] < size ) ) {<br>            arr [ Math . abs ( arr [ i ] ) ] = ( - 1 ) * arr [ Math . abs ( arr [ i ] ) ] ;<br>        }<br>        if ( size > 0 ) {<br>            System . out . print ( Math . abs ( arr [ i ] ) + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int findgroups ( int arr [ ] , int n ) {<br>  int c [ ] = new int [ ] {<br>    0 , 0 , 0 };<br>    int i ;<br>    int res = 0 ;<br>    for ( i = 0 ;<br>    i < n ;<br>    i ++ ) c [ arr [ i ] % 3 ] ++ ;<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;<br>    res += c [ 1 ] * c [ 2 ] ;<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;<br>    return res ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int findgroups ( int [ ] arr , int n ) {<br>    int [ ] c = {<br>    }<br>    int res = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        c [ arr [ i ] % 3 ] ++ ;<br>    }<br>    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;<br>    res += c [ 1 ] * c [ 2 ] ;<br>    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;<br>    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;<br>    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;<br>    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PRINT_STRING_IGNORING_ALTERNATE_OCCURRENCES_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printStringAlternate ( String str ) {<br>  int [ ] occ = new int [ 122 ] ;<br>  String s = str . toLowerCase ( ) ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    char temp = s . charAt ( i ) ;<br>    occ [ temp ] ++ ;<br>    if ( occ [ temp ] % 2 != 0 ) System . out . print ( str . charAt ( i ) ) ;<br>  }<br>  System . out . println ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printStringAlternate ( String string ) {<br>    Occ occ = new Occ ( ) ;<br>    for ( int i = 0 ;  i <= string . length ( ) ;  i ++ ) {<br>        String temp = string [ i ] . toLowerCase ( ) ;<br>        occ . put ( temp , occ . get ( temp ) + 1 ) ;<br>        if ( occ [ temp ] & 1 ){<br>            System . out . print ( string . charAt ( i ++ ) + " " ) ;<br>        }<br>    }<br>    System . out . println ( ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_DAYS_TANK_WILL_BECOME_EMPTY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minDaysToEmpty ( int C , int l ) {<br>  if ( l >= C ) return C ;<br>  double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ;<br>  return ( int ) ( Math . ceil ( eq_root ) + l ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDaysToEmpty ( int C , int l ) {<br>    if ( ( l >= C ) && ( l <= l + C ) ) {<br>        return minDaysToEmpty ( C , l , null ) ;<br>    }<br>    eqRoot = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ;<br>    return Math . ceil ( eqRoot ) + l ;<br>}</td>
  </tr><tr>
    <th>REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String reversingString ( char [ ] str , int start , int end ) {<br>  while ( start < end ) {<br>    str [ start ] ^= str [ end ] ;<br>    str [ end ] ^= str [ start ] ;<br>    str [ start ] ^= str [ end ] ;<br>    ++ start ;<br>    -- end ;<br>  }<br>  return String . valueOf ( str ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String reversingString ( String str , int start , int end ) {<br>    while ( ( start < end ) && ( str . charAt ( start ) == ' ' ) ) {<br>        str = ( str . substring ( 0 , start ) + ( char ) ( ( str . charAt ( start ) ^ str . charAt ( end ) ) + str . substring ( start + 1 ) ) ) ;<br>        str = ( str . substring ( 0 , end ) + ( char ) ( ( str . charAt ( start ) ^ str . charAt ( end ) ) + str . substring ( end + 1 ) ) ) ;<br>        str = ( str . substring ( 0 , start ) + ( char ) ( ( str . charAt ( start ) ^ str . charAt ( end ) ) + str . substring ( start + 1 ) ) ) ;<br>        start ++ ;<br>        end -- ;<br>    }<br>    return reversingString ( str , start , end , false ) ;<br>}</td>
  </tr><tr>
    <th>FREQUENCY_ELEMENT_UNSORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void countFreq ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ;<br>  SortedMap < Integer , Integer > st = new TreeMap < > ( ) ;<br>  for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) {<br>    st . put ( x . getKey ( ) , x . getValue ( ) ) ;<br>  }<br>  int cumul = 0 ;<br>  for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) {<br>    cumul += x . getValue ( ) ;<br>    System . out . println ( x . getKey ( ) + " " + cumul ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void countFreq ( int [ ] a , int n ) {<br>    HashMap hm = new HashMap ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ;<br>    }<br>    Set < Integer > st = new HashSet < Integer > ( ) ;<br>    for ( int x : hm ){<br>        st . add ( ( x , hm [ x ] ) -> hm [ x ] ) ;<br>    }<br>    long cumul = 0 ;<br>    for ( int x : Collections . list ( st ) ){<br>        cumul += x [ 1 ] ;<br>        System . out . println ( x [ 0 ] + cumul ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotations ( int arr [ ] , int n ) {<br>  int min = arr [ 0 ] , min_index = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( min > arr [ i ] ) {<br>      min = arr [ i ] ;<br>      min_index = i ;<br>    }<br>  }<br>  return min_index ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotations ( int [ ] arr , int n ) {<br>    int min = arr [ 0 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( min > arr [ i ] ) && ( max > arr [ i ] ) ) {<br>            int min = arr [ i ] ;<br>            int minIndex = i ;<br>        }<br>    }<br>    return minIndex ;<br>}</td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  int lis [ ] = new int [ n ] ;<br>  int i , j , max = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) lis [ i ] = 1 ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) for ( j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>    int n = arr . length ;<br>    lis = new int [ n ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= i ;  j ++ ) {<br>            if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) {<br>                lis [ i ] = lis [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    int maximum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        maximum = Math . max ( maximum , lis [ i ] ) ;<br>    }<br>    return maximum ;<br>}</td>
  </tr><tr>
    <th>MEDIAN_OF_TWO_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  int count ;<br>  int m1 = - 1 , m2 = - 1 ;<br>  for ( count = 0 ;<br>  count <= n ;<br>  count ++ ) {<br>    if ( i == n ) {<br>      m1 = m2 ;<br>      m2 = ar2 [ 0 ] ;<br>      break ;<br>    }<br>    else if ( j == n ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ 0 ] ;<br>      break ;<br>    }<br>    if ( ar1 [ i ] < ar2 [ j ] ) {<br>      m1 = m2 ;<br>      m2 = ar1 [ i ] ;<br>      i ++ ;<br>    }<br>    else {<br>      m1 = m2 ;<br>      m2 = ar2 [ j ] ;<br>      j ++ ;<br>    }<br>  }<br>  return ( m1 + m2 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMedian ( int [ ] ar1 , int [ ] ar2 , int n ) {<br>    int i = 0 ;<br>    int j = 0 ;<br>    int m1 = - 1 ;<br>    int m2 = - 1 ;<br>    int count = 0 ;<br>    while ( count < n + 1 ) {<br>        count ++ ;<br>        if ( i == n ) {<br>            int m1 = m2 ;<br>            int m2 = ar2 [ 0 ] ;<br>            break ;<br>        }<br>        else if ( j == n ){<br>            int m1 = m2 ;<br>            int m2 = ar1 [ 0 ] ;<br>            break ;<br>        }<br>        if ( ar1 [ i ] < ar2 [ j ] ){<br>            int m1 = m2 ;<br>            int m2 = ar1 [ i ] ;<br>            i ++ ;<br>        }<br>        else {<br>            int m1 = m2 ;<br>            int m2 = ar2 [ j ] ;<br>            j ++ ;<br>        }<br>    }<br>    return ( m1 + m2 ) / 2 ;<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String minLexRotation ( String str ) {<br>  int n = str . length ( ) ;<br>  String arr [ ] = new String [ n ] ;<br>  String concat = str + str ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = concat . substring ( i , i + n ) ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  return arr [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] minLexRotation ( String str_ ) {<br>    int n = str_ . length ( ) ;<br>    int [ ] arr = {<br>    }<br>    String concat = str_ + str_ ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = concat ( i , n + i ) ;<br>    }<br>    arr . sort ( ) ;<br>    return arr [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>INTERPOLATION_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int interpolationSearch ( int x ) {<br>  int lo = 0 , hi = ( arr . length - 1 ) ;<br>  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {<br>    if ( lo == hi ) {<br>      if ( arr [ lo ] == x ) return lo ;<br>      return - 1 ;<br>    }<br>    int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ;<br>    if ( arr [ pos ] == x ) return pos ;<br>    if ( arr [ pos ] < x ) lo = pos + 1 ;<br>    else hi = pos - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int interpolationSearch ( int [ ] arr , int n , int x ) {<br>    int lo = 0 ;<br>    int hi = ( n - 1 ) ;<br>    while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ){<br>        if ( lo == hi ){<br>            if ( arr [ lo ] == x ){<br>                return lo ;<br>            }<br>            return - 1 ;<br>        }<br>        int pos = lo + ( int ) ( ( ( ( double ) hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ;<br>        if ( arr [ pos ] == x ) {<br>            return pos ;<br>        }<br>        if ( arr [ pos ] < x ){<br>            int lo = pos + 1 ;<br>        }<br>        else {<br>            int hi = pos - 1 ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>  int count = 0 ;<br>  int l = 0 , r = n - 1 ;<br>  while ( l < m && r >= 0 ) {<br>    if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) {<br>      l ++ ;<br>      r -- ;<br>      count ++ ;<br>    }<br>    else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ;<br>    else r -- ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) {<br>    int count = 0 , l = 0 , r = n - 1 ;<br>    while ( ( l < m && r >= 0 ) || ( l < n && r >= 0 ) ){<br>        if ( ( ( arr1 [ l ] + arr2 [ r ] ) == x ) && ( ( arr1 [ l ] + arr2 [ r ] ) == x ) ) {<br>            l ++ ;<br>            r -- ;<br>            count ++ ;<br>        }<br>        else if ( ( ( arr1 [ l ] + arr2 [ r ] ) < x ) && ( ( arr1 [ l ] + arr2 [ r ] ) > x ) ){<br>            l ++ ;<br>        }<br>        else {<br>            r -- ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBSETS_DISTINCT_EVEN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubsets ( int arr [ ] , int n ) {<br>  HashSet < Integer > us = new HashSet < > ( ) ;<br>  int even_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr [ i ] % 2 == 0 ) us . add ( arr [ i ] ) ;<br>  even_count = us . size ( ) ;<br>  return ( int ) ( Math . pow ( 2 , even_count ) - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubSets ( int [ ] arr , int n ) {<br>    Set us = new HashSet ( ) ;<br>    evenCount = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] % 2 == 0 ) {<br>            us . add ( arr [ i ] ) ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < us . length ;  i ++ ) {<br>        evenCount ++ ;<br>    }<br>    return Math . pow ( 2 , evenCount ) - 1 ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOccurrences ( int arr [ ] , int n , int x ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( x == arr [ i ] ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOccurrences ( int [ ] arr , int n , int x ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( x == arr [ i ] ) {<br>            res ++ ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>CONSTRUCT_THE_ROOTED_TREE_BY_USING_START_AND_FINISH_TIME_OF_ITS_DFS_TRAVERSAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int [ ] Restore_Tree ( int [ ] S , int [ ] End ) {<br>  int [ ] Identity = new int [ N ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) Identity [ S [ i ] ] = i ;<br>  int [ ] parent = new int [ N ] ;<br>  Arrays . fill ( parent , - 1 ) ;<br>  int curr_parent = Identity [ 0 ] ;<br>  for ( int j = 1 ;<br>  j < N ;<br>  j ++ ) {<br>    int child = Identity [ j ] ;<br>    if ( End [ child ] - j > 1 ) {<br>      parent [ child ] = curr_parent ;<br>      curr_parent = child ;<br>    }<br>    else {<br>      parent [ child ] = curr_parent ;<br>      while ( parent [ child ] > - 1 && End [ child ] == End [ parent [ child ] ] ) {<br>        child = parent [ child ] ;<br>        curr_parent = parent [ child ] ;<br>        if ( curr_parent == Identity [ 0 ] ) break ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) parent [ i ] += 1 ;<br>  return parent ;<br>}<br></td>
    <td>translated code: <br><br> public static int Restore_Tree ( int S , int E ) {<br>    Identity = N * new int [ 0 ] ;<br>    for ( int i = 0 ;  i < N ;{<br>        Identity [ Start [ i ] ] = i ;<br>    }<br>    parent = N * new int [ N - 1 ] ;<br>    currParent = Identity [ 0 ] ;<br>    for ( int j = 1 ;  j <= N ;  j ++ ) {<br>        child = Identity [ j ++ ] ;<br>        if ( End [ child ] - j > 1 ){<br>            parent [ child ] = currParent ;<br>            curr_parent = child ;<br>        }<br>        else{<br>            parent [ child ] = currParent ;<br>            while ( End [ child ] == End [ parent [ child ] ] ){<br>                child = parent . get ( child ) ;<br>                curr_parent = parent [ child ] ;<br>                if ( currParent == Identity [ 0 ] ){<br>                    break ;<br>                }<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < N ;{<br>        parent [ i ] ++ ;<br>    }<br>    return parent ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countOccurrences ( String s , int K ) {<br>  int n = s . length ( ) ;<br>  int C = 0 , c1 = 0 , c2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == 'a' ) c1 ++ ;<br>    if ( s . charAt ( i ) == 'b' ) {<br>      c2 ++ ;<br>      C += c1 ;<br>    }<br>  }<br>  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countOccurrences ( String s , int K ) {<br>    int n = s . length ( ) ;<br>    int c1 = 0 ;<br>    int c2 = 0 ;<br>    int C = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( s . charAt ( i ++ ) == 'a' ) {<br>            c1 ++ ;<br>        }<br>        if ( s . charAt ( i ++ ) == 'b' ) {<br>            c2 ++ ;<br>            C += c1 ;<br>        }<br>    }<br>    return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countNonEmptySubstr ( String str ) {<br>  int n = str . length ( ) ;<br>  return n * ( n + 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countNonEmptySubstr ( String str ) {<br>    int n = str . length ( ) ;<br>    return ( int ) ( n * ( n + 1 ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_CHARACTERS_TWO_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumChars ( String str ) {<br>  int n = str . length ( ) ;<br>  int res = - 1 ;<br>  int [ ] firstInd = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) firstInd [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int first_ind = firstInd [ str . charAt ( i ) ] ;<br>    if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ;<br>    else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumChars ( String str1 ) {<br>    int n = str1 . length ( ) ;<br>    int res = - 1 ;<br>    int [ ] firstInd = new int [ MAX_CHAR ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int firstInd = firstInd [ ( int ) str1 . charAt ( i ) ] ;<br>        if ( ( first_ind == - 1 ) && ( str1 . length ( ) > 0 ) ) {<br>            firstInd [ ( int ) str1 . charAt ( i ) ] = i ;<br>        }<br>        else {<br>            int res = Math . max ( res , Math . abs ( i - firstInd - 1 ) ) ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>SUM_SQUARES_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumofsquare ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  int i , j ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j <= min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumofsquare ( int n ) {<br>    int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= Math . min ( i , n ) ;  j ++ ) {<br>            if ( ( j == 0 || j == i ) && ( n == 0 || n == i ) ){<br>                C [ i ] [ j ] = 1 ;<br>            }<br>            else {<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSubsequences ( String s ) {<br>  char [ ] str = s . toCharArray ( ) ;<br>  int n = str . length ;<br>  int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ;<br>  for ( int counter = 0 ;<br>  counter < opsize ;<br>  counter ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      System . out . print ( str [ j ] ) ;<br>      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " " ) ;<br>    }<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSubsequences ( String str ) {<br>    int n = str . length ( ) ;<br>    int opsize = ( int ) Math . pow ( 2 , n - 1 ) ;<br>    for ( int counter = 0 ;  counter < opsize ;  counter ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            System . out . print ( str . charAt ( j ) + " " ) ;<br>            if ( ( counter & ( 1 << j ) ) != 0 ){<br>                System . out . println ( "" + str ) ;<br>            }<br>        }<br>        System . out . print ( "\n" + str ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>NON_REPEATING_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int firstNonRepeating ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;<br>    if ( j == n ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int firstNonRepeating ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int j = 0 ;<br>        while ( ( j < n ) && ( j < arr . length ) ) {<br>            if ( ( i != j && arr [ i ] == arr [ j ] ) || ( i == j && arr [ i ] == arr [ j ] ) ) {<br>                break ;<br>            }<br>            j ++ ;<br>        }<br>        if ( ( j == n ) && ( j == 0 ) ) {<br>            return arr [ i ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long calculateSum ( int n ) {<br>  long sum = 0 ;<br>  for ( int row = 0 ;<br>  row < n ;<br>  row ++ ) {<br>    sum = sum + ( 1 << row ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculateSum ( int n ) {<br>    int sum = 0 ;<br>    for ( int row = 0 ;  row < n ;  row ++ ) {<br>        sum = sum + ( 1 << row ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>CHECK_TWO_STRINGS_K_ANAGRAMS_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean arekAnagrams ( String str1 , String str2 , int k ) {<br>  int n = str1 . length ( ) ;<br>  if ( str2 . length ( ) != n ) return false ;<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ;<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ;<br>  return ( count <= k ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean arekAnagrams ( String str1 , String str2 , int k ) {<br>    int n = str1 . length ( ) ;<br>    if ( ( str2 . length ( ) != n ) && ( str2 . length ( ) != k ) ) {<br>        return false ;<br>    }<br>    int [ ] count1 = new int [ MAX_CHAR ] ;<br>    int count2 [ ] = {<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        count1 [ ( int ) str1 . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        count2 [ ( int ) str2 . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        if ( ( count1 [ i ] > count2 [ i ] ) && ( count2 [ i ] > count1 [ i ] ) ) {<br>            count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ;<br>        }<br>    }<br>    return ( count <= k ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestCommonSum ( int n ) {<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int sum1 = 0 , sum2 = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      sum1 += arr1 [ j ] ;<br>      sum2 += arr2 [ j ] ;<br>      if ( sum1 == sum2 ) {<br>        int len = j - i + 1 ;<br>        if ( len > maxLen ) maxLen = len ;<br>      }<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestCommonSum ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>    int maxLen = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int sum1 = 0 ;<br>        int sum2 = 0 ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            sum1 += arr1 [ j ] ;<br>            sum2 += arr2 [ j ] ;<br>            if ( ( sum1 == sum2 ) && ( n > 0 ) ) {<br>                int len = j - i + 1 ;<br>                if ( ( int ) arr1 . length > maxLen ) {<br>                    int maxLen = arr1 . length ;<br>                }<br>            }<br>        }<br>    }<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>REMAINDER_7_LARGE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int remainderWith7 ( String num ) {<br>  int series [ ] = {<br>    1 , 3 , 2 , - 1 , - 3 , - 2 };<br>    int series_index = 0 ;<br>    int result = 0 ;<br>    for ( int i = num . length ( ) - 1 ;<br>    i >= 0 ;<br>    i -- ) {<br>      int digit = num . charAt ( i ) - '0' ;<br>      result += digit * series [ series_index ] ;<br>      series_index = ( series_index + 1 ) % 6 ;<br>      result %= 7 ;<br>    }<br>    if ( result < 0 ) result = ( result + 7 ) % 7 ;<br>    return result ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int remainderWith7 ( String num ) {<br>    int [ ] series = {<br>    }<br>    int seriesIndex = 0 ;<br>    int result = 0 ;<br>    for ( int i = ( num . length - 1 ) ;  i >= 0 ;  i -- ) {<br>        int digit = ( int ) num [ i ++ ] - 48 ;<br>        result += digit * series [ seriesIndex ] ;<br>        seriesIndex = ( seriesIndex + 1 ) % 6 ;<br>        result %= 7 ;<br>    }<br>    if ( ( result < 0 ) && ( num > 0 ) ) {<br>        result = ( result + 7 ) % 7 ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean prevPermutation ( char [ ] str ) {<br>  int n = str . length - 1 ;<br>  int i = n ;<br>  while ( i > 0 && str [ i - 1 ] <= str [ i ] ) {<br>    i -- ;<br>  }<br>  if ( i <= 0 ) {<br>    return false ;<br>  }<br>  int j = i - 1 ;<br>  while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) {<br>    j ++ ;<br>  }<br>  swap ( str , i - 1 , j ) ;<br>  StringBuilder sb = new StringBuilder ( String . valueOf ( str ) ) ;<br>  sb . reverse ( ) ;<br>  str = sb . toString ( ) . toCharArray ( ) ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean prevPermutation ( String str ) {<br>    int n = str . length ( ) - 1 ;<br>    int i = n ;<br>    while ( ( i > 0 ) && str . charAt ( i - 1 ) <= str . charAt ( i ) ) {<br>        i -- ;<br>    }<br>    if ( ( i <= 0 ) && ( i < 5 ) ){<br>        return false ;<br>    }<br>    int j = i - 1 ;<br>    while ( ( j + 1 <= n && str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) || ( j + 1 <= n && str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) ){<br>        j ++ ;<br>    }<br>    str = Arrays . asList ( str ) ;<br>    String temp = str . charAt ( i - 1 ) ;<br>    str . charAt ( i - 1 ) = str . charAt ( j ) ;<br>    str . charAt ( j ++ ) = temp ;<br>    str = "" ;<br>    str . substring ( 0 , str . length ( ) - 1 ) ;<br>    return true ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_FORM_AI_BJ_CK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubsequences ( String s ) {<br>  int aCount = 0 ;<br>  int bCount = 0 ;<br>  int cCount = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ;<br>    else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ;<br>    else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ;<br>  }<br>  return cCount ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubsequences ( String s ) {<br>    aCount = 0 ;<br>    bCount = 0 ;<br>    int cCount = 0 ;<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == 'a' ) && ( s . charAt ( i + 1 ) == 'a' ) ) {<br>            aCount = ( 1 + 2 * aCount ) ;<br>        }<br>        else if ( ( s . charAt ( i ) == 'b' ) && ( s . charAt ( i + 1 ) == 'c' ) ) {<br>            bCount = ( aCount + 2 * bCount ) ;<br>        }<br>        else if ( ( s . charAt ( i ) == 'c' ) && ( s . charAt ( i + 1 ) == 'a' ) ) {<br>            cCount = ( bCount + 2 * cCount ) ;<br>        }<br>    }<br>    return cCount ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_PRINT_IDENTITY_MATRIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isIdentity ( int mat [ ] [ ] , int N ) {<br>  for ( int row = 0 ;<br>  row < N ;<br>  row ++ ) {<br>    for ( int col = 0 ;<br>    col < N ;<br>    col ++ ) {<br>      if ( row == col && mat [ row ] [ col ] != 1 ) return false ;<br>      else if ( row != col && mat [ row ] [ col ] != 0 ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isIdentity ( int [ ] [ ] mat , int N ) {<br>    for ( int row = 0 ;  row < N ;  row ++ ) {<br>        for ( int col = 0 ;  col < N ;  col ++ ) {<br>            if ( ( row == col && mat [ row ] [ col ] != 1 ) || ( row == col && mat [ row ] [ col ] == 0 ) ){<br>                return false ;<br>            }<br>            else if ( ( row != col && mat [ row ] [ col ] != 0 ) || ( col != row && mat [ col ] [ row ] != 0 ) ){<br>                return false ;<br>            }<br>        }<br>    }<br>    return isIdentity ( mat , N , 0 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDiff ( int [ ] arr , int n ) {<br>  int result = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ;<br>    else i ++ ;<br>  }<br>  if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDiff ( int [ ] arr , int n ) {<br>    int result = 0 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        if ( ( Math . abs ( arr [ i ] ) != Math . abs ( arr [ i + 1 ] ) ) && ( n - i ) > 0 ) {<br>            result += Math . abs ( arr [ i ] ) ;<br>        }<br>        if ( n > 0 ) {<br>            }<br>        }<br>    }<br>    if ( ( arr [ n - 2 ] != arr [ n - 1 ] ) && ( arr [ n - 1 ] != arr [ n - 2 ] ) ) {<br>        result += Math . abs ( arr [ n - 1 ] ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_PRINT_SUM_GIVEN_NTH_TERM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int summingSeries ( long n ) {<br>  int S = 0 ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) S += i * i - ( i - 1 ) * ( i - 1 ) ;<br>  return S ;<br>}<br></td>
    <td>translated code: <br><br> public static long summingSeries ( int n ) {<br>    int S = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        S += i * i - ( i - 1 ) * ( i - 1 ) ;<br>    }<br>    return S ;<br>}</td>
  </tr><tr>
    <th>PREFIX_SUM_2D_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void prefixSum2D ( int a [ ] [ ] ) {<br>  int R = a . length ;<br>  int C = a [ 0 ] . length ;<br>  int psa [ ] [ ] = new int [ R ] [ C ] ;<br>  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < C ;<br>  i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ;<br>  for ( int i = 1 ;<br>  i < R ;<br>  i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < R ;<br>  i ++ ) for ( int j = 1 ;<br>  j < C ;<br>  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void prefixSum2D ( int [ ] [ ] a ) {<br>    C = a [ 0 ] ;<br>    int [ ] psa = new int [ C ] ;<br>    psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;<br>    for ( int i = 1 ;  i <= C ;  i ++ ) {<br>        psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) ;<br>    }<br>    for ( int i = 0 ;  i <= R ;{<br>        psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) ;<br>    }<br>    for ( int i = 1 ;  i <= R ;  i ++ ) {<br>        for ( int j = 1 ;  j <= C ;  j ++ ) {<br>            psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= R ;{<br>        for ( int j = 0 ;  j <= C ;  j ++ ) {<br>            System . out . print ( psa [ i ] [ j ] + " " ) ;<br>        }<br>        System . out . println ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_2X2_SQUARES_CAN_FIT_INSIDE_RIGHT_ISOSCELES_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int numberOfSquares ( int base ) {<br>  base = ( base - 2 ) ;<br>  base = base / 2 ;<br>  return base * ( base + 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfSquares ( int base ) {<br>    base = ( base - 2 ) ;<br>    base = base / 2 ;<br>    return base * ( base + 1 ) / 2 ;<br>}</td>
  </tr><tr>
    <th>GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countSubStr ( char str [ ] , int n ) {<br>  int m = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( str [ i ] == '1' ) m ++ ;<br>  }<br>  return m * ( m - 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubStr ( String st , int n ) {<br>    int m = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( st . charAt ( i ++ ) == '1' ) && ( st . charAt ( i ++ ) == '2' ) ) {<br>            m = m + 1 ;<br>        }<br>    }<br>    return m * ( m - 1 ) / 2 ;<br>}</td>
  </tr><tr>
    <th>CONVERTING_ONE_STRING_USING_APPEND_DELETE_LAST_OPERATIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isConvertible ( String str1 , String str2 , int k ) {<br>  if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ;<br>  int commonLength = 0 ;<br>  for ( int i = 0 ;<br>  i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ;<br>  i ++ ) {<br>    if ( str1 == str2 ) commonLength ++ ;<br>    else break ;<br>  }<br>  if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isConvertible ( String str1 , String str2 , int k ) {<br>    if ( ( ( str1 . length ( ) + str2 . length ( ) ) < k ) && ( ( str1 . length ( ) + str2 . length ( ) ) < k ) ) {<br>        return isConvertible ( str1 , str2 , k , null ) ;<br>    }<br>    int commonLength = 0 ;<br>    for ( int i = 0 ;  i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ;  i ++ ) {<br>        if ( ( str1 . charAt ( i ) == str2 . charAt ( i ) ) && ( str1 . charAt ( i + 1 ) == str2 . charAt ( i + 1 ) ) ) {<br>            commonLength ++ ;<br>        }<br>        else {<br>            break ;<br>        }<br>    }<br>    if ( ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) && ( ( k - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) ) {<br>        return isConvertible ( str1 , str2 , k , null ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int getOddOccurrence ( int ar [ ] , int ar_size ) {<br>  int i ;<br>  int res = 0 ;<br>  for ( i = 0 ;<br>  i < ar_size ;<br>  i ++ ) {<br>    res = res ^ ar [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getOddOccurrence ( int [ ] arr ) {<br>    int res = 0 ;<br>    for ( int element : arr ) {<br>        int res = arr [ 0 ] ^ element ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>SUM_MIDDLE_ROW_COLUMN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void middlesum ( int mat [ ] [ ] , int n ) {<br>  int row_sum = 0 , col_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) row_sum += mat [ n / 2 ] [ i ] ;<br>  System . out . println ( "Sum of middle row = " + row_sum ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) col_sum += mat [ i ] [ n / 2 ] ;<br>  System . out . println ( "Sum of middle column = " + col_sum ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void middlesum ( int [ ] [ ] mat , int n ) {<br>    int rowSum = 0 ;<br>    int colSum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        rowSum += mat [ n / 2 ] [ i ] ;<br>    }<br>    System . out . println ( "Sum of middle row = " + rowSum ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        colSum += mat [ i ] [ n / 2 ] ;<br>    }<br>    System . out . println ( "Sum of middle column = " + colSum ) ;<br>}</td>
  </tr><tr>
    <th>K_TH_DISTINCT_OR_NON_REPEATING_ELEMENT_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int printKDistinct ( int arr [ ] , int n , int k ) {<br>  int dist_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < n ;<br>    j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ;<br>    if ( j == n ) dist_count ++ ;<br>    if ( dist_count == k ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int printKDistinct ( int [ ] arr , int n , int k ) {<br>    distCount = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int j = 0 ;<br>        while ( j < n ) {<br>            if ( ( i != j && arr [ j ] == arr [ i ] ) || ( i == j && arr [ i ] == arr [ j ] ) ) {<br>                break ;<br>            }<br>            j ++ ;<br>        }<br>        if ( ( j == n ) && ( k == n ) ) {<br>            distCount ++ ;<br>        }<br>        if ( ( distCount == k ) && ( n > 0 ) ) {<br>            return arr [ i ++ ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>MERGING_INTERVALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void mergeIntervals ( Interval arr [ ] ) {<br>  Arrays . sort ( arr , new Comparator < Interval > ( ) {<br>    public int compare ( Interval i1 , Interval i2 ) {<br>      return i2 . start - i1 . start ;<br>    }<br>  }<br>  ) ;<br>  int index = 0 ;<br>  for ( int i = 1 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    if ( arr [ index ] . end >= arr [ i ] . start ) {<br>      arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ;<br>      arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ;<br>    }<br>    else {<br>      arr [ index ] = arr [ i ] ;<br>      index ++ ;<br>    }<br>  }<br>  System . out . print ( "The Merged Intervals are: " ) ;<br>  for ( int i = 0 ;<br>  i <= index ;<br>  i ++ ) {<br>    System . out . print ( "[" + arr [ i ] . start + "," + arr [ i ] . end + "]" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void mergeIntervals ( int [ ] arr ) {<br>    Arrays . sort ( arr , new Comparator < Interval > ( ) {<br>    }<br>    int [ ] m = new int [ arr . length ] ;<br>    int s = - 10000 ;<br>    int max = - 100000 ;<br>    for ( int i = 0 ;  i < arr . length ;  i ++ ) {<br>        int [ ] a = new int [ arr . length ] ;<br>        if ( a [ 0 ] > max ) a [ 0 ] = 5 ;<br>            if ( i != 0 ) {<br>                m . add ( new Interval ( s , max ) ) ;<br>            }<br>            int max = a [ 1 ] ;<br>            int s = a [ 0 ] ;<br>        else {<br>            if ( a [ 1 ] >= max ) a [ 1 ] = 5 ;<br>                int max = a [ 1 ] ;<br>        }<br>    }<br>    if ( max != - 100000 && new Integer ( s ) != m ) {<br>        m . add ( new Interval ( s , max ) ) ;<br>    }<br>    System . out . print ( "The Merged Intervals are: " + ", " ) ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        System . out . print ( m [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> double countSquares ( int a , int b ) {<br>  return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountSquares ( double a , double b ) {<br>    return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void findFibSubset ( Integer [ ] x ) {<br>  Integer max = Collections . max ( Arrays . asList ( x ) ) ;<br>  List < Integer > fib = new ArrayList < Integer > ( ) ;<br>  List < Integer > result = new ArrayList < Integer > ( ) ;<br>  Integer a = 0 ;<br>  Integer b = 1 ;<br>  while ( b < max ) {<br>    Integer c = a + b ;<br>    a = b ;<br>    b = c ;<br>    fib . add ( c ) ;<br>  }<br>  for ( Integer i = 0 ;<br>  i < x . length ;<br>  i ++ ) {<br>    if ( fib . contains ( x [ i ] ) ) {<br>      result . add ( x [ i ] ) ;<br>    }<br>  }<br>  System . out . println ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findFibSubset ( int [ ] arr , int n ) {<br>    int m = Math . max ( arr ) ;<br>    int a = 0 ;<br>    int b = 1 ;<br>    int [ ] hash = new int [ n ] ;<br>    hash . add ( a -> {<br>    }<br>    hash . add ( b ) ;<br>    while ( ( b < m ) && ( b < n ) ) {<br>        int c = a + b ;<br>        int a = b ;<br>        int b = c ;<br>        hash . add ( b ) ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == hash ) {<br>            System . out . print ( arr [ i ] + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String lexicographicSubConcat ( String s ) {<br>  int n = s . length ( ) ;<br>  int sub_count = n * ( n + 1 ) / 2 ;<br>  String [ ] arr = new String [ sub_count ] ;<br>  int index = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int len = 1 ;<br>  len <= n - i ;<br>  len ++ ) {<br>    arr [ index ++ ] = s . substring ( i , i + len ) ;<br>  }<br>  Arrays . sort ( arr ) ;<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < sub_count ;<br>  i ++ ) res += arr [ i ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String lexicographicSubConcat ( String s ) {<br>    int n = cs . length ( ) ;<br>    int subCount = ( n * ( n + 1 ) ) / 2 ;<br>    int [ ] arr = new int [ subCount ] ;<br>    int index = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n - i ;  j ++ ) {<br>            arr [ index ++ ] = s . substring ( i , i + j ) ;<br>            index ++ ;<br>        }<br>    }<br>    arr . sort ( ) ;<br>    String res = "" ;<br>    for ( int i = 0 ;  i < subCount ;  i ++ ) {<br>        res += arr [ i ++ ] ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>COUNT_OPERATIONS_MAKE_STRINGAB_FREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int abFree ( char [ ] s ) {<br>  int b_count = 0 ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ;<br>  i ++ ) {<br>    if ( s [ s . length - i - 1 ] == 'a' ) {<br>      res = ( res + b_count ) ;<br>      b_count = ( b_count * 2 ) ;<br>    }<br>    else {<br>      b_count += 1 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int abFree ( String s ) {<br>    b_count = 0 ;<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( s . charAt ( ~ i ) == 'a' ){<br>            res = ( res + b_count ) ;<br>            bCount = ( bCount * 2 ) ;<br>        }<br>        }<br>            b_count ++ ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaximumHeight ( int a [ ] , int n ) {<br>  return ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int MaximumHeight ( int a , int n ) {<br>    return ( - 1 + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxvolume ( int s ) {<br>  int maxvalue = 0 ;<br>  for ( int i = 1 ;<br>  i <= s - 2 ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= s - 1 ;<br>    j ++ ) {<br>      int k = s - i - j ;<br>      maxvalue = Math . max ( maxvalue , i * j * k ) ;<br>    }<br>  }<br>  return maxvalue ;<br>}<br></td>
    <td>translated code: <br><br> public static double maxvolume ( int s ) {<br>    maxvalue = 0 ;<br>    int i = 1 ;<br>    for ( int i = 0 ;  i < s - 1 ;  i ++ ) {<br>        j = 1 ;<br>        for ( int j = 0 ;  j < s ;  j ++ ) {<br>            int k = s - i - j ;<br>            maxvalue = Math . max ( maxvalue , i * j * k ) ;<br>        }<br>    }<br>    return maxvalue ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void decToHexa ( int n ) {<br>  char [ ] hexaDeciNum = new char [ 100 ] ;<br>  int i = 0 ;<br>  while ( n != 0 ) {<br>    int temp = 0 ;<br>    temp = n % 16 ;<br>    if ( temp < 10 ) {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;<br>      i ++ ;<br>    }<br>    else {<br>      hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;<br>      i ++ ;<br>    }<br>    n = n / 16 ;<br>  }<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) System . out . print ( hexaDeciNum [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void decToHexa ( int n ) {<br>    hexaDeciNum = new char [ n ] ;<br>    int i ;<br>    while ( ( n != 0 ) && ( n != 1 ) ) {<br>        int temp = 0 ;<br>        int temp = n % 16 ;<br>        if ( ( temp < 10 ) && ( temp > 0 ) ) {<br>            hexaDeciNum [ i ++ ] = ( char ) ( temp + 48 ) ;<br>            i = i + 1 ;<br>        }<br>        if ( n > 0 ) {<br>            hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;<br>            i = i + 1 ;<br>        }<br>        n = ( long ) ( n / 16 ) ;<br>    }<br>    int j = i - 1 ;<br>    while ( ( j >= 0 ) && ( j < n ) ) {<br>        System . out . print ( ( hexaDeciNum [ j ] ) + " " ) ;<br>        j = j - 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void smallestSubsegment ( int a [ ] , int n ) {<br>  HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ;<br>  HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>  int mx = 0 ;<br>  int mn = - 1 , strindex = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int x = a [ i ] ;<br>    if ( count . get ( x ) == null ) {<br>      left . put ( x , i ) ;<br>      count . put ( x , 1 ) ;<br>    }<br>    else count . put ( x , count . get ( x ) + 1 ) ;<br>    if ( count . get ( x ) > mx ) {<br>      mx = count . get ( x ) ;<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>    else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) {<br>      mn = i - left . get ( x ) + 1 ;<br>      strindex = left . get ( x ) ;<br>    }<br>  }<br>  for ( int i = strindex ;<br>  i < strindex + mn ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void smallestSubsegment ( int [ ] a , int n ) {<br>    Map < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ;<br>    Map < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>    int mx = 0 ;<br>    int mn = 0 , strindex = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int x = a [ i ++ ] ;<br>        if ( ( x != 0 ) && ( x < n ) ){<br>            left [ x ] = i ;<br>            count [ x ] = 1 ;<br>        }<br>        else{<br>            count [ x ] ++ ;<br>        }<br>        if ( ( count [ x ] > mx ) && ( count [ x ] > n ) ){<br>            int mx = count [ x ] ;<br>            int mn = i - left [ x ] + 1 ;<br>            int strindex = left [ x ] ;<br>        }<br>        else if ( ( count [ x ] == mx && i - left [ x ] + 1 < mn ) || ( count [ x ] == mx && i - left [ x ] + 1 < mn ) ){<br>            int mn = i - left [ x ] + 1 ;<br>            int strindex = left [ x ] ;<br>        }<br>    }<br>    for ( int i = strindex ;  i < strindex + mn ;{<br>        System . out . print ( a [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_LAST_INDEX_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLastIndex ( String str , Character x ) {<br>  for ( int i = str . length ( ) - 1 ;<br>  i >= 0 ;<br>  i -- ) if ( str . charAt ( i ) == x ) return i ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLastIndex ( String str , char x ) {<br>    for ( int i = str . length ( ) - 1 ;  i >= 0 ;  i -- ) {<br>        if ( ( str . charAt ( i ++ ) == x ) && ( str . charAt ( i ) == x ) ) {<br>            return i ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>RECAMANS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void recaman ( int n ) {<br>  int arr [ ] = new int [ n ] ;<br>  arr [ 0 ] = 0 ;<br>  System . out . print ( arr [ 0 ] + " ," ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr = arr [ i - 1 ] - i ;<br>    int j ;<br>    for ( j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ j ] == curr ) || curr < 0 ) {<br>        curr = arr [ i - 1 ] + i ;<br>        break ;<br>      }<br>    }<br>    arr [ i ] = curr ;<br>    System . out . print ( arr [ i ] + ", " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void recaman ( int n ) {<br>    int [ ] arr = {<br>    }<br>    arr [ 0 ] = 0 ;<br>    System . out . print ( arr [ 0 ] + ", " ) ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        curr = arr [ i - 1 ] - i ;<br>        for ( int j = 0 ;  j <= i ;  j ++ ) {<br>            if ( ( ( arr [ j ] == curr ) || curr < 0 ) && ( ( arr [ j ] == 0 ) || ( arr [ j ] == 1 ) || ( arr [ j ] == 2 ) || ( arr [ j ] == 3 ) || ( arr [ j ] == 4 ) || ( arr [ j ] == 5 ) ) ) {<br>                curr = arr [ i - 1 ] + i ;<br>                break ;<br>            }<br>        }<br>        arr [ i ++ ] = curr ;<br>        System . out . print ( arr [ i ] + ", " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char getSecondMostFreq ( String str ) {<br>  int [ ] count = new int [ NO_OF_CHARS ] ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) ( count [ str . charAt ( i ) ] ) ++ ;<br>  int first = 0 , second = 0 ;<br>  for ( i = 0 ;<br>  i < NO_OF_CHARS ;<br>  i ++ ) {<br>    if ( count [ i ] > count [ first ] ) {<br>      second = first ;<br>      first = i ;<br>    }<br>    else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ;<br>  }<br>  return ( char ) second ;<br>}<br></td>
    <td>translated code: <br><br> public static char getSecondMostFreq ( String str ) {<br>    final int NO_OF_CHARS = 256 ;<br>    int [ ] count = new int [ NO_OF_CHARS ] ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        count [ ( int ) str . charAt ( i ) ] ++ ;<br>    }<br>    int first = 0 , second = 0 ;<br>    for ( int i = 0 ;  i < NO_OF_CHARS ;  i ++ ) {<br>        if ( count [ i ] > count [ first ] ){<br>            second = first ;<br>            first = i ;<br>        }<br>        if ( ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) || ( count [ i ] > count [ first ] && count [ i ] != count [ second ] ) ) {<br>            second = i ;<br>        }<br>    }<br>    return ( char ) second ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_HEIGHT_PYRAMID_FROM_THE_GIVEN_ARRAY_OF_OBJECTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLevel ( int [ ] boxes , int n ) {<br>  Arrays . sort ( boxes ) ;<br>  int ans = 1 ;<br>  int prev_width = boxes [ 0 ] ;<br>  int prev_count = 1 ;<br>  int curr_count = 0 ;<br>  int curr_width = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_width += boxes [ i ] ;<br>    curr_count += 1 ;<br>    if ( curr_width > prev_width && curr_count > prev_count ) {<br>      prev_width = curr_width ;<br>      prev_count = curr_count ;<br>      curr_count = 0 ;<br>      curr_width = 0 ;<br>      ans ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLevel ( int [ ] boxes , int n ) {<br>    Collections . sort ( boxes , new Comparator < Box > ( ) {<br>    }<br>    ans = 1 ;<br>    prevWidth = boxes [ 0 ] ;<br>    prevCount = 1 ;<br>    currCount = 0 ;<br>    currWidth = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        currWidth += boxes [ i ] ;<br>        currCount ++ ;<br>        if ( ( currWidth > prevWidth && currCount > prevCount ) || ( currCount > prevCount && currWidth > prevCount ) ) {<br>            prevWidth = currWidth ;<br>            prevCount = currCount ;<br>            currCount = 0 ;<br>            currWidth = 0 ;<br>            ans ++ ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNTING_INVERSIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getInvCount ( int n ) {<br>  int inv_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;<br>  return inv_count ;<br>}<br></td>
    <td>translated code: <br><br> public static int getInvCount ( int [ ] arr , int n ) {<br>    int inv_count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] ) && ( arr [ i ] < arr [ j ] ) ) {<br>                inv_count ++ ;<br>            }<br>        }<br>    }<br>    return inv_count ;<br>}</td>
  </tr><tr>
    <th>SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) {<br>  System . out . print ( "Diagonal one : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < column ;<br>    j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ;<br>  }<br>  System . out . println ( ) ;<br>  System . out . print ( "Diagonal two : " ) ;<br>  for ( int i = 0 ;<br>  i < row ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < column ;<br>    j ++ ) if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void diagonalsquare ( int [ ] [ ] mat , int row , int column ) {<br>    System . out . print ( "Diagonal one:" + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " "<br>    for ( int i = 0 ;  i <= row ;  i ++ ) {<br>        for ( int j = 0 ;  j <= column ;  j ++ ) {<br>            if ( ( i == j ) && ( i != j ) ){<br>                System . out . print ( "{}<br>            }<br>        }<br>    }<br>    System . out . print ( " \ n \ nDiagonal SPACETOKEN two : " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN " + " SPACETOKEN "<br>    for ( int i = 0 ;  i <= row ;  i ++ ) {<br>        for ( int j = 0 ;  j <= column ;  j ++ ) {<br>            if ( ( i + j == column - 1 ) && ( row + j == row - 1 ) ) {<br>                System . out . print ( "{}<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countCommon ( int mat [ ] [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countCommon ( int [ ] [ ] mat , int n ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ){<br>            res = res + 1 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>EULERIAN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int eulerian ( int n , int m ) {<br>  if ( m >= n || n == 0 ) return 0 ;<br>  if ( m == 0 ) return 1 ;<br>  return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double eulerian ( int n , int m ) {<br>    if ( ( m >= n || n == 0 ) && ( m % 2 == 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( m == 0 ) && ( n == 0 ) ) {<br>        return 1 ;<br>    }<br>    return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) ;<br>}</td>
  </tr><tr>
    <th>EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean squareRootExists ( int n , int p ) {<br>  n = n % p ;<br>  for ( int x = 2 ;<br>  x < p ;<br>  x ++ ) if ( ( x * x ) % p == n ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean squareRootExists ( int n , int p ) {<br>    n = n % p ;<br>    for ( int x = 2 ;  x < p ;  x += 1 ) {<br>        if ( ( ( x * x ) % p == n ) && ( ( x * x ) % p == n ) ) {<br>            return true ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  int path = 1 ;<br>  for ( int i = n ;<br>  i < ( m + n - 1 ) ;<br>  i ++ ) {<br>    path *= i ;<br>    path /= ( i - n + 1 ) ;<br>  }<br>  return path ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>    for ( int i = n ;  i < ( m + n - 1 ) ;  i ++ ) {<br>        path *= i ;<br>        path /= ( i - n + 1 ) ;<br>    }<br>    return path ;<br>}</td>
  </tr><tr>
    <th>MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maximumDifferenceSum ( int arr [ ] , int N ) {<br>  int dp [ ] [ ] = new int [ N ] [ 2 ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < ( N - 1 ) ;<br>  i ++ ) {<br>    dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ;<br>    dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ;<br>  }<br>  return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maximumDifferenceSum ( int [ ] arr , int N ) {<br>    int [ ] dp = new int [ N ] ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;<br>    }<br>    for ( int i = 0 ;  i < N - 1 ;  i ++ ) {<br>        dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ;<br>        dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ;<br>    }<br>    return Math . max ( dp [ N - 1 ] . intValue ( ) , dp [ N - 1 ] . intValue ( ) ) ;<br>}</td>
  </tr><tr>
    <th>STERN_BROCOT_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) {<br>  for ( int i = 1 ;<br>  BrocotSequence . size ( ) < n ;<br>  i ++ ) {<br>    int considered_element = BrocotSequence . get ( i ) ;<br>    int precedent = BrocotSequence . get ( i - 1 ) ;<br>    BrocotSequence . add ( considered_element + precedent ) ;<br>    BrocotSequence . add ( considered_element ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < 15 ;<br>  ++ i ) System . out . print ( BrocotSequence . get ( i ) + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void SternSequenceFunc ( List < Integer > BrocotSequence , int n ) {<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        consideredElement = sequence . get ( i ) ;<br>        precedent = sequence . get ( i - 1 ) ;<br>        BrocotSequence . add ( considered_element + precedent ) ;<br>        sequence . add ( considered_element ) ;<br>    }<br>    for ( int i = 0 ;  i <= 15 ;  i ++ ) {<br>        System . out . print ( i . toString ( ) + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDivisibleSubseq ( String str , int n ) {<br>  int len = str . length ( ) ;<br>  int dp [ ] [ ] = new int [ len ] [ n ] ;<br>  dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;<br>      dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return dp [ len - 1 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDivisibleSubseq ( String str , int n ) {<br>    int l = str . length ( ) ;<br>    int [ ] dp = new int [ l ] ;<br>    dp [ 0 ] [ ( ( char ) str . charAt ( 0 ) - '0' ) % n ] ++ ;<br>    for ( int i = 1 ;  i <= l ;  i ++ ) {<br>        dp [ i ] [ ( ( char ) str . charAt ( i ) - '0' ) % n ] ++ ;<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;<br>            dp [ i ] [ ( j * 10 + ( Character . digit ( str . charAt ( i ) , 16 ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ;<br>        }<br>    }<br>    return dp [ l - 1 ] [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int search ( int arr [ ] , int n , int x ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) return i ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int x ) {<br>    int n = arr . length ;<br>    for ( int j = 0 ;  j <= n ;  j ++ ) {<br>        if ( ( x == arr [ j ] ) && ( x == arr [ i ] ) ) {<br>            return j ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getPairsCount ( int n , int sum ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ;<br>    hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;<br>  }<br>  int twice_count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ;<br>    if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;<br>  }<br>  return twice_count / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int getPairsCount ( int [ ] arr , int n , int sum ) {<br>    int [ ] m = new int [ 1000 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        m [ arr [ i ] ] ++ ;<br>        m [ arr [ i ] ] ++ ;<br>    }<br>    twiceCount = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        twiceCount += m [ sum - arr [ i ] ] ;<br>        if ( ( sum - arr [ i ] == arr [ i ] ) && ( sum - arr [ i + 1 ] == arr [ i + 1 ] ) ) {<br>            twiceCount -- ;<br>        }<br>    }<br>    return ( int ) ( twiceCount / 2 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int minDist ( int arr [ ] , int n , int x , int y ) {<br>  int i , j ;<br>  int min_dist = Integer . MAX_VALUE ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) min_dist = Math . abs ( i - j ) ;<br>    }<br>  }<br>  return min_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int minDist ( int [ ] arr , int n , int x , int y ) {<br>    int minDist = 99999999 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && minDist > Math . abs ( i - j ) ) {<br>                int minDist = Math . abs ( i - j ) ;<br>            }<br>        }<br>        return min_dist ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) res = res ^ ( i + 1 ) ^ arr [ i ] ;<br>  res = res ^ arr [ n - 1 ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        res = res ^ ( i + 1 ) ^ arr [ i ] ;<br>    }<br>    res = res ^ arr [ n - 1 ] ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) {<br>  int sp [ ] [ ] [ ] = new int [ V ] [ V ] [ k + 1 ] ;<br>  for ( int e = 0 ;<br>  e <= k ;<br>  e ++ ) {<br>    for ( int i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( int j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        sp [ i ] [ j ] [ e ] = INF ;<br>        if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ;<br>        if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ;<br>        if ( e > 1 ) {<br>          for ( int a = 0 ;<br>          a < V ;<br>          a ++ ) {<br>            if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return sp [ u ] [ v ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestPath ( int [ ] [ ] graph , int u , int v , int k ) {<br>    V = INF ;<br>    List < List < Integer >> sp = new ArrayList < List < Integer >> ( ) ;<br>    for ( int i = 0 ;  i < V ;  i ++ ) {<br>        for ( int j = 0 ;  j < V ;  j ++ ) {<br>            sp [ i ] [ j ] = new int [ k + 1 ] ;<br>        }<br>    }<br>    for ( int e = 0 ;  e < k + 1 ;  e ++ ) {<br>        for ( int i = 0 ;  i < V ;  i ++ ) {<br>            for ( int j = 0 ;  j < V ;  j ++ ) {<br>                sp [ i ] [ j ] [ e ] = INF ;<br>                if ( ( e == 0 && i == j ) || ( e == 1 && i == k ) ) {<br>                    sp [ i ] [ j ] [ e ] = 0 ;<br>                }<br>                if ( ( e == 1 && graph [ i ] [ j ] != INF ) || ( e == 2 && graph [ i ] [ j ] != INF ) ){<br>                    sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ;<br>                }<br>                if ( ( e > 1 ) && ( e < e ) ) {<br>                    for ( int a = 0 ;  a < V ;  a ++ ) {<br>                        if ( ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) || ( graph [ u ] [ v ] [ e - 1 ] != INF && u != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) ){<br>                            sp [ i ] [ j ] [ e ] = Math . min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    return sp [ u ] [ v ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void longest ( int a [ ] , int n , int k ) {<br>  int [ ] freq = new int [ 7 ] ;<br>  int start = 0 , end = 0 , now = 0 , l = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    freq [ a [ i ] ] ++ ;<br>    if ( freq [ a [ i ] ] == 1 ) now ++ ;<br>    while ( now > k ) {<br>      freq [ a [ l ] ] -- ;<br>      if ( freq [ a [ l ] ] == 0 ) now -- ;<br>      l ++ ;<br>    }<br>    if ( i - l + 1 >= end - start + 1 ) {<br>      end = i ;<br>      start = l ;<br>    }<br>  }<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void longest ( int [ ] a , int n , int k ) {<br>    int [ ] freq = new int [ n ] ;<br>    int start = 0 ;<br>    int end = 0 ;<br>    int now = 0 ;<br>    int l = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        freq [ a [ i ] ] ++ ;<br>        if ( ( freq [ a [ i ] ] == 1 ) && ( freq [ a [ i + 1 ] ] == 1 ) ) a [ i ] = 5 ;<br>            now ++ ;<br>        while ( ( now > k ) && ( now > n ) ) {<br>            freq [ a [ l ] ] -- ;<br>            if ( ( freq [ a [ l ] ] == 0 ) && ( freq [ a [ k ] ] == 0 ) ) a [ l ] = 5 ;<br>                now -- ;<br>            l ++ ;<br>        }<br>        if ( ( i - l + 1 >= end - start + 1 ) && ( i - l + 1 >= end - start + 1 ) ){<br>            int end = i ;<br>            int start = l ;<br>        }<br>    }<br>    for ( int i = start ;  i <= end ;  i ++ ) {<br>        System . out . print ( a [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_XOR_VALUE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxXOR ( int mat [ ] [ ] , int N ) {<br>  int r_xor , c_xor ;<br>  int max_xor = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    r_xor = 0 ;<br>    c_xor = 0 ;<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      r_xor = r_xor ^ mat [ i ] [ j ] ;<br>      c_xor = c_xor ^ mat [ j ] [ i ] ;<br>    }<br>    if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ;<br>  }<br>  return max_xor ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxXOR ( int [ ] [ ] mat , int N ) {<br>    maxXor = 0 ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        r_xor = 0 ;<br>        c_xor = 0 ;<br>        for ( int j = 0 ;  j < N ;  j ++ ) {<br>            r_xor = r_xor ^ mat [ i ] [ j ] ;<br>            c_xor = c_xor ^ mat [ j ] [ i ] ;<br>        }<br>        if ( ( maxXor < Math . max ( rXor , cXor ) ) && ( maxXor < Math . max ( rXor , cXor ) ) ){<br>            maxXor = Math . max ( rXor , cXor ) ;<br>        }<br>    }<br>    return maxXOR ;<br>}</td>
  </tr><tr>
    <th>LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestNull ( String str ) {<br>  ArrayList < Pair > arr = new ArrayList < > ( ) ;<br>  arr . add ( new Pair ( '@' , - 1 ) ) ;<br>  int maxlen = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    arr . add ( new Pair ( str . charAt ( i ) , i ) ) ;<br>    while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) - 3 ) . first == '1' && arr . get ( arr . size ( ) - 2 ) . first == '0' && arr . get ( arr . size ( ) - 1 ) . first == '0' ) {<br>      arr . remove ( arr . size ( ) - 3 ) ;<br>      arr . remove ( arr . size ( ) - 2 ) ;<br>      arr . remove ( arr . size ( ) - 1 ) ;<br>    }<br>    int tmp = arr . get ( arr . size ( ) - 1 ) . second ;<br>    maxlen = Math . max ( maxlen , i - tmp ) ;<br>  }<br>  return maxlen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestNull ( String S ) {<br>    int [ ] arr = new int [ 0 ] ;<br>    arr . add ( new Integer ( '@' ) , - 1 ) ;<br>    int maxlen = 0 ;<br>    for ( int i = 0 ;  i < S . length ;  i ++ ) {<br>        arr . add ( new int [ ] {<br>        }<br>        while ( ( arr . length >= 3 ) && ( arr [ arr . length - 3 ] . charAt ( 0 ) == '1' ) && ( arr [ arr . length - 2 ] . charAt ( 0 ) == '0' ) && ( arr [ arr . length - 1 ] . charAt ( 0 ) == '0' ) ) {<br>            arr . remove ( ) ;<br>            arr . remove ( ) ;<br>            arr . remove ( ) ;<br>        }<br>        int tmp = arr [ arr . length - 1 ] ;<br>        maxlen = Math . max ( maxlen , i - tmp . get ( 1 ) ) ;<br>    }<br>    return maxlen ;<br>}</td>
  </tr><tr>
    <th>LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSubarray ( boolean arr [ ] , int n ) {<br>  int len [ ] = new int [ n ] ;<br>  len [ n - 1 ] = 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  -- i ) {<br>    if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ;<br>    else len [ i ] = 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) System . out . print ( len [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSubarray ( boolean [ ] arr , int n ) {<br>    int len = new int [ n ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        len . add ( 0 ) ;<br>    }<br>    len [ n - 1 ] = 1 ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( arr [ i ] ^ arr [ i + 1 ] == true ) == false ) {<br>            len [ i ] = len [ i + 1 ] + 1 ;<br>        }<br>        else {<br>            len [ i ] = 1 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . println ( arr . length + "" + n + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " SPACETOKEN<br>    }<br>}</td>
  </tr><tr>
    <th>WILDCARD_CHARACTER_MATCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean match ( String first , String second ) {<br>  if ( first . length ( ) == 0 && second . length ( ) == 0 ) return true ;<br>  if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) return false ;<br>  if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ;<br>  if ( first . length ( ) > 0 && first . charAt ( 0 ) == '*' ) return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean match ( String first , String second ) {<br>    if ( first . length ( ) == 0 && second . length ( ) == 0 ) {<br>        return match ( first , second , false ) ;<br>    }<br>    if ( first . length ( ) > 1 && first . charAt ( 0 ) == '*' && second . length ( ) == 0 ) {<br>        return false ;<br>    }<br>    if ( ( first . length ( ) > 1 && first . charAt ( 0 ) == '?' ) || ( first . length ( ) != 0 && second . length ( ) != 0 && first . charAt ( 0 ) == second . charAt ( 0 ) ) ) {<br>        return match ( first . substring ( 1 ) , second . substring ( 1 ) ) ;<br>    }<br>    if ( first . length ( ) != 0 && first . charAt ( 0 ) == '*' ) {<br>        return match ( first . substring ( 1 ) , second ) || match ( first , second . substring ( 1 ) ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFactorialNums ( int n ) {<br>  int fact = 1 ;<br>  int x = 2 ;<br>  while ( fact <= n ) {<br>    System . out . print ( fact + " " ) ;<br>    fact = fact * x ;<br>    x ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFactorialNums ( int n ) {<br>    int fact = 1 ;<br>    int x = 2 ;<br>    while ( fact <= n ) {<br>        System . out . print ( fact + " " ) ;<br>        fact = fact * x ;<br>        x ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  int a = 1 , b = 2 , c = 0 ;<br>  if ( n <= 2 ) {<br>    return n ;<br>  }<br>  for ( int i = 3 ;<br>  i <= n ;<br>  i ++ ) {<br>    c = b + ( i - 1 ) * a ;<br>    a = b ;<br>    b = c ;<br>  }<br>  return c ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>    int a = 1 , b = 2 , c = 0 ;<br>    if ( ( n <= 2 ) && ( n > 0 ) ) {<br>        return n ;<br>    }<br>    for ( int i = 3 ;  i <= n ;  i ++ ) {<br>        c = b + ( i - 1 ) * a ;<br>        int a = b ;<br>        boolean b = c ;<br>    }<br>    return c ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxArea ( int mat [ ] [ ] ) {<br>  int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ;<br>  for ( int i = 0 ;<br>  i < C ;<br>  i ++ ) {<br>    hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;<br>    for ( int j = 1 ;<br>    j < R ;<br>    j ++ ) {<br>      hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    int count [ ] = new int [ R + 1 ] ;<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      count [ hist [ i ] [ j ] ] ++ ;<br>    }<br>    int col_no = 0 ;<br>    for ( int j = R ;<br>    j >= 0 ;<br>    j -- ) {<br>      if ( count [ j ] > 0 ) {<br>        for ( int k = 0 ;<br>        k < count [ j ] ;<br>        k ++ ) {<br>          hist [ i ] [ col_no ] = j ;<br>          col_no ++ ;<br>        }<br>      }<br>    }<br>  }<br>  int curr_area , max_area = 0 ;<br>  for ( int i = 0 ;<br>  i < R ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < C ;<br>    j ++ ) {<br>      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;<br>      if ( curr_area > max_area ) {<br>        max_area = curr_area ;<br>      }<br>    }<br>  }<br>  return max_area ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxArea ( int [ ] [ ] mat ) {<br>    int [ ] [ ] hist = new int [ C + 1 ] [ R + 1 ] ;<br>    for ( int i = 0 ;  i < C ;  i += 1 ) {<br>        hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;<br>        for ( int j = 1 ;  j < R ;  j += 1 ) {<br>            if ( ( ( mat [ j ] [ i ] == 0 ) && ( mat [ j ] [ i ] == 1 ) ) || ( ( mat [ j ] [ i ] == 2 ) && ( mat [ j ] [ i ] == 3 ) ) ){<br>                hist [ j ] [ i ] = 0 ;<br>            }<br>            else {<br>                hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < R ;  i += 1 ) {<br>        int [ ] count = new int [ R + 1 ] ;<br>        for ( int j = 0 ;  j < C ;  j += 1 ) {<br>            count [ hist [ i ] [ j ] ] ++ ;<br>        }<br>        int colNo = 0 ;<br>        j = R ;<br>        while ( ( j >= 0 ) && ( j < mat . length ) ){<br>            if ( ( count [ j ] > 0 ) && ( count [ j ] < ( count [ j ] + 1 ) ) ){<br>                for ( int k = 0 ;  k < count [ j ] ;  k += 1 ) {<br>                    hist [ i ] [ colNo ] = j ;<br>                    colNo ++ ;<br>                }<br>            }<br>            j -- ;<br>        }<br>    }<br>    maxArea = 0 ;<br>    for ( int i = 0 ;  i < R ;  i += 1 ) {<br>        for ( int j = 0 ;  j < C ;  j += 1 ) {<br>            currArea = ( j + 1 ) * hist [ i ] [ j ] ;<br>            if ( ( currArea > maxArea ) && ( currArea < maxArea ) ) {<br>                maxArea = currArea ;<br>            }<br>        }<br>    }<br>    return maxArea ;<br>}</td>
  </tr><tr>
    <th>SUM_SEQUENCE_2_22_222</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double sumOfSeries ( int n ) {<br>  return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double sumOfSeries ( int n ) {<br>    return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {<br>  int allocation [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < allocation . length ;<br>  i ++ ) allocation [ i ] = - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < m ;<br>    j ++ ) {<br>      if ( blockSize [ j ] >= processSize [ i ] ) {<br>        allocation [ i ] = j ;<br>        blockSize [ j ] -= processSize [ i ] ;<br>        break ;<br>      }<br>    }<br>  }<br>  System . out . println ( "\nProcess No.\tProcess Size\tBlock no." ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    System . out . print ( " " + ( i + 1 ) + "\t\t" + processSize [ i ] + "\t\t" ) ;<br>    if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ;<br>    else System . out . print ( "Not Allocated" ) ;<br>    System . out . println ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void firstFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) {<br>    allocation = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( blockSize [ j ] >= processSize [ i ] ) {<br>                allocation [ i ++ ] = j ;<br>                blockSize [ j ] -= processSize [ i ] ;<br>                break ;<br>            }<br>        }<br>    }<br>    System . out . println ( " Process No.Process Size      Block no." ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( " " + i + "         " + processSize [ i ] + "         " + n ) ;<br>        if ( allocation [ i ] != - 1 ){<br>            System . out . println ( allocation [ i ] + 1 ) ;<br>        }<br>        else {<br>            System . out . println ( "Not Allocated" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isPower ( int x , int y ) {<br>  if ( x == 1 ) return ( y == 1 ) ;<br>  int pow = 1 ;<br>  while ( pow < y ) pow = pow * x ;<br>  return ( pow == y ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPower ( int x , int y ) {<br>    if ( ( x == 1 ) && ( y == 1 ) ) {<br>        return ( y == 1 ) ;<br>    }<br>    int pow = 1 ;<br>    while ( ( pow < y ) && ( pow < x ) ) {<br>        pow = x ;<br>    }<br>    return ( pow == y ) ;<br>}</td>
  </tr><tr>
    <th>DIVIDE_LARGE_NUMBER_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longDivision ( String number , int divisor ) {<br>  String ans = "" ;<br>  int idx = 0 ;<br>  char [ ] num = number . toCharArray ( ) ;<br>  int temp = num [ idx ] - '0' ;<br>  while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ;<br>  idx += 1 ;<br>  while ( num . length > idx ) {<br>    ans += ( temp / divisor ) ;<br>    temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ;<br>  }<br>  if ( ans . length ( ) == 0 ) return "0" ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static String longDivision ( String number , int divisor ) {<br>    String ans = "" ;<br>    int idx = 0 ;<br>    int temp = ( int ) number . charAt ( idx ) - ( int ) '0' ;<br>    while ( ( temp = number % divisor ) != 0 ) {<br>        temp = ( temp * 10 + ( char ) number . charAt ( idx + 1 ) - '0' ) ;<br>        idx ++ ;<br>    }<br>    idx ++ ;<br>    while ( ( ( int ) number . length ( ) ) > idx ) {<br>        ans += ( char ) ( Math . floor ( temp / divisor ) + ( char ) '0' ) ;<br>        temp = ( ( temp % divisor ) * 10 + ( number . charAt ( idx ) - '0' ) ) ;<br>        idx ++ ;<br>    }<br>    ans += ( char ) ( Math . floor ( temp / divisor ) + ( char ) '0' ) ;<br>    if ( ( ans . length == 0 ) && ( divisor == 0 ) ) {<br>        return "0" ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMax ( int arr [ ] [ ] ) {<br>  int row = 0 , i , j ;<br>  for ( i = 0 , j = N - 1 ;<br>  i < N ;<br>  i ++ ) {<br>    while ( j >= 0 && arr [ i ] [ j ] == 1 ) {<br>      row = i ;<br>      j -- ;<br>    }<br>  }<br>  System . out . print ( "Row number = " + ( row + 1 ) ) ;<br>  System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMax ( int [ ] [ ] arr ) {<br>    int row = 0 ;<br>    int j = N - 1 ;<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        while ( ( arr [ i ] [ j ] == 1 && j >= 0 ) || ( arr [ i ] [ j ] == 2 && j >= 1 ) ) {<br>            int row = i ;<br>            j -- ;<br>        }<br>    }<br>    System . out . println ( "Row number = " + row + ", MaxCount = " + N - 1 - j ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_ROTATIONS_REQUIRED_GET_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRotations ( String str ) {<br>  String tmp = str + str ;<br>  int n = str . length ( ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    String substring = tmp . substring ( i , str . length ( ) ) ;<br>    if ( str == substring ) return i ;<br>  }<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRotations ( String str ) {<br>    String tmp = str + str ;<br>    int n = str . length ( ) ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        substring = tmp . substring ( i , n ) ;<br>        if ( ( str . equals ( substring ) ) && ( a == 5 ) ) {<br>            return i ;<br>        }<br>    }<br>    return n ;<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberOfPaths ( int m , int n ) {<br>  if ( m == 1 || n == 1 ) return 1 ;<br>  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfPaths ( int m , int n ) {<br>    if ( ( m == 1 || n == 1 ) && ( m == 2 || n == 2 ) ) {<br>        return 1 ;<br>    }<br>    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findNth ( int n ) {<br>  int count = 0 ;<br>  for ( int curr = 19 ;<br>  ;<br>  curr += 9 ) {<br>    int sum = 0 ;<br>    for ( int x = curr ;<br>    x > 0 ;<br>    x = x / 10 ) sum = sum + x % 10 ;<br>    if ( sum == 10 ) count ++ ;<br>    if ( count == n ) return curr ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findNth ( int n ) {<br>    int count = 0 ;<br>    int curr = 19 ;<br>    while ( ( true ) && ( n > 0 ) ) {<br>        int sum = 0 ;<br>        int x = curr ;<br>        while ( ( x > 0 ) && ( x < n ) ) {<br>            sum = sum + x % 10 ;<br>            int x = ( int ) ( n / 10 ) ;<br>        }<br>        if ( ( sum == 10 ) && ( n > 0 ) ) {<br>            count ++ ;<br>        }<br>        if ( ( count == n ) && ( count > 0 ) ) {<br>            return curr ;<br>        }<br>        curr += 9 ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumAtKthLevel ( String tree , int k , int level ) {<br>  if ( tree . charAt ( i ++ ) == '(' ) {<br>    if ( tree . charAt ( i ) == ')' ) return 0 ;<br>    int sum = 0 ;<br>    if ( level == k ) sum = tree . charAt ( i ) - '0' ;<br>    ++ i ;<br>    int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ;<br>    ++ i ;<br>    int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ;<br>    ++ i ;<br>    return sum + leftsum + rightsum ;<br>  }<br>  return Integer . MIN_VALUE ;<br>}<br></td>
    <td>translated code: <br><br> static int sumAtKthLevel ( char [ ] tree , int k , int i , int level ) {<br>    if ( ( tree [ i + level ] [ 0 ] == '(' ) && ( tree [ i + level ] [ 1 ] == ')' ) ) {<br>        i [ 0 ] ++ ;<br>        if ( ( tree [ i + 0 ] == ')' ) && ( i + 1 < tree . length ) ) {<br>            return 0 ;<br>        }<br>        int sum = 0 ;<br>        if ( ( level == k ) && ( i == k ) ) {<br>            int sum = Integer . bitCount ( tree [ i ] [ 0 ] ) ;<br>        }<br>        i [ 0 ] ++ ;<br>        int leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ;<br>        i [ 0 ] ++ ;<br>        int rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ;<br>        i [ 0 ] ++ ;<br>        return sum + leftsum + rightsum ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_OFDIFFERENT_WAYS_EXPRESS_N_SUM_1_3_4</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int n ) {<br>  int DP [ ] = new int [ n + 1 ] ;<br>  DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ;<br>  DP [ 3 ] = 2 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i ++ ) DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ;<br>  return DP [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int n ) {<br>    DP . add ( 0 ) ;<br>    DP [ 0 ] = DP [ 1 ] = DP [ 2 ] = 1 ;<br>    DP [ 3 ] = 2 ;<br>    for ( int i = 4 ;  i <= n ;  i ++ ) {<br>        DP [ i ] = DP [ i - 1 ] + DP [ i - 3 ] + DP [ i - 4 ] ;<br>    }<br>    return DP [ n ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_EQULIBRIUM_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxSum ( int [ ] arr , int n ) {<br>  int res = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int prefix_sum = arr [ i ] ;<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) prefix_sum += arr [ j ] ;<br>    int suffix_sum = arr [ i ] ;<br>    for ( int j = n - 1 ;<br>    j > i ;<br>    j -- ) suffix_sum += arr [ j ] ;<br>    if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxSum ( int [ ] arr , int n ) {<br>    int res = - Integer . MAX_VALUE - 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int prefixSum = arr [ i ] ;<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            prefixSum += arr [ j ] ;<br>        }<br>        int suffixSum = arr [ i ] ;<br>        int j = n - 1 ;<br>        while ( ( j > i ) && ( j < n ) ) {<br>            suffixSum += arr [ j ] ;<br>            j -- ;<br>        }<br>        if ( ( prefixSum == suffixSum ) && ( n > 0 ) ) {<br>            res = Math . max ( res , prefixSum ) ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>STEINS_ALGORITHM_FOR_FINDING_GCD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int gcd ( int a , int b ) {<br>  if ( a == b ) return a ;<br>  if ( a == 0 ) return b ;<br>  if ( b == 0 ) return a ;<br>  if ( ( ~ a & 1 ) == 1 ) {<br>    if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ;<br>    else return gcd ( a >> 1 , b >> 1 ) << 1 ;<br>  }<br>  if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ;<br>  if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;<br>  return gcd ( ( b - a ) >> 1 , a ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int gcd ( int a , int b ) {<br>    if ( ( a == b ) && ( a != 0 ) ) {<br>        return a % b ;<br>    }<br>    if ( ( a == 0 ) && ( b == 0 ) ) {<br>        return b ;<br>    }<br>    if ( ( b == 0 ) && ( a != 0 ) ){<br>        return a % b ;<br>    }<br>    if ( ( ( ~ a & 1 ) == 1 ) && ( ( ~ b & 1 ) == 1 ) ){<br>        if ( ( ( b & 1 ) == 1 ) && ( ( a & 2 ) == 2 ) ){<br>            return gcd ( a >>> 1 , b ) ;<br>        }<br>        if ( a == 0 ) {<br>            return ( gcd ( a >>> 1 , b >>> 1 ) << 1 ) ;<br>        }<br>    }<br>    if ( ( ( ~ b & 1 ) == 1 ) && ( ( a & 1 ) == 0 ) ){<br>        return gcd ( a , b >>> 1 ) ;<br>    }<br>    if ( ( a > b ) && ( a < 0 ) ){<br>        return gcd ( ( a - b ) >>> 1 , b ) ;<br>    }<br>    return gcd ( ( b - a ) >>> 1 , a ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_THE_VOLUME_OF_A_TRIANGULAR_PRISM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float findVolume ( float l , float b , float h ) {<br>  float volume = ( l * b * h ) / 2 ;<br>  return volume ;<br>}<br></td>
    <td>translated code: <br><br> static float findVolume ( float l , float b , float h ) {<br>    return ( ( l * b * h ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRectangle ( int m [ ] [ ] ) {<br>  int rows = m . length ;<br>  if ( rows == 0 ) return false ;<br>  int columns = m [ 0 ] . length ;<br>  for ( int y1 = 0 ;<br>  y1 < rows ;<br>  y1 ++ ) for ( int x1 = 0 ;<br>  x1 < columns ;<br>  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ;<br>  y2 < rows ;<br>  y2 ++ ) for ( int x2 = x1 + 1 ;<br>  x2 < columns ;<br>  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRectangle ( int [ ] [ ] m ) {<br>    int rows = m . length ;<br>    if ( ( rows == 0 ) && ( m > 0 ) ){<br>        return false ;<br>    }<br>    int columns = m [ 0 ] . length ;<br>    for ( int y1 = 0 ;  y1 < rows ;  y1 ++ ) {<br>        for ( int x1 = 0 ;  x1 < columns ;  x1 ++ ) {<br>            if ( ( m [ y1 ] [ x1 ] == 1 ) && ( m [ y2 ] [ y1 ] == 1 ) ) {<br>                for ( int y2 = y1 + 1 ;  y2 < rows ;  y2 ++ ) {<br>                    for ( int x2 = x1 + 1 ;  x2 < columns ;  x2 ++ ) {<br>                        if ( ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) || ( m [ y1 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 ) ) {<br>                            return true ;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBER_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPossible ( String str , int n ) {<br>  int len = str . length ( ) ;<br>  if ( len >= n ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPossible ( String str , int n ) {<br>    int l = str . length ( ) ;<br>    if ( ( l >= n ) && ( l <= n ) ) {<br>        return isPossible ( str , n , false ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>CHECK_STAR_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkStar ( int mat [ ] [ ] ) {<br>  int vertexD1 = 0 , vertexDn_1 = 0 ;<br>  if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ;<br>  if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    int degreeI = 0 ;<br>    for ( int j = 0 ;<br>    j < size ;<br>    j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ;<br>    if ( degreeI == 1 ) vertexD1 ++ ;<br>    else if ( degreeI == size - 1 ) vertexDn_1 ++ ;<br>  }<br>  return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkStar ( int [ ] [ ] mat ) {<br>    size = mat . rows ( ) ;<br>    int vertexD1 = 0 ;<br>    vertexDn_1 = 0 ;<br>    if ( ( size == 1 ) && ( mat == 5 ) ) {<br>        return ( mat [ 0 ] [ 0 ] == 0 ) ;<br>    }<br>    if ( ( size == 2 ) && ( mat [ 0 ] == mat [ 1 ] ) ) {<br>        return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ;<br>    }<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        int degreeI = 0 ;<br>        for ( int j = 0 ;  j <= size ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] ) != 0 ) {<br>                degreeI = degreeI + 1 ;<br>            }<br>        }<br>        if ( ( degreeI == 1 ) && ( mat [ 0 ] == 0 ) ) {<br>            vertexD1 = vertexD1 + 1 ;<br>        }<br>        if ( ( degreeI == size - 1 ) && ( degreeI > 0 ) ) {<br>            vertexDn_1 = vertexDn_1 + 1 ;<br>        }<br>    }<br>    return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ;<br>}</td>
  </tr><tr>
    <th>ROOTS_OF_UNITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printRoots ( int n ) {<br>  double theta = 3.14 * 2 / n ;<br>  for ( int k = 0 ;<br>  k < n ;<br>  k ++ ) {<br>    double real = Math . cos ( k * theta ) ;<br>    double img = Math . sin ( k * theta ) ;<br>    System . out . println ( real ) ;<br>    if ( img >= 0 ) System . out . println ( " + i " ) ;<br>    else System . out . println ( " - i " ) ;<br>    System . out . println ( Math . abs ( img ) ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRoots ( int n ) {<br>    double theta = Math . PI * 2 / n ;<br>    for ( int k = 0 ;  k <= n ;  k ++ ) {<br>        real = Math . cos ( k * theta ) ;<br>        img = Math . sin ( k * theta ) ;<br>        System . out . print ( real + " " ) ;<br>        if ( ( img >= 0 ) && ( img < n ) ){<br>            System . out . print ( " + i " ) ;<br>        }<br>        else {<br>            System . out . print ( " - i " ) ;<br>        }<br>        System . out . println ( Math . abs ( img ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLargestd ( int [ ] S , int n ) {<br>  boolean found = false ;<br>  Arrays . sort ( S ) ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == j ) continue ;<br>      for ( int k = j + 1 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( i == k ) continue ;<br>        for ( int l = k + 1 ;<br>        l < n ;<br>        l ++ ) {<br>          if ( i == l ) continue ;<br>          if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {<br>            found = true ;<br>            return S [ i ] ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  if ( found == false ) return Integer . MAX_VALUE ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLargestd ( int [ ] S , int n ) {<br>    boolean found = false ;<br>    Collections . sort ( S ) ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( i == j ) && ( n > 0 ) ) {<br>                continue ;<br>            }<br>            for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                if ( ( i == k ) && ( n == k ) ){<br>                    continue ;<br>                }<br>                for ( int l = k + 1 ;  l < n ;  l ++ ) {<br>                    if ( ( i == l ) && ( n == n ) ){<br>                        continue ;<br>                    }<br>                    if ( ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) && ( n == 0 ) ) {<br>                        found = true ;<br>                        return S [ i ] ;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    if ( ( found == false ) && ( n > 0 ) ) {<br>        return - 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_NUMBER_STRING_FIND_NUMBER_CONTIGUOUS_SUBSEQUENCES_RECURSIVELY_ADD_9_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count9s ( char number [ ] ) {<br>  int n = number . length ;<br>  int d [ ] = new int [ 9 ] ;<br>  d [ 0 ] = 1 ;<br>  int result = 0 ;<br>  int mod_sum = 0 , continuous_zero = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( number [ i ] - '0' ) == 0 ) {<br>      continuous_zero ++ ;<br>    }<br>    else {<br>      continuous_zero = 0 ;<br>    }<br>    mod_sum += ( number [ i ] - '0' ) ;<br>    mod_sum %= 9 ;<br>    result += d [ mod_sum ] ;<br>    d [ mod_sum ] ++ ;<br>    result -= continuous_zero ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int count9s ( String number ) {<br>    int n = number . length ( ) ;<br>    int [ ] d = new int [ 9 ] ;<br>    d [ 0 ] = 1 ;<br>    int result = 0 ;<br>    int modSum = 0 ;<br>    continuousZero = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( Character . digit ( number . charAt ( i ) , 10 ) - '0' ) == 0 ) {<br>            continuousZero ++ ;<br>        }<br>        else {<br>            continuousZero = 0 ;<br>        }<br>        modSum += ( char ) number . charAt ( i ++ ) - '0' ;<br>        modSum %= 9 ;<br>        result += d [ modSum ] ;<br>        d [ modSum ] ++ ;<br>        result -= continuousZero ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICAL_MAXIMUM_SUBSTRING_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String LexicographicalMaxString ( String str ) {<br>  String mx = "" ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  ++ i ) {<br>    if ( mx . compareTo ( str . substring ( i ) ) <= 0 ) {<br>      mx = str . substring ( i ) ;<br>    }<br>  }<br>  return mx ;<br>}<br></td>
    <td>translated code: <br><br> public static String LexicographicalMaxString ( String str ) {<br>    LexicographicalMaxString mx = new LexicographicalMaxString ( ) ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        mx = Math . max ( mx , str [ i ++ ] ) ;<br>    }<br>    return mx ;<br>}</td>
  </tr><tr>
    <th>CHECK_TWO_GIVEN_SETS_DISJOINT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) {<br>  int i = 0 , j = 0 ;<br>  Arrays . sort ( set1 ) ;<br>  Arrays . sort ( set2 ) ;<br>  while ( i < set1 . length && j < set2 . length ) {<br>    if ( set1 [ i ] < set2 [ j ] ) i ++ ;<br>    else if ( set1 [ i ] > set2 [ j ] ) j ++ ;<br>    else return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean areDisjoint ( int [ ] set1 , int [ ] set2 , int m , int n ) {<br>    Arrays . sort ( set1 , 0 , m ) ;<br>    Arrays . sort ( set1 , m , n ) ;<br>    int i = 0 ;<br>    while ( ( i < m && j < n ) || ( i < n && j < m ) ) {<br>        if ( ( set1 [ i ] < set2 [ j ] ) && ( set1 [ j ] > set2 [ i ] ) ) {<br>            i ++ ;<br>        }<br>        else if ( ( set2 [ j ] < set1 [ i ] ) && ( set2 [ i ] > set1 [ j ] ) ) {<br>            j ++ ;<br>        }<br>        else {<br>            return areDisjoint ( set1 , set2 , m , n , null ) ;<br>        }<br>    }<br>    return areDisjoint ( set1 , set2 , m , n , null ) ;<br>}</td>
  </tr><tr>
    <th>EQUILIBRIUM_INDEX_OF_AN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int equilibrium ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  int leftsum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) sum += arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    sum -= arr [ i ] ;<br>    if ( leftsum == sum ) return i ;<br>    leftsum += arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int equilibrium ( int [ ] arr ) {<br>    int totalSum = sum ( arr ) ;<br>    int leftsum = 0 ;<br>    for ( int i = 0 , num = arr . length ;  i < num ;  i ++ ) {<br>        totalSum -= num ;<br>        if ( leftsum == totalSum ) {<br>            return i ;<br>        }<br>        leftsum += num ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>AREA_CIRCUMSCRIBED_CIRCLE_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float areacircumscribed ( float a ) {<br>  float PI = 3.14159265f ;<br>  return ( a * a * ( PI / 2 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double areacircumscribed ( double a ) {<br>    return ( a * a * ( PI / 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_REPEATING_AND_NON_OVERLAPPING_SUBSTRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longestRepeatedSubstring ( String str ) {<br>  int n = str . length ( ) ;<br>  int LCSRe [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  String res = "" ;<br>  int res_length = 0 ;<br>  int i , index = 0 ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] [ j - 1 ] < ( j - i ) ) {<br>        LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ;<br>        if ( LCSRe [ i ] [ j ] > res_length ) {<br>          res_length = LCSRe [ i ] [ j ] ;<br>          index = Math . max ( i , index ) ;<br>        }<br>      }<br>      else {<br>        LCSRe [ i ] [ j ] = 0 ;<br>      }<br>    }<br>  }<br>  if ( res_length > 0 ) {<br>    for ( i = index - res_length + 1 ;<br>    i <= index ;<br>    i ++ ) {<br>      res += str . charAt ( i - 1 ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String longestRepeatedSubstring ( String str ) {<br>    int n = str . length ( ) ;<br>    LCSRe = new ArrayList < Integer > ( ) ;<br>    String res = "" ;<br>    int resLength = 0 ;<br>    int index = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j <= n ;  j ++ ) {<br>            if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && LCSRe [ i - 1 ] . charAt ( j - 1 ) < ( j - i ) ) || ( str . charAt ( i - 1 ) == str . charAt ( j - i ) && LCSRe [ i - 1 ] . charAt ( j - i ) < ( j - j ) ) ) {<br>                LCSRe [ i ] [ j ] = LCSRe [ i - 1 ] [ j - 1 ] + 1 ;<br>                if ( ( LCSRe [ i ] [ j ] > resLength ) && ( LCSRe [ i ] [ j ] > resLength ) ) {<br>                    int resLength = LCSRe [ i ] [ j ] ;<br>                    index = Math . max ( i , index ) ;<br>                }<br>            }<br>            if ( str != null ) {<br>                LCSRe [ i ] [ j ] = 0 ;<br>            }<br>        }<br>    }<br>    if ( ( resLength > 0 ) && ( resLength < resLength ) ) {<br>        for ( int i = index - resLength + 1 ;  i <= index ;  i ++ ) {<br>            String res = res + str . charAt ( i - 1 ) ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long mulmod ( long a , long b , long mod ) {<br>  long res = 0 ;<br>  a = a % mod ;<br>  while ( b > 0 ) {<br>    if ( b % 2 == 1 ) {<br>      res = ( res + a ) % mod ;<br>    }<br>    a = ( a * 2 ) % mod ;<br>    b /= 2 ;<br>  }<br>  return res % mod ;<br>}<br></td>
    <td>translated code: <br><br> public static int mulmod ( int a , int b , int mod ) {<br>    int res = 0 ;<br>    a = a % mod ;<br>    while ( ( b > 0 ) && ( a % mod == 0 ) ) {<br>        if ( ( b % 2 == 1 ) && ( mod % 2 == 0 ) ){<br>            int res = ( res + a ) % mod ;<br>        }<br>        a = ( a * 2 ) % mod ;<br>        b /= 2 ;<br>    }<br>    return res % mod ;<br>}</td>
  </tr><tr>
    <th>PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isProduct ( int arr [ ] , int n , int x ) {<br>  HashSet < Integer > hset = new HashSet < > ( ) ;<br>  if ( n < 2 ) return false ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 0 ) {<br>      if ( x == 0 ) return true ;<br>      else continue ;<br>    }<br>    if ( x % arr [ i ] == 0 ) {<br>      if ( hset . contains ( x / arr [ i ] ) ) return true ;<br>      hset . add ( arr [ i ] ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isProduct ( int [ ] arr , int n , int x ) {<br>    if ( n < 2 ) {<br>        return false ;<br>    }<br>    Set s = new HashSet ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( arr [ i ] == 0 ) {<br>            if ( x == 0 ) {<br>                return isProduct ( arr , n , x , 0 ) ;<br>            }<br>            else {<br>                continue ;<br>            }<br>        }<br>        if ( x % arr [ i ] == 0 ) {<br>            if ( x / arr [ i ] == s ){<br>                return isProduct ( arr , n , x , 0 ) ;<br>            }<br>            s . add ( arr [ i ] ) ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int kthgroupsum ( int k ) {<br>  int cur = ( k * ( k - 1 ) ) + 1 ;<br>  int sum = 0 ;<br>  while ( k -- > 0 ) {<br>    sum += cur ;<br>    cur += 2 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int kthGroupSum ( int k ) {<br>    int cur = ( int ) ( ( k * ( k - 1 ) ) + 1 ) ;<br>    int sum = 0 ;<br>    while ( k -- > 0 ) {<br>        sum += cur ;<br>        cur += 2 ;<br>        k = k - 1 ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findElements ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) System . out . print ( arr [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findElements ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i <= n - 2 ;  i ++ ) {<br>        System . out . print ( arr [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MINIMUM_STEPS_TO_DELETE_A_STRING_AFTER_REPEATED_DELETION_OF_PALINDROME_SUBSTRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minStepToDeleteString ( String str ) {<br>  int N = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= N ;<br>  j ++ ) dp [ i ] [ j ] = 0 ;<br>  for ( int len = 1 ;<br>  len <= N ;<br>  len ++ ) {<br>    for ( int i = 0 , j = len - 1 ;<br>    j < N ;<br>    i ++ , j ++ ) {<br>      if ( len == 1 ) dp [ i ] [ j ] = 1 ;<br>      else {<br>        dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ;<br>        if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ;<br>        for ( int K = i + 2 ;<br>        K <= j ;<br>        K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ 0 ] [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minStepToDeleteString ( String str ) {<br>    int N = str . length ( ) ;<br>    int [ ] dp = new int [ N + 1 ] ;<br>    for ( int l = 1 ;  l <= N ;  l ++ ) {<br>        int i = 0 ;<br>        int j = l - 1 ;<br>        while ( j < N ) {<br>            if ( ( l == 1 ) && ( str != null ) ) {<br>                dp [ i ] [ j ] = 1 ;<br>            }<br>            if ( str != null ) {<br>                dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ;<br>                if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) && ( str . charAt ( i + 2 ) == str . charAt ( i + 3 ) ) ) {<br>                    dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ;<br>                }<br>                for ( K i = i + 2 ;  i <= j ;  i ++ ) {<br>                    if ( ( str . charAt ( i ) == str . charAt ( K ) ) && ( str . charAt ( K + 1 ) == str . charAt ( K + 2 ) ) ) {<br>                        dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ;<br>                    }<br>                }<br>            }<br>            i ++ ;<br>            j ++ ;<br>        }<br>    }<br>    return dp [ 0 ] [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>CALCULATE_AREA_TETRAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double vol_tetra ( int side ) {<br>  double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ;<br>  return volume ;<br>}<br></td>
    <td>translated code: <br><br> public static int volTetra ( int side ) {<br>    volume = ( side * side / ( 6 * Math . sqrt ( 2 ) ) ) ;<br>    return Math . round ( volume ) ;<br>}</td>
  </tr><tr>
    <th>SIEVE_OF_ATKIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int SieveOfAtkin ( int limit ) {<br>  if ( limit > 2 ) System . out . print ( 2 + " " ) ;<br>  if ( limit > 3 ) System . out . print ( 3 + " " ) ;<br>  boolean sieve [ ] = new boolean [ limit ] ;<br>  for ( int i = 0 ;<br>  i < limit ;<br>  i ++ ) sieve [ i ] = false ;<br>  for ( int x = 1 ;<br>  x * x < limit ;<br>  x ++ ) {<br>    for ( int y = 1 ;<br>    y * y < limit ;<br>    y ++ ) {<br>      int n = ( 4 * x * x ) + ( y * y ) ;<br>      if ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) + ( y * y ) ;<br>      if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ;<br>      n = ( 3 * x * x ) - ( y * y ) ;<br>      if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ;<br>    }<br>  }<br>  for ( int r = 5 ;<br>  r * r < limit ;<br>  r ++ ) {<br>    if ( sieve [ r ] ) {<br>      for ( int i = r * r ;<br>      i < limit ;<br>      i += r * r ) sieve [ i ] = false ;<br>    }<br>  }<br>  for ( int a = 5 ;<br>  a < limit ;<br>  a ++ ) if ( sieve [ a ] ) System . out . print ( a + " " ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static void SieveOfAtkin ( int limit ) {<br>    if ( ( limit > 2 ) && ( limit < 5 ) ) {<br>        System . out . print ( 2 + " " ) ;<br>    }<br>    if ( ( limit > 3 ) && ( limit < 5 ) ) {<br>        System . out . print ( 3 + " " ) ;<br>    }<br>    sieve = new boolean [ limit ] ;<br>    for ( int i = 0 ;  i <= limit ;  i ++ ) {<br>        sieve [ i ] = false ;<br>    }<br>    int x = 1 ;<br>    while ( ( x * x < limit ) && ( x * x < limit ) ) {<br>        int y = 1 ;<br>        while ( ( y * y < limit ) && ( y * y < limit ) ) {<br>            double n = ( 4 * x * x ) + ( y * y ) ;<br>            if ( ( n <= limit && ( n % 12 == 1 || n % 12 == 5 ) ) || ( n % 12 == 0 ) ){<br>                sieve [ n ] ^= true ;<br>            }<br>            double n = ( 3 * x * x ) + ( y * y ) ;<br>            if ( ( n <= limit && n % 12 == 7 ) || ( n % 12 == 0 ) ) {<br>                sieve [ n ] ^= true ;<br>            }<br>            double n = ( 3 * x * x ) - ( y * y ) ;<br>            if ( ( x > y && n <= limit && n % 12 == 11 ) || ( x > y && n > limit && n % 12 == 11 ) ) {<br>                sieve [ n ] ^= true ;<br>            }<br>            y ++ ;<br>        }<br>        x ++ ;<br>    }<br>    int r = 5 ;<br>    while ( ( r * r < limit ) && ( r * r < limit ) ) {<br>        if ( ( sieve [ r ] ) . length > limit ) {<br>            for ( int i = r * r ;  i < limit ;  i += r * r ) {<br>                sieve [ i ] = false ;<br>            }<br>        }<br>    }<br>    for ( int a = 5 ;  a < limit ;  a ++ ) {<br>        if ( ( sieve [ a ] = new Sieve ( limit ) ) . length > 0 ) {<br>            System . out . print ( a + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenghtOfLongestAP ( int set [ ] , int n ) {<br>  if ( n <= 2 ) return n ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  int llap = 2 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) L [ i ] [ n - 1 ] = 2 ;<br>  for ( int j = n - 2 ;<br>  j >= 1 ;<br>  j -- ) {<br>    int i = j - 1 , k = j + 1 ;<br>    while ( i >= 0 && k <= n - 1 ) {<br>      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;<br>      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {<br>        L [ i ] [ j ] = 2 ;<br>        i -- ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        llap = Math . max ( llap , L [ i ] [ j ] ) ;<br>        i -- ;<br>        k ++ ;<br>      }<br>    }<br>    while ( i >= 0 ) {<br>      L [ i ] [ j ] = 2 ;<br>      i -- ;<br>    }<br>  }<br>  return llap ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenghtOfLongestAP ( int [ ] set , int n ) {<br>    if ( ( n <= 2 ) && ( set . size ( ) > n ) ) {<br>        return n ;<br>    }<br>    int L [ ] = new int [ n ] ;<br>    int llap = 2 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        L [ i ] [ n - 1 ] = 2 ;<br>    }<br>    for ( int j = n - 2 ;  j > 0 ;  j -- ) {<br>        int i = j - 1 ;<br>        int k = j + 1 ;<br>        while ( ( i >= 0 && k <= n - 1 ) || ( i >= 0 && k <= n - 2 ) ) {<br>            if ( ( set [ i ] + set [ k ] < 2 * set [ j ] ) && ( set [ i ] + set [ k ] < 2 * set [ j ] ) ) {<br>                k ++ ;<br>            }<br>            if ( ( set [ i ] + set [ k ] > 2 * set [ j ] ) && ( set [ i ] + set [ k ] > 2 * set [ j ] ) ) {<br>                L [ i ] [ j ] = 2 ;<br>                i -- ;<br>            }<br>            else {<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>                llap = Math . max ( llap , L [ i ] [ j ] ) ;<br>                i -- ;<br>                k ++ ;<br>                while ( ( i >= 0 ) && ( i < n ) ) {<br>                    L [ i ] [ j ] = 2 ;<br>                    i -- ;<br>                }<br>            }<br>        }<br>    }<br>    return llap ;<br>}</td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countGroups ( int position , int previous_sum , int length , char [ ] num ) {<br>  if ( position == length ) return 1 ;<br>  if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ;<br>  dp [ position ] [ previous_sum ] = 0 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum += ( num [ i ] - '0' ) ;<br>    if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  dp [ position ] [ previous_sum ] = res ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countGroups ( int position , int previousSum , int length , char [ ] num ) {<br>    if ( ( position == length ) && ( previousSum == 0 ) ) {<br>        return 1 ;<br>    }<br>    if ( ( dp [ position ] [ previousSum ] != - 1 ) && ( length > 0 ) ) {<br>        return dp [ position ] [ previousSum ] ;<br>    }<br>    dp [ position ] [ previousSum ] = 0 ;<br>    int res = 0 ;<br>    sum = 0 ;<br>    for ( int i = position ;  i < length ;  i ++ ) {<br>        sum += ( ( char ) num . charAt ( i ) - '0' ) ;<br>        if ( ( sum >= previousSum ) && ( sum < previousSum ) ) {<br>            res += countGroups ( i + 1 , sum , length , num ) ;<br>        }<br>    }<br>    dp [ position ] [ previousSum ] = res ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestCommonSum ( int n ) {<br>  int maxLen = 0 ;<br>  int preSum1 = 0 , preSum2 = 0 ;<br>  int diff [ ] = new int [ 2 * n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < diff . length ;<br>  i ++ ) {<br>    diff [ i ] = - 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    preSum1 += arr1 [ i ] ;<br>    preSum2 += arr2 [ i ] ;<br>    int curr_diff = preSum1 - preSum2 ;<br>    int diffIndex = n + curr_diff ;<br>    if ( curr_diff == 0 ) maxLen = i + 1 ;<br>    else if ( diff [ diffIndex ] == - 1 ) diff [ diffIndex ] = i ;<br>    else {<br>      int len = i - diff [ diffIndex ] ;<br>      if ( len > maxLen ) maxLen = len ;<br>    }<br>  }<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestCommonSum ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>    int maxLen = 0 ;<br>    presum1 = presum2 = 0 ;<br>    int [ ] diff = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        presum1 += arr1 [ i ] ;<br>        presum2 += arr2 [ i ] ;<br>        int currDiff = presum1 - presum2 ;<br>        if ( currDiff == 0 ) {<br>            int maxLen = i + 1 ;<br>        }<br>        else if ( currDiff != null ) {<br>            diff [ currDiff ++ ] = i ;<br>        }<br>        else {<br>            int length = i - diff [ currDiff ] ;<br>            maxLen = Math . max ( maxLen , length ) ;<br>        }<br>    }<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFibonacciNumbers ( int n ) {<br>  int f1 = 0 , f2 = 1 , i ;<br>  if ( n < 1 ) return ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    System . out . print ( f2 + " " ) ;<br>    int next = f1 + f2 ;<br>    f1 = f2 ;<br>    f2 = next ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFibonacciNumbers ( int n ) {<br>    int f1 = 0 ;<br>    int f2 = 1 ;<br>    if ( ( n < 1 ) && ( n > 2 ) ) {<br>        }<br>    }<br>    for ( int x = 0 ;  x <= n ;  x ++ ) {<br>        System . out . print ( f2 + " " ) ;<br>        next = f1 + f2 ;<br>        f1 = f2 ;<br>        f2 = next ;<br>    }<br>}</td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here += a [ i ] ;<br>    if ( max_so_far < max_ending_here ) {<br>      max_so_far = max_ending_here ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( max_ending_here < 0 ) {<br>      max_ending_here = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  System . out . println ( "Maximum contiguous sum is " + max_so_far ) ;<br>  System . out . println ( "Starting index " + start ) ;<br>  System . out . println ( "Ending index " + end ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void maxSubArraySum ( int [ ] a , int size ) {<br>    maxSoFar = - maxsize - 1 ;<br>    int maxEndingHere = 0 ;<br>    int start = 0 ;<br>    int end = 0 ;<br>    int s = 0 ;<br>    for ( int i = 0 ;<br>        maxEndingHere += a [ i ] ;<br>        if ( maxSo_far < maxEndingHere ) {<br>            maxSoFar = maxEndingHere ;<br>            int start = s ;<br>            int end = i ;<br>        }<br>        if ( maxEndingHere < 0 ) {<br>            int maxEndingHere = 0 ;<br>            int s = i + 1 ;<br>        }<br>    System . out . println ( "Maximum contiguous sum is " + ( maxSoFar ) ) ;<br>    System . out . println ( "Starting Index " + ( start ++ ) ) ;<br>    System . out . println ( "Ending Index " + ( end - start ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_EQUAL_POINT_STRING_BRACKETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findIndex ( String str ) {<br>  int len = str . length ( ) ;<br>  int open [ ] = new int [ len + 1 ] ;<br>  int close [ ] = new int [ len + 1 ] ;<br>  int index = - 1 ;<br>  open [ 0 ] = 0 ;<br>  close [ len ] = 0 ;<br>  if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ;<br>  if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < len ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ;<br>    else open [ i + 1 ] = open [ i ] ;<br>  }<br>  for ( int i = len - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ;<br>    else close [ i ] = close [ i + 1 ] ;<br>  }<br>  if ( open [ len ] == 0 ) return len ;<br>  if ( close [ 0 ] == 0 ) return 0 ;<br>  for ( int i = 0 ;<br>  i <= len ;<br>  i ++ ) if ( open [ i ] == close [ i ] ) index = i ;<br>  return index ;<br>}<br></td>
    <td>translated code: <br><br> public static int findIndex ( String str ) {<br>    int l = str . length ( ) ;<br>    open = new int [ l + 1 ] ;<br>    close = new int [ l + 1 ] ;<br>    index = - 1 ;<br>    open [ 0 ] = 0 ;<br>    close [ l ++ ] = 0 ;<br>    if ( ( str . charAt ( 0 ) == '(' ) && ( str . charAt ( 1 ) == ')' ) ) {<br>        open [ 1 ] = 1 ;<br>    }<br>    if ( ( str . charAt ( l - 1 ) == ')' ) && ( str . charAt ( l - 1 ) == '(' ) ) {<br>        close [ l - 1 ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= l ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == '(' ) && ( str . charAt ( i + 1 ) == ')' ) ) {<br>            open [ i + 1 ] = open [ i ] + 1 ;<br>        }<br>        }<br>            open [ i + 1 ] = open [ i ] ;<br>    }<br>    for ( int i = l - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( str . charAt ( i ++ ) == ')' ) {<br>            close [ i ] = close [ i + 1 ] + 1 ;<br>        }<br>        }<br>            close [ i ] = close [ i + 1 ] ;<br>    }<br>    if ( ( open [ l ] == 0 ) && ( open [ l ] != - 1 ) ) {<br>        return str . indexOf ( "." ) ;<br>    }<br>    if ( ( close [ 0 ] == 0 ) && ( close [ 1 ] == 0 ) ) {<br>        return 0 ;<br>    }<br>    for ( int i = 0 ;  i < l + 1 ;  i ++ ) {<br>        if ( ( open [ i ] == close [ i ] ) && ( open [ i ] == close [ i ] ) ) {<br>            index = i ;<br>        }<br>    }<br>    return index ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countP ( int n , int k ) {<br>  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i <= k ;<br>  i ++ ) dp [ 0 ] [ k ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= k ;<br>  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;<br>  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ;<br>  return dp [ n ] [ k ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countP ( int n , int k ) {<br>    int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        dp [ i ] [ 0 ] = 0 ;<br>    }<br>    for ( int i = 0 ;  i < k + 1 ;  i ++ ) {<br>        dp [ 0 ] [ k ] = 0 ;<br>    }<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= k ;  j ++ ) {<br>            if ( ( j == 1 || i == j ) && ( k == 1 || i == k ) ) {<br>                dp [ i ] [ j ] = 1 ;<br>            }<br>            else{<br>                dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ n ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>LONGEST_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lis ( int arr [ ] , int n ) {<br>  max_ref = 1 ;<br>  _lis ( arr , n ) ;<br>  return max_ref ;<br>}<br></td>
    <td>translated code: <br><br> public static int lis ( int [ ] arr ) {<br>    maximum = arr ;<br>    int n = arr . length ;<br>    int maximum = 1 ;<br>    _lis ( arr , n ) ;<br>    return maximum ;<br>}</td>
  </tr><tr>
    <th>FIND_REPEATED_CHARACTER_PRESENT_FIRST_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeatFirstN2 ( String s ) {<br>  int p = - 1 , i , j ;<br>  for ( i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    for ( j = i + 1 ;<br>    j < s . length ( ) ;<br>    j ++ ) {<br>      if ( s . charAt ( i ) == s . charAt ( j ) ) {<br>        p = i ;<br>        break ;<br>      }<br>    }<br>    if ( p != - 1 ) break ;<br>  }<br>  return p ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeatFirstN2 ( String s ) {<br>    int p = - 1 ;<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < s . length ( ) ;  j ++ ) {<br>            if ( ( s . charAt ( i ) == s . charAt ( j ) ) && ( s . charAt ( i ) == s . charAt ( j ) ) ) {<br>                I2 p = i ;<br>                break ;<br>            }<br>        }<br>        if ( ( p != - 1 ) && ( p != 0 ) ) {<br>            break ;<br>        }<br>    }<br>    return p ;<br>}</td>
  </tr><tr>
    <th>K_TH_SMALLEST_ELEMENT_REMOVING_INTEGERS_NATURAL_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int ksmallest ( int arr [ ] , int n , int k ) {<br>  int b [ ] = new int [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    b [ arr [ i ] ] = 1 ;<br>  }<br>  for ( int j = 1 ;<br>  j < MAX ;<br>  j ++ ) {<br>    if ( b [ j ] != 1 ) {<br>      k -- ;<br>    }<br>    if ( k != 1 ) {<br>      return j ;<br>    }<br>  }<br>  return Integer . MAX_VALUE ;<br>}<br></td>
    <td>translated code: <br><br> public static int ksmallest ( int [ ] arr , int n , int k ) {<br>    int [ ] b = {<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        b [ arr [ i ] ] = 1 ;<br>    }<br>    for ( int j = 1 ;  j <= MAX ;  j ++ ) {<br>        if ( ( b [ j ] != 1 ) && ( b [ j ] != 2 ) ){<br>            k -- ;<br>        }<br>        if ( ( k != 1 ) && ( k != n ) ) {<br>            return j ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_IF_STACK_ELEMENTS_ARE_PAIRWISE_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean pairWiseConsecutive ( Stack < Integer > s ) {<br>  Stack < Integer > aux = new Stack < Integer > ( ) ;<br>  while ( ! s . isEmpty ( ) ) {<br>    aux . push ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  boolean result = true ;<br>  while ( aux . size ( ) > 1 ) {<br>    int x = aux . peek ( ) ;<br>    aux . pop ( ) ;<br>    int y = aux . peek ( ) ;<br>    aux . pop ( ) ;<br>    if ( Math . abs ( x - y ) != 1 ) result = false ;<br>    s . push ( x ) ;<br>    s . push ( y ) ;<br>  }<br>  if ( aux . size ( ) == 1 ) s . push ( aux . peek ( ) ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean pairWiseConsecutive ( Stack < Integer > s ) {<br>    String [ ] aux = new String [ 2 ] ;<br>    while ( ( s . length ( ) != 0 ) && ( s . charAt ( 0 ) != ' ' ) ) {<br>        aux . add ( s . charAt ( s . length ( ) - 1 ) ) ;<br>        s . pop ( ) ;<br>    }<br>    boolean result = true ;<br>    while ( ( aux . length ( ) > 1 ) && ( aux . charAt ( 0 ) == ' ' ) ) {<br>        int x = aux [ aux . length - 1 ] ;<br>        aux . remove ( ) ;<br>        int y = aux . get ( aux . length - 1 ) ;<br>        aux . remove ( ) ;<br>        if ( ( Math . abs ( x - y ) != 1 ) && ( Math . abs ( x - y ) != 2 ) ) {<br>            boolean result = false ;<br>        }<br>        s . add ( x -> {<br>        }<br>        s . add ( y ) ;<br>    }<br>    if ( ( aux . length ( ) == 1 ) && ( s . length ( ) == 2 ) ) {<br>        s . add ( aux . get ( s . size ( ) - 1 ) ) ;<br>    }<br>    return result -> {<br>    }<br>}</td>
  </tr><tr>
    <th>BINARY_SEARCH_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int binarySearch ( int arr [ ] , int x ) {<br>  int l = 0 , r = arr . length - 1 ;<br>  while ( l <= r ) {<br>    int m = l + ( r - l ) / 2 ;<br>    if ( arr [ m ] == x ) return m ;<br>    if ( arr [ m ] < x ) l = m + 1 ;<br>    else r = m - 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int binarySearch ( int [ ] arr , int l , int r , int x ) {<br>    while ( l <= r ) {<br>        int mid = l + ( r - l ) / 2 ;<br>        if ( arr [ mid ] == x ){<br>            return mid ;<br>        }<br>        else if ( arr [ mid ] < x ){<br>            l = mid + 1 ;<br>        }<br>        if ( arr == null ) {    return 0 ;  }  else {<br>            r = mid - 1 ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSubsequenceCount ( String S , String T ) {<br>  int m = T . length ( ) ;<br>  int n = S . length ( ) ;<br>  if ( m > n ) return 0 ;<br>  int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) mat [ i ] [ 0 ] = 0 ;<br>  for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) mat [ 0 ] [ j ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;<br>      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  return mat [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubsequenceCount ( String S , String T ) {<br>    int m = T . length ( ) ;<br>    int n = S . length ( ) ;<br>    if ( m > n ){<br>        return 0 ;<br>    }<br>    int [ ] [ ] mat = new int [ n + 1 ] [ m + 1 ] ;<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        mat [ i ] [ 0 ] = 0 ;<br>    }<br>    for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>        mat [ 0 ] [ j ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            if ( T [ i - 1 ] != S [ j - 1 ] ) {<br>                mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;<br>            }<br>            else {<br>                mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return mat [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void swap ( int [ ] xp , int [ ] yp ) {<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void swap ( int [ ] xp , int [ ] yp ) {<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>POLICEMEN_CATCH_THIEVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int policeThief ( char arr [ ] , int n , int k ) {<br>  int res = 0 ;<br>  ArrayList < Integer > thi = new ArrayList < Integer > ( ) ;<br>  ArrayList < Integer > pol = new ArrayList < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 'P' ) pol . add ( i ) ;<br>    else if ( arr [ i ] == 'T' ) thi . add ( i ) ;<br>  }<br>  int l = 0 , r = 0 ;<br>  while ( l < thi . size ( ) && r < pol . size ( ) ) {<br>    if ( Math . abs ( thi . get ( l ) - pol . get ( r ) ) <= k ) {<br>      res ++ ;<br>      l ++ ;<br>      r ++ ;<br>    }<br>    else if ( thi . get ( l ) < pol . get ( r ) ) l ++ ;<br>    else r ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int policeThief ( char [ ] arr , int n , int k ) {<br>    int i = 0 ;<br>    int l = 0 ;<br>    int r = 0 ;<br>    int res = 0 ;<br>    int [ ] thi = new int [ n ] ;<br>    int [ ] pol = new int [ n ] ;<br>    while ( i < n ) {<br>        if ( arr [ i ] == 'P' ) {<br>            pol . add ( i ) ;<br>        }<br>        else if ( arr [ i ] == 'T' ) {<br>            thi . add ( i ) ;<br>        }<br>        i ++ ;<br>    }<br>    while ( l < thi . length && r < pol . length ){<br>        if ( ( Math . abs ( thi [ l ] - pol [ r ] ) <= k ) && ( n > 0 ) ){<br>            res ++ ;<br>            l ++ ;<br>            r ++ ;<br>        }<br>        if ( thi [ l ] < pol [ r ] ){<br>            l ++ ;<br>        }<br>        else {<br>            r ++ ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int maxLen ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ;<br>  int sum = 0 ;<br>  int max_len = 0 ;<br>  int ending_index = - 1 ;<br>  int start_index = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    if ( sum == 0 ) {<br>      max_len = i + 1 ;<br>      ending_index = i ;<br>    }<br>    if ( hM . containsKey ( sum + n ) ) {<br>      if ( max_len < i - hM . get ( sum + n ) ) {<br>        max_len = i - hM . get ( sum + n ) ;<br>        ending_index = i ;<br>      }<br>    }<br>    else hM . put ( sum + n , i ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;<br>  }<br>  int end = ending_index - max_len + 1 ;<br>  System . out . println ( end + " to " + ending_index ) ;<br>  return max_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLen ( int [ ] arr , int n ) {<br>    HashMap < Integer , Integer > hashMap = new HashMap < Integer , Integer > ( ) ;<br>    int currSum = 0 ;<br>    int maxLen = 0 ;<br>    int endingIndex = - 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] == 0 ) && ( n > 0 ) ) {<br>            arr [ i ++ ] = - 1 ;<br>        }<br>        else {<br>            arr [ i ++ ] = 1 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        currSum = currSum + arr [ i ] ;<br>        if ( ( currSum == 0 ) && ( n > 0 ) ) {<br>            int maxLen = i + 1 ;<br>            endingIndex = i ;<br>        }<br>        if ( ( currSum + n ) < hashMap . length ) {<br>            maxLen = Math . max ( maxLen , i - hashMap [ currSum + n ] ) ;<br>        }<br>        else {<br>            hashMap [ currSum ++ ] = i -> hashMap [ currSum ] = i ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] == - 1 ) && ( n > 0 ) ) {<br>            arr [ i ++ ] = 0 ;<br>        }<br>        else {<br>            arr [ i ++ ] = 1 ;<br>        }<br>    }<br>    System . out . print ( endingIndex - maxLen + 1 + " " ) ;<br>    System . out . print ( "to" ) ;<br>    System . out . println ( endingIndex ) ;<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_ZEROS_ONES_BINARY_STRING_SET_2_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int findLength ( String str , int n ) {<br>  int current_sum = 0 ;<br>  int max_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ;<br>    if ( current_sum < 0 ) current_sum = 0 ;<br>    max_sum = Math . max ( current_sum , max_sum ) ;<br>  }<br>  return max_sum == 0 ? - 1 : max_sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLength ( String string , int n ) {<br>    currentSum = 0 ;<br>    int maxSum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        current_sum += ( 1 == string . charAt ( i ) ? - 1 : n ) ;<br>        if ( currentSum < 0 ){<br>            currentSum = 0 ;<br>        }<br>        maxSum = Math . max ( currentSum , maxSum ) ;<br>    }<br>    return maxSum == 0 ? 0 : findLength ( string , n ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findLongestConseqSubseq ( int arr [ ] , int n ) {<br>  HashSet < Integer > S = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) S . add ( arr [ i ] ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( S . contains ( arr [ i ] ) ) {<br>      int j = arr [ i ] ;<br>      while ( S . contains ( j ) ) j ++ ;<br>      ans = Math . max ( ans , j - arr [ i ] ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findLongestConseqSubseq ( int [ ] arr , int n ) {<br>    Set < Integer > S = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        S . add ( arr [ i ] ) ;<br>    }<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( S . contains ( arr [ i ] ) ) {<br>            int j = arr [ i ++ ] ;<br>            while ( ( S . contains ( j ) ) && ( n > 0 ) ) {<br>                j ++ ;<br>            }<br>            ans = Math . max ( ans , j - arr [ i ] ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>LEXICOGRAPHICALLY_NEXT_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String nextWord ( String str ) {<br>  if ( str == "" ) return "a" ;<br>  int i = str . length ( ) - 1 ;<br>  while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ;<br>  if ( i == - 1 ) str = str + 'a' ;<br>  else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ;<br>  return str ;<br>}<br></td>
    <td>translated code: <br><br> public static String nextWord ( String s ) {<br>    if ( ( s . equals ( " " ) ) && ( a == 5 ) ) {<br>        return "a" ;<br>    }<br>    int i = s . length ( ) - 1 ;<br>    while ( ( s . charAt ( i ++ ) == 'z' ) && i >= 0 ) {<br>        i -- ;<br>    }<br>    if ( ( i == - 1 ) && ( s . length ( ) > 0 ) ){<br>        sb . append ( 'a' ) ;<br>    }<br>    else{<br>        s = s . replace ( s . charAt ( i ) , ( char ) ( Character . MAX_VALUE + 1 ) , 1 ) ;<br>    }<br>    return s ;<br>}</td>
  </tr><tr>
    <th>SCHEDULE_JOBS_SERVER_GETS_EQUAL_LOAD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int a [ ] , int b [ ] , int n ) {<br>  int i ;<br>  int s = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) s += ( a [ i ] + b [ i ] ) ;<br>  if ( n == 1 ) return a [ 0 ] + b [ 0 ] ;<br>  if ( s % n != 0 ) return - 1 ;<br>  int x = s / n ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] > x ) return - 1 ;<br>    if ( i > 0 ) {<br>      a [ i ] += b [ i - 1 ] ;<br>      b [ i - 1 ] = 0 ;<br>    }<br>    if ( a [ i ] == x ) continue ;<br>    int y = a [ i ] + b [ i ] ;<br>    if ( i + 1 < n ) y += b [ i + 1 ] ;<br>    if ( y == x ) {<br>      a [ i ] = y ;<br>      b [ i ] = 0 ;<br>      continue ;<br>    }<br>    if ( a [ i ] + b [ i ] == x ) {<br>      a [ i ] += b [ i ] ;<br>      b [ i ] = 0 ;<br>      continue ;<br>    }<br>    if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) {<br>      a [ i ] += b [ i + 1 ] ;<br>      b [ i + 1 ] = 0 ;<br>      continue ;<br>    }<br>    return - 1 ;<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) if ( b [ i ] != 0 ) return - 1 ;<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] a , int [ ] b , int n ) {<br>    int s = 0 ;<br>    for ( int i = 0 ;  i <= n ;{<br>        s += a [ i ] + b [ i ] ;<br>    }<br>    if ( n == 1 ){<br>        return solve ( a , 0 , a . length , b , 0 , b . length ) ;<br>    }<br>    if ( s % n != 0 ){<br>        return - 1 ;<br>    }<br>    int x = s / n ;<br>    for ( int i = 0 ;  i <= n ;{<br>        if ( a [ i ] > x ) a [ i ] = 5 ;<br>            return - 1 ;<br>        if ( i > 0 ){<br>            a [ i ] += b [ i - 1 ] ;<br>            b [ i - 1 ] = 0 ;<br>        }<br>        if ( a [ i ] == x ) a [ i ] = 5 ;<br>            continue ;<br>        int y = a [ i ] + b [ i ] ;<br>        if ( i ++ < n ){<br>            y += b [ i + 1 ] ;<br>        }<br>        if ( y == x ){<br>            a [ i ] = y ;<br>            b [ i ] = 0 ;<br>            if ( i ++ < n ){<br>                b [ i + 1 ] = 0 ;<br>            }<br>            continue ;<br>        }<br>        if ( a [ i ] + b [ i ] == x ) a [ i ] = 5 ;<br>            a [ i ] += b [ i ] ;<br>            b [ i ] = 0 ;<br>            continue ;<br>        if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) a [ i ] = 5 ;<br>            a [ i ] += b [ i + 1 ] ;<br>            b [ i + 1 ] = 0 ;<br>            continue ;<br>        return - 1 ;<br>    }<br>    for ( int i = 0 ;  i <= n ;{<br>        if ( b [ i ] != 0 ){<br>            return - 1 ;<br>        }<br>    }<br>    return x ;<br>}</td>
  </tr><tr>
    <th>FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String getMinNumberForPattern ( String seq ) {<br>  int n = seq . length ( ) ;<br>  if ( n >= 9 ) return "-1" ;<br>  char result [ ] = new char [ n + 1 ] ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i == n || seq . charAt ( i ) == 'I' ) {<br>      for ( int j = i - 1 ;<br>      j >= - 1 ;<br>      j -- ) {<br>        result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ;<br>        if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;<br>      }<br>    }<br>  }<br>  return new String ( result ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String getMinNumberForPattern ( String seq ) {<br>    int n = list . size ( ) ;<br>    if ( ( n >= 9 ) && ( n <= 10 ) ) {<br>        return "-1" ;<br>    }<br>    int [ ] result = new int [ n + 1 ] ;<br>    int count = 1 ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        if ( ( i == n || seq . charAt ( i ) == 'I' ) && ( i != 0 || seq . charAt ( i ) == 'O' ) ) {<br>            for ( int j = i - 1 ;  j >= 2 ;  j -- ) {<br>                result [ j + 1 ] = Integer . parseInt ( "0" + count ++ ) ;<br>                count ++ ;<br>                if ( ( j >= 0 && seq . charAt ( j ) == 'I' ) || ( j >= 0 && seq . charAt ( j ) == 'J' ) ) {<br>                    break ;<br>                }<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SHUFFLE_2N_INTEGERS_FORMAT_A1_B1_A2_B2_A3_B3_BN_WITHOUT_USING_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void shuffleArray ( int a [ ] , int n ) {<br>  for ( int i = 0 , q = 1 , k = n ;<br>  i < n ;<br>  i ++ , k ++ , q ++ ) for ( int j = k ;<br>  j > i + q ;<br>  j -- ) {<br>    int temp = a [ j - 1 ] ;<br>    a [ j - 1 ] = a [ j ] ;<br>    a [ j ] = temp ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shuffleArray ( int [ ] a , int n ) {<br>    int i = 0 , q = 1 , k = n ;<br>    while ( ( i = a ) < n ) {<br>        int j = k ;<br>        while ( ( j > i + q ) && ( j < i + q ) ) {<br>            a [ j - 1 ] = a [ j ] ;<br>            j -- ;<br>        }<br>        i ++ ;<br>        k ++ ;<br>        q ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . contains ( arr [ i ] ) ) return arr [ i ] ;<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == s ) {<br>            return findRepeating ( arr , i -> n - i ) ;<br>        }<br>        s . add ( arr [ i ] ) ;<br>    }<br>    return rteurn - 1 ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_SUBTRACTION_MATICES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) {<br>  int i , j ;<br>  for ( i = 0 ;<br>  i < N ;<br>  i ++ ) for ( j = 0 ;<br>  j < N ;<br>  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void multiply ( int [ ] [ ] A , int [ ] [ ] B , int [ ] [ ] C ) {<br>    for ( int i = 0 ;  i < N ;{<br>        for ( int j = 0 ;  j < N ;{<br>            C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIRST_NEGATIVE_INTEGER_EVERY_WINDOW_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) {<br>  boolean flag ;<br>  for ( int i = 0 ;<br>  i < ( n - k + 1 ) ;<br>  i ++ ) {<br>    flag = false ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      if ( arr [ i + j ] < 0 ) {<br>        System . out . print ( ( arr [ i + j ] ) + " " ) ;<br>        flag = true ;<br>        break ;<br>      }<br>    }<br>    if ( ! flag ) System . out . print ( "0" + " " ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printFirstNegativeInteger ( int [ ] arr , int n , int k ) {<br>    for ( int i = 0 ;  i <= ( n - k + 1 ) ;  i ++ ) {<br>        boolean flag = false ;<br>        for ( int j = 0 ;  j <= k ;  j ++ ) {<br>            if ( ( arr [ i + j ] < 0 ) && ( arr [ i + j ] > n ) ) {<br>                System . out . print ( arr [ i + j ] + " " ) ;<br>                flag = true ;<br>                break ;<br>            }<br>        }<br>        if ( ( ! ( flag ) ) && ( n > 0 ) ) {<br>            System . out . print ( "0" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>NUMBER_FULL_BINARY_TREES_NODE_PRODUCT_CHILDREN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numoffbt ( int arr [ ] , int n ) {<br>  int maxvalue = - 2147483647 ;<br>  int minvalue = 2147483647 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    maxvalue = Math . max ( maxvalue , arr [ i ] ) ;<br>    minvalue = Math . min ( minvalue , arr [ i ] ) ;<br>  }<br>  int mark [ ] = new int [ maxvalue + 2 ] ;<br>  int value [ ] = new int [ maxvalue + 2 ] ;<br>  Arrays . fill ( mark , 0 ) ;<br>  Arrays . fill ( value , 0 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    mark [ arr [ i ] ] = 1 ;<br>    value [ arr [ i ] ] = 1 ;<br>  }<br>  int ans = 0 ;<br>  for ( int i = minvalue ;<br>  i <= maxvalue ;<br>  i ++ ) {<br>    if ( mark [ i ] != 0 ) {<br>      for ( int j = i + i ;<br>      j <= maxvalue && j / i <= i ;<br>      j += i ) {<br>        if ( mark [ j ] == 0 ) continue ;<br>        value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>        if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>      }<br>    }<br>    ans += value [ i ] ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numoffbt ( int [ ] arr , int n ) {<br>    int maxvalue = - 2147483647 ;<br>    int minvalue = 2147483647 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        maxvalue = Math . max ( maxvalue , arr [ i ] ) ;<br>        minvalue = Math . min ( minvalue , arr [ i ] ) ;<br>    }<br>    int [ ] mark = new int [ maxvalue + 2 ] ;<br>    int [ ] value = new int [ maxvalue + 2 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        mark [ arr [ i ] ] = 1 ;<br>        value [ arr [ i ] ] = 1 ;<br>    }<br>    int ans = 0 ;<br>    for ( int i = minvalue ;  i <= maxvalue ;  i ++ ) {<br>        if ( ( mark [ i ] != 0 ) && ( mark [ i ] != n ) ){<br>            int j = i + i ;<br>            while ( ( j <= maxvalue && j / i <= i ) || ( j % i == 0 ) ){<br>                if ( ( mark [ j ] == 0 ) && ( n > 0 ) ){<br>                    continue ;<br>                }<br>                value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>                if ( ( i != j / i ) && ( n != 0 ) ){<br>                    value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ;<br>                }<br>                j += i ;<br>            }<br>        }<br>        ans += value [ i ] ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>TRIANGULAR_MATCHSTICK_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int numberOfSticks ( int x ) {<br>  return ( 3 * x * ( x + 1 ) ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberOfSticks ( int x ) {<br>    return ( 3 * x * ( x + 1 ) ) / 2 ;<br>}</td>
  </tr><tr>
    <th>K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) {<br>  PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) pq . add ( A [ i ] + B [ j ] ) ;<br>  int count = 0 ;<br>  while ( count < K ) {<br>    System . out . println ( pq . peek ( ) ) ;<br>    pq . remove ( ) ;<br>    count ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void KMaxCombinations ( int [ ] A , int [ ] B , int N , int K ) {<br>    PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ;<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        for ( int j = 0 ;  j <= N ;  j ++ ) {<br>            int a = A [ i ] + B [ j ] ;<br>            pq . put ( new Pair ( - a , a ) ) ;<br>        }<br>    }<br>    int count = 0 ;<br>    while ( ( count < K ) && ( count < N ) ) {<br>        System . out . println ( pq . get ( ) . get ( 1 ) ) ;<br>        count = count + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>CONSTRUCT_ARRAY_PAIR_SUM_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void constructArr ( int arr [ ] , int pair [ ] , int n ) {<br>  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void constructArr ( int [ ] arr , int [ ] pair , int n ) {<br>    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkCorrectOrNot ( String s ) {<br>  int [ ] count1 = new int [ MAX_CHAR ] ;<br>  int [ ] count2 = new int [ MAX_CHAR ] ;<br>  int n = s . length ( ) ;<br>  if ( n == 1 ) return true ;<br>  for ( int i = 0 , j = n - 1 ;<br>  i < j ;<br>  i ++ , j -- ) {<br>    count1 [ s . charAt ( i ) - 'a' ] ++ ;<br>    count2 [ s . charAt ( j ) - 'a' ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < MAX_CHAR ;<br>  i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkCorrectOrNot ( String s ) {<br>    MAX_CHAR = s . length ( ) ;<br>    int [ ] count1 = {<br>    }<br>    int count2 = new int [ MAX_CHAR ] ;<br>    int n = s . length ( ) ;<br>    if ( n == 1 ) {<br>        return true ;<br>    }<br>    int i = 0 ;<br>    while ( ( i < j ) && ( i < j ) ) {<br>        count1 [ ( int ) s . charAt ( i ) - 'a' ] ++ ;<br>        count2 [ ( int ) s . charAt ( j ) - 'a' ] ++ ;<br>        i ++ ;<br>    }<br>    for ( int i = 0 ;  i < MAX_CHAR ;  i ++ ) {<br>        if ( count1 [ i ] != count2 [ i ] ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinDiff ( int arr [ ] , int n , int k ) {<br>  if ( n == 1 ) return 0 ;<br>  Arrays . sort ( arr ) ;<br>  int ans = arr [ n - 1 ] - arr [ 0 ] ;<br>  int small = arr [ 0 ] + k ;<br>  int big = arr [ n - 1 ] - k ;<br>  int temp = 0 ;<br>  if ( small > big ) {<br>    temp = small ;<br>    small = big ;<br>    big = temp ;<br>  }<br>  for ( int i = 1 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    int subtract = arr [ i ] - k ;<br>    int add = arr [ i ] + k ;<br>    if ( subtract >= small || add <= big ) continue ;<br>    if ( big - subtract <= add - small ) small = subtract ;<br>    else big = add ;<br>  }<br>  return Math . min ( ans , big - small ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinDiff ( int [ ] arr , int n , int k ) {<br>    if ( ( n == 1 ) && ( k == 1 ) ) {<br>        return 0 ;<br>    }<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int ans = arr [ n - 1 ] - arr [ 0 ] ;<br>    int small = arr [ 0 ] + k ;<br>    int big = arr [ n - 1 ] - k ;<br>    if ( ( small > big ) && ( small < big ) ) {<br>        int small = big , big = small ;<br>    }<br>    for ( int i = 1 ;  i <= n - 1 ;  i ++ ) {<br>        int subtract = arr [ i ] - k ;<br>        int add = arr [ i ] + k ;<br>        if ( ( subtract >= small || add <= big ) && ( n >= small || add <= big ) ){<br>            continue ;<br>        }<br>        if ( ( big - subtract <= add - small ) && ( big - add <= big - small ) ){<br>            small = subtract ;<br>        }<br>        else {<br>            big = add ;<br>        }<br>    }<br>    return Math . min ( ans , big - small ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void pairs ( int arr [ ] , int n , int k ) {<br>  int smallest = Integer . MAX_VALUE ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) {<br>    if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {<br>      smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;<br>      count = 1 ;<br>    }<br>    else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ;<br>  }<br>  System . out . println ( "Minimal Value = " + smallest ) ;<br>  System . out . println ( "Total Pairs = " + count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void pairs ( int [ ] arr , int n , int k ) {<br>    int smallest = 999999999999 ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ){<br>                int smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;<br>                int count = 1 ;<br>            }<br>            if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ){<br>                count ++ ;<br>            }<br>        }<br>    }<br>    System . out . println ( "Minimal Value = " + smallest ) ;<br>    System . out . println ( "Total Pairs = " + count ) ;<br>}</td>
  </tr><tr>
    <th>SIZE_SUBARRAY_MAXIMUM_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] , int size ) {<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here += a [ i ] ;<br>    if ( max_so_far < max_ending_here ) {<br>      max_so_far = max_ending_here ;<br>      start = s ;<br>      end = i ;<br>    }<br>    if ( max_ending_here < 0 ) {<br>      max_ending_here = 0 ;<br>      s = i + 1 ;<br>    }<br>  }<br>  return ( end - start + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>    maxSoFar = - maxsize - 1 ;<br>    int maxEndingHere = 0 ;<br>    int start = 0 ;<br>    int end = 0 ;<br>    int s = 0 ;<br>    for ( int i = 0 ;<br>        maxEndingHere += a [ i ] ;<br>        if ( maxSo_far < maxEndingHere ) {<br>            maxSoFar = maxEndingHere ;<br>            int start = s ;<br>            int end = i ;<br>        }<br>        if ( maxEndingHere < 0 ) {<br>            int maxEndingHere = 0 ;<br>            int s = i + 1 ;<br>        }<br>    return ( end - start + 1 ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMinSquares ( int n ) {<br>  if ( n <= 3 ) return n ;<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = 0 ;<br>  dp [ 1 ] = 1 ;<br>  dp [ 2 ] = 2 ;<br>  dp [ 3 ] = 3 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i ++ ) {<br>    dp [ i ] = i ;<br>    for ( int x = 1 ;<br>    x <= Math . ceil ( Math . sqrt ( i ) ) ;<br>    x ++ ) {<br>      int temp = x * x ;<br>      if ( temp > i ) break ;<br>      else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ;<br>    }<br>  }<br>  int res = dp [ n ] ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMinSquares ( int n ) {<br>    int [ ] dp = {<br>    }<br>    for ( int i = 4 ;  i <= n ;  i ++ ) {<br>        dp . add ( i ) ;<br>        for ( int x = 1 ;  x <= ( int ) Math . ceil ( Math . sqrt ( i ) ) ;  x ++ ) {<br>            int temp = x * x ;<br>            if ( temp > i ){<br>                break ;<br>            }<br>            else{<br>                dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>DIVISIBILITY_BY_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisibleBy7 ( int num ) {<br>  if ( num < 0 ) return isDivisibleBy7 ( - num ) ;<br>  if ( num == 0 || num == 7 ) return true ;<br>  if ( num < 10 ) return false ;<br>  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisibleBy7 ( int num ) {<br>    if ( num < 0 ) {<br>        return isDivisibleBy7 ( - num ) ;<br>    }<br>    if ( ( num == 0 || num == 7 ) && ( num % 2 == 0 ) ) {<br>        return true ;<br>    }<br>    if ( ( num < 10 ) && ( num > 7 ) ) {<br>        return false ;<br>    }<br>    return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ;<br>}</td>
  </tr><tr>
    <th>POSITION_OF_RIGHTMOST_SET_BIT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Right_most_setbit ( int num ) {<br>  int pos = 1 ;<br>  for ( int i = 0 ;<br>  i < INT_SIZE ;<br>  i ++ ) {<br>    if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ;<br>    else break ;<br>  }<br>  return pos ;<br>}<br></td>
    <td>translated code: <br><br> public static int Right_most_setbit ( int num ) {<br>    pos = 1 ;<br>    for ( int i = 0 ;  i < INT_SIZE ;  i ++ ) {<br>        if ( ! ( num & ( 1 << i ) ) ){<br>            pos ++ ;<br>        }<br>        else {<br>            break ;<br>        }<br>    }<br>    return pos ;<br>}</td>
  </tr><tr>
    <th>EFFICIENT_WAY_TO_MULTIPLY_WITH_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int multiplyBySeven ( int n ) {<br>  return ( ( n << 3 ) - n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int multiplyBySeven ( int n ) {<br>    return ( ( n << 3 ) - n ) ;<br>}</td>
  </tr><tr>
    <th>NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int snoob ( int x ) {<br>  int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ;<br>  if ( x > 0 ) {<br>    rightOne = x & - x ;<br>    nextHigherOneBit = x + rightOne ;<br>    rightOnesPattern = x ^ nextHigherOneBit ;<br>    rightOnesPattern = ( rightOnesPattern ) / rightOne ;<br>    rightOnesPattern >>= 2 ;<br>    next = nextHigherOneBit | rightOnesPattern ;<br>  }<br>  return next ;<br>}<br></td>
    <td>translated code: <br><br> public static int snoob ( int x ) {<br>    next = 0 ;<br>    if ( ( x ) . equals ( null ) ) {<br>        int rightOne = x & - ( x ) ;<br>        nextHigherOneBit = x + ( int ) rightOne ;<br>        rightOnesPattern = x ^ ( int ) nextHigherOneBit ;<br>        rightOnesPattern = ( int ) rightOnesPattern / ( int ) rightOne ;<br>        rightOnesPattern = Integer . numberOfTrailingZeros ( x ) >> 2 ;<br>        next = nextHigherOneBit | rightOnesPattern ;<br>    }<br>    return next ;<br>}</td>
  </tr><tr>
    <th>CHANGE_ARRAY_PERMUTATION_NUMBERS_1_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void makePermutation ( int [ ] a , int n ) {<br>  HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . containsKey ( a [ i ] ) ) {<br>      count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      count . put ( a [ i ] , 1 ) ;<br>    }<br>  }<br>  int next_missing = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 || a [ i ] > n || a [ i ] < 1 ) {<br>      count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ;<br>      while ( count . containsKey ( next_missing ) ) next_missing ++ ;<br>      a [ i ] = next_missing ;<br>      count . put ( next_missing , 1 ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void makePermutation ( int [ ] a , int n ) {<br>    Map < Integer , Integer > count = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    for ( int i = 0 ;  i < n ;{<br>        if ( count . contains ( a [ i ] ) ) a [ i ] = 5 ;<br>            count [ a [ i ] ] ++ ;<br>        if ( n > 0 ) {<br>            count [ a [ i ] ] = 1 ;<br>        }<br>    }<br>    nextMissing = 1 ;<br>    for ( int i = 0 ;  i < n ;{<br>        if ( count [ a [ i ] ] != 1 || a [ i ] > n || a [ i ] < 1 ) a [ i ] = 5 ;<br>            count [ a [ i ] ] -- ;<br>            while ( count . get ( nextMissing ) ){<br>                nextMissing ++ ;<br>            }<br>            a [ i ++ ] = nextMissing ;<br>            count [ nextMissing ++ ] = 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_AREA_QUADRILATERAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double maxArea ( double a , double b , double c , double d ) {<br>  double semiperimeter = ( a + b + c + d ) / 2 ;<br>  return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double maxArea ( double a , double b , double c , double d ) {<br>    double semiPerimeter = ( a + b + c + d ) / 2 ;<br>    return Math . sqrt ( ( semiPerimeter - a ) * ( semiPerimeter - b ) * ( semiPerimeter - c ) * ( semiPerimeter - d ) ) ;<br>}</td>
  </tr><tr>
    <th>REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void translate ( char str [ ] ) {<br>  int len = str . length ;<br>  if ( len < 2 ) return ;<br>  int i = 0 ;<br>  int j = 0 ;<br>  while ( j < len - 1 ) {<br>    if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {<br>      j = j + 2 ;<br>      str [ i ++ ] = 'C' ;<br>      continue ;<br>    }<br>    str [ i ++ ] = str [ j ++ ] ;<br>  }<br>  if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;<br>  str [ i ] = ' ' ;<br>  str [ len - 1 ] = ' ' ;<br>}<br></td>
    <td>translated code: <br><br> public static void translate ( String st ) {<br>    int l = st . length ( ) ;<br>    if ( ( l < 2 ) && ( l > 0 ) ){<br>        }<br>    }<br>    int i = 0 ;<br>    int j = 0 ;<br>    while ( ( j < l - 1 ) && ( j < l ) ){<br>        if ( ( st . charAt ( j ) == 'A' && st . charAt ( j + 1 ) == 'B' ) || ( st . charAt ( j ) == 'C' && st . charAt ( j + 1 ) == 'D' ) ){<br>            j += 2 ;<br>            st . charAt ( i ++ ) = 'C' ;<br>            i ++ ;<br>            continue ;<br>        }<br>        st [ i ] = st [ j ] ;<br>        i ++ ;<br>        j ++ ;<br>    }<br>    if ( ( j == l - 1 ) && ( j != 0 ) ){<br>        st [ i ] = st [ j ] ;<br>        i ++ ;<br>    }<br>    st . charAt ( i ++ ) = ' ' ;<br>    st . charAt ( l - 1 ) = ' ' ;<br>}</td>
  </tr><tr>
    <th>FIND_POWER_POWER_MOD_PRIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int Calculate ( int A , int B , int C , int M ) {<br>  int res , ans ;<br>  res = power ( B , C , M - 1 ) ;<br>  ans = power ( A , res , M ) ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int calculate ( int A , int B , int C , int M ) {<br>    int res = pow ( B , C , M - 1 ) ;<br>    double ans = pow ( A , res , M ) ;<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>CHECK_EXIST_TWO_ELEMENTS_ARRAY_WHOSE_SUM_EQUAL_SUM_REST_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkPair ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>  }<br>  if ( sum % 2 != 0 ) {<br>    return false ;<br>  }<br>  sum = sum / 2 ;<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int val = sum - arr [ i ] ;<br>    if ( s . contains ( val ) && val == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) {<br>      System . out . printf ( "Pair elements are %d and %d\n" , arr [ i ] , val ) ;<br>      return true ;<br>    }<br>    s . add ( arr [ i ] ) ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkPair ( int [ ] arr , int n ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        sum += arr [ i ] ;<br>    }<br>    if ( sum % 2 != 0 ){<br>        return false ;<br>    }<br>    sum = sum / 2 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int val = sum - arr [ i ] ;<br>        if ( arr [ i ] != s ){<br>            s . add ( arr [ i ] ) ;<br>        }<br>        if ( val == s ){<br>            System . out . println ( "Pair elements are" + arr [ i ] + " and" + Integer . toString ( val ) ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double surface_area_octahedron ( double side ) {<br>  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double surfaceAreaOCTAhedron ( double side ) {<br>    return ( 2 * ( Math . sqrt ( 3 ) ) ) * ( side * side ) ;<br>}</td>
  </tr><tr>
    <th>FIND_A_SPECIFIC_PAIR_IN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxValue ( int N , int mat [ ] [ ] ) {<br>  int maxValue = Integer . MIN_VALUE ;<br>  for ( int a = 0 ;<br>  a < N - 1 ;<br>  a ++ ) for ( int b = 0 ;<br>  b < N - 1 ;<br>  b ++ ) for ( int d = a + 1 ;<br>  d < N ;<br>  d ++ ) for ( int e = b + 1 ;<br>  e < N ;<br>  e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ;<br>  return maxValue ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxValue ( int [ ] [ ] mat ) {<br>    int maxValue = 0 ;<br>    for ( int a = 0 ;<br>        for ( int b = 0 ;  b < N - 1 ;  b ++ ) {<br>            for ( int d = a + 1 ;  d < N ;{<br>                for ( int e = b + 1 ;  e < N ;{<br>                    if ( maxValue < Integer . MAX_VALUE ) {<br>                        int maxValue = ( int ) ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ;<br>                    }<br>                }<br>            }<br>        }<br>    return maxValue ;<br>}</td>
  </tr><tr>
    <th>MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_OPERATORS_AND_NO_LOOPS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int multiply ( int x , int y ) {<br>  if ( y == 0 ) return 0 ;<br>  if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;<br>  if ( y < 0 ) return - multiply ( x , - y ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int multiply ( int x , int y ) {<br>    if ( ( y == 0 ) && ( x == 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( y > 0 ) && ( x > 0 ) ) {<br>        return ( x + multiply ( x , y - 1 ) ) ;<br>    }<br>    if ( ( y < 0 ) && ( x < 0 ) ) {<br>        return - multiply ( x , - y ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int arr [ ] , int n ) {<br>  boolean found = false ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) {<br>      int x = - ( arr [ i ] + arr [ j ] ) ;<br>      if ( s . contains ( x ) ) {<br>        System . out . printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ;<br>        found = true ;<br>      }<br>      else {<br>        s . add ( arr [ j ] ) ;<br>      }<br>    }<br>  }<br>  if ( found == false ) {<br>    System . out . printf ( " No Triplet Found\n" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int [ ] arr , int n ) {<br>    boolean found = false ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        Set < Integer > s = new HashSet < Integer > ( ) ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            int x = - ( arr [ i ] + arr [ j ] ) ;<br>            if ( x == s ){<br>                System . out . println ( x + " " + arr [ i ] + " " + arr [ j ] ) ;<br>                found = true ;<br>            }<br>            else {<br>                s . add ( arr [ j ] ) ;<br>            }<br>        }<br>    }<br>    if ( found == false ) {<br>        System . out . println ( "No Triplet Found" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_VALUE_OF_SUM_IARRI_WITH_ONLY_ROTATIONS_ON_GIVEN_ARRAY_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( ) {<br>  int arrSum = 0 ;<br>  int currVal = 0 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    arrSum = arrSum + arr [ i ] ;<br>    currVal = currVal + ( i * arr [ i ] ) ;<br>  }<br>  int maxVal = currVal ;<br>  for ( int j = 1 ;<br>  j < arr . length ;<br>  j ++ ) {<br>    currVal = currVal + arrSum - arr . length * arr [ arr . length - j ] ;<br>    if ( currVal > maxVal ) maxVal = currVal ;<br>  }<br>  return maxVal ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr ) {<br>    arrSum = 0 ;<br>    int currVal = 0 ;<br>    int n = arr . length ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        arrSum = arrSum + arr [ i ] ;<br>        currVal = currVal + ( i * arr [ i ] ) ;<br>    }<br>    maxVal = currVal ;<br>    for ( int j = 1 ;  j <= n ;  j ++ ) {<br>        currVal = currVal + arrSum - n * arr [ n - j ] ;<br>        if ( currVal > maxVal ) {<br>            maxVal = currVal ;<br>        }<br>    }<br>    return maxVal ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_SCALAR_MULTIPLICATION_OF_A_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void scalarProductMat ( int mat [ ] [ ] , int k ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] * k ;<br>}<br></td>
    <td>translated code: <br><br> public static void scalarProductMat ( double [ ] [ ] mat , double k ) {<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        for ( int j = 0 ;  j < N ;  j ++ ) {<br>            mat [ i ] [ j ] = mat [ i ] [ j ] * k ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSquares ( int n ) {<br>  int square = 0 , odd = 1 ;<br>  for ( int x = 0 ;<br>  x < n ;<br>  x ++ ) {<br>    System . out . print ( square + " " ) ;<br>    square = square + odd ;<br>    odd = odd + 2 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printSquares ( int n ) {<br>    int square = 0 ;<br>    odd = 1 ;<br>    for ( int x = 0 ;  x <= n ;  x ++ ) {<br>        System . out . print ( square + " " ) ;<br>        square = square + odd ;<br>        odd = odd + 2 ;<br>    }<br>}</td>
  </tr><tr>
    <th>NTH_PENTAGONAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int pentagonalNum ( int n ) {<br>  return ( 3 * n * n - n ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int pentagonalNum ( int n ) {<br>    return ( 3 * n * n - n ) / 2 ;<br>}</td>
  </tr><tr>
    <th>COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofArray ( int n , int m ) {<br>  int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;<br>  Vector < Integer > [ ] di = new Vector [ MAX ] ;<br>  Vector < Integer > [ ] mu = new Vector [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < MAX ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) {<br>    di [ i ] = new Vector < > ( ) ;<br>    mu [ i ] = new Vector < > ( ) ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 2 * i ;<br>    j <= m ;<br>    j += i ) {<br>      di [ j ] . add ( i ) ;<br>      mu [ i ] . add ( j ) ;<br>    }<br>    di [ i ] . add ( i ) ;<br>  }<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) dp [ 1 ] [ i ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= m ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = 0 ;<br>      for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>      for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    ans += dp [ n ] [ i ] ;<br>    di [ i ] . clear ( ) ;<br>    mu [ i ] . clear ( ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofArray ( int n , int m ) {<br>    int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;<br>    int [ ] di = new int [ MAX ] ;<br>    mu = new int [ MAX ] ;<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 2 * i ;  j <= m ;  j += i ) {<br>            di [ j ] . add ( i ) ;<br>            mu [ i ] . add ( j ) ;<br>        }<br>        di [ i ] . add ( i ) ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        dp [ 1 ] [ i ] = 1 ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= m ;  j ++ ) {<br>            dp [ i ] [ j ] = 0 ;<br>            for ( int x : di [ j ] ) {<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>            }<br>            for ( int x : mu [ j ] ) {<br>                dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;<br>            }<br>        }<br>    }<br>    int ans = 0 ;<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        ans += dp [ n ] [ i ] ;<br>        di [ i ] . clear ( ) ;<br>        mu [ i ] . clear ( ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  if ( n == 0 || W == 0 ) return 0 ;<br>  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;<br>  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , double [ ] wt , double [ ] val , int n ) {<br>    if ( n == 0 || W == 0 ) {<br>        return 0 ;<br>    }<br>    if ( ( wt [ n - 1 ] > W ) && ( wt [ n - 1 ] > val ) ) {<br>        return knapSack ( W , wt , val , n - 1 ) ;<br>    }<br>    else {<br>        return Math . max ( val [ n - 1 ] + knapSack ( W . length - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int [ ] arr , int n ) {<br>  boolean found = true ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < n ;<br>      k ++ ) {<br>        if ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) {<br>          System . out . print ( arr [ i ] ) ;<br>          System . out . print ( " " ) ;<br>          System . out . print ( arr [ j ] ) ;<br>          System . out . print ( " " ) ;<br>          System . out . print ( arr [ k ] ) ;<br>          System . out . print ( "\n" ) ;<br>          found = true ;<br>        }<br>      }<br>    }<br>  }<br>  if ( found == false ) System . out . println ( " not exist " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int [ ] arr , int n ) {<br>    found = true ;<br>    for ( int i = 0 ;  i <= n - 2 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j <= n - 1 ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                if ( ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) && ( arr [ i ] + arr [ j ] + arr [ k ] == 0 ) ) {<br>                    System . out . println ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] ) ;<br>                    found = true ;<br>                }<br>            }<br>        }<br>    }<br>    if ( ( found == false ) && ( n > 0 ) ) {<br>        System . out . print ( " not exist " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int count ( int n ) {<br>  int table [ ] = new int [ n + 1 ] , i ;<br>  Arrays . fill ( table , 0 ) ;<br>  table [ 0 ] = 1 ;<br>  for ( i = 3 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 3 ] ;<br>  for ( i = 5 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 5 ] ;<br>  for ( i = 10 ;<br>  i <= n ;<br>  i ++ ) table [ i ] += table [ i - 10 ] ;<br>  return table [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int count ( int n ) {<br>    int [ ] table = new int [ n + 1 ] ;<br>    table [ 0 ] = 1 ;<br>    for ( int i = 3 ;  i <= n ;  i ++ ) {<br>        table [ i ] += table [ i - 3 ] ;<br>    }<br>    for ( int i = 5 ;  i <= n ;  i ++ ) {<br>        table [ i ] += table [ i - 5 ] ;<br>    }<br>    for ( int i = 10 ;  i <= n ;  i ++ ) {<br>        table [ i ] += table [ i - 10 ] ;<br>    }<br>    return table [ n ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_ABSOLUTE_DIFFERENCE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MaxSumDifference ( Integer [ ] a , int n ) {<br>  List < Integer > finalSequence = new ArrayList < Integer > ( ) ;<br>  Arrays . sort ( a ) ;<br>  for ( int i = 0 ;<br>  i < n / 2 ;<br>  ++ i ) {<br>    finalSequence . add ( a [ i ] ) ;<br>    finalSequence . add ( a [ n - i - 1 ] ) ;<br>  }<br>  int MaximumSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  ++ i ) {<br>    MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ;<br>  }<br>  MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ;<br>  return MaximumSum ;<br>}<br></td>
    <td>translated code: <br><br> public static void MaxSumDifference ( int [ ] a , int n ) {<br>    Arrays . sort ( a ) ;<br>    int j = 0 ;<br>    int [ ] finalSequence = new int [ n ] ;<br>    for ( int i = 0 ;  i <= ( int ) ( n / 2 ) ;  i ++ ) {<br>        finalSequence [ j ] = a [ i ] ;<br>        finalSequence [ j + 1 ] = a [ n - i - 1 ] ;<br>        j = j + 2 ;<br>    }<br>    int MaximumSum = 0 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        MaximumSum = ( MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) ;<br>    }<br>    MaximumSum = ( MaximumSum + Math . abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) ;<br>    System . out . println ( MaximumSum ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_MID_POINT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void midpoint ( int x1 , int x2 , int y1 , int y2 ) {<br>  System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void midpoint ( int x1 , int x2 , int y1 , int y2 ) {<br>    System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>ALTERNATIVE_SORTING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void alternateSort ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int i = 0 , j = n - 1 ;<br>  while ( i < j ) {<br>    System . out . print ( arr [ j -- ] + " " ) ;<br>    System . out . print ( arr [ i ++ ] + " " ) ;<br>  }<br>  if ( n % 2 != 0 ) System . out . print ( arr [ i ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void alternateSort ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int i = 0 ;<br>    int j = n - 1 ;<br>    while ( ( i < j ) && ( i < n ) ) {<br>        System . out . print ( arr [ j ] + " " ) ;<br>        j -- ;<br>        System . out . print ( arr [ i ] + " " ) ;<br>        i ++ ;<br>    }<br>    if ( ( n % 2 != 0 ) && ( n % 2 == 0 ) ) {<br>        System . out . println ( arr [ i ] ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBARRAYS_SUM_EXACTLY_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSubarraySum ( int arr [ ] , int n , int sum ) {<br>  HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ;<br>  int res = 0 ;<br>  int currsum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    currsum += arr [ i ] ;<br>    if ( currsum == sum ) res ++ ;<br>    if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ;<br>    Integer count = prevSum . get ( currsum ) ;<br>    if ( count == null ) prevSum . put ( currsum , 1 ) ;<br>    else prevSum . put ( currsum , count + 1 ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSubarraySum ( int [ ] arr , int n , int Sum ) {<br>    int [ ] prevSum = new TreeMap < Integer , Integer > ( ) ;<br>    int res = 0 ;<br>    int currsum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        currsum += arr [ i ] ;<br>        if ( currsum == Sum ) {<br>            res ++ ;<br>        }<br>        if ( ( currsum - Sum ) == prevSum ) {<br>            res += prevSum [ currsum - Sum ] ;<br>        }<br>        prevSum [ currsum ] ++ ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( int [ ] arr , int low , int high ) {<br>  if ( low > high ) return ;<br>  if ( low == high ) {<br>    System . out . println ( "The required element is " + arr [ low ] ) ;<br>    return ;<br>  }<br>  int mid = ( low + high ) / 2 ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ;<br>    else search ( arr , low , mid ) ;<br>  }<br>  else if ( mid % 2 == 1 ) {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ;<br>    else search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int low , int high ) {<br>    if ( low > high ) {<br>        return null ;<br>    }<br>    if ( low == high ) {<br>        return search ( arr , low , high , 0 ) ;<br>    }<br>    int mid = low + ( high - low ) / 2 ;<br>    if ( mid % 2 == 0 ){<br>        if ( arr [ mid ] == arr [ mid + 1 ] ) {<br>            return search ( arr , mid + 2 , high ) ;<br>        }<br>        if ( low > high ) {<br>            return search ( arr , low , mid -> mid > 0 ) ;<br>        }<br>    }<br>    if ( low > high ) {<br>        if ( arr [ mid ] == arr [ mid - 1 ] ) {<br>            return search ( arr , mid + 1 , high ) ;<br>        }<br>        if ( low > high ) {<br>            return search ( arr , low , mid - 1 ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FORM_SMALLEST_NUMBER_USING_ONE_SWAP_OPERATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static String smallestNumber ( String str ) {<br>  char [ ] num = str . toCharArray ( ) ;<br>  int n = str . length ( ) ;<br>  int [ ] rightMin = new int [ n ] ;<br>  rightMin [ n - 1 ] = - 1 ;<br>  int right = n - 1 ;<br>  for ( int i = n - 2 ;<br>  i >= 1 ;<br>  i -- ) {<br>    if ( num [ i ] > num [ right ] ) rightMin [ i ] = right ;<br>    else {<br>      rightMin [ i ] = - 1 ;<br>      right = i ;<br>    }<br>  }<br>  int small = - 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( num [ i ] != '0' ) {<br>    if ( small == - 1 ) {<br>      if ( num [ i ] < num [ 0 ] ) small = i ;<br>    }<br>    else if ( num [ i ] < num [ small ] ) small = i ;<br>  }<br>  if ( small != - 1 ) {<br>    char temp ;<br>    temp = num [ 0 ] ;<br>    num [ 0 ] = num [ small ] ;<br>    num [ small ] = temp ;<br>  }<br>  else {<br>    for ( int i = 1 ;<br>    i < n ;<br>    i ++ ) {<br>      if ( rightMin [ i ] != - 1 ) {<br>        char temp ;<br>        temp = num [ i ] ;<br>        num [ i ] = num [ rightMin [ i ] ] ;<br>        num [ rightMin [ i ] ] = temp ;<br>        break ;<br>      }<br>    }<br>  }<br>  return ( new String ( num ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String smallestNumber ( String num ) {<br>    num = Arrays . copyOf ( num , num . length ) ;<br>    int n = num . length ( ) ;<br>    rightMin [ 0 ] = num ;<br>    int right = 0 ;<br>    rightMin [ n - 1 ] = - 1 ;<br>    right = n - 1 ;<br>    for ( int i = n - 2 ;  i > 0 ;  i -- ) {<br>        if ( num [ i ] > num [ right ] ) {<br>            rightMin [ i ] = right ;<br>        }<br>        else {<br>            rightMin [ i ] = - 1 ;<br>            right = i ;<br>        }<br>    }<br>    small = - 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( num . charAt ( i ++ ) != '0' ) {<br>            if ( small == - 1 ) {<br>                if ( num [ i ] < num [ 0 ] ) {<br>                    small = i ;<br>                }<br>            }<br>            else if ( num [ i ] < num [ small ] ) {<br>                small = i ;<br>            }<br>        }<br>    }<br>    if ( small != - 1 ) {<br>        return num [ 0 ] , num [ small ] ;<br>    }<br>    else {<br>        for ( int i = 1 ;  i <= n ;  i ++ ) {<br>            if ( rightMin [ i ] != - 1 ) {<br>                num [ i ] = num [ rightMin [ i ] ] ;<br>                break ;<br>            }<br>        }<br>    }<br>    return smallestNumber ( num , false ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_AREA_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int areaSquare ( int side ) {<br>  int area = side * side ;<br>  return area ;<br>}<br></td>
    <td>translated code: <br><br> public static int areaSquare ( int side ) {<br>    area = side * side ;<br>    return area ;<br>}</td>
  </tr><tr>
    <th>FIND_DAY_OF_THE_WEEK_FOR_A_GIVEN_DATE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int dayofweek ( int d , int m , int y ) {<br>  int t [ ] = {<br>    0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 };<br>    y -= ( m < 3 ) ? 1 : 0 ;<br>    return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ;<br>  }<br>  </td>
    <td>translated code: <br><br> public static int dayofweek ( int d , int m , int y ) {<br>    int t [ ] = {<br>    }<br>    y -= m < 3 ? 1 : 0 ;<br>    return ( ( y + Integer . MIN_VALUE / 4 ) - Integer . MIN_VALUE / 100 + Integer . MIN_VALUE / 400 + t [ m - 1 ] + d ) % 7 ;<br>}</td>
  </tr><tr>
    <th>CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean checkSorted ( int n ) {<br>  Stack < Integer > st = new Stack < Integer > ( ) ;<br>  int expected = 1 ;<br>  int fnt ;<br>  while ( q . size ( ) != 0 ) {<br>    fnt = q . peek ( ) ;<br>    q . poll ( ) ;<br>    if ( fnt == expected ) expected ++ ;<br>    else {<br>      if ( st . size ( ) == 0 ) {<br>        st . push ( fnt ) ;<br>      }<br>      else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) {<br>        return false ;<br>      }<br>      else st . push ( fnt ) ;<br>    }<br>    while ( st . size ( ) != 0 && st . peek ( ) == expected ) {<br>      st . pop ( ) ;<br>      expected ++ ;<br>    }<br>  }<br>  if ( expected - 1 == n && st . size ( ) == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean checkSorted ( int n , Queue q ) {<br>    int [ ] st = new int [ n ] ;<br>    int expected = 1 ;<br>    Fnt fnt ;<br>    while ( ( ! q . isEmpty ( ) ) && ( n > 0 ) ) {<br>        Fnt fnt = q . getQueue ( ) . poll ( ) ;<br>        q . poll ( ) ;<br>        if ( ( fnt == expected ) && ( n > q ) ){<br>            expected ++ ;<br>        }<br>        if ( n < q ) {<br>            if ( ( st . size ( ) == 0 ) && ( q == 0 ) ) {<br>                st . add ( fnt ) ;<br>            }<br>            else if ( ( st . length != 0 && st [ st . length - 1 ] < fnt ) || ( q < fnt ) ){<br>                return false ;<br>            }<br>            if ( n < q ) {<br>                st . add ( fnt ) ;<br>            }<br>        }<br>        while ( ( st . length != 0 ) && ( st [ st . length - 1 ] == expected ) ){<br>            st . remove ( ) ;<br>            expected ++ ;<br>        }<br>    }<br>    if ( ( expected - 1 == n && st . length == 0 ) || ( n - 1 == q ) ){<br>        return checkSorted ( n , q , 0 , q . length ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_CONTAIN_1_N_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortit ( int [ ] arr , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    arr [ i ] = i + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortit ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = i + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcsOf3 ( int i , int j , int k ) {<br>  if ( i == - 1 || j == - 1 || k == - 1 ) {<br>    return 0 ;<br>  }<br>  if ( dp [ i ] [ j ] [ k ] != - 1 ) {<br>    return dp [ i ] [ j ] [ k ] ;<br>  }<br>  if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) {<br>    return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ;<br>  }<br>  else {<br>    return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int lcsOf3 ( int i , int j , int k ) {<br>    if ( ( i == - 1 || j == - 1 || k == - 1 ) && ( i == - 1 || k == - 1 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( dp [ i ] [ j ] [ k ] != - 1 ) && ( dp [ i ] [ j ] [ k ] != - 1 ) ){<br>        return dp [ i ] [ j ] [ k ] ;<br>    }<br>    if ( ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) || ( X [ i ] == Z [ j ] && Z [ k ] == Y [ k ] ) ) {<br>        dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ;<br>        return dp [ i ] [ j ] [ k ] ;<br>    }<br>    }<br>        dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ;<br>        return dp [ i ] [ j ] [ k ] ;<br>}</td>
  </tr><tr>
    <th>LOWER_INSERTION_POINT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int LowerInsertionPoint ( int arr [ ] , int n , int X ) {<br>  if ( X < arr [ 0 ] ) return 0 ;<br>  else if ( X > arr [ n - 1 ] ) return n ;<br>  int lowerPnt = 0 ;<br>  int i = 1 ;<br>  while ( i < n && arr [ i ] < X ) {<br>    lowerPnt = i ;<br>    i = i * 2 ;<br>  }<br>  while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ;<br>  return lowerPnt ;<br>}<br></td>
    <td>translated code: <br><br> public static int LowerInsertionPoint ( int [ ] arr , int n , int X ) {<br>    if ( ( X < arr [ 0 ] ) && ( X > arr [ n - 1 ] ) ) {<br>        return 0 ;<br>    }<br>    else if ( ( X > arr [ n - 1 ] ) && ( X < arr [ n - 2 ] ) ) {<br>        return n ;<br>    }<br>    lowerPnt = 0 ;<br>    int i = 1 ;<br>    while ( ( i < n && arr [ i ] < X ) || ( i < n && arr [ i ] > X ) ) {<br>        lowerPnt = i ;<br>        i = i * 2 ;<br>    }<br>    while ( ( lowerPnt < n && arr [ lowerPnt ] < X ) || ( lowerPnt < n && arr [ lowerPnt ] > X ) ) {<br>        lowerPnt ++ ;<br>    }<br>    return lowerPnt ;<br>}</td>
  </tr><tr>
    <th>CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String constructPalin ( char [ ] str , int len ) {<br>  int i = 0 , j = len - 1 ;<br>  for ( ;<br>  i < j ;<br>  i ++ , j -- ) {<br>    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continue ;<br>    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {<br>      str [ i ] = 'a' ;<br>      str [ j ] = 'a' ;<br>      continue ;<br>    }<br>    else if ( str [ i ] == '*' ) {<br>      str [ i ] = str [ j ] ;<br>      continue ;<br>    }<br>    else if ( str [ j ] == '*' ) {<br>      str [ j ] = str [ i ] ;<br>      continue ;<br>    }<br>    System . out . println ( "Not Possible" ) ;<br>    return "" ;<br>  }<br>  return String . valueOf ( str ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String constructPalin ( String string , int l ) {<br>    string = Arrays . asList ( string ) ;<br>    int i = - 1 ;<br>    int j = l ;<br>    while ( i < j ){<br>        i ++ ;<br>        j -- ;<br>        if ( ( string . charAt ( i ) == string . charAt ( j ) && string . charAt ( i ) != '*' ) || ( string . charAt ( i ) == '+' && string . charAt ( j ) != '*' ) ) {<br>            continue ;<br>        }<br>        else if ( ( string . charAt ( i ) == string . charAt ( j ) && string . charAt ( i ) == '*' ) || ( string . charAt ( i ) == '*' && string . charAt ( j ) == '*' ) ) {<br>            string . charAt ( i ++ ) = 'a' ;<br>            string . charAt ( j ++ ) = 'a' ;<br>            continue ;<br>        }<br>        else if ( string . charAt ( i ++ ) == '*' ) {<br>            string [ i ++ ] = string [ j ++ ] ;<br>            continue ;<br>        }<br>        else if ( string . charAt ( j ) == '*' ) {<br>            string [ j ] = string [ i ] ;<br>            continue ;<br>        }<br>        System . out . println ( "Not Possible" ) ;<br>        return constructPalin ( string , l , null ) ;<br>    }<br>    return constructPalin ( string , l , null ) ;<br>}</td>
  </tr><tr>
    <th>SECTION_FORMULA_POINT_DIVIDES_LINE_GIVEN_RATIO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) {<br>  double x = ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ;<br>  double y = ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ;<br>  System . out . println ( "(" + x + ", " + y + ")" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void section ( double x1 , double x2 , double y1 , double y2 , double m , double n ) {<br>    double x = ( ( double ) ( ( n * x1 ) + ( m * x2 ) ) / ( m + n ) ) ;<br>    float y = ( float ) ( ( n * y1 ) + ( m * y2 ) ) / ( m + n ) ;<br>    System . out . println ( x + " " + y ) ;<br>}</td>
  </tr><tr>
    <th>SQUARE_ROOT_NUMBER_USING_LOG</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double squareRoot ( double n ) {<br>  return Math . pow ( 2 , 0.5 * ( Math . log ( n ) / Math . log ( 2 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double squareRoot ( double n ) {<br>    return Math . pow ( 2 , 0.5 * Math . log2 ( n ) ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_SUM_ARRII</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSum ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += ( arr [ i ] * i ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSum ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr , 0 , n ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        sum += arr [ i ] * i ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>STRING_K_DISTINCT_CHARACTERS_NO_CHARACTERS_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String findString ( int n , int k ) {<br>  String res = "" ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) res = res + ( char ) ( 'a' + i ) ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n - k ;<br>  i ++ ) {<br>    res = res + ( char ) ( 'a' + count ) ;<br>    count ++ ;<br>    if ( count == k ) count = 0 ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String findString ( int n , int k ) {<br>    String res = "" ;<br>    for ( int i = 0 ;  i < k ;  i ++ ) {<br>        String res = res + ( char ) ( 'a' + i ++ ) ;<br>    }<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n - k ;  i ++ ) {<br>        String res = res + ( char ) ( 'a' + count ++ ) ;<br>        count ++ ;<br>        if ( ( count == k ) && ( n == 0 ) ) {<br>            int count = 0 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWords ( String str , int len ) {<br>  int count = 1 ;<br>  if ( len == 1 ) return count ;<br>  if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ;<br>  else count *= 2 ;<br>  for ( int j = 1 ;<br>  j < len - 1 ;<br>  j ++ ) {<br>    if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ;<br>    else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ;<br>    else count *= 3 ;<br>  }<br>  if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ;<br>  else count *= 2 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWords ( String str , int l ) {<br>    int count = 1 ;<br>    if ( ( l == 1 ) && ( str != null ) ) {<br>        return count ;<br>    }<br>    if ( ( str . charAt ( 0 ) == str . charAt ( 1 ) ) && ( l > 0 ) ) {<br>        count *= 1 ;<br>    }<br>    if ( l > 0 ) {<br>        count *= 2 ;<br>    }<br>    for ( int j = 1 ;  j <= l - 1 ;  j ++ ) {<br>        if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) || ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) ) {<br>            count *= 1 ;<br>        }<br>        if ( ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) && ( l < 5 ) ) {<br>            count *= 2 ;<br>        }<br>        if ( l > 0 ) {<br>            count *= 3 ;<br>        }<br>    }<br>    if ( ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) && ( str . charAt ( l - 3 ) == str . charAt ( l - 4 ) ) ) {<br>        count *= 1 ;<br>    }<br>    if ( l > 0 ) {<br>        count *= 2 ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>NUMBER_JUMP_REQUIRED_GIVEN_LENGTH_REACH_POINT_FORM_D_0_ORIGIN_2D_PLANE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minJumps ( int a , int b , int d ) {<br>  int temp = a ;<br>  a = Math . min ( a , b ) ;<br>  b = Math . max ( temp , b ) ;<br>  if ( d >= b ) return ( d + b - 1 ) / b ;<br>  if ( d == 0 ) return 0 ;<br>  if ( d == a ) return 1 ;<br>  return 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int minJumps ( int a , int b , int d ) {<br>    int temp = a ;<br>    a = Math . min ( a , b ) ;<br>    b = Math . max ( temp , b ) ;<br>    if ( ( d >= b ) && ( d <= a ) ){<br>        return ( d + b - 1 ) / b ;<br>    }<br>    if ( ( d == 0 ) && ( a == 5 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( d == a ) && ( b == a ) ) {<br>        return 1 ;<br>    }<br>    return 2 ;<br>}</td>
  </tr><tr>
    <th>SUM_FACTORS_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumofFactors ( int n ) {<br>  int res = 1 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    int curr_sum = 1 ;<br>    int curr_term = 1 ;<br>    while ( n % i == 0 ) {<br>      n = n / i ;<br>      curr_term *= i ;<br>      curr_sum += curr_term ;<br>    }<br>    res *= curr_sum ;<br>  }<br>  if ( n > 2 ) res *= ( 1 + n ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static long sumofFactors ( long n ) {<br>    int res = 1 ;<br>    for ( int i = 2 ;  i <= ( int ) ( m . sqrt ( n ) + 1 ) ;  i ++ ) {<br>        currSum = 1 ;<br>        currTerm = 1 ;<br>        while ( n % i == 0 ){<br>            n = n / i ;<br>            currTerm = currTerm * i ;<br>            currSum += currTerm ;<br>        }<br>        res = res * currSum ;<br>    }<br>    if ( n > 2 ) {<br>        res = res * ( 1 + n ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int removeConsecutiveSame ( Vector < String > v ) {<br>  int n = v . size ( ) ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  ) {<br>    if ( v . get ( i ) . equals ( v . get ( i + 1 ) ) ) {<br>      v . remove ( i ) ;<br>      v . remove ( i ) ;<br>      if ( i > 0 ) i -- ;<br>      n = n - 2 ;<br>    }<br>    else i ++ ;<br>  }<br>  return v . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int removeConsecutiveSame ( int [ ] v ) {<br>    int n = v . length ( ) ;<br>    int i = 0 ;<br>    while ( ( i < n - 1 ) && ( i < n ) ) {<br>        if ( ( ( i + 1 ) < v . length ) && ( v [ i ] == v [ i + 1 ] ) ) {<br>            v = v . substring ( 0 , i ) ;<br>            v = v . substring ( 0 , i ) ;<br>            if ( ( i > 0 ) && ( i < 5 ) ) {<br>                i -- ;<br>            }<br>            n = n - 2 ;<br>        }<br>        }<br>            i ++ ;<br>    }<br>    return removeConsecutiveSame ( v , 0 , v . length - 1 ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n ) {<br>  int a [ ] = new int [ n ] ;<br>  int b [ ] = new int [ n ] ;<br>  a [ 0 ] = b [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  return a [ n - 1 ] + b [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countStrings ( int n ) {<br>    int [ ] a = new int [ n ] ;<br>    StringBuilder b = new StringBuilder ( ) ;<br>    a [ 0 ] = b [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>        b [ i ] = a [ i - 1 ] ;<br>    }<br>    return a [ n - 1 ] + b [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getMissingNo ( int a [ ] , int n ) {<br>  int i , total ;<br>  total = ( n + 1 ) * ( n + 2 ) / 2 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) total -= a [ i ] ;<br>  return total ;<br>}<br></td>
    <td>translated code: <br><br> public static int getMissingNo ( int [ ] A ) {<br>    int n = A . length ;<br>    int total = ( n + 1 ) * ( n + 2 ) / 2 ;<br>    int sumOfA = Arrays . stream ( A ) . mapToInt ( Integer :: sum ) . sum ( ) ;<br>    return total - sumOfA ;<br>}</td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_A_PERFECT_SQUARE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float squareRoot ( float n ) {<br>  float x = n ;<br>  float y = 1 ;<br>  double e = 0.000001 ;<br>  while ( x - y > e ) {<br>    x = ( x + y ) / 2 ;<br>    y = n / x ;<br>  }<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static double squareRoot ( double n ) {<br>    int x = n ;<br>    int y = 1 ;<br>    double e = 0.000001 ;<br>    while ( ( x - y > e ) && ( x - y > e ) ) {<br>        x = ( x + y ) / 2 ;<br>        int y = n / x ;<br>    }<br>    return x ;<br>}</td>
  </tr><tr>
    <th>SUBSET_SUM_PROBLEM_OSUM_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {<br>  boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= sum ;<br>    j ++ ) {<br>      if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;<br>      else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;<br>      else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ;<br>      else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ;<br>    }<br>  }<br>  return subset [ n % 2 ] [ sum ] ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSubsetSum ( int [ ] arr , int n , int sum ) {<br>    boolean [ ] subset = new boolean [ sum + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < sum + 1 ;  j ++ ) {<br>            if ( ( j == 0 ) && ( sum == 0 ) ) {<br>                subset [ i % 2 ] [ j ] = true ;<br>            }<br>            else if ( ( i == 0 ) && ( sum == 0 ) ) {<br>                subset [ i % 2 ] [ j ] = false ;<br>            }<br>            else if ( ( arr [ i - 1 ] <= j ) && ( arr [ i ] >= 0 ) && ( arr [ i ] <= n ) && ( arr [ i ] >= sum ) && ( arr [ i ] <= j ) ) {<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ;<br>            }<br>            if ( sum > 0 ) {<br>                subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ;<br>            }<br>        }<br>    }<br>    return subset [ n % 2 ] [ sum ] ;<br>}</td>
  </tr><tr>
    <th>MULTIPLICATIVE_INVERSE_UNDER_MODULO_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int modInverse ( int a , int m ) {<br>  a = a % m ;<br>  for ( int x = 1 ;<br>  x < m ;<br>  x ++ ) if ( ( a * x ) % m == 1 ) return x ;<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> static int modInverse ( int a , int m ) {<br>    a = a % m ;<br>    for ( int x = 1 ;  x < m ;{<br>        if ( ( ( a * x ) % m == 1 ) && ( ( a * x ) % m == 0 ) ){<br>            return x ;<br>        }<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute_average ( int a , int b ) {<br>  return ( a + b ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static double computeAverage ( double a , double b ) {<br>    return Math . floor ( ( a + b ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>REPRESENT_GIVEN_SET_POINTS_BEST_POSSIBLE_STRAIGHT_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bestApproximate ( int x [ ] , int y [ ] ) {<br>  int n = x . length ;<br>  double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum_x += x [ i ] ;<br>    sum_y += y [ i ] ;<br>    sum_xy += x [ i ] * y [ i ] ;<br>    sum_x2 += pow ( x [ i ] , 2 ) ;<br>  }<br>  m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ;<br>  c = ( sum_y - m * sum_x ) / n ;<br>  System . out . println ( "m = " + m ) ;<br>  System . out . println ( "c = " + c ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void bestApproximate ( double [ ] x , double [ ] y , int n ) {<br>    int sumX = 0 ;<br>    int sumY = 0 ;<br>    int sumXY = 0 ;<br>    int sum_x2 = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        sumX += x [ i ] ;<br>        sumY += y [ i ] ;<br>        sumXY += x [ i ] * y [ i ] ;<br>        sum_x2 += Math . pow ( x [ i ] , 2 ) ;<br>    }<br>    double m = ( double ) ( ( n * sumXY - sumX * sumY ) / ( n * sumX2 - Math . pow ( sumX , 2 ) ) ) ;<br>    double c = ( double ) ( sumY - m * sumX ) / n ;<br>    System . out . println ( "m = " + m ) ;<br>    System . out . println ( "c = " + c ) ;<br>}</td>
  </tr><tr>
    <th>SPLIT_ARRAY_ADD_FIRST_PART_END</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void splitArr ( int arr [ ] , int n , int k ) {<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    int x = arr [ 0 ] ;<br>    for ( int j = 0 ;<br>    j < n - 1 ;<br>    ++ j ) arr [ j ] = arr [ j + 1 ] ;<br>    arr [ n - 1 ] = x ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void splitArr ( int [ ] arr , int n , int k ) {<br>    for ( int i = 0 ;  i <= k ;  i ++ ) {<br>        int x = arr [ 0 ] ;<br>        for ( int j = 0 ;  j <= n - 1 ;  j ++ ) {<br>            splitArr ( arr , j , k , n , k ) ;<br>        }<br>        arr [ n - 1 ] = x ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDiff ( int [ ] arr , int n ) {<br>  int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;<br>  for ( int i = 0 ;<br>  i <= n - 1 ;<br>  i ++ ) {<br>    boolean isSingleOccurance = true ;<br>    for ( int j = i + 1 ;<br>    j <= n - 1 ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) {<br>        isSingleOccurance = false ;<br>        arr [ i ] = arr [ j ] = 0 ;<br>        break ;<br>      }<br>    }<br>    if ( isSingleOccurance ) {<br>      if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;<br>      else SubsetSum_2 += arr [ i ] ;<br>    }<br>  }<br>  return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDiff ( int [ ] arr , int n ) {<br>    SubsetSum_1 = 0 ;<br>    SubsetSum_2 = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        isSingleOccurance = true ;<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] == arr [ j ] ) && ( n > 0 ) ) {<br>                isSingleOccurance = false ;<br>                arr [ i ] = arr [ j ] = 0 ;<br>                break ;<br>            }<br>        }<br>        if ( ( isSingleOccurance == true ) && ( arr . length > n ) ) {<br>            if ( ( arr [ i ] > 0 ) && ( arr [ i ] < n ) ) {<br>                SubsetSum_1 += arr [ i ] ;<br>            }<br>            if ( n > 0 ) {<br>                SubsetSum_2 += arr [ i ] ;<br>            }<br>        }<br>    }<br>    return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;<br>}</td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longLenSub ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = 0 ;<br>    if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ;<br>    if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ;<br>    um . put ( arr [ i ] , len + 1 ) ;<br>    if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ;<br>  }<br>  return longLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longLenSub ( int [ ] arr , int n ) {<br>    Map < Long , Long > um = new TreeMap < Long , Long > ( ) ;<br>    longLen = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        long len1 = 0 ;<br>        if ( ( arr [ i - 1 ] < um && len1 < um [ arr [ i ] - 1 ] ) || ( arr [ i ] < um && len1 < um [ arr [ i ] - 1 ] ) ) {<br>            int len1 = um [ arr [ i ] - 1 ] ;<br>        }<br>        if ( ( arr [ i ] + 1 < um . length && len1 < um [ arr [ i ] + 1 ] ) || ( arr [ i ] + 1 < um . length && len1 < um [ arr [ i ] + 1 ] ) ){<br>            int len1 = um [ arr [ i ] + 1 ] ;<br>        }<br>        um [ arr [ i ++ ] ] = len1 + 1 ;<br>        if ( longLen < um [ arr [ i ] ] ){<br>            longLen = um [ arr [ i ] ] ;<br>        }<br>    }<br>    return longLen ;<br>}</td>
  </tr><tr>
    <th>LONGEST_REPEATED_SUBSEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String longestRepeatedSubSeq ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 0 ;<br>  j <= n ;<br>  j ++ ) dp [ i ] [ j ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = 1 ;<br>  j <= n ;<br>  j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>  else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>  String res = "" ;<br>  int i = n , j = n ;<br>  while ( i > 0 && j > 0 ) {<br>    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {<br>      res = res + str . charAt ( i - 1 ) ;<br>      i -- ;<br>      j -- ;<br>    }<br>    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;<br>    else j -- ;<br>  }<br>  String reverse = "" ;<br>  for ( int k = res . length ( ) - 1 ;<br>  k >= 0 ;<br>  k -- ) {<br>    reverse = reverse + res . charAt ( k ) ;<br>  }<br>  return reverse ;<br>}<br></td>
    <td>translated code: <br><br> public static String longestRepeatedSubSeq ( String str ) {<br>    int n = str . length ( ) ;<br>    int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            if ( ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) || ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) ) {<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>            }<br>            if ( str != null ) {<br>                dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    String res = "" ;<br>    int i = n ;<br>    int j = n ;<br>    while ( ( i > 0 && j > 0 ) || ( i < 0 && j < 0 ) ) {<br>        if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) && ( dp [ i - 1 ] [ j - 1 ] == dp [ i - 1 ] [ j - 1 ] + 1 ) ) {<br>            res += str . charAt ( i - 1 ) ;<br>            i -- ;<br>            j -- ;<br>        }<br>        if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) && ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) ) {<br>            i -- ;<br>        }<br>        if ( str != null ) {<br>            j -- ;<br>        }<br>    }<br>    String res = new String ( reverse ( str ) ) ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findRandomIndexOfMax ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( mp . containsKey ( arr [ i ] ) ) {<br>    mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;<br>  }<br>  else {<br>    mp . put ( arr [ i ] , 1 ) ;<br>  }<br>  int max_element = Integer . MIN_VALUE ;<br>  int max_so_far = Integer . MIN_VALUE ;<br>  for ( Map . Entry < Integer , Integer > p : mp . entrySet ( ) ) {<br>    if ( p . getValue ( ) > max_so_far ) {<br>      max_so_far = p . getValue ( ) ;<br>      max_element = p . getKey ( ) ;<br>    }<br>  }<br>  int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) ;<br>  for ( int i = 0 , count = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == max_element ) count ++ ;<br>    if ( count == r ) {<br>      System . out . print ( "Element with maximum frequency present " + "at index " + i + "\n" ) ;<br>      break ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void findRandomIndexOfMax ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > mp = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] = mp ) . equals ( n ) ) {<br>            mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ;<br>        }<br>        if ( n > 0 ) {<br>            mp [ arr [ i ] ] = 1 ;<br>        }<br>    }<br>    int maxElement = - 323567 ;<br>    int maxSoFar = - 323567 ;<br>    for ( int p = 0 ;  p < mp . length ;  p ++ ) {<br>        if ( ( mp [ p ] > maxSoFar ) && ( mp [ p ] > maxSoFar ) ){<br>            int maxSoFar = mp [ p ] ;<br>            maxElement = p ;<br>        }<br>    }<br>    int r = ( int ) ( ( ( Math . random ( ) * 1 + maxSo_far ) % maxSo_far ) + 1 ) ;<br>    int i = 0 ;<br>    int count = 0 ;<br>    while ( ( i < n ) && ( i < arr . length ) ) {<br>        if ( ( arr [ i ] == maxElement ) && ( n > 0 ) ) {<br>            count = count + 1 ;<br>        }<br>        if ( ( count == r ) && ( n > 0 ) ){<br>            System . out . println ( "Element with maximum frequency present at index " + i ) ;<br>            break ;<br>        }<br>        int i = arr . length ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPerfectSquare ( int n ) {<br>  for ( int sum = 0 , i = 1 ;<br>  sum < n ;<br>  i += 2 ) {<br>    sum += i ;<br>    if ( sum == n ) return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPerfectSquare ( int n ) {<br>    int i = 1 ;<br>    int theSum = 0 ;<br>    while ( theSum < n ) {<br>        theSum += i ;<br>        if ( theSum == n ) {<br>            return true ;<br>        }<br>        i += 2 ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>N_BONACCI_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bonacciseries ( int n , int m ) {<br>  int a [ ] = new int [ m ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 0 ;<br>  a [ n - 1 ] = 1 ;<br>  a [ n ] = 1 ;<br>  for ( int i = n + 1 ;<br>  i < m ;<br>  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) System . out . print ( a [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void bonacciSeries ( int n , int m ) {<br>    int [ ] a = new int [ m ] ;<br>    a [ n - 1 ] = 1 ;<br>    a [ n ] = 1 ;<br>    for ( int i = n + 1 ;  i < m ;  i ++ ) {<br>        a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;<br>    }<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        System . out . print ( a [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countPairs ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;<br>    else hm . put ( arr [ i ] , 1 ) ;<br>  }<br>  int ans = 0 ;<br>  for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) {<br>    int count = it . getValue ( ) ;<br>    ans += ( count * ( count - 1 ) ) / 2 ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPairs ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > mp = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == mp . keySet ( ) . stream ( ) . filter ( p -> p . length > n ) . count ( ) ) {<br>            mp [ arr [ i ] ] ++ ;<br>        }<br>        if ( n > 0 ) {<br>            mp [ arr [ i ] ] = 1 ;<br>        }<br>    }<br>    int ans = 0 ;<br>    for ( Iterator it = mp . iterator ( ) ;  it . hasNext ( ) ;  ) {<br>        int count = mp [ it ] ;<br>        ans += ( count * ( count - 1 ) ) / 2 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void bitonicGenerator ( int arr [ ] , int n ) {<br>  Vector < Integer > evenArr = new Vector < Integer > ( ) ;<br>  Vector < Integer > oddArr = new Vector < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 != 1 ) {<br>      evenArr . add ( arr [ i ] ) ;<br>    }<br>    else {<br>      oddArr . add ( arr [ i ] ) ;<br>    }<br>  }<br>  Collections . sort ( evenArr ) ;<br>  Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ;<br>  int i = 0 ;<br>  for ( int j = 0 ;<br>  j < evenArr . size ( ) ;<br>  j ++ ) {<br>    arr [ i ++ ] = evenArr . get ( j ) ;<br>  }<br>  for ( int j = 0 ;<br>  j < oddArr . size ( ) ;<br>  j ++ ) {<br>    arr [ i ++ ] = oddArr . get ( j ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void bitonicGenerator ( int [ ] arr , int n ) {<br>    int [ ] evenArr = new int [ n ] ;<br>    int [ ] oddArr = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( ( i % 2 ) == 0 ) && ( ( i % 3 ) == 0 ) ) {<br>            evenArr . add ( arr [ i ] ) ;<br>        }<br>        else {<br>            oddArr . add ( arr [ i ] ) ;<br>        }<br>    }<br>    int [ ] evenArr = new int [ n ] ;<br>    int [ ] oddArr = new int [ n ] ;<br>    oddArr = oddArr . clone ( ) ;<br>    int i = 0 ;<br>    for ( int j = 0 ;  j < evenArr . length ;  j ++ ) {<br>        arr [ i ] = evenArr [ j ] ;<br>        i ++ ;<br>    }<br>    for ( int j = 0 ;  j < oddArr . length ;  j ++ ) {<br>        arr [ i ] = oddArr [ j ] ;<br>        i ++ ;<br>    }<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int binomialCoeff ( int n , int k ) {<br>  if ( k == 0 || k == n ) return 1 ;<br>  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double binomialCoeff ( int n , int k ) {<br>    if ( k == 0 || k == n ) {<br>        return 1 ;<br>    }<br>    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ;<br>}</td>
  </tr><tr>
    <th>WRITE_A_C_PROGRAM_TO_FIND_THE_PARITY_OF_AN_UNSIGNED_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean getParity ( int n ) {<br>  boolean parity = false ;<br>  while ( n != 0 ) {<br>    parity = ! parity ;<br>    n = n & ( n - 1 ) ;<br>  }<br>  return parity ;<br>}<br></td>
    <td>translated code: <br><br> public static int getParity ( int n ) {<br>    parity = 0 ;<br>    while ( n -- > 0 ) {<br>        parity = ~ parity ;<br>        n = n & ( n - 1 ) ;<br>    }<br>    return parity ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDivisible7 ( String num ) {<br>  int n = num . length ( ) ;<br>  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;<br>  if ( n % 3 == 1 ) num = "00" + num ;<br>  if ( n % 3 == 2 ) num = "0" + num ;<br>  n = num . length ( ) ;<br>  int gSum = 0 , p = 1 ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int group = 0 ;<br>    group += num . charAt ( i -- ) - '0' ;<br>    group += ( num . charAt ( i -- ) - '0' ) * 10 ;<br>    group += ( num . charAt ( i ) - '0' ) * 100 ;<br>    gSum = gSum + group * p ;<br>    p = p * - 1 ;<br>  }<br>  return ( gSum % 7 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDivisible7 ( String num ) {<br>    int n = num . length ( ) ;<br>    if ( ( n == 0 && num . charAt ( 0 ) == '\n' ) || ( n == 1 && num . charAt ( 0 ) == '' ) ) {<br>        return 1 ;<br>    }<br>    if ( ( n % 3 == 1 ) && ( n % 4 == 0 ) ) {<br>        num = String . valueOf ( num ) + "00" ;<br>        n += 2 ;<br>    }<br>    }<br>        num = String . valueOf ( num ) + "0" ;<br>        n ++ ;<br>    GSum = 0 ;<br>    int p = 1 ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        int group = 0 ;<br>        group += ( char ) ( num . charAt ( i ) - '0' ) ;<br>        i -- ;<br>        group += ( ( char ) num . charAt ( i ++ ) - '0' ) * 10 ;<br>        i -- ;<br>        group += ( ( char ) num . charAt ( i ++ ) - '0' ) * 100 ;<br>        GSum = GSum + group * p ;<br>        p *= ( - 1 ) ;<br>    }<br>    return ( GSum % 7 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>PRODUCT_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int productAtKthLevel ( String tree , int k ) {<br>  int level = - 1 ;<br>  int product = 1 ;<br>  int n = tree . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( tree . charAt ( i ) == '(' ) level ++ ;<br>    else if ( tree . charAt ( i ) == ')' ) level -- ;<br>    else {<br>      if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ;<br>    }<br>  }<br>  return product ;<br>}<br></td>
    <td>translated code: <br><br> public static int productAtKthLevel ( String tree , int k ) {<br>    int level = - 1 ;<br>    int product = 1 ;<br>    int n = tree . size ( ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( tree . charAt ( i ) == '(' ) && ( tree . charAt ( i + 1 ) == ')' ) ) {<br>            level ++ ;<br>        }<br>        else if ( ( tree . charAt ( i ) == ')' ) ) {<br>            level -- ;<br>        }<br>        else {<br>            if ( ( level == k ) && ( level == 0 ) ) {<br>                product *= ( Integer . parseInt ( tree [ i ] ) - Integer . parseInt ( "0" ) ) ;<br>            }<br>        }<br>    }<br>    return product ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean isEven ( int n ) {<br>  return ( n % 2 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isEven ( int n ) {<br>    return ( n % 2 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS_IMMEDIATE_RIGHT_SUB_GROUP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countGroups ( int position , int previous_sum , int length , String num ) {<br>  if ( position == length ) return 1 ;<br>  int res = 0 ;<br>  int sum = 0 ;<br>  for ( int i = position ;<br>  i < length ;<br>  i ++ ) {<br>    sum += ( num . charAt ( i ) - '0' ) ;<br>    if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countGroups ( int position , int previousSum , int length , int [ ] num ) {<br>    if ( ( position == length ) && ( previousSum == 0 ) ) {<br>        return 1 ;<br>    }<br>    int res = 0 ;<br>    sum = 0 ;<br>    for ( int i = position ;  i < length ;  i ++ ) {<br>        sum = sum + ( int ) num [ i ] ;<br>        if ( ( sum >= previousSum ) && ( sum < previousSum ) ) {<br>            int [ ] res = new int [ num ] ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_ODD_NUMBER_OF_TIMES_IN_OLOG_N_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void search ( int arr [ ] , int low , int high ) {<br>  if ( low > high ) return ;<br>  if ( low == high ) {<br>    System . out . printf ( "The required element is %d " , arr [ low ] ) ;<br>    return ;<br>  }<br>  int mid = ( low + high ) / 2 ;<br>  if ( mid % 2 == 0 ) {<br>    if ( arr [ mid ] == arr [ mid + 1 ] ) search ( arr , mid + 2 , high ) ;<br>    else search ( arr , low , mid ) ;<br>  }<br>  else {<br>    if ( arr [ mid ] == arr [ mid - 1 ] ) search ( arr , mid + 1 , high ) ;<br>    else search ( arr , low , mid - 1 ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int search ( int [ ] arr , int low , int high ) {<br>    if ( low > high ) {<br>        return null ;<br>    }<br>    if ( low == high ) {<br>        return search ( arr , low , high , 0 ) ;<br>    }<br>    int mid = ( low + high ) / 2 ;<br>    if ( mid % 2 == 0 ){<br>        if ( arr [ mid ] == arr [ mid + 1 ] ) {<br>            return search ( arr , mid + 2 , high ) ;<br>        }<br>        if ( low > high ) {<br>            return search ( arr , low , mid -> mid > 0 ) ;<br>        }<br>    }<br>    if ( low > high ) {<br>        if ( arr [ mid ] == arr [ mid - 1 ] ) {<br>            return search ( arr , mid + 1 , high ) ;<br>        }<br>        if ( low > high ) {<br>            return search ( arr , low , mid - 1 ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>DELETE_CONSECUTIVE_WORDS_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int removeConsecutiveSame ( Vector < String > v ) {<br>  Stack < String > st = new Stack < > ( ) ;<br>  for ( int i = 0 ;<br>  i < v . size ( ) ;<br>  i ++ ) {<br>    if ( st . empty ( ) ) st . push ( v . get ( i ) ) ;<br>    else {<br>      String str = st . peek ( ) ;<br>      if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ;<br>      else st . push ( v . get ( i ) ) ;<br>    }<br>  }<br>  return st . size ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int removeConsecutiveSame ( String v ) {<br>    int [ ] st = new int [ 2 ] ;<br>    for ( int i = 0 ;  i < v . length ;  i ++ ) {<br>        if ( ( st . size ( ) == 0 ) && ( v == 5 ) ) {<br>            st . add ( v [ i ] ) ;<br>        }<br>        }<br>            Str = st . get ( st . size ( ) - 1 ) ;<br>            if ( ( Str . equals ( v [ i ] ) ) && ( Str . equals ( v [ j ] ) ) ) {<br>                st . remove ( v ) ;<br>            }<br>            }<br>                st . add ( v [ i ] ) ;<br>    }<br>    return st . size ( ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minJumps ( int arr [ ] , int n ) {<br>  int [ ] jumps = new int [ n ] ;<br>  int min ;<br>  jumps [ n - 1 ] = 0 ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ;<br>    else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;<br>    else {<br>      min = Integer . MAX_VALUE ;<br>      for ( int j = i + 1 ;<br>      j < n && j <= arr [ i ] + i ;<br>      j ++ ) {<br>        if ( min > jumps [ j ] ) min = jumps [ j ] ;<br>      }<br>      if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ;<br>      else jumps [ i ] = min ;<br>    }<br>  }<br>  return jumps [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minJumps ( int [ ] arr , int n ) {<br>    int [ ] jumps = new int [ n ] ;<br>    for ( int i = n - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( arr [ i ] == 0 ) && ( n > 0 ) ) {<br>            jumps [ i ] = Double . POSITIVE_INFINITY ;<br>        }<br>        if ( ( arr [ i ] >= n - i - 1 ) && ( arr [ i ] >= 0 ) ) {<br>            jumps [ i ] = 1 ;<br>        }<br>        else {<br>            float min = Float . POSITIVE_INFINITY ;<br>            for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>                if ( ( j <= arr [ i ] + i ) && ( j <= arr [ n ] ) ) {<br>                    if ( ( min > jumps [ j ] ) && ( j < n ) ){<br>                        int min = jumps [ j ] ;<br>                    }<br>                }<br>            }<br>            if ( ( min != Double . POSITIVE_INFINITY ) && ( n > 0 ) ) {<br>                jumps [ i ] = min + 1 ;<br>            }<br>            else {<br>                jumps [ i ] = min ;<br>            }<br>        }<br>    }<br>    return jumps [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double gcd ( double a , double b ) {<br>  if ( a < b ) return gcd ( b , a ) ;<br>  if ( Math . abs ( b ) < 0.001 ) return a ;<br>  else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double gcd ( double a , double b ) {<br>    if ( ( a < b ) && ( a != b ) ) {<br>        return gcd ( b , a ) ;<br>    }<br>    if ( ( Math . abs ( b ) < 0.001 ) && ( a > b ) ){<br>        return a % b ;<br>    }<br>    if ( a == 0 ) {<br>        return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxProfit ( int price [ ] , int n ) {<br>  int profit [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) profit [ i ] = 0 ;<br>  int max_price = price [ n - 1 ] ;<br>  for ( int i = n - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( price [ i ] > max_price ) max_price = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ;<br>  }<br>  int min_price = price [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( price [ i ] < min_price ) min_price = price [ i ] ;<br>    profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ;<br>  }<br>  int result = profit [ n - 1 ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxProfit ( int [ ] price , int n ) {<br>    profit = new int [ n ] ;<br>    maxPrice = price [ n - 1 ] ;<br>    for ( int i = n - 2 ;  i > 0 ;  i -- ) {<br>        if ( price [ i ] > maxPrice ) {<br>            maxPrice = price [ i ] ;<br>        }<br>        profit [ i ] = Math . max ( profit [ i + 1 ] , maxPrice - price [ i ] ) ;<br>    }<br>    minPrice = price [ 0 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( price [ i ] < minPrice ) {<br>            minPrice = price [ i ] ;<br>        }<br>        profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - minPrice ) ) ;<br>    }<br>    double result = profit [ n - 1 ] ;<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int countSetBits ( int n ) {<br>  if ( n == 0 ) return 0 ;<br>  else return ( n & 1 ) + countSetBits ( n >> 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int countSetBits ( int n ) {<br>    if ( ( n == 0 ) && ( a == 5 ) ) {<br>        return 0 ;<br>    }<br>    }<br>        return ( n & 1 ) + countSetBits ( n >> 1 ) ;<br>}</td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reorder ( ) {<br>  int temp [ ] = new int [ arr . length ] ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) temp [ index [ i ] ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    arr [ i ] = temp [ i ] ;<br>    index [ i ] = i ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void reorder ( int [ ] arr , int [ ] index , int n ) {<br>    int [ ] temp = new int [ n ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        temp [ index [ i ] ] = arr [ i ] ;<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        arr [ i ] = temp [ i ] ;<br>        index [ i ] = i ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> boolean canRepresentBST ( int pre [ ] , int n ) {<br>  Stack < Integer > s = new Stack < Integer > ( ) ;<br>  int root = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( pre [ i ] < root ) {<br>      return false ;<br>    }<br>    while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) {<br>      root = s . peek ( ) ;<br>      s . pop ( ) ;<br>    }<br>    s . push ( pre [ i ] ) ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean canRepresentBST ( int [ ] pre ) {<br>    StringBuilder sb = new StringBuilder ( ) ;<br>    int root = INT_MIN ;<br>    for ( Integer value : pre ) {<br>        if ( value < root ){<br>            return false ;<br>        }<br>        while ( ( s . length ( ) > 0 ) && s . charAt ( s . length ( ) - 1 ) < value ) {<br>            Node root = s . remove ( ) ;<br>        }<br>        s . add ( value ) ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findRepeating ( int arr [ ] , int n ) {<br>  int missingElement = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int element = arr [ Math . abs ( arr [ i ] ) ] ;<br>    if ( element < 0 ) {<br>      missingElement = arr [ i ] ;<br>      break ;<br>    }<br>    arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>  }<br>  return Math . abs ( missingElement ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findRepeating ( int [ ] arr , int n ) {<br>    int missingElement = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int element = arr [ Math . abs ( arr [ i ] ) ] ;<br>        if ( ( element < 0 ) && ( element < n ) ) {<br>            int missingElement = arr [ i ] ;<br>            break ;<br>        }<br>        arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ;<br>    }<br>    return Math . abs ( missingElement ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int MatrixChainOrder ( int p [ ] , int n ) {<br>  int m [ ] [ ] = new int [ n ] [ n ] ;<br>  int i , j , k , L , q ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) m [ i ] [ i ] = 0 ;<br>  for ( L = 2 ;<br>  L < n ;<br>  L ++ ) {<br>    for ( i = 1 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( j == n ) continue ;<br>      m [ i ] [ j ] = Integer . MAX_VALUE ;<br>      for ( k = i ;<br>      k <= j - 1 ;<br>      k ++ ) {<br>        q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ;<br>        if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ;<br>      }<br>    }<br>  }<br>  return m [ 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int MatrixChainOrder ( int [ ] p , int n ) {<br>    int [ ] [ ] m = new int [ n ] [ n ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        m [ i ] [ i ] = 0 ;<br>    }<br>    for ( int L = 2 ;  L < n ;  L ++ ) {<br>        for ( int i = 1 ;  i <= n - L + 1 ;  i ++ ) {<br>            int j = i + L - 1 ;<br>            m [ i ] [ j ] = Integer . MAX_VALUE ;<br>            for ( int k = i ;  k < j ;  k ++ ) {<br>                q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ;<br>                if ( q < m [ i ] [ j ] ){<br>                    m [ i ] [ j ] = q ;<br>                }<br>            }<br>        }<br>    }<br>    return m [ 1 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countIslands ( int mat [ ] [ ] , int m , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( mat [ i ] [ j ] == 'X' ) {<br>        if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) count ++ ;<br>      }<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countIslands ( char [ ] [ ] mat ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= M ;  i ++ ) {<br>        for ( int j = 0 ;  j <= N ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] == 'X' ) && ( mat [ i ] [ j ] == 'Y' ) ) {<br>                if ( ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) && ( ( i == 0 || mat [ i ] [ j ] == 'O' ) && ( j == 0 || mat [ i ] [ j - 1 ] == 'O' ) ) ) {<br>                    count = count + 1 ;<br>                }<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>MINIMIZE_MAXAI_BJ_CK_MINAI_BJ_CK_THREE_DIFFERENT_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int solve ( int [ ] A , int [ ] B , int [ ] C ) {<br>  int i , j , k ;<br>  i = A . length - 1 ;<br>  j = B . length - 1 ;<br>  k = C . length - 1 ;<br>  int min_diff , current_diff , max_term ;<br>  min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ;<br>  while ( i != - 1 && j != - 1 && k != - 1 ) {<br>    current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ;<br>    if ( current_diff < min_diff ) min_diff = current_diff ;<br>    max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ;<br>    if ( A [ i ] == max_term ) i -= 1 ;<br>    else if ( B [ j ] == max_term ) j -= 1 ;<br>    else k -= 1 ;<br>  }<br>  return min_diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int solve ( int [ ] A , int [ ] B , int [ ] C ) {<br>    int i = A . length - 1 ;<br>    int j = B . length - 1 ;<br>    int k = C . length - 1 ;<br>    int minDiff = Math . abs ( Math . max ( A [ i ] , B [ j ] , C [ k ] ) - Math . min ( A [ i ] , B [ j ] , C [ k ] ) ) ;<br>    while ( i != - 1 && j != - 1 && k != - 1 ){<br>        int currentDiff = Math . abs ( Math . max ( A [ i ] , B [ j ] , C [ k ] ) - Math . min ( A [ i ] , B [ j ] , C [ k ] ) ) ;<br>        if ( currentDiff < minDiff ){<br>            minDiff = currentDiff ;<br>        }<br>        int maxTerm = Math . max ( A [ i ] , B [ j ] , C [ k ] ) ;<br>        if ( A [ i ] == maxTerm ){<br>            i -- ;<br>        }<br>        if ( B [ j ] == maxTerm ){<br>            j -- ;<br>        }<br>        else{<br>            k -- ;<br>        }<br>    }<br>    return minDiff ;<br>}</td>
  </tr><tr>
    <th>ROOTS_QUADRATIC_EQUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void findRoots ( int a , int b , int c ) {<br>  if ( a == 0 ) {<br>    System . out . println ( "Invalid" ) ;<br>    return ;<br>  }<br>  int d = b * b - 4 * a * c ;<br>  double sqrt_val = sqrt ( abs ( d ) ) ;<br>  if ( d > 0 ) {<br>    System . out . println ( "Roots are real and different \n" ) ;<br>    System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "\n" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ;<br>  }<br>  else {<br>    System . out . println ( "Roots are complex \n" ) ;<br>    System . out . println ( - ( double ) b / ( 2 * a ) + " + i" + sqrt_val + "\n" + - ( double ) b / ( 2 * a ) + " - i" + sqrt_val ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int findRoots ( int a , int b , int c ) {<br>    if ( a == 0 ){<br>        System . out . println ( "Invalid" ) ;<br>        return - 1 ;<br>    }<br>    int d = b * b - 4 * a * c ;<br>    double sqrt_val = Math . sqrt ( Math . abs ( d ) ) ;<br>    if ( d > 0 ){<br>        System . out . println ( "Roots are real and different " ) ;<br>        System . out . println ( ( - b + sqrt_val ) / ( 2 * a ) ) ;<br>        System . out . println ( ( - b - sqrt_val ) / ( 2 * a ) ) ;<br>    }<br>    else if ( d == 0 ){<br>        System . out . println ( "Roots are real and same" ) ;<br>        System . out . println ( - b / ( 2 * a ) ) ;<br>    }<br>    if ( a > b ) {<br>        System . out . println ( "Roots are complex" ) ;<br>        System . out . println ( - b / ( 2 * a ) + " + i" + sqrt_val ) ;<br>        System . out . println ( - b / ( 2 * a ) + " - i" + sqrt_val ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMinHeap ( int [ ] level ) {<br>  int n = level . length - 1 ;<br>  for ( int i = ( n / 2 - 1 ) ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;<br>    if ( 2 * i + 2 < n ) {<br>      if ( level [ i ] > level [ 2 * i + 2 ] ) return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMinHeap ( int [ ] level , int n ) {<br>    for ( int i = Integer . MAX_VALUE / 2 ;  i >= 0 ;  i -- ) {<br>        if ( level [ i ] > level [ 2 * i + 1 ] ) {<br>            return false ;<br>        }<br>        if ( 2 * i + 2 < n ){<br>            if ( level [ i ] > level [ 2 * i + 2 ] ) {<br>                return false ;<br>            }<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMin ( int arr [ ] , int low , int high ) {<br>  if ( high < low ) return arr [ 0 ] ;<br>  if ( high == low ) return arr [ low ] ;<br>  int mid = low + ( high - low ) / 2 ;<br>  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;<br>  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;<br>  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ;<br>  return findMin ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMin ( int [ ] arr , int low , int high ) {<br>    if ( high < low ) {<br>        return findMin ( arr , low , high , 0 ) ;<br>    }<br>    if ( high == low ) {<br>        return findMin ( arr , low , high , 0 ) ;<br>    }<br>    int mid = ( int ) ( ( low + high ) / 2 ) ;<br>    if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ){<br>        return arr [ mid + 1 ] ;<br>    }<br>    if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ){<br>        return arr [ mid ] ;<br>    }<br>    if ( arr [ high ] > arr [ mid ] ) {<br>        return findMin ( arr , low , mid - 1 ) ;<br>    }<br>    return findMin ( arr , mid + 1 , high ) ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTINCT_ADJACENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int stringReduction ( String str ) {<br>  int n = str . length ( ) ;<br>  int count [ ] = new int [ 3 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    count [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) {<br>    return n ;<br>  }<br>  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) {<br>    return 2 ;<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int stringReduction ( String str ) {<br>    int n = str . length ( ) ;<br>    int [ ] count = {<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        count [ ( int ) str . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    if ( ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) && ( count [ 3 ] == n ) ) {<br>        return n ;<br>    }<br>    if ( ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) || ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) ) {<br>        return 2 ;<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_3_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  int digitSum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;<br>  return ( digitSum % 3 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( int num ) {<br>    digitSum = 0 ;<br>    while ( num -- > 0 ) {<br>        int rem = num % 10 ;<br>        digitSum = digitSum + rem ;<br>        num = num / 10 ;<br>    }<br>    return ( digitSum % 3 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_N_UNDER_MODULO_P</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int modFact ( int n , int p ) {<br>  if ( n >= p ) return 0 ;<br>  int result = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) result = ( result * i ) % p ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> static int modFact ( int n , int p ) {<br>    if ( n >= p ){<br>        return 0 ;<br>    }<br>    int result = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        result = ( result * i ) % p ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPresent ( String s , String q ) {<br>  int [ ] freq = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) freq [ s . charAt ( i ) ] ++ ;<br>  for ( int i = 0 ;<br>  i < q . length ( ) ;<br>  i ++ ) {<br>    freq [ q . charAt ( i ) ] -- ;<br>    if ( freq [ q . charAt ( i ) ] < 0 ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPresent ( String s , String q ) {<br>    freq = new int [ MAX_CHAR ] ;<br>    for ( int i = 0 ;  i <= s . length ( ) ;  i ++ ) {<br>        freq [ ( int ) s . charAt ( i ++ ) ] ++ ;<br>    }<br>    for ( int i = 0 ;  i != q . length ;  i ++ ) {<br>        freq [ ( int ) q . charAt ( i ++ ) ] -- ;<br>        if ( ( freq [ ( int ) q . charAt ( i ) ] < 0 ) && ( freq [ ( int ) q . charAt ( i ) ] > 0 ) ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>NEXT_POWER_OF_2_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  int p = 1 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( p < n ) p <<= 1 ;<br>  return p ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>    p = 1 ;<br>    if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) {<br>        return n ;<br>    }<br>    while ( ( p < n ) && ( p < n ) ) {<br>        p <<= 1 ;<br>    }<br>    return p ;<br>}</td>
  </tr><tr>
    <th>REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void reorder ( ) {<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) {<br>    while ( index [ i ] != i ) {<br>      int oldTargetI = index [ index [ i ] ] ;<br>      char oldTargetE = ( char ) arr [ index [ i ] ] ;<br>      arr [ index [ i ] ] = arr [ i ] ;<br>      index [ index [ i ] ] = index [ i ] ;<br>      index [ i ] = oldTargetI ;<br>      arr [ i ] = oldTargetE ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void reorder ( int [ ] arr , int [ ] index , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        while ( ( index [ i ] != i ) && ( index [ i ] != n ) ) {<br>            int oldTargetI = index [ index [ i ] ] ;<br>            int oldTargetE = arr [ index [ i ] ] ;<br>            reorder ( arr , index , n , arr . length ) ;<br>            index [ index [ i ] ] = index [ i ] ;<br>            index [ i ] = oldTargetI ;<br>            arr [ i ] = oldTargetE ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>UNBOUNDED_KNAPSACK_REPETITION_ITEMS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) {<br>  int dp [ ] = new int [ W + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= W ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( wt [ j ] <= i ) {<br>        dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ;<br>      }<br>    }<br>  }<br>  return dp [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) {<br>    int [ ] dp = new int [ W + 1 ] ;<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < W + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( wt [ j ] <= i ) && ( wt [ j ] > val ) ){<br>                dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ W ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isDiagonalMatrix ( int mat [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isDiagonalMatrix ( int [ ] [ ] mat ) {<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        for ( int j = 0 ;  j <= N ;  j ++ ) {<br>            if ( ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) || ( ( i == j ) && ( mat [ i ] [ j ] == 0 ) ) ){<br>                return false ;<br>            }<br>        }<br>    }<br>    return isDiagonalMatrix ( mat , 0 , mat . length ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_REMOVAL_FROM_ARRAY_WHEN_REMOVAL_TIME_WAITING_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxRemoval ( int arr [ ] , int n ) {<br>  int count = 0 ;<br>  int cummulative_sum = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] >= cummulative_sum ) {<br>      count ++ ;<br>      cummulative_sum += arr [ i ] ;<br>    }<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxRemoval ( int [ ] arr , int n ) {<br>    int count = 0 ;<br>    cummulativeSum = 0 ;<br>    Arrays . sort ( arr , 0 , n ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] >= cummulativeSum ) {<br>            count ++ ;<br>            cummulativeSum += arr [ i ] ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String censor ( String text , String word ) {<br>  String [ ] word_list = text . split ( "\\s+" ) ;<br>  String result = "" ;<br>  String stars = "" ;<br>  for ( int i = 0 ;<br>  i < word . length ( ) ;<br>  i ++ ) stars += '*' ;<br>  int index = 0 ;<br>  for ( String i : word_list ) {<br>    if ( i . compareTo ( word ) == 0 ) word_list [ index ] = stars ;<br>    index ++ ;<br>  }<br>  for ( String i : word_list ) result += i + ' ' ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static String censor ( String text , String word ) {<br>    String [ ] wordArray = text . split ( " " ) ;<br>    String result = "" ;<br>    String stars = "*" ;<br>    int count = 0 ;<br>    int index = 0 ;<br>    for ( int i = 0 ;  i < wordList . length ;  i ++ ) {<br>        if ( i == word ) {<br>            wordList [ index ++ ] = stars ;<br>        }<br>        index ++ ;<br>    }<br>    String result = censor ( text , word ) ;<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_STRINGS_WITH_CONSECUTIVE_1S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countStrings ( int n ) {<br>  int a [ ] = new int [ n ] , b [ ] = new int [ n ] ;<br>  a [ 0 ] = b [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>    b [ i ] = a [ i - 1 ] ;<br>  }<br>  from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> static int countStrings ( int n ) {<br>    int [ ] a = new int [ n ] ;<br>    StringBuilder b = new StringBuilder ( 0 ) ;<br>    a [ 0 ] = b [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;<br>        b [ i ] = a [ i - 1 ] ;<br>    }<br>    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>LENGTH_LONGEST_BALANCED_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLength ( String s , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ;<br>  for ( int l = 2 ;<br>  l < n ;<br>  l ++ ) {<br>    for ( int i = 0 , j = l ;<br>    j < n ;<br>    i ++ , j ++ ) {<br>      if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ;<br>      for ( int k = i ;<br>      k < j ;<br>      k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLength ( String s , int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) || ( s . charAt ( i + 1 ) == '(' && s . charAt ( i + 2 ) == ')' ) ) {<br>            dp [ i ] [ i + 1 ] = 2 ;<br>        }<br>    }<br>    for ( int l = 2 ;  l <= n ;  l ++ ) {<br>        int i = - 1 ;<br>        for ( int j = l ;  j < n ;  j ++ ) {<br>            i ++ ;<br>            if ( ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) || ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) ) {<br>                dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ;<br>            }<br>            for ( int k = i ;  k < j ;  k ++ ) {<br>                dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ 0 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_POINT_WHERE_MAXIMUM_INTERVALS_OVERLAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) {<br>  Arrays . sort ( arrl ) ;<br>  Arrays . sort ( exit ) ;<br>  int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ;<br>  int i = 1 , j = 0 ;<br>  while ( i < n && j < n ) {<br>    if ( arrl [ i ] <= exit [ j ] ) {<br>      guests_in ++ ;<br>      if ( guests_in > max_guests ) {<br>        max_guests = guests_in ;<br>        time = arrl [ i ] ;<br>      }<br>      i ++ ;<br>    }<br>    else {<br>      guests_in -- ;<br>      j ++ ;<br>    }<br>  }<br>  System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) {<br>    Collections . sort ( arrl ) ;<br>    Collections . sort ( exit ) ;<br>    guestsIn = 1 ;<br>    maxGuests = 1 ;<br>    long time = array [ 0 ] ;<br>    int i = 1 ;<br>    int j = 0 ;<br>    while ( ( i < n && j < n ) || ( i > n && j > n ) ) {<br>        if ( ( arrl [ i ] <= exit [ j ] ) && ( arrl [ i ] >= exit [ j ] ) ) {<br>            guestsIn = guestsIn + 1 ;<br>            if ( ( guestsIn > maxGuests ) && ( exit ) ) {<br>                maxGuests = guestsIn ;<br>                int time = arrl [ i ] ;<br>            }<br>            i = i + 1 ;<br>        }<br>        else {<br>            guestsIn = guestsIn - 1 ;<br>            j = j + 1 ;<br>        }<br>    }<br>    System . out . println ( "Maximum Number of Guests =" + maxGuests + " at time" + time ) ;<br>}</td>
  </tr><tr>
    <th>EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isMultipleOf10 ( int n ) {<br>  if ( n % 15 == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isMultipleOf10 ( int n ) {<br>    return ( n % 15 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) {<br>  Arrays . sort ( arr ) ;<br>  int dp [ ] = new int [ N ] ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) {<br>    dp [ i ] = dp [ i - 1 ] ;<br>    if ( arr [ i ] - arr [ i - 1 ] < K ) {<br>      if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ;<br>      else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ;<br>    }<br>  }<br>  return dp [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int K ) {<br>    Arrays . sort ( arr , 0 , N ) ;<br>    int [ ] dp = new int [ N ] ;<br>    dp [ 0 ] = 0 ;<br>    for ( int i = 1 ;  i < N ;  i ++ ) {<br>        dp [ i ] = dp [ i - 1 ] ;<br>        if ( ( arr [ i ] - arr [ i - 1 ] < K ) && ( arr [ i ] - arr [ i - 2 ] < K ) ) {<br>            if ( ( i >= 2 ) && ( i <= K ) ) {<br>                dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ;<br>            }<br>            else {<br>                dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) {<br>  if ( k > n1 * n2 ) {<br>    System . out . print ( "k pairs don't exist" ) ;<br>    return ;<br>  }<br>  int index2 [ ] = new int [ n1 ] ;<br>  while ( k > 0 ) {<br>    int min_sum = Integer . MAX_VALUE ;<br>    int min_index = 0 ;<br>    for ( int i1 = 0 ;<br>    i1 < n1 ;<br>    i1 ++ ) {<br>      if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) {<br>        min_index = i1 ;<br>        min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;<br>      }<br>    }<br>    System . out . print ( "(" + arr1 [ min_index ] + ", " + arr2 [ index2 [ min_index ] ] + ") " ) ;<br>    index2 [ min_index ] ++ ;<br>    k -- ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void kSmallestPair ( int [ ] arr1 , int n1 , int [ ] arr2 , int n2 , int k ) {<br>    if ( ( k > n1 * n2 ) && ( k > arr2 * n2 ) ) {<br>        System . out . println ( "k pairs don't exist" ) ;<br>        }<br>    }<br>    int index2 [ ] = new int [ n1 ] ;<br>    while ( ( k -- > 0 ) && ( arr1 [ k ] > arr2 [ k ] ) ) {<br>        int minSum = Integer . MAX_VALUE ;<br>        int minIndex = 0 ;<br>        for ( int i1 = 0 ;  i1 < n1 ;  i1 += 1 ) {<br>            if ( ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < minSum ) || ( index2 [ i1 ] < n1 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < minSum ) ) {<br>                int minIndex = i1 ;<br>                int minSum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;<br>            }<br>        }<br>        System . out . print ( "(" + arr1 [ minIndex ] + "," + arr2 [ index2 [ minIndex ] ] + ")" + " " ) ;<br>        index2 [ minIndex ++ ] = arr1 ;<br>        k -- ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char first ( String str , int i ) {<br>  if ( str . charAt ( i ) == '\0' ) return 0 ;<br>  if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ;<br>  return first ( str , i + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int first ( String str , int i ) {<br>    if ( ( str . charAt ( i ) == '\0' ) && ( str . charAt ( i + 1 ) == '\0' ) ) {<br>        return 0 ;<br>    }<br>    if ( ( str . charAt ( i ) == ' ' ) && ( str . charAt ( i + 1 ) == ' ' ) ) {<br>        return str . substring ( i ) ;<br>    }<br>    return first ( str , i + 1 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_PAIRS_B_ARRAY_B_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean printPairs ( int arr [ ] , int n , int k ) {<br>  boolean isPairFound = true ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i != j && arr [ i ] % arr [ j ] == k ) {<br>        System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ;<br>        isPairFound = true ;<br>      }<br>    }<br>  }<br>  return isPairFound ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean printPairs ( int [ ] arr , int n , int k ) {<br>    isPairFound = true ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( i != j && arr [ i ] % arr [ j ] == k ) || ( i == j && arr [ i ] % arr [ j ] == k ) ){<br>                System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + ", " + arr [ k ] + ")" + " " ) ;<br>                isPairFound = true ;<br>            }<br>        }<br>    }<br>    return isPairFound ;<br>}</td>
  </tr><tr>
    <th>FIND_ARRANGEMENT_QUEUE_GIVEN_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void solve ( int n , int t , char s [ ] ) {<br>  for ( int i = 0 ;<br>  i < t ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n - 1 ;<br>  j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {<br>    char temp = s [ j ] ;<br>    s [ j ] = s [ j + 1 ] ;<br>    s [ j + 1 ] = temp ;<br>    j ++ ;<br>  }<br>  System . out . print ( s ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void solve ( int n , int t , char [ ] p ) {<br>    List < Integer > s = Arrays . asList ( p ) ;<br>    for ( int i = 0 ;  i <= t ;  i ++ ) {<br>        for ( int j = 0 ;  j <= n - 1 ;  j ++ ) {<br>            if ( ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) || ( s [ j ] == 'C' && s [ j + 1 ] == 'D' ) ){<br>                int temp = s [ j ] ;<br>                s [ j ] = s [ j + 1 ] ;<br>                s [ j ++ ] = temp ;<br>                j = j + 1 ;<br>            }<br>        }<br>    }<br>    System . out . println ( "" + s ) ;<br>}</td>
  </tr><tr>
    <th>SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printSuperSeq ( String a , String b ) {<br>  int m = a . length ( ) , n = b . length ( ) ;<br>  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 ) dp [ i ] [ j ] = j ;<br>      else if ( j == 0 ) dp [ i ] [ j ] = i ;<br>      else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  String res = "" ;<br>  int i = m , j = n ;<br>  while ( i > 0 && j > 0 ) {<br>    if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) {<br>      res = a . charAt ( i - 1 ) + res ;<br>      i -- ;<br>      j -- ;<br>    }<br>    else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {<br>      res = a . charAt ( i - 1 ) + res ;<br>      i -- ;<br>    }<br>    else {<br>      res = b . charAt ( j - 1 ) + res ;<br>      j -- ;<br>    }<br>  }<br>  while ( i > 0 ) {<br>    res = a . charAt ( i - 1 ) + res ;<br>    i -- ;<br>  }<br>  while ( j > 0 ) {<br>    res = b . charAt ( j - 1 ) + res ;<br>    j -- ;<br>  }<br>  System . out . println ( res ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void printSuperSeq ( String a , String b ) {<br>    int m = a . length ;<br>    int n = b . length ;<br>    int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ;<br>    for ( int i = 0 ;  i <= m ;{<br>        for ( int j = 0 ;  j <= n ;{<br>            if ( ! i ){<br>                dp [ i ] [ j ] = j ;<br>            }<br>            else if ( ! j ){<br>                dp [ i ] [ j ] = i ;<br>            }<br>            else if ( ( a [ i - 1 ] == b [ j - 1 ] ) && ( a [ i ] == b [ j - 1 ] ) ) a [ i ] = 5 ;<br>                dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;<br>            else{<br>                dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    int index = dp [ m ] [ n ] ;<br>    String res = new String ( "" ) ;<br>    int i = m ;<br>    int j = n ;<br>    while ( ( i > 0 && j > 0 ) || ( i < 0 && j < 0 ) ) {<br>        if ( ( a [ i - 1 ] == b [ j - 1 ] ) && ( a [ i - 1 ] == b [ j - 1 ] ) ) {<br>            res [ index - 1 ] = a [ i - 1 ] ;<br>            i -- ;<br>            j -- ;<br>            index -- ;<br>        }<br>        else if ( ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) && ( dp [ i ] [ j - 1 ] > dp [ i ] [ j - 1 ] ) ){<br>            res [ index - 1 ] = a [ i - 1 ] ;<br>            i -- ;<br>            index -- ;<br>        }<br>        else{<br>            res [ index - 1 ] = b [ j - 1 ] ;<br>            j -- ;<br>            index -- ;<br>        }<br>    }<br>    while ( ( i > 0 ) && ( i < b ) ) {<br>        res [ index - 1 ] = a [ i - 1 ] ;<br>        i -- ;<br>        index -- ;<br>    }<br>    while ( ( j > 0 ) && ( a < 5 ) ) {<br>        res [ index - 1 ] = b [ j - 1 ] ;<br>        j -- ;<br>        index -- ;<br>    }<br>    System . out . println ( "" + res ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_ROTATIONS_DIVISIBLE_8</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotationsDivBy8 ( String n ) {<br>  int len = n . length ( ) ;<br>  int count = 0 ;<br>  if ( len == 1 ) {<br>    int oneDigit = n . charAt ( 0 ) - '0' ;<br>    if ( oneDigit % 8 == 0 ) return 1 ;<br>    return 0 ;<br>  }<br>  if ( len == 2 ) {<br>    int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ;<br>    int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ;<br>    if ( first % 8 == 0 ) count ++ ;<br>    if ( second % 8 == 0 ) count ++ ;<br>    return count ;<br>  }<br>  int threeDigit ;<br>  for ( int i = 0 ;<br>  i < ( len - 2 ) ;<br>  i ++ ) {<br>    threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ;<br>    if ( threeDigit % 8 == 0 ) count ++ ;<br>  }<br>  threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ;<br>  if ( threeDigit % 8 == 0 ) count ++ ;<br>  threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ;<br>  if ( threeDigit % 8 == 0 ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotationsDivBy8 ( String n ) {<br>    int l = n . length ;<br>    int count = 0 ;<br>    if ( ( l == 1 ) && ( n == 2 ) ) {<br>        int oneDigit = Integer . parseInt ( n . substring ( 0 , 1 ) ) ;<br>        if ( ( oneDigit % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>            return 1 ;<br>        }<br>        return 0 ;<br>    }<br>    if ( ( l == 2 ) && ( n == 3 ) ) {<br>        int first = ( int ) n [ 0 ] * 10 + ( int ) n [ 1 ] ;<br>        int second = Integer . parseInt ( n . substring ( 1 ) ) * 10 + Integer . parseInt ( n . substring ( 0 ) ) ;<br>        if ( ( first % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>            count ++ ;<br>        }<br>        if ( ( second % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>            count ++ ;<br>        }<br>        return count ;<br>    }<br>    threeDigit = 0 ;<br>    for ( int i = 0 ;  i <= ( l - 2 ) ;  i ++ ) {<br>        int threeDigit = ( Integer . parseInt ( n . substring ( i , i + 3 ) ) * 100 + Integer . parseInt ( n . substring ( i + 1 , i + 3 ) ) * 10 + Integer . parseInt ( n . substring ( i + 2 ) ) ) ;<br>        if ( ( threeDigit % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>            count ++ ;<br>        }<br>    }<br>    threeDigit = ( Integer . parseInt ( n . charAt ( l - 1 ) ) * 100 + Integer . parseInt ( n . charAt ( 0 ) ) * 10 + Integer . parseInt ( n . charAt ( 1 ) ) ) ;<br>    if ( ( threeDigit % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>        count ++ ;<br>    }<br>    threeDigit = ( Integer . parseInt ( n . charAt ( l - 2 ) ) * 100 + Integer . parseInt ( n . charAt ( l - 1 ) ) * 10 + Integer . parseInt ( n . charAt ( 0 ) ) ) ;<br>    if ( ( threeDigit % 8 == 0 ) && ( n % 8 == 0 ) ) {<br>        count ++ ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) {<br>  if ( k < 0 ) return - 10000000 ;<br>  if ( n < 0 || m < 0 ) return 0 ;<br>  int ans = dp [ n ] [ m ] [ k ] ;<br>  if ( ans != - 1 ) return ans ;<br>  try {<br>    ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ;<br>    if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ;<br>    ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ;<br>  }<br>  catch ( Exception e ) {<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) {<br>    if ( k < 0 ) {<br>        return - ( 10 * 7 ) ;<br>    }<br>    if ( n < 0 || m < 0 ){<br>        return 0 ;<br>    }<br>    int ans = dp [ n ] [ m ] [ k ] ;<br>    if ( ans != - 1 ) {<br>        return ans ;<br>    }<br>    int ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ;<br>    if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) {<br>        ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ;<br>    }<br>    ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ;<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>CHECK_LINE_TOUCHES_INTERSECTS_CIRCLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void checkCollision ( int a , int b , int c , int x , int y , int radius ) {<br>  double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ;<br>  if ( radius == dist ) System . out . println ( "Touch" ) ;<br>  else if ( radius > dist ) System . out . println ( "Intersect" ) ;<br>  else System . out . println ( "Outside" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void checkCollision ( float a , float b , float c , float x , float y , float radius ) {<br>    float dist = ( ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ) ;<br>    if ( ( radius == dist ) && ( x == a ) && ( y == b ) && ( x == c ) ) {<br>        System . out . println ( "Touch" ) ;<br>    }<br>    else if ( ( radius > dist ) && ( x < dist ) && ( y < dist ) ){<br>        System . out . println ( "Intersect" ) ;<br>    }<br>    if ( a > b ) {<br>        System . out . println ( "Outside" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubarrayXOR ( int arr [ ] , int n ) {<br>  int ans = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_xor = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      curr_xor = curr_xor ^ arr [ j ] ;<br>      ans = Math . max ( ans , curr_xor ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubarrayXOR ( int [ ] arr , int n ) {<br>    int ans = - 2147483648 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int currXor = 0 ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            currXor = currXor ^ arr [ j ] ;<br>            ans = Math . max ( ans , currXor ) ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) {<br>  if ( k == 0 && u == v ) return 0 ;<br>  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ;<br>  if ( k <= 0 ) return INF ;<br>  int res = INF ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) {<br>    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {<br>      int rec_res = shortestPath ( graph , i , v , k - 1 ) ;<br>      if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int shortestPath ( int [ ] [ ] graph , int u , int v , int k ) {<br>    int V = 4 ;<br>    int INF = 999999999999 ;<br>    if ( k == 0 && u == v ) {<br>        return 0 ;<br>    }<br>    if ( k == 1 && graph [ u ] [ v ] != INF ){<br>        return shortestPath ( graph , u , v , k , 0 ) ;<br>    }<br>    if ( k <= 0 ) {<br>        return INF ;<br>    }<br>    int res = INF ;<br>    for ( int i = 0 ;  i < V ;  i ++ ) {<br>        if ( graph [ u ] [ i ] != INF && u != i && v != i ){<br>            int recRes = shortestPath ( graph , i , v , k - 1 ) ;<br>            if ( recRes != INF ) {<br>                res = Math . min ( res , graph [ u ] [ i ] + recRes ) ;<br>            }<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int subArraySum ( int arr [ ] , int n , int sum ) {<br>  int curr_sum , i , j ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_sum = arr [ i ] ;<br>    for ( j = i + 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( curr_sum == sum ) {<br>        int p = j - 1 ;<br>        System . out . println ( "Sum found between indexes " + i + " and " + p ) ;<br>        return 1 ;<br>      }<br>      if ( curr_sum > sum || j == n ) break ;<br>      curr_sum = curr_sum + arr [ j ] ;<br>    }<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int subArraySum ( int [ ] arr , int n , int sum ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int currSum = arr [ i ] ;<br>        int j = i + 1 ;<br>        while ( j <= n ) {<br>            if ( currSum == sum ) {<br>                System . out . println ( "Sum found between" ) ;<br>                System . out . println ( "indexes " + i + " and " + j - 1 ) ;<br>                return 1 ;<br>            }<br>            if ( currSum > sum || j == n ){<br>                break ;<br>            }<br>            currSum = currSum + arr [ j ] ;<br>            j ++ ;<br>        }<br>    }<br>    System . out . println ( "No subarray found" ) ;<br>    return 0 ;<br>}</td>
  </tr><tr>
    <th>K_TH_PRIME_FACTOR_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int kPrimeFactor ( int n , int k ) {<br>  while ( n % 2 == 0 ) {<br>    k -- ;<br>    n = n / 2 ;<br>    if ( k == 0 ) return 2 ;<br>  }<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i = i + 2 ) {<br>    while ( n % i == 0 ) {<br>      if ( k == 1 ) return i ;<br>      k -- ;<br>      n = n / i ;<br>    }<br>  }<br>  if ( n > 2 && k == 1 ) return n ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int kPrimeFactor ( int n , int k ) {<br>    while ( ( n % 2 == 0 ) && ( n % k == 0 ) ) {<br>        k = k - 1 ;<br>        n = n / 2 ;<br>        if ( ( k == 0 ) && ( n > 0 ) ) {<br>            return 2 ;<br>        }<br>    }<br>    int i = 3 ;<br>    while ( i <= Math . sqrt ( n ) ){<br>        while ( ( n % i == 0 ) && ( n % i == k ) ) {<br>            if ( ( k == 1 ) && ( n > 1 ) ) {<br>                return i ;<br>            }<br>            k = k - 1 ;<br>            n = n . divide ( i ) ;<br>        }<br>        i = i + 2 ;<br>    }<br>    if ( ( n > 2 && k == 1 ) || ( n > 3 && k == 2 ) ) {<br>        return n ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countRotations ( int arr [ ] , int low , int high ) {<br>  if ( high < low ) return 0 ;<br>  if ( high == low ) return low ;<br>  int mid = low + ( high - low ) / 2 ;<br>  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ;<br>  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ;<br>  if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ;<br>  return countRotations ( arr , mid + 1 , high ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int countRotations ( int [ ] arr , int low , int high ) {<br>    if ( ( high < low ) && ( arr [ 0 ] < arr [ 1 ] ) ) {<br>        return 0 ;<br>    }<br>    if ( ( high == low ) && ( arr != null ) ) {<br>        return countRotations ( arr , low , high , 0 ) ;<br>    }<br>    int mid = low + ( high - low ) / 2 ;<br>    int mid = ( int ) Math . round ( arr [ low ] ) ;<br>    if ( ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) || ( mid + 1 < high && arr [ mid ] > arr [ mid + 1 ] ) ) {<br>        return ( mid + 1 ) ;<br>    }<br>    if ( ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) || ( mid > high && arr [ mid ] > arr [ high - 1 ] ) ) {<br>        return mid ;<br>    }<br>    if ( ( arr [ high ] > arr [ mid ] ) && ( arr [ low ] > arr [ mid ] ) ) {<br>        return countRotations ( arr , low , mid - 1 ) ;<br>    }<br>    return countRotations ( arr , mid + 1 , high ) ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int compute_average ( int a , int b ) {<br>  return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int computeAverage ( int a , int b ) {<br>    return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>SORTING_USING_TRIVIAL_HASH_FUNCTION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortUsingHash ( int a [ ] , int n ) {<br>  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;<br>  int min = Math . abs ( Arrays . stream ( a ) . min ( ) . getAsInt ( ) ) ;<br>  int hashpos [ ] = new int [ max + 1 ] ;<br>  int hashneg [ ] = new int [ min + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;<br>    else hashneg [ Math . abs ( a [ i ] ) ] += 1 ;<br>  }<br>  for ( int i = min ;<br>  i > 0 ;<br>  i -- ) {<br>    if ( hashneg [ i ] > 0 ) {<br>      for ( int j = 0 ;<br>      j < hashneg [ i ] ;<br>      j ++ ) {<br>        System . out . print ( ( - 1 ) * i + " " ) ;<br>      }<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i <= max ;<br>  i ++ ) {<br>    if ( hashpos [ i ] > 0 ) {<br>      for ( int j = 0 ;<br>      j < hashpos [ i ] ;<br>      j ++ ) {<br>        System . out . print ( i + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortUsingHash ( int [ ] a , int n ) {<br>    int Max = Math . max ( a , n ) ;<br>    int Min = Math . abs ( Math . min ( a , n ) ) ;<br>    int [ ] hashpos = new int [ Max + 1 ] ;<br>    int [ ] hashneg = new int [ Min + 1 ] ;<br>    for ( int i = 0 ;<br>        if ( a [ i ] >= 0 ) {<br>            hashpos [ a [ i ] ] ++ ;<br>        }<br>        else{<br>            hashneg [ Math . abs ( a [ i ] ) ] ++ ;<br>        }<br>    for ( int i = Min . INSTANCE ;  i > 0 ;{<br>        if ( hashneg [ i ] != 0 ){<br>            for ( int j = 0 ;  j <= hashneg [ i ] ;  j ++ ) {<br>                System . out . print ( ( - 1 ) * i ++ + " " ) ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i <= Max ;  i ++ ) {<br>        if ( hashpos [ i ] != 0 ){<br>            for ( int j = 0 ;  j <= hashpos [ i ] ;  j ++ ) {<br>                System . out . print ( i + " " ) ;<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void printRepeating ( int arr [ ] , int size ) {<br>  int count [ ] = new int [ size ] ;<br>  int i ;<br>  System . out . println ( "Repeated elements are : " ) ;<br>  for ( i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ;<br>    else count [ arr [ i ] ] ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printRepeating ( int [ ] arr , int size ) {<br>    int [ ] count = new int [ size ] ;<br>    System . out . print ( " Repeating elements are " ) ;<br>    for ( int i = 0 ;  i <= size ;  i ++ ) {<br>        if ( ( count [ arr [ i ] ] == 1 ) && ( count [ arr [ i ] ] == 2 ) ) {<br>            System . out . print ( arr [ i ++ ] + " " ) ;<br>        }<br>        if ( size > 0 ) {<br>            count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDecodingDP ( char digits [ ] , int n ) {<br>  int count [ ] = new int [ n + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  count [ 1 ] = 1 ;<br>  if ( digits [ 0 ] == '0' ) return 0 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    count [ i ] = 0 ;<br>    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ;<br>    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ;<br>  }<br>  return count [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDecodingDP ( char [ ] digits , int n ) {<br>    int [ ] count = new int [ n + 1 ] ;<br>    count [ 0 ] = 1 ;<br>    count [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        count [ i ] = 0 ;<br>        if ( ( digits [ i - 1 ] > '0' ) && ( digits [ i ] <= '9' ) ) {<br>            count [ i ] = count [ i - 1 ] ;<br>        }<br>        if ( ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) && ( digits [ i - 1 ] == '3' ) ) {<br>            count [ i ] += count [ i - 2 ] ;<br>        }<br>    }<br>    return count [ n ] ;<br>}</td>
  </tr><tr>
    <th>EULERS_FOUR_SQUARE_IDENTITY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void checkEulerFourSquareIdentity ( int a , int b ) {<br>  int ab = a * b ;<br>  boolean flag = false ;<br>  int i = 0 ;<br>  while ( i * i <= ab ) {<br>    int j = i ;<br>    while ( i * i + j * j <= ab ) {<br>      int k = j ;<br>      while ( i * i + j * j + k * k <= ab ) {<br>        double l = Math . sqrt ( ab - ( i * i + j * j + k * k ) ) ;<br>        if ( Math . floor ( l ) == Math . ceil ( l ) && l >= k ) {<br>          flag = true ;<br>          System . out . print ( "i = " + i + "\n" ) ;<br>          System . out . print ( "j = " + j + "\n" ) ;<br>          System . out . print ( "k = " + k + "\n" ) ;<br>          System . out . print ( "l = " + ( int ) l + "\n" ) ;<br>          System . out . print ( "Product of " + a + " and " + b + " can be written as sum of squares" + " of i, j, k, l \n" ) ;<br>          System . out . print ( ab + " = " + i + "*" + i + " + " + j + "*" + j + " + " + k + "*" + k + " + " + ( int ) l + "*" + ( int ) l + "\n" ) ;<br>        }<br>        k += 1 ;<br>      }<br>      j += 1 ;<br>    }<br>    i += 1 ;<br>  }<br>  if ( flag == false ) {<br>    System . out . println ( "Solution doesn't exist!" ) ;<br>    return ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void checkEulerFourSquareIdentity ( double a , double b ) {<br>    double ab = a * b ;<br>    flag = false ;<br>    int i ;<br>    while ( i * i <= ab ){<br>        float j = i ;<br>        while ( i * i + j * j <= ab ){<br>            int k = j ;<br>            while ( i * i + j * j + k * k <= ab ){<br>                double l = ( ab - ( i * i + j * j + k * k ) ) * ( 0.5 ) ;<br>                if ( l == Integer . MIN_VALUE && l >= k ){<br>                    flag = true ;<br>                    System . out . println ( "i = " + i ) ;<br>                    System . out . println ( "j = " + j ) ;<br>                    System . out . println ( "k = " + k ) ;<br>                    System . out . println ( "l = " + l ) ;<br>                    System . out . println ( "Product of" + a + "and" + b + " can be written as sum of squares of i, j, k, l" ) ;<br>                    System . out . println ( ab + " = " + i + "*" + i + "+" + j + "*" + j + "+" + k + "*" + k + "+" + l + "*" + l ) ;<br>                }<br>                k ++ ;<br>            }<br>            j ++ ;<br>        }<br>        i ++ ;<br>    }<br>    if ( flag == false ){<br>        System . out . println ( "Solution doesn't exist!" ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) {<br>  int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    dp [ 0 ] [ i ] = 1 ;<br>  }<br>  for ( int l = 1 ;<br>  l < k ;<br>  l ++ ) {<br>    for ( int i = l ;<br>    i < n ;<br>    i ++ ) {<br>      dp [ l ] [ i ] = 0 ;<br>      for ( int j = l - 1 ;<br>      j < i ;<br>      j ++ ) {<br>        if ( arr [ j ] < arr [ i ] ) {<br>          dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;<br>        }<br>      }<br>    }<br>  }<br>  for ( int i = k - 1 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += dp [ k - 1 ] [ i ] ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int numOfIncSubseqOfSizeK ( int [ ] arr , int n , int k ) {<br>    int [ ] [ ] dp = new int [ n ] [ k ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        dp [ 0 ] [ i ] = 1 ;<br>    }<br>    for ( int l = 1 ;  l <= k ;  l ++ ) {<br>        for ( int i = l ;  i < n ;  i ++ ) {<br>            dp [ l ] [ i ] = 0 ;<br>            for ( int j = l - 1 ;  j >= i ;  j -- ) {<br>                if ( ( arr [ j ] < arr [ i ] ) && ( arr [ k ] < arr [ j ] ) ) {<br>                    dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;<br>                }<br>            }<br>        }<br>    }<br>    int Sum = 0 ;<br>    for ( int i = k - 1 ;  i < n ;  i ++ ) {<br>        Sum += dp [ k - 1 ] [ i ] ;<br>    }<br>    return Sum ;<br>}</td>
  </tr><tr>
    <th>KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>    K = new int [ W + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int w = 0 ;  w < W + 1 ;  w ++ ) {<br>            if ( i == 0 || w == 0 ){<br>                K [ i ] [ w ] = 0 ;<br>            }<br>            else if ( wt [ i - 1 ] <= w ){<br>                K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>            }<br>            else {<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>            }<br>        }<br>    }<br>    return K [ n ] [ W ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_PRINT_DOUBLE_HEADED_ARROW_PATTERN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void drawPattern ( int N ) {<br>  int n = N ;<br>  int row = 1 ;<br>  int nst = 1 ;<br>  int nsp1 = n - 1 ;<br>  int nsp2 = - 1 ;<br>  int val1 = row ;<br>  int val2 = 1 ;<br>  while ( row <= n ) {<br>    int csp1 = 1 ;<br>    while ( csp1 <= nsp1 ) {<br>      System . out . print ( "  " ) ;<br>      csp1 = csp1 + 1 ;<br>    }<br>    int cst1 = 1 ;<br>    while ( cst1 <= nst ) {<br>      System . out . print ( val1 + " " ) ;<br>      val1 = val1 - 1 ;<br>      cst1 = cst1 + 1 ;<br>    }<br>    int csp2 = 1 ;<br>    while ( csp2 <= nsp2 ) {<br>      System . out . print ( "  " ) ;<br>      csp2 = csp2 + 1 ;<br>    }<br>    if ( row != 1 && row != n ) {<br>      int cst2 = 1 ;<br>      while ( cst2 <= nst ) {<br>        System . out . print ( val2 + " " ) ;<br>        val2 = val2 + 1 ;<br>        cst2 = cst2 + 1 ;<br>      }<br>    }<br>    System . out . println ( ) ;<br>    if ( row <= n / 2 ) {<br>      nst = nst + 1 ;<br>      nsp1 = nsp1 - 2 ;<br>      nsp2 = nsp2 + 2 ;<br>      val1 = row + 1 ;<br>      val2 = 1 ;<br>    }<br>    else {<br>      nst = nst - 1 ;<br>      nsp1 = nsp1 + 2 ;<br>      nsp2 = nsp2 - 2 ;<br>      val1 = n - row ;<br>      val2 = 1 ;<br>    }<br>    row = row + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void drawPattern ( int N ) {<br>    n = N ;<br>    int row = 1 ;<br>    int nst = 1 ;<br>    nsp1 = n - 1 ;<br>    nsp2 = - 1 ;<br>    int val1 = row ;<br>    val2 = 1 ;<br>    while ( ( row <= n ) && ( row <= n ) ) {<br>        csp1 = 1 ;<br>        while ( ( csp1 <= nsp1 ) && ( csp2 <= nsp2 ) ) {<br>            System . out . print ( " " ) ;<br>            csp1 = csp1 + 1 ;<br>        }<br>        cst1 = 1 ;<br>        while ( ( cst1 <= nst ) && ( cst2 <= nst ) ) {<br>            System . out . print ( val1 + " " ) ;<br>            val1 = val1 - 1 ;<br>            cst1 = cst1 + 1 ;<br>        }<br>        csp2 = 1 ;<br>        while ( ( csp2 <= nsp2 ) && ( csp2 <= nsp2 ) ){<br>            System . out . print ( " " ) ;<br>            csp2 = csp2 + 1 ;<br>        }<br>        if ( ( row != 1 && row != n ) || ( row != n && row != 0 ) ){<br>            cst2 = 1 ;<br>            while ( ( cst2 <= nst ) && ( cst2 <= nst ) ){<br>                System . out . print ( val2 + " " ) ;<br>                val2 = val2 + 1 ;<br>                cst2 = cst2 + 1 ;<br>            }<br>        }<br>        System . out . println ( ) ;<br>        if ( ( row <= n / 2 ) && ( row <= n / 3 ) ){<br>            nst = nst + 1 ;<br>            nsp1 = nsp1 - 2 ;<br>            nsp2 = nsp2 + 2 ;<br>            int val1 = row + 1 ;<br>            val2 = 1 ;<br>        }<br>        if ( N > 0 ) {<br>            nst = nst - 1 ;<br>            nsp1 = nsp1 + 2 ;<br>            nsp2 = nsp2 - 2 ;<br>            int val1 = n - row ;<br>            val2 = 1 ;<br>        }<br>        row = row + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findInteger ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;<br>  int maximum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) - 1 ) ;<br>    else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get ( Math . abs ( arr [ i ] ) ) == null ? 0 : hash . get ( Math . abs ( arr [ i ] ) ) ) + 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findInteger ( int [ ] arr , int n ) {<br>    HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ;<br>    int maximum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( i < 0 ) && ( i < n ) ) {<br>            if ( Math . abs ( i ) != 0 ) {<br>                hash [ Math . abs ( i ) ] = - 1 ;<br>            }<br>            if ( n > 0 ) {<br>                hash [ Math . abs ( i ) ] -- ;<br>            }<br>        }<br>        if ( n > 0 ) {<br>            hash [ i ] = hash . indexOf ( i , n ) + 1 ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( i < hash . length && hash [ i ] > 0 ) {<br>            return i ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_SOLUTION_LCS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int lcs ( String X , String Y ) {<br>  int m = X . length ( ) , n = Y . length ( ) ;<br>  int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ;<br>  int bi = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  i ++ ) {<br>    bi = i & 1 ;<br>    for ( int j = 0 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( i == 0 || j == 0 ) L [ bi ] [ j ] = 0 ;<br>      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ;<br>      else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ;<br>    }<br>  }<br>  return L [ bi ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int lcs ( int [ ] X , int [ ] Y ) {<br>    int m = X . length ;<br>    int n = Y . length ( ) ;<br>    int [ ] [ ] L = new int [ n + 1 ] [ 2 ] ;<br>    boolean bi = false ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        bi = i & 1 ;<br>        for ( int j = 0 ;  j < n + 1 ;  j ++ ) {<br>            if ( ( i == 0 || j == 0 ) && ( i == 0 || j == 0 ) ) {<br>                L [ bi ] [ j ] = 0 ;<br>            }<br>            else if ( ( X [ i ] == Y [ j - 1 ] ) && ( X [ j - 1 ] == Y [ i ] ) ) {<br>                L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ;<br>            }<br>            else {<br>                L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return L [ bi ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void psuedoBinary ( int n ) {<br>  while ( n != 0 ) {<br>    int temp = n , m = 0 , p = 1 ;<br>    while ( temp != 0 ) {<br>      int rem = temp % 10 ;<br>      temp = temp / 10 ;<br>      if ( rem != 0 ) m += p ;<br>      p *= 10 ;<br>    }<br>    System . out . print ( m + " " ) ;<br>    n = n - m ;<br>  }<br>  System . out . println ( " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void psuedoBinary ( int n ) {<br>    while ( ( n > 0 ) && ( n -- > 0 ) ) {<br>        int temp = n ;<br>        int m = 0 ;<br>        int p = 1 ;<br>        while ( ( temp = n ) != 0 ) {<br>            int rem = temp % 10 ;<br>            int temp ;<br>            if ( ( rem != 0 ) && ( rem != n ) ){<br>                m += p ;<br>            }<br>            p *= 10 ;<br>        }<br>        System . out . print ( m + " " ) ;<br>        n = n - m ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_CURRENCY_NOTES_SUM_UPTO_GIVEN_AMOUNT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void countCurrency ( int amount ) {<br>  int [ ] notes = new int [ ] {<br>    2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 };<br>    int [ ] noteCounter = new int [ 9 ] ;<br>    for ( int i = 0 ;<br>    i < 9 ;<br>    i ++ ) {<br>      if ( amount >= notes [ i ] ) {<br>        noteCounter [ i ] = amount / notes [ i ] ;<br>        amount = amount - noteCounter [ i ] * notes [ i ] ;<br>      }<br>    }<br>    System . out . println ( "Currency Count ->" ) ;<br>    for ( int i = 0 ;<br>    i < 9 ;<br>    i ++ ) {<br>      if ( noteCounter [ i ] != 0 ) {<br>        System . out . println ( notes [ i ] + " : " + noteCounter [ i ] ) ;<br>      }<br>    }<br>  }<br>  </td>
    <td>translated code: <br><br> public static void countCurrency ( int amount ) {<br>    int [ ] notes = {<br>    }<br>    noteCounter [ 0 ] = amount . add ( Currency . getInstance ( "BTC" ) ) . add ( Currency . getInstance ( "USD" ) ) . add ( Currency . getInstance ( "EUR" ) ) . add ( Currency . getInstance ( "EUR" ) ) . add ( Currency . getInstance ( "USD" ) ) ;<br>    System . out . print ( "Currency Count -> " ) ;<br>    for ( int i = 0 , j = notes . length ;  i < j ;  i ++ , j ++ ) {<br>        if ( amount >= i ) {<br>            int j = amount / i ;<br>            amount = amount - j * i ;<br>            System . out . println ( i + ":" + j ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void rearrange ( int a [ ] , int size ) {<br>  int positive = 0 , negative = 1 , temp ;<br>  while ( true ) {<br>    while ( positive < size && a [ positive ] >= 0 ) positive += 2 ;<br>    while ( negative < size && a [ negative ] <= 0 ) negative += 2 ;<br>    if ( positive < size && negative < size ) {<br>      temp = a [ positive ] ;<br>      a [ positive ] = a [ negative ] ;<br>      a [ negative ] = temp ;<br>    }<br>    else break ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void rearrange ( int [ ] a , int size ) {<br>    int positive = 0 ;<br>    negative = 1 ;<br>    while ( ( true ) && ( a > 5 ) ) {<br>        while ( ( positive < size && a [ positive ] >= 0 ) || ( negative < size && a [ negative ] >= 0 ) ) {<br>            positive = positive + 2 ;<br>        }<br>        while ( ( negative < size && a [ negative ] <= 0 ) || ( negative > size && a [ negative ] > 0 ) ) {<br>            negative = negative + 2 ;<br>        }<br>        if ( ( positive < size && negative < size ) || ( negative < size && positive < size ) ){<br>            int temp = a [ positive ] ;<br>            a [ positive ] = a [ negative ] ;<br>            a [ negative ] = temp ;<br>        }<br>        if ( size > 0 ) {<br>            break ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_AN_ARRAY_IS_SUBSET_OF_ANOTHER_ARRAY_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>  int i = 0 ;<br>  int j = 0 ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j < m ;<br>    j ++ ) if ( arr2 [ i ] == arr1 [ j ] ) break ;<br>    if ( j == m ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static int isSubset ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {<br>    int i = 0 ;<br>    int j = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( arr2 [ i ] == arr1 [ j ] ) && ( arr2 [ j ] == arr1 [ i ] ) ) {<br>                break ;<br>            }<br>        }<br>        if ( ( j == m ) && ( j == n ) ) {<br>            return 0 ;<br>        }<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;<br>  int l = ( i + 1 ) % n ;<br>  int r = i ;<br>  while ( l != r ) {<br>    if ( arr [ l ] + arr [ r ] == x ) return true ;<br>    if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;<br>    else r = ( n + r - 1 ) % n ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean pairInSortedRotated ( int [ ] arr , int n , int x ) {<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( arr [ i ] > arr [ i + 1 ] ) && ( arr [ i + 1 ] < arr [ n ] ) ) {<br>            break ;<br>        }<br>    }<br>    int l = ( i + 1 ) % n ;<br>    int r = i ;<br>    while ( ( l != r ) && ( l != n ) ) {<br>        if ( ( arr [ l ] + arr [ r ] == x ) && ( arr [ l ] + arr [ r ] == x ) ) {<br>            return pairInSortedRotated ( arr , n , x , false ) ;<br>        }<br>        if ( ( arr [ l ] + arr [ r ] < x ) && ( arr [ l ] + arr [ r ] > x ) ){<br>            l = ( l + 1 ) % n ;<br>        }<br>        else {<br>            r = ( n + r - 1 ) % n ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  if ( divisor == 0 ) {<br>    System . out . println ( "Error: divisor " + "can't be zero \n" ) ;<br>    return - 1 ;<br>  }<br>  if ( divisor < 0 ) divisor = - divisor ;<br>  if ( num < 0 ) num = - num ;<br>  int i = 1 ;<br>  int product = 0 ;<br>  while ( product <= num ) {<br>    product = divisor * i ;<br>    i ++ ;<br>  }<br>  return num - ( product - divisor ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getRemainder ( int num , int divisor ) {<br>    if ( ( divisor == 0 ) && ( num >= 0 ) ) {<br>        return false ;<br>    }<br>    if ( ( divisor < 0 ) || ( divisor > 5 ) ) {<br>        divisor = - divisor ;<br>    }<br>    if ( ( num < 0 ) && ( divisor > 0 ) ) {<br>        num = - num ;<br>    }<br>    int i = 1 ;<br>    int product = 0 ;<br>    while ( ( product <= num ) && ( product <= divisor ) ) {<br>        int product = divisor * i ;<br>        i ++ ;<br>    }<br>    return num - ( product - divisor ) ;<br>}</td>
  </tr><tr>
    <th>GNOME_SORT_A_STUPID_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void gnomeSort ( int arr [ ] , int n ) {<br>  int index = 0 ;<br>  while ( index < n ) {<br>    if ( index == 0 ) index ++ ;<br>    if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;<br>    else {<br>      int temp = 0 ;<br>      temp = arr [ index ] ;<br>      arr [ index ] = arr [ index - 1 ] ;<br>      arr [ index - 1 ] = temp ;<br>      index -- ;<br>    }<br>  }<br>  return ;<br>}<br></td>
    <td>translated code: <br><br> public static int [ ] gnomeSort ( int [ ] arr , int n ) {<br>    int index = 0 ;<br>    while ( index < n ) {<br>        if ( index == 0 ){<br>            index = index + 1 ;<br>        }<br>        if ( arr [ index ] >= arr [ index - 1 ] ) {<br>            index = index + 1 ;<br>        }<br>        else {<br>            arr [ index ] = arr [ index - 1 ] , arr [ index - 2 ] = arr [ index ] ;<br>            index = index - 1 ;<br>        }<br>    }<br>    gnomeSort ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numberofways ( String A , String B , int N , int M ) {<br>  Vector < Integer > [ ] pos = new Vector [ MAX ] ;<br>  for ( int i = 0 ;<br>  i < MAX ;<br>  i ++ ) pos [ i ] = new Vector < > ( ) ;<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ;<br>  int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= M ;<br>    j ++ ) {<br>      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ;<br>      else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ;<br>    }<br>  }<br>  int LCS = dpl [ N ] [ M ] ;<br>  int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ;<br>  for ( int i = N ;<br>  i >= 1 ;<br>  i -- ) {<br>    for ( int j = M ;<br>    j >= 1 ;<br>    j -- ) {<br>      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ;<br>      else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ;<br>    }<br>  }<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i <= N ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < MAX ;<br>    j ++ ) {<br>      for ( int x : pos [ j ] ) {<br>        if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) {<br>          ans ++ ;<br>          break ;<br>        }<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int numberofways ( int [ ] A , int [ ] B , int N , int M ) {<br>    int pos [ ] = new int [ MAX ] ;<br>    for ( int i = 0 ;  i < M ;  i ++ ) {<br>        pos [ ( char ) B [ i ] ] . add ( i + 1 ) ;<br>    }<br>    int [ ] dpl = new int [ N + 2 ] ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        for ( int j = 1 ;  j <= M ;  j ++ ) {<br>            if ( A [ i - 1 ] == B [ j - 1 ] ){<br>                dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ;<br>            }<br>            else{<br>                dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    int LCS = dpl [ N ] [ M ] ;<br>    int [ ] dpr = new int [ N + 2 ] ;<br>    for ( int i = N ;  i > 0 ;  i -- ) {<br>        for ( int j = M ;  j > 0 ;  j -- ) {<br>            if ( A [ i - 1 ] == B [ j - 1 ] ){<br>                dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ;<br>            }<br>            else{<br>                dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ;<br>            }<br>        }<br>    }<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < N + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < MAX ;  j ++ ) {<br>            for ( int x = pos [ j ] ;  x < pos [ i ] ;  x ++ ) {<br>                if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ){<br>                    ans ++ ;<br>                    break ;<br>                }<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int minProduct ( int [ ] arr , int n , int k ) {<br>  PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) pq . add ( arr [ i ] ) ;<br>  int count = 0 , ans = 1 ;<br>  while ( pq . isEmpty ( ) == false && count < k ) {<br>    ans = ans * pq . element ( ) ;<br>    pq . remove ( ) ;<br>    count ++ ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int minProduct ( int [ ] arr , int n , int k ) {<br>    heapify ( arr , n , k ) ;<br>    int count = 0 ;<br>    int ans = 1 ;<br>    while ( ( arr != null ) && count < k ) {<br>        int x = heapMaxProduct ( arr , n , k ) ;<br>        ans = ans * x ;<br>        count = count + 1 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>FIND_UNIQUE_ELEMENTS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void unique ( int mat [ ] [ ] , int n , int m ) {<br>  int maximum = 0 , flag = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( maximum < mat [ i ] [ j ] ) maximum = mat [ i ] [ j ] ;<br>  int b [ ] = new int [ maximum + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) b [ mat [ i ] [ j ] ] ++ ;<br>  for ( int i = 1 ;<br>  i <= maximum ;<br>  i ++ ) if ( b [ i ] == 1 ) System . out . print ( i + " " ) ;<br>  flag = 1 ;<br>  if ( flag == 0 ) {<br>    System . out . println ( "No unique element " + "in the matrix" ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void unique ( int [ ] [ ] mat , int n , int m ) {<br>    int maximum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= m ;  j ++ ) {<br>            if ( ( maximum < mat [ i ] [ j ] ) && ( maximum < mat [ i ] [ j ] ) ){<br>                int maximum = mat [ i ] [ j ] ;<br>            }<br>        }<br>    }<br>    uniqueElementMap = new int [ maximum + 1 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= m ;  j ++ ) {<br>            uniqueElementMap . put ( mat [ i ] [ j ] , 1 ) ;<br>        }<br>    }<br>    for ( int key = 0 ;  key < maximum + 1 ;  key ++ ) {<br>        if ( uniqueElementMap . get ( key ) == 1 ) {<br>            System . out . print ( key + " " ) ;<br>            flag = 1 ;<br>        }<br>    }<br>    if ( ( flag == 0 ) && ( n > 0 ) ){<br>        System . out . println ( "No unique element in the matrix" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS_ONE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longestSubseqWithDiffOne ( int arr [ ] , int n ) {<br>  int dp [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < i ;<br>    j ++ ) {<br>      if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ;<br>    }<br>  }<br>  int result = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int longestSubseqWithDiffOne ( int [ ] arr , int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) && ( ( arr [ i ] == arr [ j ] ) || ( arr [ i ] == arr [ j ] ) ) ) {<br>                dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ;<br>            }<br>        }<br>    }<br>    int result = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( result < dp [ i ] ) && ( n > 0 ) ) {<br>            int result = dp [ i ] ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String repeat ( String s , int n ) {<br>  String s1 = s ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) s += s1 ;<br>  return s ;<br>}<br></td>
    <td>translated code: <br><br> public static String repeat ( String s , int n ) {<br>    String s1 = s ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        sb . append ( s1 ) ;<br>    }<br>    return repeat ( s , n , "" ) ;<br>}</td>
  </tr><tr>
    <th>SEARCHING_FOR_PATTERNS_SET_1_NAIVE_PATTERN_SEARCHING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void search ( String txt , String pat ) {<br>  int M = pat . length ( ) ;<br>  int N = txt . length ( ) ;<br>  for ( int i = 0 ;<br>  i <= N - M ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < M ;<br>    j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ;<br>    if ( j == M ) System . out . println ( "Pattern found at index " + i ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void search ( String pat , String txt ) {<br>    int M = pat . length ( ) ;<br>    int N = txt . length ( ) ;<br>    for ( int i = 0 ;  i < N - M + 1 ;  i ++ ) {<br>        int j = 0 ;<br>        while ( ( j < M ) && ( j < N ) ){<br>            if ( ( txt . charAt ( i + j ) != pat . charAt ( j ) ) && ( txt . charAt ( i + j ) != pat . charAt ( j ) ) ){<br>                break ;<br>            }<br>            j ++ ;<br>        }<br>        if ( ( j == M ) && ( txt != null ) ){<br>            System . out . println ( "Pattern found at index " + i ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int countwalks ( int graph [ ] [ ] , int u , int v , int k ) {<br>  if ( k == 0 && u == v ) return 1 ;<br>  if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ;<br>  if ( k <= 0 ) return 0 ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < V ;<br>  i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int countwalks ( int [ ] [ ] graph , int u , int v , int k ) {<br>    if ( ( k == 0 && u == v ) || ( k == 1 && u == v ) ) {<br>        return 1 ;<br>    }<br>    if ( ( k == 1 && graph [ u ] [ v ] ) || ( k == 2 && graph [ u ] [ v ] ) ) {<br>        return 1 ;<br>    }<br>    if ( ( k <= 0 ) && ( u <= 0 ) ) {<br>        return 0 ;<br>    }<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= V ;  i ++ ) {<br>        if ( ( graph [ u ] [ i ] == 1 ) && ( graph [ v ] [ i ] == 1 ) ) {<br>            count += countwalks ( graph , i -> u + i * v , k - 1 ) ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_DIVISIBLE_PAIRS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDivisibles ( int arr [ ] , int n ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDivisibles ( int [ ] arr , int n ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) && ( arr [ i ] % arr [ j ] == 0 ) ) {<br>                res ++ ;<br>            }<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isSymmetric ( int mat [ ] [ ] , int N ) {<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isSymmetric ( int [ ] [ ] mat , int N ) {<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        for ( int j = 0 ;  j < N ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] != mat [ j ] [ i ] ) && ( mat [ i ] [ j ] != mat [ j ] [ i ] ) ){<br>                return false ;<br>            }<br>        }<br>    }<br>    return isSymmetric ( mat , N , false ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_PALINDROME_SUB_STRINGS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int CountPS ( char str [ ] , int n ) {<br>  int dp [ ] [ ] = new int [ n ] [ n ] ;<br>  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) P [ i ] [ i ] = true ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( str [ i ] == str [ i + 1 ] ) {<br>      P [ i ] [ i + 1 ] = true ;<br>      dp [ i ] [ i + 1 ] = 1 ;<br>    }<br>  }<br>  for ( int gap = 2 ;<br>  gap < n ;<br>  gap ++ ) {<br>    for ( int i = 0 ;<br>    i < n - gap ;<br>    i ++ ) {<br>      int j = gap + i ;<br>      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;<br>      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int CountPS ( String str , int n ) {<br>    int [ ] dp = new int [ n ] ;<br>    P = new ArrayList < > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        P [ i ] [ i ] = true ;<br>    }<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == str . charAt ( i + 1 ) ) && ( str . charAt ( i + 2 ) == str . charAt ( i + 3 ) ) ) {<br>            P [ i ] [ i + 1 ] = true ;<br>            dp [ i ] [ i + 1 ] = 1 ;<br>        }<br>    }<br>    for ( int gap = 2 ;  gap < n ;  gap ++ ) {<br>        for ( int i = 0 ;  i < n - gap ;  i ++ ) {<br>            int j = gap + i ;<br>            if ( ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) ){<br>                P [ i ] [ j ] = true ;<br>            }<br>            if ( ( P [ i ] [ j ] == true ) && ( ( P [ i ] [ j ] == false ) || ( P [ i ] [ j ] == null ) ) ) {<br>                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) ;<br>            }<br>            if ( n > 0 ) {<br>                dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return dp [ 0 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countWays ( int N ) {<br>  int count [ ] = new int [ N + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) for ( int j = 0 ;<br>  j < arr . length ;<br>  j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ;<br>  return count [ N ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countWays ( int [ ] arr , int m , int N ) {<br>    int [ ] count = new int [ N + 1 ] ;<br>    count [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( i >= arr [ j ] ) && ( i <= arr [ m ] ) && ( i >= arr [ N ] ) ) {<br>                count [ i ] += count [ i - arr [ j ] ] ;<br>            }<br>        }<br>    }<br>    return count [ N ] ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_OF_OPERATIONS_TO_MOVE_ALL_UPPERCASE_CHARACTERS_BEFORE_ALL_LOWER_CASE_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minOperations ( String str , int n ) {<br>  int i , lastUpper = - 1 , firstLower = - 1 ;<br>  for ( i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) {<br>      lastUpper = i ;<br>      break ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( Character . isLowerCase ( str . charAt ( i ) ) ) {<br>      firstLower = i ;<br>      break ;<br>    }<br>  }<br>  if ( lastUpper == - 1 || firstLower == - 1 ) return 0 ;<br>  int countUpper = 0 ;<br>  for ( i = firstLower ;<br>  i < n ;<br>  i ++ ) {<br>    if ( Character . isUpperCase ( str . charAt ( i ) ) ) {<br>      countUpper ++ ;<br>    }<br>  }<br>  int countLower = 0 ;<br>  for ( i = 0 ;<br>  i < lastUpper ;<br>  i ++ ) {<br>    if ( Character . isLowerCase ( str . charAt ( i ) ) ) {<br>      countLower ++ ;<br>    }<br>  }<br>  return Math . min ( countLower , countUpper ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int minOperations ( String str , int n ) {<br>    lastUpper = - 1 ;<br>    firstLower = - 1 ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        if ( ( str . charAt ( i ) == 'a' ) && ( str . charAt ( i + 1 ) == 'b' ) ) {<br>            lastUpper = i ;<br>            break ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == 'a' ) && ( str . charAt ( i + 1 ) == 'b' ) ) {<br>            firstLower = i ;<br>            break ;<br>        }<br>    }<br>    if ( ( lastUpper == - 1 || firstLower == - 1 ) && ( n > 0 ) ) {<br>        return minOperations ( str , n , 0 ) ;<br>    }<br>    countUpper = 0 ;<br>    for ( int i = firstLower ;  i < n ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == 'a' ) && ( str . charAt ( i + 1 ) == 'b' ) ) {<br>            countUpper ++ ;<br>        }<br>    }<br>    countLower = 0 ;<br>    for ( int i = 0 ;  i < lastUpper ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == 'a' ) && ( str . charAt ( i + 1 ) == 'b' ) ) {<br>            countLower ++ ;<br>        }<br>    }<br>    return Math . min ( countLower , countUpper ) ;<br>}</td>
  </tr><tr>
    <th>PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void spiralPrint ( int m , int n , int a [ ] [ ] ) {<br>  int i , k = 0 , l = 0 ;<br>  while ( k < m && l < n ) {<br>    for ( i = l ;<br>    i < n ;<br>    ++ i ) {<br>      System . out . print ( a [ k ] [ i ] + " " ) ;<br>    }<br>    k ++ ;<br>    for ( i = k ;<br>    i < m ;<br>    ++ i ) {<br>      System . out . print ( a [ i ] [ n - 1 ] + " " ) ;<br>    }<br>    n -- ;<br>    if ( k < m ) {<br>      for ( i = n - 1 ;<br>      i >= l ;<br>      -- i ) {<br>        System . out . print ( a [ m - 1 ] [ i ] + " " ) ;<br>      }<br>      m -- ;<br>    }<br>    if ( l < n ) {<br>      for ( i = m - 1 ;<br>      i >= k ;<br>      -- i ) {<br>        System . out . print ( a [ i ] [ l ] + " " ) ;<br>      }<br>      l ++ ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void spiralPrint ( int m , int n , int [ ] [ ] a ) {<br>    int k = 0 ;<br>    while ( ( k < m && l < n ) || ( k < m && l < n ) ) {<br>        for ( int i = l ;  i < n ;{<br>            System . out . print ( a [ k ] [ i ] + " " ) ;<br>        }<br>        k ++ ;<br>        for ( int i = k ;  i < m ;{<br>            System . out . print ( a [ i ] [ n - 1 ] + " " ) ;<br>        }<br>        n -- ;<br>        if ( ( k < m ) && ( k < n ) ){<br>            for ( int i = n - 1 ;  i >= ( l - 1 ) ;{<br>                System . out . print ( a [ m - 1 ] [ i ] + " " ) ;<br>            }<br>            m -- ;<br>        }<br>        if ( ( l < n ) && ( l < m ) ){<br>            for ( int i = m - 1 ;  i >= k - 1 ;{<br>                System . out . print ( a [ i ] [ l ] + " " ) ;<br>            }<br>            l ++ ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void findTriplets ( int x ) {<br>  Vector < Integer > fact = new Vector < Integer > ( ) ;<br>  HashSet < Integer > factors = new HashSet < Integer > ( ) ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( x ) ;<br>  i ++ ) {<br>    if ( x % i == 0 ) {<br>      fact . add ( i ) ;<br>      if ( x / i != i ) fact . add ( x / i ) ;<br>      factors . add ( i ) ;<br>      factors . add ( x / i ) ;<br>    }<br>  }<br>  boolean found = false ;<br>  int k = fact . size ( ) ;<br>  for ( int i = 0 ;<br>  i < k ;<br>  i ++ ) {<br>    int a = fact . get ( i ) ;<br>    for ( int j = 0 ;<br>    j < k ;<br>    j ++ ) {<br>      int b = fact . get ( j ) ;<br>      if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) {<br>        System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ;<br>        found = true ;<br>        break ;<br>      }<br>    }<br>    if ( found ) break ;<br>  }<br>  if ( ! found ) System . out . print ( "-1" ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void findTriplets ( int x ) {<br>    int [ ] fact = new int [ x ] ;<br>    Set < Integer > factors = new HashSet < Integer > ( ) ;<br>    for ( int i = 2 ;  i <= Integer . MAX_VALUE ;  i ++ ) {<br>        if ( ( x % i == 0 ) && ( x % i == 0 ) ) {<br>            fact . add ( i ) ;<br>            if ( ( x / i != i ) && ( x % i != 0 ) ) {<br>                fact . add ( x / i ) ;<br>            }<br>            factors . add ( i ) ;<br>            factors . add ( x / i ) ;<br>        }<br>    }<br>    found = false ;<br>    int k = fact . length ;<br>    for ( int i = 0 ;  i < k ;  i ++ ) {<br>        int a = fact [ i ] ;<br>        for ( int j = 0 ;  j < k ;  j ++ ) {<br>            int b = fact [ j ] ;<br>            if ( ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) ){<br>                System . out . println ( a + "," + b + "," + x / ( a * b ) ) ;<br>                found = true ;<br>                break ;<br>            }<br>        }<br>        if ( ( found ) && ( x > 0 ) ) {<br>            break ;<br>        }<br>    }<br>    if ( ( ! found ) && ( x > 5 ) ) {<br>        System . out . println ( "-1" ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SUM_TWO_LARGE_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String findSum ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) > str2 . length ( ) ) {<br>    String t = str1 ;<br>    str1 = str2 ;<br>    str2 = t ;<br>  }<br>  String str = "" ;<br>  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;<br>  int diff = n2 - n1 ;<br>  int carry = 0 ;<br>  for ( int i = n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i + diff ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  for ( int i = n2 - n1 - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;<br>  return new StringBuilder ( str ) . reverse ( ) . toString ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String findSum ( String str1 , String str2 ) {<br>    if ( str1 . length ( ) > str2 . length ( ) ) {<br>        String temp = str1 ;<br>        str1 = str2 ;<br>        str2 = temp ;<br>    }<br>    String str3 = "" ;<br>    int n1 = str1 . length ( ) ;<br>    int n2 = str2 . length ( ) ;<br>    int diff = n2 - n1 ;<br>    int carry = 0 ;<br>    for ( int i = n1 - 1 ;  i >= 0 ;  i -- ) {<br>        int sum = ( ( Character . digit ( str1 . charAt ( i ) , 16 ) - '0' ) + ( Character . digit ( str2 . charAt ( i + diff ) , 16 ) - '0' ) ) + carry ;<br>        str3 = str1 + String . valueOf ( sum % 10 ) ;<br>        int carry = sum / 10 ;<br>    }<br>    for ( int i = n2 - n1 - 1 ;  i >= 0 ;  i -- ) {<br>        sum = ( ( Character . digit ( str2 . charAt ( i ) , 16 ) - '0' ) + carry ) ;<br>        str3 = str1 + String . valueOf ( sum % 10 ) ;<br>        int carry = sum / 10 ;<br>    }<br>    if ( ( carry ) && ( str1 . length ( ) > 0 ) ) {<br>        return str3 + String . valueOf ( carry + '0' ) ;<br>    }<br>    String str3 = str1 ;<br>    return str3 ;<br>}</td>
  </tr><tr>
    <th>COCKTAIL_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> void cocktailSort ( int a [ ] ) {<br>  boolean swapped = true ;<br>  int start = 0 ;<br>  int end = a . length ;<br>  while ( swapped == true ) {<br>    swapped = false ;<br>    for ( int i = start ;<br>    i < end - 1 ;<br>    ++ i ) {<br>      if ( a [ i ] > a [ i + 1 ] ) {<br>        int temp = a [ i ] ;<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    if ( swapped == false ) break ;<br>    swapped = false ;<br>    end = end - 1 ;<br>    for ( int i = end - 1 ;<br>    i >= start ;<br>    i -- ) {<br>      if ( a [ i ] > a [ i + 1 ] ) {<br>        int temp = a [ i ] ;<br>        a [ i ] = a [ i + 1 ] ;<br>        a [ i + 1 ] = temp ;<br>        swapped = true ;<br>      }<br>    }<br>    start = start + 1 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void cocktailSort ( int [ ] a ) {<br>    int n = a . length ;<br>    swapped = true ;<br>    int start = 0 ;<br>    int end = n - 1 ;<br>    while ( ( swapped == true ) && ( a > 5 ) ) {<br>        swapped = false ;<br>        for ( int i = start ;  i < end ;  i ++ ) {<br>            if ( ( a [ i ] > a [ i + 1 ] ) && ( a [ i + 1 ] < a [ i ] ) ) {<br>                a [ i ] = a [ i + 1 ] ;<br>                swapped = true ;<br>            }<br>        }<br>        if ( ( swapped == false ) && ( a > 5 ) ) {<br>            break ;<br>        }<br>        swapped = false ;<br>        end = end - 1 ;<br>        for ( int i = end - 1 ;  i >= start - 1 ;  i -- ) {<br>            if ( ( a [ i ] > a [ i + 1 ] ) && ( a [ i + 1 ] < a [ i ] ) ) {<br>                a [ i ] = a [ i + 1 ] ;<br>                swapped = true ;<br>            }<br>        }<br>        start = start + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_IN_ITS_ORIGINAL_POSITION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countDer ( int n ) {<br>  int der [ ] = new int [ n + 1 ] ;<br>  der [ 0 ] = 1 ;<br>  der [ 1 ] = 0 ;<br>  der [ 2 ] = 1 ;<br>  for ( int i = 3 ;<br>  i <= n ;<br>  ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ;<br>  return der [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countDer ( int n ) {<br>    int [ ] der = new int [ n + 1 ] ;<br>    der [ 0 ] = 1 ;<br>    der [ 1 ] = 0 ;<br>    der [ 2 ] = 1 ;<br>    for ( int i = 3 ;  i <= n ;  i ++ ) {<br>        der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ;<br>    }<br>    return der [ n ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_SUBARRAY_ADDED_NEGATIVE_PRODUCT_CASE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findMaxProduct ( int arr [ ] , int n ) {<br>  int i ;<br>  int ans = Integer . MIN_VALUE ;<br>  int maxval = 1 ;<br>  int minval = 1 ;<br>  int prevMax ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] > 0 ) {<br>      maxval = maxval * arr [ i ] ;<br>      minval = Math . min ( 1 , minval * arr [ i ] ) ;<br>    }<br>    else if ( arr [ i ] == 0 ) {<br>      minval = 1 ;<br>      maxval = 0 ;<br>    }<br>    else if ( arr [ i ] < 0 ) {<br>      prevMax = maxval ;<br>      maxval = minval * arr [ i ] ;<br>      minval = prevMax * arr [ i ] ;<br>    }<br>    ans = Math . max ( ans , maxval ) ;<br>    if ( maxval <= 0 ) {<br>      maxval = 1 ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int findMaxProduct ( int [ ] arr , int n ) {<br>    int ans = - Integer . MAX_VALUE ;<br>    int maxval = 1 ;<br>    int minval = 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( arr [ i ] > 0 ) {<br>            maxval = maxval * arr [ i ] ;<br>            minval = Math . min ( 1 , minval * arr [ i ] ) ;<br>        }<br>        else if ( arr [ i ] == 0 ) {<br>            int minval = 1 ;<br>            int maxval = 0 ;<br>        }<br>        else if ( arr [ i ] < 0 ){<br>            prevMax = maxval ;<br>            double maxval = minval * arr [ i ] ;<br>            int minval = prevMax * arr [ i ] ;<br>        }<br>        ans = Math . max ( ans , maxval ) ;<br>        if ( maxval <= 0 ){<br>            int maxval = 1 ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_ODD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void assign ( int a [ ] , int n ) {<br>  Arrays . sort ( a ) ;<br>  int ans [ ] = new int [ n ] ;<br>  int p = 0 , q = n - 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;<br>    else ans [ i ] = a [ p ++ ] ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) System . out . print ( ans [ i ] + " " ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void assign ( int [ ] a , int n ) {<br>    a . length = n ;<br>    ans = new int [ n ] ;<br>    int p = 0 ;<br>    int q = n - 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( i ++ ) % 2 == 0 ){<br>            ans [ i ] = a [ q ++ ] ;<br>            q = q - 1 ;<br>        }<br>        }<br>            ans [ i ] = a [ p ] ;<br>            p = p + 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        System . out . print ( ans [ i ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>FRIENDS_PAIRING_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFriendsPairings ( int n ) {<br>  int dp [ ] = new int [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i <= 2 ) dp [ i ] = i ;<br>    else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFriendsPairings ( int n ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        if ( ( i <= 2 ) && ( i <= n ) ) {<br>            dp [ i ] = i ;<br>        }<br>        else {<br>            dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;<br>        }<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>PRIME_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isPrime ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) if ( n % i == 0 ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPrime ( int n ) {<br>    if ( ( n <= 1 ) && ( n > 2 ) ) {<br>        return false ;<br>    }<br>    for ( int i = 2 ;  i < n ;  i ++ ) {<br>        if ( ( n % i == 0 ) && ( n % i == 1 ) ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>PROBABILITY_REACHING_POINT_2_3_STEPS_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float find_prob ( int N , float P ) {<br>  double dp [ ] = new double [ N + 1 ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 0 ;<br>  dp [ 2 ] = P ;<br>  dp [ 3 ] = 1 - P ;<br>  for ( int i = 4 ;<br>  i <= N ;<br>  ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ;<br>  return ( ( float ) ( dp [ N ] ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findProb ( int N , int P ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    dp [ 0 ] = 1 ;<br>    dp [ 1 ] = 0 ;<br>    dp [ 2 ] = P ;<br>    dp [ 3 ] = 1 - P ;<br>    for ( int i = 4 ;  i <= N ;  i ++ ) {<br>        dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ;<br>    }<br>    return dp [ N ] ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int smallest ( int x , int y , int z ) {<br>  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;<br>  return ( ( x / z ) != 1 ) ? x : z ;<br>}<br></td>
    <td>translated code: <br><br> public static int smallest ( int x , int y , int z ) {<br>    if ( ( ! ( y / x ) ) && ( ! ( z / x ) ) ) {<br>        return y < z ? ( ! ( y / z ) ) : z ;<br>    }<br>    return x < y ? ( ! ( x / z ) ) : z ;<br>}</td>
  </tr><tr>
    <th>COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void printCommonElements ( int mat [ ] [ ] ) {<br>  Map < Integer , Integer > mp = new HashMap < > ( ) ;<br>  for ( int j = 0 ;<br>  j < N ;<br>  j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ;<br>  for ( int i = 1 ;<br>  i < M ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < N ;<br>    j ++ ) {<br>      if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( mat [ i ] [ j ] ) == i ) {<br>        mp . put ( mat [ i ] [ j ] , i + 1 ) ;<br>        if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " " ) ;<br>      }<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void printCommonElements ( int [ ] [ ] mat ) {<br>    Map < Double , Double > mp = Maps . newHashMap ( ) ;<br>    for ( int j = 0 ;  j < N ;  j ++ ) {<br>        mp [ mat [ 0 ] [ j ] ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= M ;  i ++ ) {<br>        for ( int j = 0 ;  j < N ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] < mp . length && mp [ mat [ i ] [ j ] ] == i ) || ( mat [ i ] [ j ] < mp [ mat [ i ] [ j ] ] == j ) ){<br>                mp [ mat [ i ] [ j ] ] = i + 1 ;<br>                if ( i == M - 1 ){<br>                    System . out . print ( mat [ i ] [ j ] + " " ) ;<br>                }<br>            }<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>DETECTING_NEGATIVE_CYCLE_USING_FLOYD_WARSHALL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean negCyclefloydWarshall ( int graph [ ] [ ] ) {<br>  int dist [ ] [ ] = new int [ V ] [ V ] , i , j , k ;<br>  for ( i = 0 ;<br>  i < V ;<br>  i ++ ) for ( j = 0 ;<br>  j < V ;<br>  j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ;<br>  for ( k = 0 ;<br>  k < V ;<br>  k ++ ) {<br>    for ( i = 0 ;<br>    i < V ;<br>    i ++ ) {<br>      for ( j = 0 ;<br>      j < V ;<br>      j ++ ) {<br>        if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ;<br>      }<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < V ;<br>  i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean negCyclefloydWarshall ( int [ ] [ ] graph ) {<br>    int [ ] dist = new int [ V + 1 ] ;<br>    for ( int i = 0 ;  i < V ;  i ++ ) {<br>        for ( int j = 0 ;  j < V ;  j ++ ) {<br>            dist [ i ] [ j ] = graph [ i ] [ j ] ;<br>        }<br>    }<br>    for ( int k = 0 ;  k < V ;  k ++ ) {<br>        for ( int i = 0 ;  i < V ;  i ++ ) {<br>            for ( int j = 0 ;  j < V ;  j ++ ) {<br>                if ( ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) && ( dist [ i ] [ j ] < dist [ k ] [ j ] ) ) {<br>                    dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ;<br>                }<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < V ;  i ++ ) {<br>        if ( ( dist [ i ] [ i ] < 0 ) && ( dist [ i ] [ i ] > 0 ) ) {<br>            return true ;<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_SORT_STRING_DESCENDING_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void sortString ( String str ) {<br>  int charCount [ ] = new int [ MAX_CHAR ] ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    charCount [ str . charAt ( i ) - 'a' ] ++ ;<br>  }<br>  for ( int i = MAX_CHAR - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < charCount [ i ] ;<br>    j ++ ) {<br>      System . out . print ( ( char ) ( 'a' + i ) ) ;<br>    }<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void sortString ( String str ) {<br>    charCount = new int [ MAX_CHAR ] ;<br>    for ( int i = 0 ;  i < str . length ( ) ;  i ++ ) {<br>        charCount [ ( int ) str . charAt ( i ) - 'a' ] ++ ;<br>    }<br>    for ( int i = MAX_CHAR - 1 ;  i >= 0 ;  i -- ) {<br>        for ( int j = 0 ;  j < charCount [ i ] ;  j ++ ) {<br>            System . out . print ( ( char ) ( 97 + i ) + " " ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_WITH_GIVEN_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void getPairsCount ( int [ ] arr , int sum ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < arr . length ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < arr . length ;<br>  j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ;<br>  System . out . printf ( "Count of pairs is %d" , count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int getPairsCount ( int [ ] arr , int n , int sum ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( arr [ i ] + arr [ j ] == sum ) {<br>                count ++ ;<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>SUM_SERIES_12_32_52_2N_12_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int sumOfSeries ( int n ) {<br>  return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ;<br>}<br></td>
    <td>translated code: <br><br> static int sumOfSeries ( int n ) {<br>    return ( int ) ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THAT_ELEMENT_HAVING_GREATER_FREQUENCY_IS_ALSO_GREATER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxdiff ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > freq = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ;<br>      else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxdiff ( int arr [ ] , int n ) {<br>    TreeMap < Integer , Integer > freq = new TreeMap < Integer , Integer > ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        freq [ arr [ i ] ] ++ ;<br>    }<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ){<br>                ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ;<br>            }<br>            else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ){<br>                ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ;<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SHIFT_MATRIX_ELEMENTS_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {<br>  if ( k > N ) {<br>    System . out . print ( "Shifting is" + " not possible" ) ;<br>    return ;<br>  }<br>  int j = 0 ;<br>  while ( j < N ) {<br>    for ( int i = k ;<br>    i < N ;<br>    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;<br>    for ( int i = 0 ;<br>    i < k ;<br>    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;<br>    System . out . println ( ) ;<br>    j ++ ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {<br>    if ( ( k > N ) && ( k < N ) ){<br>        System . out . println ( "shifting is" + " not possible" ) ;<br>        shiftMatrixByK ( mat , k , 0 ) ;<br>    }<br>    int j = 0 ;<br>    while ( ( j < N ) && ( j < k ) ) {<br>        for ( int i = k ;  i < N ;  i ++ ) {<br>            System . out . print ( "{}<br>        }<br>        for ( int i = 0 ;  i <= k ;  i ++ ) {<br>            System . out . print ( "{}<br>        }<br>        System . out . println ( "" ) ;<br>        j = j + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void maxMin ( int arr [ ] [ ] , int n ) {<br>  int min = + 2147483647 ;<br>  int max = - 2147483648 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= n / 2 ;<br>    j ++ ) {<br>      if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {<br>        if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ;<br>        if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;<br>      }<br>      else {<br>        if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;<br>        if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ;<br>      }<br>    }<br>  }<br>  System . out . print ( "Maximum = " + max + ", Minimum = " + min ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void MAXMIN ( int [ ] [ ] arr , int n ) {<br>    int MIN = 10 * 9 ;<br>    int MAX = - 10 * 9 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n / 2 + 1 ;  j ++ ) {<br>            if ( ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) && ( arr [ j ] [ i ] > arr [ j - i - 1 ] ) ){<br>                if ( ( MIN > arr [ i ] [ n - j - 1 ] ) && ( MIN > arr [ i ] [ n - j - 1 ] ) ){<br>                    MIN = arr [ i ] [ n - j - 1 ] ;<br>                }<br>                if ( ( MAX < arr [ i ] [ j ] ) && ( ( MAX < arr [ i ] [ j ] ) || ( ( MAX < arr [ i ] [ j ] ) ) ) ){<br>                    MAX = arr [ i ] [ j ] ;<br>                }<br>            }<br>            if ( n > 0 ) {<br>                if ( ( MIN > arr [ i ] [ j ] ) && ( ( MIN > arr [ i ] [ j ] ) || ( MIN > arr [ i ] [ j ] ) ) ){<br>                    MIN = arr [ i ] [ j ] ;<br>                }<br>                if ( ( MAX < arr [ i ] [ n - j - 1 ] ) && ( MAX < arr [ i ] [ n - j - 1 ] ) ){<br>                    MAX = arr [ i ] [ n - j - 1 ] ;<br>                }<br>            }<br>        }<br>    }<br>    System . out . println ( "MAXimum =" + MAX + ", MINimum =" + MIN ) ;<br>}</td>
  </tr><tr>
    <th>FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findGreatest ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > m = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( m . containsKey ( arr [ i ] ) ) {<br>      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ;<br>    }<br>  }<br>  Arrays . sort ( arr ) ;<br>  for ( int i = n - 1 ;<br>  i > 1 ;<br>  i -- ) {<br>    for ( int j = 0 ;<br>    j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ;<br>    j ++ ) {<br>      if ( arr [ i ] % arr [ j ] == 0 ) {<br>        int result = arr [ i ] / arr [ j ] ;<br>        if ( result != arr [ j ] && m . get ( result ) == null || m . get ( result ) > 0 ) {<br>          return arr [ i ] ;<br>        }<br>        else if ( result == arr [ j ] && m . get ( result ) > 1 ) {<br>          return arr [ i ] ;<br>        }<br>      }<br>    }<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int findGreatest ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > m = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        m [ i ] = m . get ( i ) + 1 ;<br>    }<br>    Collections . sort ( arr ) ;<br>    for ( int i = n - 1 ;  i > 0 ;  i -- ) {<br>        int j = 0 ;<br>        while ( ( j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ) || ( j > i && arr [ j - 1 ] <= Math . sqrt ( arr [ j ] ) ) ) {<br>            if ( ( arr [ i ] % arr [ j ] == 0 ) && ( arr [ i ] % arr [ j ] == 0 ) ) {<br>                int result = arr [ i ] / arr [ j ] ;<br>                if ( ( result != arr [ j ] && ( result < m . length ) && m [ result ] > 0 ) || ( result == arr [ j ] && ( result < m . length ) && m [ result ] == 0 ) ) {<br>                    return findGreatest ( arr , i -> n - i ) ;<br>                }<br>                if ( ( result == arr [ j ] && ( result < m . length ) && m [ result ] > 1 ) || ( result == arr [ j ] && ( result < m . length ) && m [ result ] > 2 ) ) {<br>                    return findGreatest ( arr , i -> n - i ) ;<br>                }<br>            }<br>            j ++ ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>0_1_KNAPSACK_PROBLEM_DP_10_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {<br>  int i , w ;<br>  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( w = 0 ;<br>    w <= W ;<br>    w ++ ) {<br>      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;<br>      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>    }<br>  }<br>  return K [ n ] [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) {<br>    K = new int [ W + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int w = 0 ;  w < W + 1 ;  w ++ ) {<br>            if ( i == 0 || w == 0 ){<br>                K [ i ] [ w ] = 0 ;<br>            }<br>            else if ( wt [ i - 1 ] <= w ){<br>                K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ;<br>            }<br>            else {<br>                K [ i ] [ w ] = K [ i - 1 ] [ w ] ;<br>            }<br>        }<br>    }<br>    return K [ n ] [ W ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_DECIMAL_OCTAL_CONVERSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void decToOctal ( int n ) {<br>  int [ ] octalNum = new int [ 100 ] ;<br>  int i = 0 ;<br>  while ( n != 0 ) {<br>    octalNum [ i ] = n % 8 ;<br>    n = n / 8 ;<br>    i ++ ;<br>  }<br>  for ( int j = i - 1 ;<br>  j >= 0 ;<br>  j -- ) System . out . print ( octalNum [ j ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void decToOctal ( int n ) {<br>    octalNum [ 0 ] = 0 ;<br>    int i ;<br>    while ( ( n != 0 ) && ( n != 1 ) ) {<br>        octalNum [ i ++ ] = n % 8 ;<br>        n = ( int ) ( n / 8 ) ;<br>        i ++ ;<br>    }<br>    for ( int j = i - 1 ;  j >= 0 ;  j -- ) {<br>        System . out . print ( octalNum [ j ] + " " ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countSubSeq ( int A [ ] , int N , int M ) {<br>  int ans = 0 ;<br>  int h [ ] = new int [ M ] ;<br>  Arrays . fill ( h , 0 ) ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    A [ i ] = A [ i ] % M ;<br>    h [ A [ i ] ] ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < M ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < M ;<br>    j ++ ) {<br>      int rem = ( M - ( i + j ) % M ) % M ;<br>      if ( rem < j ) continue ;<br>      if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ;<br>      else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ;<br>      else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ;<br>      else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ;<br>      else ans = ans + h [ i ] * h [ j ] * h [ rem ] ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int countSubSeq ( int [ ] A , int N , int M ) {<br>    int ans = 0 ;<br>    int [ ] h = {<br>    }<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        A [ i ] = A [ i ] % M ;<br>        h [ A [ i ] ] = h [ A [ i ] ] + 1 ;<br>    }<br>    for ( int i = 0 ;  i <= M ;  i ++ ) {<br>        for ( int j = i ;  j < M ;  j ++ ) {<br>            int rem = ( M - ( i + j ) % M ) % M ;<br>            if ( ( rem < j ) && ( rem < a ) ){<br>                continue ;<br>            }<br>            if ( ( i == j && rem == j ) || ( i == j && rem == i ) ){<br>                ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ;<br>            }<br>            else if ( ( i == j ) && ( i == N ) ){<br>                ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) ;<br>            }<br>            else if ( ( i == rem ) && ( i == n ) ){<br>                ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ;<br>            }<br>            else if ( ( rem == j ) && ( A [ 0 ] == A [ 1 ] ) ){<br>                ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ;<br>            }<br>            else int{<br>                ans = ans + h [ i ] * h [ j ] * h [ rem ] ;<br>            }<br>        }<br>        return ans ;<br>    }<br>}</td>
  </tr><tr>
    <th>COUNT_FIBONACCI_NUMBERS_GIVEN_RANGE_LOG_TIME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countFibs ( int low , int high ) {<br>  int f1 = 0 , f2 = 1 , f3 = 1 ;<br>  int result = 0 ;<br>  while ( f1 <= high ) {<br>    if ( f1 >= low ) result ++ ;<br>    f1 = f2 ;<br>    f2 = f3 ;<br>    f3 = f1 + f2 ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countFibs ( int low , int high ) {<br>    int f1 = 0 , f2 = 1 , f3 = 1 ;<br>    int result = 0 ;<br>    while ( ( f1 <= high ) && ( f1 <= low ) ) {<br>        if ( ( f1 >= low ) && ( f1 <= high ) ) {<br>            result ++ ;<br>        }<br>        f1 = f2 ;<br>        f2 = f3 ;<br>        int f3 = f1 + f2 ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int isPowerOfFour ( int n ) {<br>  int count = 0 ;<br>  int x = n & ( n - 1 ) ;<br>  if ( n > 0 && x == 0 ) {<br>    while ( n > 1 ) {<br>      n >>= 1 ;<br>      count += 1 ;<br>    }<br>    return ( count % 2 == 0 ) ? 1 : 0 ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isPowerOfFour ( int n ) {<br>    int count = 0 ;<br>    if ( ( n > 0 ) && ( ! ( n & ( n - 1 ) ) ) ) {<br>        while ( ( n > 1 ) && ( n % 2 == 0 ) ) {<br>            n >>= 1 ;<br>            count ++ ;<br>        }<br>        if ( ( count % 2 == 0 ) && ( count % 4 == 0 ) ) {<br>            return true ;<br>        }<br>        else {<br>            return false ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_SUM_EVEN_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int sumofFactors ( int n ) {<br>  if ( n % 2 != 0 ) return 0 ;<br>  int res = 1 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    int count = 0 , curr_sum = 1 ;<br>    int curr_term = 1 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n = n / i ;<br>      if ( i == 2 && count == 1 ) curr_sum = 0 ;<br>      curr_term *= i ;<br>      curr_sum += curr_term ;<br>    }<br>    res *= curr_sum ;<br>  }<br>  if ( n >= 2 ) res *= ( 1 + n ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int sumofFactors ( int n ) {<br>    if ( ( n % 2 != 0 ) && ( n % 3 != 0 ) ) {<br>        return 0 ;<br>    }<br>    int res = 1 ;<br>    for ( int i = 2 ;  i <= ( int ) ( Math . sqrt ( n ) ) ;  i ++ ) {<br>        int count = 0 ;<br>        currSum = 1 ;<br>        currTerm = 1 ;<br>        while ( ( n % i == 0 ) && ( n % i == 0 ) ) {<br>            count = count + 1 ;<br>            n = n / i ;<br>            if ( ( i == 2 && count == 1 ) || ( i == 3 && count == 2 ) ){<br>                int currSum = 0 ;<br>            }<br>            currTerm = currTerm * i ;<br>            currSum = currSum + currTerm ;<br>        }<br>        res = res * currSum ;<br>    }<br>    if ( ( n >= 2 ) && ( n <= 3 ) ) {<br>        res = res * ( 1 + n ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_NON_REPEATING_DISTINCT_ELEMENTS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findSum ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  HashSet < Integer > s = new HashSet < Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! s . contains ( arr [ i ] ) ) {<br>      sum += arr [ i ] ;<br>      s . add ( arr [ i ] ) ;<br>    }<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int findSum ( int [ ] arr , int n ) {<br>    Set < Integer > s = new HashSet < Integer > ( ) ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] != s ){<br>            s . add ( arr [ i ] ) ;<br>        }<br>    }<br>    for ( int i = 0 ;  i < s . length ;  i ++ ) {<br>        sum = sum + i ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minPalPartion ( String str ) {<br>  int n = str . length ( ) ;<br>  int [ ] C = new int [ n ] ;<br>  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;<br>  int i , j , k , L ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    P [ i ] [ i ] = true ;<br>  }<br>  for ( L = 2 ;<br>  L <= n ;<br>  L ++ ) {<br>    for ( i = 0 ;<br>    i < n - L + 1 ;<br>    i ++ ) {<br>      j = i + L - 1 ;<br>      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ;<br>      else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ;<br>    }<br>  }<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( P [ 0 ] [ i ] == true ) C [ i ] = 0 ;<br>    else {<br>      C [ i ] = Integer . MAX_VALUE ;<br>      for ( j = 0 ;<br>      j < i ;<br>      j ++ ) {<br>        if ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) C [ i ] = 1 + C [ j ] ;<br>      }<br>    }<br>  }<br>  return C [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minPalPartion ( String str1 ) {<br>    int n = str1 . length ( ) ;<br>    int [ ] C = {<br>    }<br>    P = new boolean [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        P [ i ] [ i ] = true ;<br>    }<br>    for ( int L = 2 ;  L <= n ;  L ++ ) {<br>        for ( int i = 0 ;  i < n - L + 1 ;  i ++ ) {<br>            int j = i + L - 1 ;<br>            if ( ( L == 2 ) && ( str1 . length ( ) > 0 ) ) {<br>                P [ i ] [ j ] = ( str1 . charAt ( i ) == str1 . charAt ( j ) ) ;<br>            }<br>            else {<br>                P [ i ] [ j ] = ( ( str1 . charAt ( i ) == str1 . charAt ( j ) ) ? P [ i + 1 ] [ j - 1 ] : null ) ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( P [ 0 ] [ i ] == true ) && ( P [ 1 ] [ i ] == true ) ) {<br>            C [ i ++ ] = 0 ;<br>        }<br>        else {<br>            C [ i ] = Integer . MAX_VALUE ;<br>            for ( int j = 0 ;  j < i ;  j ++ ) {<br>                if ( ( P [ j + 1 ] [ i ] == true && 1 + C [ j ] < C [ i ] ) || ( P [ j + 1 ] [ i ] == false && 1 + C [ j ] < C [ i ] ) ) {<br>                    C [ i ] = 1 + C [ j ] ;<br>                }<br>            }<br>        }<br>    }<br>    return C [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int minInitialPoints ( int points [ ] [ ] , int R , int C ) {<br>  int dp [ ] [ ] = new int [ R ] [ C ] ;<br>  int m = R , n = C ;<br>  dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ;<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ;<br>  for ( int j = n - 2 ;<br>  j >= 0 ;<br>  j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ;<br>  for ( int i = m - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    for ( int j = n - 2 ;<br>    j >= 0 ;<br>    j -- ) {<br>      int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ;<br>      dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ;<br>    }<br>  }<br>  return dp [ 0 ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minInitialPoints ( int [ ] [ ] points ) {<br>    int [ ] dp = new int [ C + 1 ] ;<br>    int m = R , n = C ;<br>    if ( points [ m - 1 ] [ n - 1 ] > 0 ){<br>        dp [ m - 1 ] [ n - 1 ] = 1 ;<br>    }<br>    if ( points . length > 0 ) {<br>        dp [ m - 1 ] [ n - 1 ] = Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ;<br>    }<br>    for ( int i = m - 2 ;  i >= 0 ;  i -- ) {<br>        dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ;<br>    }<br>    for ( int i = 2 ;  i >= 0 ;  i -- ) {<br>        dp [ m - 1 ] [ i ] = Math . max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) ;<br>    }<br>    for ( int i = m - 2 ;  i >= 0 ;  i -- ) {<br>        for ( int j = n - 2 ;  j >= 0 ;  j -- ) {<br>            minPointsOnExit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ;<br>            dp [ i ] [ j ] = Math . max ( minPointsOnExit - points [ i ] [ j ] , 1 ) ;<br>        }<br>    }<br>    return dp [ 0 ] [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_OF_PAIRS_SATISFYING_THE_GIVEN_CONDITION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int countPair ( int a , int b ) {<br>  String s = String . valueOf ( b ) ;<br>  int i ;<br>  for ( i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) != '9' ) break ;<br>  }<br>  int result ;<br>  if ( i == s . length ( ) ) result = a * s . length ( ) ;<br>  else result = a * ( s . length ( ) - 1 ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int countPair ( int a , int b ) {<br>    String s = Integer . toString ( b ) ;<br>    int i = 0 ;<br>    while ( i < ( s . length ) ) {<br>        if ( ( s [ i ] != '9' ) && ( s [ i ] != 'a' ) && ( s [ i ] != 'f' ) && ( s [ i ] != 'g' ) && ( s [ i ] != 'h' ) && ( s [ i ] != 'i' ) && ( s [ i ] != 'j' ) && ( s [ i ] != 'k' ) && (<br>            break ;<br>        i ++ ;<br>    }<br>    int result = 0 ;<br>    if ( ( i == s . length ) && ( b == s . length ) ){<br>        int result = a * s . length ;<br>    }<br>    }<br>        int result = a * ( s . length - 1 ) ;<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SURVIVAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void survival ( int S , int N , int M ) {<br>  if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) System . out . println ( "No" ) ;<br>  else {<br>    int days = ( M * S ) / N ;<br>    if ( ( ( M * S ) % N ) != 0 ) days ++ ;<br>    System . out . println ( "Yes " + days ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void survival ( int S , int N , int M ) {<br>    if ( ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) || M > N ) ){<br>        System . out . println ( "No" ) ;<br>    }<br>    else {<br>        int days = ( M * S ) / N ;<br>        if ( ( ( ( M * S ) % N ) != 0 ) && ( ( ( M * S ) % N ) != 0 ) ) {<br>            days ++ ;<br>        }<br>        System . out . print ( "Yes " ) ;<br>        System . out . println ( days ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>INTERLEAVE_FIRST_HALF_QUEUE_SECOND_HALF</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void interLeaveQueue ( Queue < Integer > q ) {<br>  if ( q . size ( ) % 2 != 0 ) System . out . println ( "Input even number of integers." ) ;<br>  Stack < Integer > s = new Stack < > ( ) ;<br>  int halfSize = q . size ( ) / 2 ;<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  while ( ! s . empty ( ) ) {<br>    q . add ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    q . add ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < halfSize ;<br>  i ++ ) {<br>    s . push ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>  while ( ! s . empty ( ) ) {<br>    q . add ( s . peek ( ) ) ;<br>    s . pop ( ) ;<br>    q . add ( q . peek ( ) ) ;<br>    q . poll ( ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void interLeaveQueue ( Queue q ) {<br>    if ( ( q . qsize ( ) % 2 != 0 ) && ( q . qsize ( ) % 2 == 0 ) ) {<br>        System . out . println ( "Input even number of integers." ) ;<br>    }<br>    Stack < Integer > s = new Stack < Integer > ( ) ;<br>    int halfSize = ( int ) ( q . qsize ( ) / 2 ) ;<br>    for ( int i = 0 ;  i < halfSize ;  i ++ ) {<br>        s . add ( q . queue . get ( ) ) ;<br>        q . poll ( ) ;<br>    }<br>    while ( s . size ( ) != 0 ) {<br>        q . offer ( s . charAt ( q . size ( ) - 1 ) ) ;<br>        s . remove ( ) ;<br>    }<br>    for ( int i = 0 ;  i < halfSize ;  i ++ ) {<br>        q . put ( q . queue . get ( ) ) ;<br>        q . poll ( ) ;<br>    }<br>    for ( int i = 0 ;  i < halfSize ;  i ++ ) {<br>        s . add ( q . queue . get ( ) ) ;<br>        q . poll ( ) ;<br>    }<br>    while ( s . size ( ) != 0 ) {<br>        q . offer ( s . charAt ( q . size ( ) - 1 ) ) ;<br>        s . remove ( ) ;<br>        q . put ( q . queue . get ( ) ) ;<br>        q . poll ( ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int findInteger ( int arr [ ] , int n ) {<br>  int neg = 0 , pos = 0 ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    sum += arr [ i ] ;<br>    if ( arr [ i ] < 0 ) neg ++ ;<br>    else pos ++ ;<br>  }<br>  return ( sum / Math . abs ( neg - pos ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int findInteger ( int [ ] arr , int n ) {<br>    int neg = 0 ;<br>    int pos = 0 ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        sum += arr [ i ] ;<br>        if ( ( arr [ i ] < 0 ) && ( arr [ i ] > n ) ) {<br>            neg ++ ;<br>        }<br>        if ( n > 0 ) {<br>            pos ++ ;<br>        }<br>    }<br>    return ( sum / Math . abs ( neg - pos ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int evenSum ( int n ) {<br>  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  int i , j ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( i = 0 ;<br>  i <= n ;<br>  i += 2 ) sum += C [ n ] [ i ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int evenSum ( int n ) {<br>    int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= Math . min ( i , n + 1 ) ;  j ++ ) {<br>            if ( j == 0 || j == i ) {<br>                C [ i ] [ j ] = 1 ;<br>            }<br>            }<br>                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( n % 2 == 0 ) {<br>            sum = sum + C [ n ] [ i ] ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>DELANNOY_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int dealnnoy ( int n , int m ) {<br>  if ( m == 0 || n == 0 ) return 1 ;<br>  return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int dealnnoy ( int n , int m ) {<br>    if ( ( m == 0 || n == 0 ) && ( m == 0 || n == 1 ) ) {<br>        return 1 ;<br>    }<br>    return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxLen ( int arr [ ] , int n ) {<br>  int max_len = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_sum = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      curr_sum += arr [ j ] ;<br>      if ( curr_sum == 0 ) max_len = Math . max ( max_len , j - i + 1 ) ;<br>    }<br>  }<br>  return max_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxLen ( int [ ] arr ) {<br>    maxLen = 0 ;<br>    for ( int i = 0 ;  i < arr . length ;  i ++ ) {<br>        int currSum = 0 ;<br>        for ( int j = i ;  j < arr . length ;  j ++ ) {<br>            currSum += arr [ j ] ;<br>            if ( currSum == 0 ) {<br>                maxLen = Math . max ( maxLen , j - i + 1 ) ;<br>            }<br>        }<br>    }<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>NEXT_POWER_OF_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextPowerOf2 ( int n ) {<br>  int count = 0 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( n != 0 ) {<br>    n >>= 1 ;<br>    count += 1 ;<br>  }<br>  return 1 << count ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextPowerOf2 ( int n ) {<br>    count = 0 ;<br>    if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) {<br>        return n ;<br>    }<br>    while ( ( n != 0 ) && ( n % 2 == 0 ) ) {<br>        n >>= 1 ;<br>        count ++ ;<br>    }<br>    return 1 << count ++ ;<br>}</td>
  </tr><tr>
    <th>LONGEST_GEOMETRIC_PROGRESSION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int lenOfLongestGP ( int set [ ] , int n ) {<br>  if ( n < 2 ) {<br>    return n ;<br>  }<br>  if ( n == 2 ) {<br>    return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ;<br>  }<br>  Arrays . sort ( set ) ;<br>  int L [ ] [ ] = new int [ n ] [ n ] ;<br>  int llgp = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( set [ n - 1 ] % set [ i ] == 0 ) {<br>      L [ i ] [ n - 1 ] = 2 ;<br>    }<br>    else {<br>      L [ i ] [ n - 1 ] = 1 ;<br>    }<br>  }<br>  for ( int j = n - 2 ;<br>  j >= 1 ;<br>  -- j ) {<br>    int i = j - 1 , k = j + 1 ;<br>    while ( i >= 0 && k <= n - 1 ) {<br>      if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) {<br>        ++ k ;<br>      }<br>      else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) {<br>        if ( set [ j ] % set [ i ] == 0 ) {<br>          L [ i ] [ j ] = 2 ;<br>        }<br>        else {<br>          L [ i ] [ j ] = 1 ;<br>        }<br>        -- i ;<br>      }<br>      else {<br>        L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>        if ( L [ i ] [ j ] > llgp ) {<br>          llgp = L [ i ] [ j ] ;<br>        }<br>        -- i ;<br>        ++ k ;<br>      }<br>    }<br>    while ( i >= 0 ) {<br>      if ( set [ j ] % set [ i ] == 0 ) {<br>        L [ i ] [ j ] = 2 ;<br>      }<br>      else {<br>        L [ i ] [ j ] = 1 ;<br>      }<br>      -- i ;<br>    }<br>  }<br>  return llgp ;<br>}<br></td>
    <td>translated code: <br><br> public static int lenOfLongestGP ( int [ ] sett , int n ) {<br>    if ( n < 2 ) {<br>        return n ;<br>    }<br>    if ( n == 2 ) {<br>        return ( sett [ 1 ] % sett [ 0 ] == 0 ? 1 : 0 ) ;<br>    }<br>    Collections . sort ( sett ) ;<br>    int [ ] L = new int [ n ] ;<br>    long llgp = 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( sett [ n - 1 ] % sett [ i ] == 0 ){<br>            L [ i ] [ n - 1 ] = 2 ;<br>        }<br>        else {<br>            L [ i ] [ n - 1 ] = 1 ;<br>        }<br>    }<br>    for ( int j = n - 2 ;  j > 0 ;  j -- ) {<br>        int i = j - 1 ;<br>        int k = j + 1 ;<br>        while ( i >= 0 && k <= n - 1 ) {<br>            if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ){<br>                k ++ ;<br>            }<br>            if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) {<br>                if ( sett [ j ] % sett [ i ] == 0 ){<br>                    L [ i ] [ j ] = 2 ;<br>                }<br>                else {<br>                    L [ i ] [ j ] = 1 ;<br>                }<br>                i -- ;<br>            }<br>            else {<br>                L [ i ] [ j ] = L [ j ] [ k ] + 1 ;<br>                if ( L [ i ] [ j ] > llgp ){<br>                    int llgp = L [ i ] [ j ] ;<br>                }<br>                i -- ;<br>                return k + 1 ;<br>            }<br>        }<br>        while ( i >= 0 ) {<br>            if ( sett [ j ] % sett [ i ] == 0 ){<br>                L [ i ] [ j ] = 2 ;<br>            }<br>            else {<br>                L [ i ] [ j ] = 1 ;<br>            }<br>            i -- ;<br>        }<br>    }<br>    return llgp ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> private static int minCost ( int cost [ ] [ ] , int m , int n ) {<br>  int i , j ;<br>  int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;<br>  for ( i = 1 ;<br>  i <= m ;<br>  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;<br>  for ( j = 1 ;<br>  j <= n ;<br>  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;<br>  for ( i = 1 ;<br>  i <= m ;<br>  i ++ ) for ( j = 1 ;<br>  j <= n ;<br>  j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ;<br>  return tc [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int minCost ( int [ ] cost , int m , int n ) {<br>    int [ ] tc = new int [ C ] ;<br>    tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;<br>    }<br>    for ( int j = 1 ;  j <= n ;  j ++ ) {<br>        tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;<br>    }<br>    for ( int i = 1 ;  i <= m ;  i ++ ) {<br>        for ( int j = 1 ;  j <= n ;  j ++ ) {<br>            tc [ i ] [ j ] = Math . min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ;<br>        }<br>    }<br>    return tc [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_DISTANCE_TWO_POINTS_EARTH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) {<br>  lon1 = Math . toRadians ( lon1 ) ;<br>  lon2 = Math . toRadians ( lon2 ) ;<br>  lat1 = Math . toRadians ( lat1 ) ;<br>  lat2 = Math . toRadians ( lat2 ) ;<br>  double dlon = lon2 - lon1 ;<br>  double dlat = lat2 - lat1 ;<br>  double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Math . cos ( lat1 ) * Math . cos ( lat2 ) * Math . pow ( Math . sin ( dlon / 2 ) , 2 ) ;<br>  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;<br>  double r = 6371 ;<br>  return ( c * r ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) {<br>    lon1 = Math . toRadians ( lon1 ) ;<br>    lon2 = Math . toRadians ( lon2 ) ;<br>    lat1 = Math . toRadians ( lat1 ) ;<br>    lat2 = Math . toRadians ( lat2 ) ;<br>    double dlon = lon2 - lon1 ;<br>    double dlat = lat2 - lat1 ;<br>    double a = sin ( dlat / 2 ) * ( lon1 - lon2 ) + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) * ( lon1 - lon2 ) ;<br>    double c = 2 * asin ( Math . sqrt ( a ) ) ;<br>    double r = 6371 ;<br>    return ( c * r ) ;<br>}</td>
  </tr><tr>
    <th>BIN_PACKING_PROBLEM_MINIMIZE_NUMBER_OF_USED_BINS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int nextFit ( int weight [ ] , int n , int c ) {<br>  int res = 0 , bin_rem = c ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( weight [ i ] > bin_rem ) {<br>      res ++ ;<br>      bin_rem = c - weight [ i ] ;<br>    }<br>    else bin_rem -= weight [ i ] ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int nextfit ( int [ ] weight , int c ) {<br>    int res = 0 ;<br>    double rem = c ;<br>    for ( ;  weight . length > c ;  ) {<br>        if ( rem >= weight [ _ ] ){<br>            rem = rem - weight [ _ ] ;<br>        }<br>        else{<br>            res ++ ;<br>            double rem = c - weight [ _ ] ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_SUBARRAY_WITH_GIVEN_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> int subArraySum ( int arr [ ] , int n , int sum ) {<br>  int curr_sum = arr [ 0 ] , start = 0 , i ;<br>  for ( i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    while ( curr_sum > sum && start < i - 1 ) {<br>      curr_sum = curr_sum - arr [ start ] ;<br>      start ++ ;<br>    }<br>    if ( curr_sum == sum ) {<br>      int p = i - 1 ;<br>      System . out . println ( "Sum found between indexes " + start + " and " + p ) ;<br>      return 1 ;<br>    }<br>    if ( i < n ) curr_sum = curr_sum + arr [ i ] ;<br>  }<br>  System . out . println ( "No subarray found" ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int subArraySum ( int [ ] arr , int n , int sum ) {<br>    int currSum = arr [ 0 ] ;<br>    int start = 0 ;<br>    int i = 1 ;<br>    while ( i <= n ) {<br>        while ( currSum > sum && start < i - 1 ) {<br>            currSum = currSum - arr [ start ] ;<br>            start ++ ;<br>        }<br>        if ( currSum == sum ) {<br>            System . out . println ( "Sum found between indexes" ) ;<br>            System . out . println ( start + " and " + i - 1 ) ;<br>            return 1 ;<br>        }<br>        if ( i < n ){<br>            currSum = currSum + arr [ i ] ;<br>        }<br>        i ++ ;<br>    }<br>    System . out . println ( "No subarray found" ) ;<br>    return 0 ;<br>}</td>
  </tr><tr>
    <th>SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {<br>  int [ ] dp = new int [ W + 1 ] ;<br>  Arrays . fill ( dp , 0 ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = W ;<br>  j >= wt [ i ] ;<br>  j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ;<br>  return dp [ W ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) {<br>    double dp [ ] = new double [ W + 1 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = W ;  j > wt [ i ] ;  j -- ) {<br>            dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ;<br>        }<br>    }<br>    return dp [ W ] ;<br>}</td>
  </tr><tr>
    <th>FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long yMod ( long y , long x ) {<br>  if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y ;<br>  if ( x > 63 ) return y ;<br>  return ( y % ( 1 << ( int ) x ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double yMod ( double y , double x ) {<br>    return ( y % Math . pow ( 2 , x ) ) ;<br>}</td>
  </tr><tr>
    <th>SUM_SERIES_23_45_67_89_UPTO_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double seriesSum ( int n ) {<br>  int i = 1 ;<br>  double res = 0.0 ;<br>  boolean sign = true ;<br>  while ( n > 0 ) {<br>    n -- ;<br>    if ( sign ) {<br>      sign = ! sign ;<br>      res = res + ( double ) ++ i / ++ i ;<br>    }<br>    else {<br>      sign = ! sign ;<br>      res = res - ( double ) ++ i / ++ i ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static double seriesSum ( int n ) {<br>    int i = 1 ;<br>    double res = 0.0 ;<br>    sign = true ;<br>    while ( ( n -- > 0 ) && ( n > 0 ) ) {<br>        n = n - 1 ;<br>        if ( ( sign ) && ( n > 0 ) ) {<br>            sign = false ;<br>            res = res + ( i + 1 ) / ( i + 2 ) ;<br>            i = i + 2 ;<br>        }<br>        else {<br>            sign = true ;<br>            res = res - ( i + 1 ) / ( i + 2 ) ;<br>            i = i + 2 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>LENGTH_LONGEST_STRICT_BITONIC_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int longLenStrictBitonicSub ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ;<br>  HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ;<br>  int len_inc [ ] = new int [ n ] ;<br>  int len_dcr [ ] = new int [ n ] ;<br>  int longLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int len = 0 ;<br>    if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ;<br>    len_inc [ i ] = len + 1 ;<br>    inc . put ( arr [ i ] , len_inc [ i ] ) ;<br>  }<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int len = 0 ;<br>    if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ;<br>    len_dcr [ i ] = len + 1 ;<br>    dcr . put ( arr [ i ] , len_dcr [ i ] ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ;<br>  return longLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int longLenStrictBitonicSub ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > inc = Collections . emptyMap ( ) , dcr = Collections . emptyMap ( ) ;<br>    int lenInc = arr [ 0 ] , lenDcr = arr [ 0 ] ;<br>    long longLen = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int len = 0 ;<br>        if ( inc . get ( arr [ i ] - 1 ) == null ) {<br>            int len = inc . get ( arr [ i ] - 1 ) ;<br>        }<br>        inc [ arr [ i ] ] = lenInc [ i ] = len + 1 ;<br>    }<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        int len = 0 ;<br>        if ( dcr . get ( arr [ i ] - 1 ) == null ) {<br>            int len = dcr . get ( arr [ i ] - 1 ) ;<br>        }<br>        dcr [ arr [ i ] ] = lenDcr [ i ] = len + 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( longLen < ( lenInc [ i ] + lenDcr [ i ] - 1 ) ){<br>            longLen = lenInc [ i ] + lenDcr [ i ] - 1 ;<br>        }<br>    }<br>    return longLen ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxDistance ( int [ ] arr , int n ) {<br>  HashMap < Integer , Integer > map = new HashMap < > ( ) ;<br>  int max_dist = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ;<br>    else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ;<br>  }<br>  return max_dist ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxDistance ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;<br>    int maxMap = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] != mp . keySet ( ) . iterator ( ) . next ( ) ) {<br>            mp [ arr [ i ] ] = i ;<br>        }<br>        if ( n > 0 ) {<br>            maxMap = Math . max ( maxMap , i - mp [ arr [ i ] ] ) ;<br>        }<br>    }<br>    return maxMap ;<br>}</td>
  </tr><tr>
    <th>FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean isRectangle ( int matrix [ ] [ ] ) {<br>  int rows = matrix . length ;<br>  if ( rows == 0 ) return false ;<br>  int columns = matrix [ 0 ] . length ;<br>  HashMap < Integer , HashSet < Integer >> table = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < rows ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < columns - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < columns ;<br>      k ++ ) {<br>        if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) {<br>          if ( table . containsKey ( j ) && table . get ( j ) . contains ( k ) ) {<br>            return true ;<br>          }<br>          if ( table . containsKey ( k ) && table . get ( k ) . contains ( j ) ) {<br>            return true ;<br>          }<br>          if ( ! table . containsKey ( j ) ) {<br>            HashSet < Integer > x = new HashSet < > ( ) ;<br>            x . add ( k ) ;<br>            table . put ( j , x ) ;<br>          }<br>          else {<br>            table . get ( j ) . add ( k ) ;<br>          }<br>          if ( ! table . containsKey ( k ) ) {<br>            HashSet < Integer > x = new HashSet < > ( ) ;<br>            x . add ( j ) ;<br>            table . put ( k , x ) ;<br>          }<br>          else {<br>            table . get ( k ) . add ( j ) ;<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean isRectangle ( int [ ] [ ] matrix ) {<br>    int rows = matrix . length ;<br>    if ( ( rows == 0 ) && ( cols == 0 ) ) {<br>        return false ;<br>    }<br>    int columns = matrix [ 0 ] . length ;<br>    Hashtable table = new Hashtable ( ) ;<br>    for ( int i = 0 ;  i < rows ;  i ++ ) {<br>        for ( int j = 0 ;  j < columns - 1 ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < columns ;  k ++ ) {<br>                if ( ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) || ( matrix [ i ] [ j ] == 0 && matrix [ i ] [ k ] == 0 ) ) {<br>                    if ( ( j < table . length && k < table [ j ] . length ) || ( j > table . length && k > table [ j ] [ k ] ) ){<br>                        return isRectangle ( matrix , false ) ;<br>                    }<br>                    if ( ( k < table . length ) && ( j < table . length ) ){<br>                        return isRectangle ( matrix , false ) ;<br>                    }<br>                    if ( j != 0 ){<br>                        table [ j ] = new HashSet ( ) ;<br>                    }<br>                    if ( k != 0 ){<br>                        table . put ( k , new HashSet < > ( ) ) ;<br>                    }<br>                    table [ j ] . add ( k ) ;<br>                    table [ k ] . add ( j ) ;<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int numofsubset ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int count = 1 ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int numofSubset ( int [ ] arr , int n ) {<br>    int [ ] x = new int [ n ] ;<br>    int count = 1 ;<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( x [ i ] + 1 != x [ i + 1 ] ) && ( x [ i + 1 ] + 2 != x [ i + 2 ] ) ){<br>            count = count + 1 ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>LARGEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int maxSubArraySum ( int a [ ] ) {<br>  int size = a . length ;<br>  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ;<br>  for ( int i = 0 ;<br>  i < size ;<br>  i ++ ) {<br>    max_ending_here = max_ending_here + a [ i ] ;<br>    if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;<br>    if ( max_ending_here < 0 ) max_ending_here = 0 ;<br>  }<br>  return max_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int maxSubArraySum ( int [ ] a , int size ) {<br>    maxSoFar = - Integer . MAX_VALUE - 1 ;<br>    int maxEndingHere = 0 ;<br>    for ( int i = 0 ;<br>        maxEndingHere = maxEndingHere + a [ i ] ;<br>        if ( ( maxSo_far < maxEndingHere ) && ( size > 0 ) ) {<br>            maxSoFar = maxEndingHere ;<br>        }<br>        if ( maxEndingHere < 0 ) {<br>            int maxEndingHere = 0 ;<br>        }<br>    return max_so_far ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getRemainder ( int num , int divisor ) {<br>  while ( num >= divisor ) num -= divisor ;<br>  return num ;<br>}<br></td>
    <td>translated code: <br><br> public static int getRemainder ( int num , int divisor ) {<br>    while ( ( num >= divisor ) && ( num < divisor ) ) {<br>        num -= divisor ;<br>    }<br>    return num ;<br>}</td>
  </tr><tr>
    <th>CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean check ( String str ) {<br>  int n = str . length ( ) ;<br>  if ( n == 0 ) return false ;<br>  if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ;<br>  int last = str . charAt ( n - 1 ) - '0' ;<br>  int second_last = str . charAt ( n - 2 ) - '0' ;<br>  return ( ( second_last * 10 + last ) % 4 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean check ( String st ) {<br>    int n = st . length ( ) ;<br>    if ( ( n == 0 ) && ( st instanceof MethodNode ) ) {<br>        return false ;<br>    }<br>    if ( ( n == 1 ) && ( st instanceof MethodNode ) ) {<br>        return ( ( st . charAt ( 0 ) - '0' ) % 4 == 0 ) ;<br>    }<br>    int last = ( Integer ) ( st . charAt ( n - 1 ) ) ;<br>    secondLast = ( Integer ) ( st . charAt ( n - 2 ) ) ;<br>    return ( ( secondLast * 10 + last ) % 4 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int getSingle ( int arr [ ] , int n ) {<br>  int result = 0 ;<br>  int x , sum ;<br>  for ( int i = 0 ;<br>  i < INT_SIZE ;<br>  i ++ ) {<br>    sum = 0 ;<br>    x = ( 1 << i ) ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( arr [ j ] & x ) == 0 ) sum ++ ;<br>    }<br>    if ( ( sum % 3 ) == 0 ) result |= x ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> static int getSingle ( int [ ] arr , int n ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i <= INT_SIZE ;  i ++ ) {<br>        int sm = 0 ;<br>        int x = ( 1 << i ) ;<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            if ( ( arr [ j ] & x ) != 0 ){<br>                sm = sm + 1 ;<br>            }<br>        }<br>        if ( ( sm % 3 ) != 0 ){<br>            result = result | x ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>NUMBER_RECTANGLES_NM_GRID</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long rectCount ( int n , int m ) {<br>  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;<br>}<br></td>
    <td>translated code: <br><br> static int rectCount ( int n , int m ) {<br>    return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_POINTS_INTERSECTION_N_CIRCLES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int intersection ( int n ) {<br>  return n * ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int intersection ( int n ) {<br>    return n * ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>ADD_1_TO_A_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x ) {<br>  int m = 1 ;<br>  while ( ( int ) ( x & m ) >= 1 ) {<br>    x = x ^ m ;<br>    m <<= 1 ;<br>  }<br>  x = x ^ m ;<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int x ) {<br>    int m = 1 ;<br>    while ( ( x & m ) != 0 ) {<br>        x = x ^ m ;<br>        m <<= 1 ;<br>    }<br>    x = x ^ m ;<br>    return x ;<br>}</td>
  </tr><tr>
    <th>ADD_TWO_NUMBERS_WITHOUT_USING_ARITHMETIC_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x , int y ) {<br>  while ( y != 0 ) {<br>    int carry = x & y ;<br>    x = x ^ y ;<br>    y = carry << 1 ;<br>  }<br>  return x ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int x , int y ) {<br>    while ( ( y != 0 ) && ( x != 0 ) ) {<br>        int carry = x & y ;<br>        x = x ^ y ;<br>        y = carry << 1 ;<br>    }<br>    return x ;<br>}</td>
  </tr><tr>
    <th>AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_IN_IT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float f_gold ( int a ) {<br>  float area = ( float ) ( Math . PI * a * a ) / 4 ;<br>  return area ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenArea ( double a ) {<br>    int area = ( Math . PI * a * a ) / 4 ;<br>    return area ;<br>}</td>
  </tr><tr>
    <th>ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int start , int end , int arr [ ] ) {<br>  Map < Integer , Integer > mp = new HashMap < > ( ) ;<br>  for ( int i = start ;<br>  i <= end ;<br>  i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ;<br>  int count = 0 ;<br>  for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int start , int end , int [ ] arr ) {<br>    Map < Integer , Integer > frequency = Collections . emptyMap ( ) ;<br>    for ( int i = start ;  i <= end ;  i ++ ) {<br>        if ( arr [ i ] < frequency . length ) {<br>            frequency [ arr [ i ] ] ++ ;<br>        }<br>        else {<br>            frequency [ arr [ i ] ] = 1 ;<br>        }<br>    }<br>    int count = 0 ;<br>    for ( int x = 0 ;  x < frequency ;  x ++ ) {<br>        if ( x == frequency [ x ] ) {<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>BELL_NUMBERS_NUMBER_OF_WAYS_TO_PARTITION_A_SET</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ;<br>  bell [ 0 ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ;<br>    for ( int j = 1 ;<br>    j <= i ;<br>    j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ;<br>  }<br>  return bell [ n ] [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] bell = new int [ n + 1 ] ;<br>    bell [ 0 ] [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ;<br>        for ( int j = 1 ;  j <= i ;  j ++ ) {<br>            bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ;<br>        }<br>    }<br>    return bell [ n ] [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>BINARY_SEARCH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int l , int r , int x ) {<br>  if ( r >= l ) {<br>    int mid = l + ( r - l ) / 2 ;<br>    if ( arr [ mid ] == x ) return mid ;<br>    if ( arr [ mid ] > x ) return f_gold ( arr , l , mid - 1 , x ) ;<br>    return f_gold ( arr , mid + 1 , r , x ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int l , int r , int x ) {<br>    if ( r >= l ){<br>        int mid = l + ( r - l ) / 2 ;<br>        if ( arr [ mid ] == x ){<br>            return mid ;<br>        }<br>        else if ( arr [ mid ] > x ){<br>            return f_gold ( arr , l , mid - 1 , x ) ;<br>        }<br>        else {<br>            return f_gold ( arr , mid + 1 , r , x ) ;<br>        }<br>    }<br>    else {<br>        return - 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>BREAK_NUMBER_THREE_PARTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( long n ) {<br>  long count = 0 ;<br>  count = ( n + 1 ) * ( n + 2 ) / 2 ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int count = 0 ;<br>    int count = ( n + 1 ) * ( n + 2 ) / 2 ;<br>    return count ;<br>}</td>
  </tr><tr>
    <th>CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( double h , double m ) {<br>  if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( "Wrong input" ) ;<br>  if ( h == 12 ) h = 0 ;<br>  if ( m == 60 ) m = 0 ;<br>  int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ;<br>  int minute_angle = ( int ) ( 6 * m ) ;<br>  int angle = Math . abs ( hour_angle - minute_angle ) ;<br>  angle = Math . min ( 360 - angle , angle ) ;<br>  return angle ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int h , int m ) {<br>    if ( ( h < 0 || m < 0 || h > 12 || m > 60 ) && ( h < 0 || m > 60 ) ) {<br>        System . out . println ( "Wrong input" ) ;<br>    }<br>    if ( ( h == 12 ) && ( m == 12 ) ) {<br>        h = 0 ;<br>    }<br>    if ( ( m == 60 ) && ( h == 0 ) ) {<br>        m = 0 ;<br>    }<br>    hourAngle = 0.5 * ( h * 60 + m ) ;<br>    minuteAngle = 6 * m ;<br>    angle = Math . abs ( hourAngle - minuteAngle ) ;<br>    angle = Math . min ( 360 - angle , angle ) ;<br>    return angle ;<br>}</td>
  </tr><tr>
    <th>CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String str ) {<br>  int res = str . charAt ( 0 ) - '0' ;<br>  for ( int i = 1 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ;<br>    else res *= ( str . charAt ( i ) - '0' ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String str ) {<br>    int res = ( int ) ( str . charAt ( 0 ) - 48 ) ;<br>    for ( int i = 1 ;  i < str . length ( ) ;  i ++ ) {<br>        if ( ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) && ( i < 5 ) ){<br>            res += ( char ) ( str . charAt ( i ++ ) - 48 ) ;<br>        }<br>        }<br>            res *= ( char ) ( str . charAt ( i ++ ) - 48 ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>CALCULATE_VOLUME_DODECAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double f_gold ( int side ) {<br>  return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGold ( int side ) {<br>    return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ;<br>}</td>
  </tr><tr>
    <th>CEILING_IN_A_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int low , int high , int x ) {<br>  int i ;<br>  if ( x <= arr [ low ] ) return low ;<br>  for ( i = low ;<br>  i < high ;<br>  i ++ ) {<br>    if ( arr [ i ] == x ) return i ;<br>    if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int low , int high , int x ) {<br>    if ( x <= arr [ low ] ) {<br>        return low ;<br>    }<br>    int i = low ;<br>    for ( int i = 0 ;  i < high ;  i ++ ) {<br>        if ( arr [ i ] == x ) {<br>            return i ;<br>        }<br>        if ( arr [ i ] < x && arr [ i + 1 ] >= x ) {<br>            return i ++ ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>CEILING_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int low , int high , int x ) {<br>  int mid ;<br>  if ( x <= arr [ low ] ) return low ;<br>  if ( x > arr [ high ] ) return - 1 ;<br>  mid = ( low + high ) / 2 ;<br>  if ( arr [ mid ] == x ) return mid ;<br>  else if ( arr [ mid ] < x ) {<br>    if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ;<br>    else return f_gold ( arr , mid + 1 , high , x ) ;<br>  }<br>  else {<br>    if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ;<br>    else return f_gold ( arr , low , mid - 1 , x ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int low , int high , int x ) {<br>    if ( x <= arr [ low ] ) {<br>        return low ;<br>    }<br>    if ( x > arr [ high ] ) {<br>        return - 1 ;<br>    }<br>    int mid = ( low + high ) / 2 ;<br>    if ( arr [ mid ] == x ) {<br>        return mid ;<br>    }<br>    else if ( arr [ mid ] < x ){<br>        if ( mid + 1 <= high && x <= arr [ mid + 1 ] ){<br>            return mid + 1 ;<br>        }<br>        else {<br>            return fGold ( arr , mid + 1 , high , x ) ;<br>        }<br>    }<br>    else {<br>        if ( mid - 1 >= low && x > arr [ mid - 1 ] ){<br>            return mid ;<br>        }<br>        else {<br>            return fGold ( arr , low , mid - 1 , x ) ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int mat [ ] [ ] , int n ) {<br>  int diag1_left = 0 , diag1_right = 0 ;<br>  int diag2_left = 0 , diag2_right = 0 ;<br>  for ( int i = 0 , j = n - 1 ;<br>  i < n ;<br>  i ++ , j -- ) {<br>    if ( i < n / 2 ) {<br>      diag1_left += mat [ i ] [ i ] ;<br>      diag2_left += mat [ j ] [ i ] ;<br>    }<br>    else if ( i > n / 2 ) {<br>      diag1_right += mat [ i ] [ i ] ;<br>      diag2_right += mat [ j ] [ i ] ;<br>    }<br>  }<br>  return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] [ ] mat , int n ) {<br>    diag1Left = 0 ;<br>    diag1Right = 0 ;<br>    diag2Left = 0 ;<br>    diag2Right = 0 ;<br>    int i = 0 ;<br>    int j = n - 1 ;<br>    while ( i < n ) {<br>        if ( ( i < n / 2 ) && ( i < n / 3 ) ){<br>            diag1Left += mat [ i ] [ i ] ;<br>            diag2Left += mat [ j ] [ i ] ;<br>        }<br>        if ( ( i > n / 2 ) && ( i < n / 2 ) ) {<br>            diag1Right += mat [ i ] [ i ] ;<br>            diag2Right += mat [ j ] [ i ] ;<br>        }<br>        i ++ ;<br>        j -- ;<br>    }<br>    return ( diag1Left == diag2Right && diag2Right == diag1Left && diag1Right == diag2Left && diag2Right == mat [ n / 2 ] [ n / 2 ] ) ;<br>}</td>
  </tr><tr>
    <th>CHANGE_BITS_CAN_MADE_ONE_FLIP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String str ) {<br>  int zeros = 0 , ones = 0 ;<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) {<br>    char ch = str . charAt ( i ) ;<br>    if ( ch == '0' ) ++ zeros ;<br>    else ++ ones ;<br>  }<br>  return ( zeros == 1 || ones == 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( String str ) {<br>    int zeros = 0 ;<br>    int ones = 0 ;<br>    for ( int i = 0 ;  i <= str . length ( ) ;  i ++ ) {<br>        char ch = str . charAt ( i ++ ) ;<br>        if ( ( ch == '0' ) || ( ch == '1' ) ) {<br>            zeros = zeros + 1 ;<br>        }<br>        }<br>            ones = ones + 1 ;<br>    }<br>    return ( zeros == 1 || ones == 1 ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_ARRAY_CONTAINS_CONTIGUOUS_INTEGERS_DUPLICATES_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n ) {<br>  int max = Integer . MIN_VALUE ;<br>  int min = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    max = Math . max ( max , arr [ i ] ) ;<br>    min = Math . min ( min , arr [ i ] ) ;<br>  }<br>  int m = max - min + 1 ;<br>  if ( m > n ) return false ;<br>  boolean visited [ ] = new boolean [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) visited [ arr [ i ] - min ] = true ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) if ( visited [ i ] == false ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int [ ] arr , int n ) {<br>    int max1 = Math . max ( arr ) ;<br>    int min1 = Math . min ( arr ) ;<br>    int m = max1 - min1 + 1 ;<br>    if ( ( m > n ) && ( m < n ) ) {<br>        return false ;<br>    }<br>    int visited [ ] = new int [ m ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        visited [ arr [ i ] - min1 ] = true ;<br>    }<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        if ( ( visited [ i ] == false ) && ( n > 0 ) ) {<br>            return false ;<br>        }<br>    }<br>    return fGold ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVERTING_ADJACENT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int [ ] a , int n ) {<br>  int count_odd = 0 , count_even = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ;<br>    else count_even ++ ;<br>  }<br>  if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ;<br>  else return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] a , int n ) {<br>    int countOdd = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( a [ i ] & 1 ) != 0 ) a [ i ] = 5 ;<br>            countOdd ++ ;<br>        if ( n > 0 ) {<br>            countEven ++ ;<br>        }<br>    }<br>    if ( ( countOdd % 2 && countEven % 2 ) != 0 ) {<br>        return false ;<br>    }<br>    if ( n > 0 ) {<br>        return true ;<br>    }<br>}</td>
  </tr><tr>
    <th>CHECK_IF_A_NUMBER_IS_JUMBLED_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int num ) {<br>  if ( num / 10 == 0 ) return true ;<br>  while ( num != 0 ) {<br>    if ( num / 10 == 0 ) return true ;<br>    int digit1 = num % 10 ;<br>    int digit2 = ( num / 10 ) % 10 ;<br>    if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ;<br>    num = num / 10 ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int num ) {<br>    if ( ( num / 10 == 0 ) && ( num % 10 == 0 ) ) {<br>        return fGold ( num , true ) ;<br>    }<br>    while ( ( num != 0 ) && ( num != 1 ) ) {<br>        if ( ( num / 10 == 0 ) && ( num % 10 == 0 ) ) {<br>            return fGold ( num , true ) ;<br>        }<br>        int digit1 = num % 10 ;<br>        int digit2 = ( num / 10 ) % 10 ;<br>        if ( ( Math . abs ( digit2 - digit1 ) > 1 ) && ( num > 0 ) ) {<br>            return false ;<br>        }<br>        num = num / 10 ;<br>    }<br>    return fGold ( num , true ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int notes [ ] , int n ) {<br>  int fiveCount = 0 ;<br>  int tenCount = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( notes [ i ] == 5 ) fiveCount ++ ;<br>    else if ( notes [ i ] == 10 ) {<br>      if ( fiveCount > 0 ) {<br>        fiveCount -- ;<br>        tenCount ++ ;<br>      }<br>      else return 0 ;<br>    }<br>    else {<br>      if ( fiveCount > 0 && tenCount > 0 ) {<br>        fiveCount -- ;<br>        tenCount -- ;<br>      }<br>      else if ( fiveCount >= 3 ) {<br>        fiveCount -= 3 ;<br>      }<br>      else return 0 ;<br>    }<br>  }<br>  return 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] notes , int n ) {<br>    fiveCount = 0 ;<br>    int tenCount = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( notes [ i ] == 5 ) && ( notes [ i + 1 ] == 5 ) ) {<br>            fiveCount ++ ;<br>        }<br>        else if ( ( notes [ i ] == 10 ) && ( notes [ i + 1 ] == 11 ) ) {<br>            if ( ( fiveCount > 0 ) && ( n > 0 ) ) {<br>                fiveCount -- ;<br>                tenCount ++ ;<br>            }<br>            else {<br>                return 0 ;<br>            }<br>        }<br>        else {<br>            if ( ( fiveCount > 0 && tenCount > 0 ) && ( n > 0 ) ) {<br>                fiveCount -- ;<br>                tenCount -- ;<br>            }<br>            }<br>                fiveCount -= 3 ;<br>            else {<br>                return 0 ;<br>            }<br>        }<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>CHECK_INTEGER_OVERFLOW_MULTIPLICATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static Boolean f_gold ( long a , long b ) {<br>  if ( a == 0 || b == 0 ) return false ;<br>  long result = a * b ;<br>  if ( a == result / b ) return false ;<br>  else return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( long a , long b ) {<br>    if ( ( a == 0 || b == 0 ) && ( a == 5 ) ) {<br>        return false ;<br>    }<br>    int result = a * b ;<br>    if ( ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) && ( a == b ) ) {<br>        int result = 0 ;<br>    }<br>    if ( ( a == ( result / b ) ) && ( b == ( result / a ) ) ) {<br>        System . out . println ( result / b ) ;<br>        return false ;<br>    }<br>    }<br>        return true ;<br>}</td>
  </tr><tr>
    <th>CHECK_LINE_PASSES_ORIGIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int x1 , int y1 , int x2 , int y2 ) {<br>  return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int x1 , int y1 , int x2 , int y2 ) {<br>    return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_POSSIBLE_SORT_ARRAY_CONDITIONAL_SWAPPING_ADJACENT_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) {<br>    if ( arr [ i ] > arr [ i + 1 ] ) {<br>      if ( arr [ i ] - arr [ i + 1 ] == 1 ) {<br>        int temp = arr [ i ] ;<br>        arr [ i ] = arr [ i + 1 ] ;<br>        arr [ i + 1 ] = temp ;<br>      }<br>      else return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i <= n - 1 ;  i ++ ) {<br>        if ( ( arr [ i ] > arr [ i + 1 ] ) && ( arr [ i + 1 ] < arr [ n ] ) ) {<br>            if ( ( arr [ i ] - arr [ i + 1 ] == 1 ) && ( arr [ i + 1 ] - arr [ n ] == 1 ) ) {<br>                arr [ i ] = arr [ i + 1 ] = arr [ i ] ;<br>            }<br>            if ( n > 0 ) {<br>                return false ;<br>            }<br>        }<br>    }<br>    return fGold ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String s1 , String s2 ) {<br>  int n = s1 . length ( ) ;<br>  int m = s2 . length ( ) ;<br>  boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= m ;<br>    j ++ ) {<br>      dp [ i ] [ j ] = false ;<br>    }<br>  }<br>  dp [ 0 ] [ 0 ] = true ;<br>  for ( int i = 0 ;<br>  i < s1 . length ( ) ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= s2 . length ( ) ;<br>    j ++ ) {<br>      if ( dp [ i ] [ j ] ) {<br>        if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ;<br>        if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ;<br>      }<br>    }<br>  }<br>  return ( dp [ n ] [ m ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( String s1 , String s2 ) {<br>    int n = s1 . length ( ) ;<br>    int m = s2 . length ( ) ;<br>    int [ ] dp = ( new boolean [ m + 1 ] ) [ 0 ] ;<br>    dp [ 0 ] [ 0 ] = true ;<br>    for ( int i = 0 ;  i < s1 . length ( ) ;  i ++ ) {<br>        for ( int j = 0 ;  j < s2 . length ( ) + 1 ;  j ++ ) {<br>            if ( ( dp [ i ] [ j ] ) != null ) {<br>                if ( ( ( j < s2 . length ( ) ) && ( s1 . charAt ( i ) . toUpperCase ( ) . equals ( s2 . charAt ( j ) ) ) ) || ( ( j < s1 . length ( ) ) && ( s2 . charAt ( j ) . toUpperCase ( ) . equals ( s1 . charAt ( i ) ) ) ) ) {<br>                    dp [ i + 1 ] [ j + 1 ] = true ;<br>                }<br>                if ( ( s1 [ i ] . isUpperCase ( ) == false ) && ( s2 [ i ] . isUpperCase ( ) == false ) ) {<br>                    dp [ i + 1 ] [ j ] = true ;<br>                }<br>            }<br>        }<br>    }<br>    return ( dp [ n ] [ m ] ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n ) {<br>  int temp [ ] = new int [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    temp [ i ] = arr [ i ] ;<br>  }<br>  Arrays . sort ( temp ) ;<br>  int front ;<br>  for ( front = 0 ;<br>  front < n ;<br>  front ++ ) {<br>    if ( temp [ front ] != arr [ front ] ) {<br>      break ;<br>    }<br>  }<br>  int back ;<br>  for ( back = n - 1 ;<br>  back >= 0 ;<br>  back -- ) {<br>    if ( temp [ back ] != arr [ back ] ) {<br>      break ;<br>    }<br>  }<br>  if ( front >= back ) {<br>    return true ;<br>  }<br>  do {<br>    front ++ ;<br>    if ( arr [ front - 1 ] < arr [ front ] ) {<br>      return false ;<br>    }<br>  }<br>  while ( front != back ) ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int [ ] arr , int n ) {<br>    int [ ] temp = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        temp [ i ] = arr [ i ] ;<br>    }<br>    temp . sort ( ) ;<br>    for ( int front = 0 ;  front < n ;  front ++ ) {<br>        if ( temp [ front ] != arr [ front ] ){<br>            break ;<br>        }<br>    }<br>    for ( int back = n - 1 ;  back >= 0 ;  back -- ) {<br>        if ( temp [ back ] != arr [ back ] ){<br>            break ;<br>        }<br>    }<br>    if ( front >= back ){<br>        return fGold ( arr , 0 , n ) ;<br>    }<br>    while ( front != back ) {<br>        front ++ ;<br>        if ( arr [ front - 1 ] < arr [ front ] ) {<br>            return false ;<br>        }<br>    }<br>    return fGold ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n ) {<br>  if ( n == 1 ) {<br>    return true ;<br>  }<br>  int i ;<br>  for ( i = 1 ;<br>  arr [ i - 1 ] < arr [ i ] && i < n ;<br>  i ++ ) ;<br>  if ( i == n ) {<br>    return true ;<br>  }<br>  int j = i ++ ;<br>  while ( arr [ j ] < arr [ j - 1 ] ) {<br>    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {<br>      return false ;<br>    }<br>    j ++ ;<br>  }<br>  if ( j == n ) {<br>    return true ;<br>  }<br>  int k = j ;<br>  if ( arr [ k ] < arr [ i - 1 ] ) {<br>    return false ;<br>  }<br>  while ( k > 1 && k < n ) {<br>    if ( arr [ k ] < arr [ k - 1 ] ) {<br>      return false ;<br>    }<br>    k ++ ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] arr , int n ) {<br>    if ( ( n == 1 ) && ( arr [ 0 ] == 1 ) ) {<br>        return fGold ( arr , 0 , n ) ;<br>    }<br>    int i = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        if ( arr [ i - 1 ] < arr [ i ] ) {<br>            if ( ( i == n ) && ( i == arr . length ) ) {<br>                return fGold ( arr , 0 , n ) ;<br>            }<br>        }<br>    }<br>    int j = i ;<br>    while ( ( arr [ j ] < arr [ j - 1 ] ) && ( arr [ j ] > arr [ j - 1 ] ) ) {<br>        if ( ( i > 1 && arr [ j ] < arr [ i - 2 ] ) || ( i > 2 && arr [ j ] > arr [ i - 1 ] ) ){<br>            return false ;<br>        }<br>        j ++ ;<br>    }<br>    if ( ( j == n ) && ( j != 0 ) ) {<br>        return fGold ( arr , 0 , n ) ;<br>    }<br>    int k = j ;<br>    if ( ( arr [ k ] < arr [ i - 1 ] ) && ( arr [ i - 1 ] > arr [ k ] ) ) {<br>        return false ;<br>    }<br>    while ( ( k > 1 && k < n ) || ( k < n ) ) {<br>        if ( ( arr [ k ] < arr [ k - 1 ] ) && ( arr [ k ] > arr [ n - 1 ] ) ) {<br>            return false ;<br>        }<br>        k ++ ;<br>    }<br>    return fGold ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_VALID_SEQUENCE_DIVISIBLE_M_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) {<br>  modulo = ( ( modulo % M ) + M ) % M ;<br>  if ( index == n ) {<br>    if ( modulo == 0 ) {<br>      return 1 ;<br>    }<br>    return 0 ;<br>  }<br>  if ( dp [ index ] [ modulo ] != - 1 ) {<br>    return dp [ index ] [ modulo ] ;<br>  }<br>  int placeAdd = f_gold ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ;<br>  int placeMinus = f_gold ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ;<br>  int res = placeAdd ;<br>  dp [ index ] [ modulo ] = res ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int n , int index , int modulo , int M , int [ ] arr , int [ ] [ ] dp ) {<br>    modulo = ( ( modulo % M ) + M ) % M ;<br>    if ( ( index == n ) && ( modulo == M ) ) {<br>        if ( ( modulo == 0 ) && ( index == 0 ) ) {<br>            return 1 ;<br>        }<br>        return 0 ;<br>    }<br>    if ( ( dp [ index ] [ modulo ] != - 1 ) && ( dp [ index ] [ modulo ] != 0 ) ){<br>        return dp [ index ] [ modulo ] ;<br>    }<br>    int placeAdd = f_gold ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ;<br>    int placeMinus = fGold ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ;<br>    boolean res = Boolean . valueOf ( placeAdd || placeMinus ) . booleanValue ( ) ;<br>    dp [ index ] [ modulo ] = res ;<br>    return res ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static boolean f_gold ( int n ) {<br>  if ( ( n & 1 ) == 0 ) return true ;<br>  else return false ;<br>}<br></td>
    <td>translated code: <br><br> static boolean f_gold ( int n ) {<br>    return ( ! ( n & 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>CHECK_WHETHER_TWO_STRINGS_ARE_ANAGRAM_OF_EACH_OTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( char [ ] str1 , char [ ] str2 ) {<br>  int n1 = str1 . length ;<br>  int n2 = str2 . length ;<br>  if ( n1 != n2 ) return false ;<br>  Arrays . sort ( str1 ) ;<br>  Arrays . sort ( str2 ) ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( String str1 , String str2 ) {<br>    int n1 = str1 . length ( ) ;<br>    int n2 = str2 . length ( ) ;<br>    if ( n1 != n2 ) {<br>        return 0 ;<br>    }<br>    str1 = new TreeSet < > ( str1 ) ;<br>    str2 = Collections . singletonList ( str2 ) ;<br>    for ( int i = 0 ;  i <= n1 ;  i ++ ) {<br>        if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) {<br>            return 0 ;<br>        }<br>    }<br>    return 1 ;<br>}</td>
  </tr><tr>
    <th>CHOCOLATE_DISTRIBUTION_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int m ) {<br>  if ( m == 0 || n == 0 ) return 0 ;<br>  Arrays . sort ( arr ) ;<br>  if ( n < m ) return - 1 ;<br>  int min_diff = Integer . MAX_VALUE ;<br>  int first = 0 , last = 0 ;<br>  for ( int i = 0 ;<br>  i + m - 1 < n ;<br>  i ++ ) {<br>    int diff = arr [ i + m - 1 ] - arr [ i ] ;<br>    if ( diff < min_diff ) {<br>      min_diff = diff ;<br>      first = i ;<br>      last = i + m - 1 ;<br>    }<br>  }<br>  return ( arr [ last ] - arr [ first ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int m ) {<br>    if ( ( m == 0 || n == 0 ) && ( arr != null ) ) {<br>        return 0 ;<br>    }<br>    Arrays . sort ( arr ) ;<br>    if ( ( n < m ) && ( n > 0 ) ) {<br>        return - 1 ;<br>    }<br>    int minDiff = Integer . MAX_VALUE ;<br>    int first = 0 ;<br>    int last = 0 ;<br>    int i = 0 ;<br>    while ( ( i + m - 1 < n ) && ( i + m - 1 < n ) ) {<br>        int diff = arr [ i + m - 1 ] - arr [ i ] ;<br>        if ( ( diff < minDiff ) && ( diff > minDiff ) ){<br>            int minDiff = diff ;<br>            int first = i ;<br>            int last = i + m - 1 ;<br>        }<br>        i ++ ;<br>    }<br>    return ( arr [ last ] - arr [ first ] ) ;<br>}</td>
  </tr><tr>
    <th>CIRCLE_LATTICE_POINTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int r ) {<br>  if ( r <= 0 ) return 0 ;<br>  int result = 4 ;<br>  for ( int x = 1 ;<br>  x < r ;<br>  x ++ ) {<br>    int ySquare = r * r - x * x ;<br>    int y = ( int ) Math . sqrt ( ySquare ) ;<br>    if ( y * y == ySquare ) result += 4 ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int r ) {<br>    if ( ( r <= 0 ) && ( r > 0 ) ) {<br>        return 0 ;<br>    }<br>    int result = 4 ;<br>    for ( int x = 1 ;  x < r ;  x ++ ) {<br>        ySquare = r * r - x * x ;<br>        int y = ( int ) Math . sqrt ( ySquare ) ;<br>        if ( ( y * y == ySquare ) && ( r == 0 ) ) {<br>            result += 4 ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COMPOSITE_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int n ) {<br>  if ( n <= 1 ) System . out . println ( "False" ) ;<br>  if ( n <= 3 ) System . out . println ( "False" ) ;<br>  if ( n % 2 == 0 || n % 3 == 0 ) return true ;<br>  for ( int i = 5 ;<br>  i * i <= n ;<br>  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int n ) {<br>    if ( ( n <= 1 ) && ( n > 2 ) ) {<br>        return false ;<br>    }<br>    if ( ( n <= 3 ) && ( n > 0 ) ) {<br>        return false ;<br>    }<br>    if ( ( n % 2 == 0 || n % 3 == 0 ) && ( n % 4 == 0 ) ) {<br>        return fGoldenNum ( n , true ) ;<br>    }<br>    int i = 5 ;<br>    while ( ( i * i <= n ) && ( i * i <= n ) ){<br>        if ( ( n % i == 0 || n % ( i + 2 ) == 0 ) && ( n % i == 0 || n % i == 0 ) ) {<br>            return fGoldenNum ( n , true ) ;<br>        }<br>        i = i + 6 ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLUTION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int r , int p ) {<br>  int C [ ] = new int [ r + 1 ] ;<br>  Arrays . fill ( C , 0 ) ;<br>  C [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = Math . min ( i , r ) ;<br>    j > 0 ;<br>    j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;<br>  }<br>  return C [ r ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n , int r , int p ) {<br>    int [ ] C = new int [ r + 1 ] ;<br>    C [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = Math . min ( i , r ) ;  j > 0 ;  j -- ) {<br>            C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;<br>        }<br>    }<br>    return C [ r ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n , int k , int x ) {<br>  int [ ] dp = new int [ 109 ] ;<br>  dp [ 0 ] = 0 ;<br>  dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ;<br>  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n , int k , int x ) {<br>    List < Integer > dp = Lists . newArrayList ( ) ;<br>    dp . add ( 0 ) ;<br>    dp . add ( 1 ) ;<br>    int i = 2 ;<br>    while ( i < n ){<br>        dp . add ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ;<br>        i = i + 1 ;<br>    }<br>    return ( ( k - 1 ) * dp [ n - 2 ] == 1 ? 1 : dp [ n - 1 ] ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_DIGITS_FACTORIAL_SET_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n < 0 ) return 0 ;<br>  if ( n <= 1 ) return 1 ;<br>  double digits = 0 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) digits += Math . log10 ( i ) ;<br>  return ( int ) ( Math . floor ( digits ) ) + 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    if ( ( n < 0 ) && ( n > 1 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n <= 1 ) && ( n > 2 ) ) {<br>        return 1 ;<br>    }<br>    int digits = 0 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        digits += Math . log10 ( i ) ;<br>    }<br>    return Math . floor ( digits + 1 ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int x ) {<br>  int f_gold = 0 ;<br>  for ( int i = 1 ;<br>  i <= n && i <= x ;<br>  i ++ ) {<br>    if ( x / i <= n && x % i == 0 ) f_gold ++ ;<br>  }<br>  return f_gold ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n , int x ) {<br>    int cnt = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( i <= x ){<br>            if ( x / i <= n && x % i == 0 ){<br>                cnt ++ ;<br>            }<br>        }<br>    }<br>    return cnt ;<br>}</td>
  </tr><tr>
    <th>COUNT_FACTORIAL_NUMBERS_IN_A_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int low , int high ) {<br>  int fact = 1 , x = 1 ;<br>  while ( fact < low ) {<br>    fact = fact * x ;<br>    x ++ ;<br>  }<br>  int res = 0 ;<br>  while ( fact <= high ) {<br>    res ++ ;<br>    fact = fact * x ;<br>    x ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int low , int high ) {<br>    int fact = 1 ;<br>    int x = 1 ;<br>    while ( ( fact < low ) && ( fact > high ) ) {<br>        fact = fact * x ;<br>        x ++ ;<br>    }<br>    int res = 0 ;<br>    while ( ( fact <= high ) && ( fact > low ) ) {<br>        res ++ ;<br>        fact = fact * x ;<br>        x ++ ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n , int k ) {<br>  if ( n + 1 >= k ) return ( k - 1 ) ;<br>  else return ( 2 * n + 1 - k ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n , int k ) {<br>    if ( ( n + 1 >= k ) && ( n + 1 >= k ) ) {<br>        return ( k - 1 ) ;<br>    }<br>    }<br>        return ( 2 * n + 1 - k ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( arr [ i ] == arr [ j ] ) && ( arr [ i ] == arr [ j ] ) ) {<br>                ans ++ ;<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_SOLUTIONS_OF_X2_1_MOD_P_IN_GIVEN_RANGE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int p ) {<br>  int ans = 0 ;<br>  for ( int x = 1 ;<br>  x < p ;<br>  x ++ ) {<br>    if ( ( x * x ) % p == 1 ) {<br>      int last = x + p * ( n / p ) ;<br>      if ( last > n ) last -= p ;<br>      ans += ( ( last - x ) / p + 1 ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n , int p ) {<br>    int ans = 0 ;<br>    for ( int x = 1 ;  x < p ;  x ++ ) {<br>        if ( ( ( x * x ) % p == 1 ) && ( ( x * x ) % p == 0 ) ) {<br>            last = x + p * ( n / p ) ;<br>            if ( ( last > n ) && ( last < p ) ){<br>                last -= p ;<br>            }<br>            ans += ( ( last - x ) / p + 1 ) ;<br>        }<br>    }<br>    return ( int ) ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_COVER_A_DISTANCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int dist ) {<br>  int [ ] count = new int [ dist + 1 ] ;<br>  count [ 0 ] = 1 ;<br>  count [ 1 ] = 1 ;<br>  count [ 2 ] = 2 ;<br>  for ( int i = 3 ;<br>  i <= dist ;<br>  i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ;<br>  return count [ dist ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int dist ) {<br>    int [ ] count = new int [ dist + 1 ] ;<br>    count [ 0 ] = 1 ;<br>    count [ 1 ] = 1 ;<br>    count [ 2 ] = 2 ;<br>    for ( int i = 3 ;  i <= dist ;  i ++ ) {<br>        count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) ;<br>    }<br>    return count [ dist ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_NUMBER_OF_WAYS_TO_FILL_A_N_X_4_GRID_USING_1_X_4_TILES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int [ ] dp = new int [ n + 1 ] ;<br>  dp [ 0 ] = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ;<br>    else if ( i == 4 ) dp [ i ] = 2 ;<br>    else {<br>      dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ;<br>    }<br>  }<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( i <= 3 ){<br>            dp [ i ] = 1 ;<br>        }<br>        }<br>            dp [ i ] = 2 ;<br>        }<br>            dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ;<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_OF_OCCURRENCES_OF_A_101_PATTERN_IN_A_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String str ) {<br>  int len = str . length ( ) ;<br>  boolean oneSeen = false ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < len ;<br>  i ++ ) {<br>    char getChar = str . charAt ( i ) ;<br>    if ( getChar == '1' && oneSeen == true ) {<br>      if ( str . charAt ( i - 1 ) == '0' ) count ++ ;<br>    }<br>    if ( getChar == '1' && oneSeen == false ) oneSeen = true ;<br>    if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int length = s . length ( ) ;<br>    oneSeen = false ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < length ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == '1' && oneSeen ) || ( s . charAt ( i ) == '0' && oneSeen ) ) {<br>            if ( ( s . charAt ( i - 1 ) == '0' ) && ( s . charAt ( i - 2 ) == '0' ) ) {<br>                count ++ ;<br>            }<br>        }<br>        if ( ( s . charAt ( i ) == '1' && oneSeen == 0 ) || ( s . charAt ( i ) == '0' && oneSeen == 1 ) ) {<br>            oneSeen = true ;<br>        }<br>        if ( ( s . charAt ( i ) != '0' && s . charAt ( i ) != '1' ) || ( s . charAt ( i ) != '0' && s . charAt ( i ) != '1' ) ) {<br>            oneSeen = false ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_DIFFERENCE_EQUAL_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int k ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n , int k ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) {<br>                count ++ ;<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < m ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( arr1 [ i ] + arr2 [ j ] == x ) {<br>                count = count + 1 ;<br>            }<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String str ) {<br>  int N = str . length ( ) ;<br>  int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) cps [ i ] [ i ] = 1 ;<br>  for ( int L = 2 ;<br>  L <= N ;<br>  L ++ ) {<br>    for ( int i = 0 ;<br>    i < N ;<br>    i ++ ) {<br>      int k = L + i - 1 ;<br>      if ( k < N ) {<br>        if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ;<br>        else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ;<br>      }<br>    }<br>  }<br>  return cps [ 0 ] [ N - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String str ) {<br>    int N = str . length ( ) ;<br>    int [ ] [ ] cps = new int [ N + 2 ] [ N + 2 ] ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        cps [ i ] [ i ] = 1 ;<br>    }<br>    for ( int L = 2 ;  L <= N ;  L ++ ) {<br>        for ( int i = 0 ;  i < N ;  i ++ ) {<br>            int k = L + i - 1 ;<br>            if ( ( k < N ) && ( k > 0 ) ){<br>                if ( ( str . charAt ( i ) == str . charAt ( k ) ) && ( str . charAt ( j ) == str . charAt ( k ) ) ) {<br>                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) ;<br>                }<br>                }<br>                    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) ;<br>            }<br>        }<br>    }<br>    return cps [ 0 ] [ N - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int m , int n ) {<br>  int [ ] dp = new int [ n ] ;<br>  dp [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j < n ;<br>    j ++ ) {<br>      dp [ j ] += dp [ j - 1 ] ;<br>    }<br>  }<br>  return dp [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int p , int q ) {<br>    int [ ] dp = new int [ q ] ;<br>    for ( int i = 0 ;  i < p - 1 ;  i ++ ) {<br>        for ( int j = 1 ;  j < q ;  j ++ ) {<br>            dp [ j ] += dp [ j - 1 ] ;<br>        }<br>    }<br>    return dp [ q - 1 ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int count = 0 ;<br>  while ( n > 0 ) {<br>    n &= ( n - 1 ) ;<br>    count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int count = 0 ;<br>    while ( ( n -- ) > 0 ) {<br>        n &= ( n - 1 ) ;<br>        count ++ ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_SET_BITS_IN_AN_INTEGER_3</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n ) {<br>  if ( n == 0 ) return 0 ;<br>  else return 1 + f_gold ( n & ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    if ( ( n == 0 ) && ( n == 1 ) ) {<br>        return 0 ;<br>    }<br>    }<br>        return 1 + f_gold ( n & ( n - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_SORTED_ROWS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int mat [ ] [ ] , int r , int c ) {<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < r ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = 0 ;<br>    j < c - 1 ;<br>    j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ;<br>    if ( j == c - 1 ) result ++ ;<br>  }<br>  for ( int i = 0 ;<br>  i < r ;<br>  i ++ ) {<br>    int j ;<br>    for ( j = c - 1 ;<br>    j > 0 ;<br>    j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ;<br>    if ( c > 1 && j == 0 ) result ++ ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] mat , int r , int c ) {<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < r ;  i ++ ) {<br>        int j = 0 ;<br>        for ( int j = 0 ;  j < c - 1 ;  j ++ ) {<br>            if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ){<br>                break ;<br>            }<br>        }<br>        if ( j == c - 2 ){<br>            result ++ ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= r ;  i ++ ) {<br>        int j = 0 ;<br>        for ( int j = c - 1 ;  j > 0 ;  j -- ) {<br>            if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ){<br>                break ;<br>            }<br>        }<br>        if ( c > 1 && j == 1 ){<br>            result ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  Map < Integer , Integer > um = new HashMap < > ( ) ;<br>  int curr_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ;<br>    um . put ( curr_sum , um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 ) ;<br>  }<br>  int count = 0 ;<br>  for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) {<br>    if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ;<br>  }<br>  if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > um = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    int currSum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        currSum += ( - 1 == ( arr [ i ] == 0 ) ? 0 : arr [ i ] ) ;<br>        if ( um . get ( currSum ) ) {<br>            um [ currSum ] ++ ;<br>        }<br>        if ( n > 0 ) {<br>            um [ currSum ++ ] = 1 ;<br>        }<br>    }<br>    int count = 0 ;<br>    for ( Iterator itr = um . iterator ( ) ;  itr . hasNext ( ) ;  ) {<br>        if ( um [ itr ] > 1 ){<br>            count += ( ( um [ itr ] * ( int ) ( um [ itr ] - 1 ) ) / 2 ) ;<br>        }<br>    }<br>    if ( um . get ( 0 ) ) {<br>        count += um [ 0 ] ;<br>    }<br>    return ( int ) count ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_EQUAL_NUMBER_1S_0S_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  Map < Integer , Integer > myMap = new HashMap < > ( ) ;<br>  int sum = 0 ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == 0 ) arr [ i ] = - 1 ;<br>    sum += arr [ i ] ;<br>    if ( sum == 0 ) count ++ ;<br>    if ( myMap . containsKey ( sum ) ) count += myMap . get ( sum ) ;<br>    if ( ! myMap . containsKey ( sum ) ) myMap . put ( sum , 1 ) ;<br>    else myMap . put ( sum , myMap . get ( sum ) + 1 ) ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > mp = Collections . emptyMap ( ) ;<br>    int Sum = 0 ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] == 0 ) && ( n > 0 ) ) {<br>            arr [ i ] = - 1 ;<br>        }<br>        Sum += arr [ i ] ;<br>        if ( ( Sum == 0 ) && ( n > 0 ) ) {<br>            count ++ ;<br>        }<br>        if ( ( Sum . class . equals ( mp . getClass ( ) ) ) && ( n > 0 ) ) {<br>            count += mp [ Sum ] ;<br>        }<br>        mp [ Sum . class . getName ( ) ] = mp . get ( Sum . class . getName ( ) ) + 1 ;<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_TOTAL_DISTINCT_ELEMENTS_ORIGINAL_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > vis = new HashMap < Integer , Integer > ( ) {<br>    @ Override public Integer get ( Object key ) {<br>      if ( ! containsKey ( key ) ) return 0 ;<br>      return super . get ( key ) ;<br>    }<br>  };<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) vis . put ( arr [ i ] , 1 ) ;<br>  int k = vis . size ( ) ;<br>  vis . clear ( ) ;<br>  int ans = 0 , right = 0 , window = 0 ;<br>  for ( int left = 0 ;<br>  left < n ;<br>  ++ left ) {<br>    while ( right < n && window < k ) {<br>      vis . put ( arr [ right ] , vis . get ( arr [ right ] ) + 1 ) ;<br>      if ( vis . get ( arr [ right ] ) == 1 ) ++ window ;<br>      ++ right ;<br>    }<br>    if ( window == k ) ans += ( n - right + 1 ) ;<br>    vis . put ( arr [ left ] , vis . get ( arr [ left ] ) - 1 ) ;<br>    if ( vis . get ( arr [ left ] ) == 0 ) -- window ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > vis = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        vis [ arr [ i ] ] = 1 ;<br>    }<br>    int k = vis . length ;<br>    Map < Integer , Integer > vid = new HashMap < Integer , Integer > ( ) ;<br>    int ans = 0 ;<br>    int right = 0 ;<br>    int window = 0 ;<br>    for ( int left = 0 ;  left < n ;  left ++ ) {<br>        while ( ( right < n && window < k ) || ( left < n && window < k ) ) {<br>            if ( arr [ right ] == vid . keySet ( ) ){<br>                vid [ arr [ right ] ] ++ ;<br>            }<br>            if ( n > 0 ) {<br>                vid [ arr [ right ] ] = 1 ;<br>            }<br>            if ( ( vid [ arr [ right ] ] == 1 ) && ( n == 1 ) ) {<br>                window ++ ;<br>            }<br>            right ++ ;<br>        }<br>        if ( ( window == k ) && ( n > 0 ) ){<br>            ans += ( n - right + 1 ) ;<br>        }<br>        vid [ arr [ left ] ] -- ;<br>        if ( ( vid [ arr [ left ] ] == 0 ) && ( n == 0 ) ) {<br>            window -- ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  int difference = 0 ;<br>  int ans = 0 ;<br>  int [ ] hash_positive = new int [ n + 1 ] ;<br>  int [ ] hash_negative = new int [ n + 1 ] ;<br>  hash_positive [ 0 ] = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( arr [ i ] & 1 ) == 1 ) {<br>      difference ++ ;<br>    }<br>    else {<br>      difference -- ;<br>    }<br>    if ( difference < 0 ) {<br>      ans += hash_negative [ - difference ] ;<br>      hash_negative [ - difference ] ++ ;<br>    }<br>    else {<br>      ans += hash_positive [ difference ] ;<br>      hash_positive [ difference ] ++ ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int difference = 0 ;<br>    int ans = 0 ;<br>    int [ ] hashPositive = new int [ n + 1 ] ;<br>    int [ ] hashNegative = new int [ n + 1 ] ;<br>    hash_positive [ 0 ] = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( arr [ i ] & 1 == 1 ) != 0 ) {<br>            difference = difference + 1 ;<br>        }<br>        if ( n > 0 ) {<br>            int difference = difference - 1 ;<br>        }<br>        if ( ( difference < 0 ) && ( n > 0 ) ) {<br>            ans += hashNegative [ - difference ] ;<br>            hash_negative [ - difference ] = hash_negative [ - difference ] + 1 ;<br>        }<br>        if ( n > 0 ) {<br>            ans += hashPositive [ difference ] ;<br>            hashPositive [ difference ] = hashPositive [ difference ] + 1 ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s ) {<br>  int result = 0 ;<br>  int n = s . length ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i ;<br>  j < n ;<br>  j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int result = 0 ;<br>    int n = s . length ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            if ( ( s [ i ] . equals ( s [ j ] ) ) && ( s [ i ] . equals ( s [ j ] ) ) ) {<br>                result = result + 1 ;<br>            }<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>COUNT_SUM_OF_DIGITS_IN_NUMBERS_FROM_1_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ;<br>  int d = ( int ) ( Math . log10 ( n ) ) ;<br>  int a [ ] = new int [ d + 1 ] ;<br>  a [ 0 ] = 0 ;<br>  a [ 1 ] = 45 ;<br>  for ( int i = 2 ;<br>  i <= d ;<br>  i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ;<br>  int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ;<br>  int msd = n / p ;<br>  return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + f_gold ( n % p ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    if ( ( n < 10 ) && ( n > 0 ) ) {<br>        return ( n * ( n + 1 ) / 2 ) ;<br>    }<br>    int d = ( int ) ( Math . log10 ( n ) ) ;<br>    int [ ] a = new int [ d + 1 ] ;<br>    a [ 0 ] = 0 ;<br>    a [ 1 ] = 45 ;<br>    for ( int i = 2 ;  i <= d ;  i ++ ) {<br>        a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ;<br>    }<br>    int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ;<br>    int msd = n / p ;<br>    return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + f_gold ( n % p ) ) ;<br>}</td>
  </tr><tr>
    <th>COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int A ) {<br>  int n = 2 * A ;<br>  int [ ] dpArray = new int [ n + 1 ] ;<br>  dpArray [ 0 ] = 1 ;<br>  dpArray [ 2 ] = 1 ;<br>  for ( int i = 4 ;<br>  i <= n ;<br>  i += 2 ) {<br>    for ( int j = 0 ;<br>    j < i - 1 ;<br>    j += 2 ) {<br>      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ;<br>    }<br>  }<br>  return dpArray [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int A ) {<br>    int n = 2 * A ;<br>    int [ ] dpArray = new int [ n + 1 ] ;<br>    dpArray [ 0 ] = 1 ;<br>    dpArray [ 2 ] = 1 ;<br>    for ( int i = 4 ;  i < n + 1 ;  i += 2 ) {<br>        for ( int j = 0 ;  j <= i - 1 ;  j += 2 ) {<br>            dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ;<br>        }<br>    }<br>    return ( int ) dpArray [ n ] ;<br>}</td>
  </tr><tr>
    <th>COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String str [ ] , int n ) {<br>  HashMap < String , Integer > m = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( m . containsKey ( str [ i ] ) ) {<br>      int get = m . get ( str [ i ] ) ;<br>      m . put ( str [ i ] , get + 1 ) ;<br>    }<br>    else {<br>      m . put ( str [ i ] , 1 ) ;<br>    }<br>  }<br>  int res = 0 ;<br>  for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) {<br>    if ( it . getValue ( ) == 2 ) res ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String stri , int n ) {<br>    Map < String , String > m = Collections . < String , String > emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        m . put ( stri [ i ] , m . get ( stri [ i ] ) + 1 ) ;<br>    }<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < m . values ( ) . length ;  i ++ ) {<br>        if ( i == 2 ){<br>            res ++ ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int res = 1 , i ;<br>  for ( i = 2 ;<br>  i <= n ;<br>  i ++ ) res *= i ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? 0 : n * fGold ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FACTORIAL_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return ( n == 1 || n == 0 ) ? 1 : n * f_gold ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? 0 : n * fGold ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  return arr [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    return Math . max ( arr . length , n ) ;<br>}</td>
  </tr><tr>
    <th>DECODE_MEDIAN_STRING_ORIGINAL_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String f_gold ( String s ) {<br>  int l = s . length ( ) ;<br>  String s1 = "" ;<br>  boolean isEven = ( l % 2 == 0 ) ? true : false ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i += 2 ) {<br>    if ( isEven ) {<br>      s1 = s . charAt ( i ) + s1 ;<br>      s1 += s . charAt ( i + 1 ) ;<br>    }<br>    else {<br>      if ( l - i > 1 ) {<br>        s1 += s . charAt ( i ) ;<br>        s1 = s . charAt ( i + 1 ) + s1 ;<br>      }<br>      else {<br>        s1 += s . charAt ( i ) ;<br>      }<br>    }<br>  }<br>  return s1 ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String s ) {<br>    int l = s . length ( ) ;<br>    String s1 = "" ;<br>    if ( ( l % 2 == 0 ) && ( l % 3 == 0 ) ){<br>        isEven = true ;<br>    }<br>    }<br>        isEven = false ;<br>    for ( int i = 0 ;  i < l ;  i += 2 ) {<br>        if ( ( isEven ) && ( s . length ( ) > 0 ) ) {<br>            String s1 = s [ i ] + s1 ;<br>            s1 += s . charAt ( i + 1 ) ;<br>        }<br>        }<br>            if ( ( l - i > 1 ) && ( l - i > 0 ) ){<br>                s1 += s . charAt ( i ) ;<br>                String s1 = s . charAt ( i + 1 ) + s1 ;<br>            }<br>            }<br>                s1 += s . charAt ( i ) ;<br>    }<br>    return s1 ;<br>}</td>
  </tr><tr>
    <th>DIAGONALLY_DOMINANT_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int m [ ] [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int sum = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ;<br>    sum -= Math . abs ( m [ i ] [ i ] ) ;<br>    if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] [ ] m , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int sum = 0 ;<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            sum = sum + Math . abs ( m [ i ] [ j ] ) ;<br>        }<br>        sum = sum - Math . abs ( m [ i ] [ i ] ) ;<br>        if ( ( Math . abs ( m [ i ] [ i ] ) < sum ) && ( Math . abs ( m [ i ] [ i ] ) > sum ) ) {<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>DICE_THROW_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long f_gold ( int m , int n , int x ) {<br>  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ;<br>  for ( int j = 1 ;<br>  j <= m && j <= x ;<br>  j ++ ) table [ 1 ] [ j ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= x ;<br>    j ++ ) {<br>      for ( int k = 1 ;<br>      k < j && k <= m ;<br>      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;<br>    }<br>  }<br>  return table [ n ] [ x ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int m , int n , int x ) {<br>    int [ ] [ ] table = new int [ n + 1 ] [ m + 1 ] ;<br>    for ( int j = 1 ;  j <= Math . min ( m + 1 , x + 1 ) ;  j ++ ) {<br>        table [ 1 ] [ j ] = 1 ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= x ;  j ++ ) {<br>            for ( int k = 1 ;  k < Math . min ( m + 1 , j ) ;  k ++ ) {<br>                table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;<br>            }<br>        }<br>    }<br>    return table [ table . length - 1 ] [ table . length - 1 ] ;<br>}</td>
  </tr><tr>
    <th>DICE_THROW_PROBLEM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static long f_gold ( int f , int d , int s ) {<br>  long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ;<br>  mem [ 0 ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= d ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j <= s ;<br>    j ++ ) {<br>      mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ;<br>      if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ;<br>    }<br>  }<br>  return mem [ d ] [ s ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int f , int d , int s ) {<br>    int [ ] mem = new int [ s + 1 ] ;<br>    mem [ 0 ] [ 0 ] = 1 ;<br>    for ( int i = 1 ;  i <= d ;  i ++ ) {<br>        for ( int j = 1 ;  j <= s ;  j ++ ) {<br>            mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ;<br>            if ( j - f - 1 >= 0 ){<br>                mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ;<br>            }<br>        }<br>    }<br>    return mem [ d ] [ s ] ;<br>}</td>
  </tr><tr>
    <th>DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int count = 0 , max_count = 0 , min_count = n ;<br>  for ( int i = 0 ;<br>  i < ( n - 1 ) ;<br>  i ++ ) {<br>    if ( arr [ i ] == arr [ i + 1 ] ) {<br>      count += 1 ;<br>      continue ;<br>    }<br>    else {<br>      max_count = Math . max ( max_count , count ) ;<br>      min_count = Math . min ( min_count , count ) ;<br>      count = 0 ;<br>    }<br>  }<br>  return ( max_count - min_count ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    Arrays . sort ( arr ) ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= ( n - 1 ) ;  i ++ ) {<br>        if ( arr [ i ] == arr [ i + 1 ] ) {<br>            count ++ ;<br>            continue ;<br>        }<br>        if ( n > 0 ) {<br>            maxCount = Math . max ( maxCount , count ) ;<br>            minCount = Math . min ( minCount , count ) ;<br>            int count = 0 ;<br>        }<br>    }<br>    return maxCount - minCount ;<br>}</td>
  </tr><tr>
    <th>DOUBLE_FACTORIAL_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int res = 1 ;<br>  for ( int i = n ;<br>  i >= 0 ;<br>  i = i - 2 ) {<br>    if ( i == 0 || i == 1 ) return res ;<br>    else res *= i ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int res = 1 ;<br>    for ( int i = n ;  i >= 0 ;  i -- ) {<br>        if ( ( i == 0 || i == 1 ) && ( n == 0 || n == 1 ) ) {<br>            return res ;<br>        }<br>        }<br>            res *= i ;<br>    }<br>}</td>
  </tr><tr>
    <th>DYCK_PATH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n ) {<br>  int res = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    res *= ( 2 * n - i ) ;<br>    res /= ( i + 1 ) ;<br>  }<br>  return res / ( n + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenN ( int n ) {<br>    int res = 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        res *= ( 2 * n - i ) ;<br>        res /= ( i + 1 ) ;<br>    }<br>    return res / ( n + 1 ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int high [ ] , int low [ ] , int n ) {<br>  if ( n <= 0 ) return 0 ;<br>  return Math . max ( high [ n - 1 ] + f_gold ( high , low , ( n - 2 ) ) , low [ n - 1 ] + f_gold ( high , low , ( n - 1 ) ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] high , int [ ] low , int n ) {<br>    if ( ( n <= 0 ) && ( high > low ) ) {<br>        return 0 ;<br>    }<br>    return Math . max ( high [ n - 1 ] + fGold ( high , low , ( n - 2 ) ) , low [ n - 1 ] + fGold ( high , low , ( n - 1 ) ) ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int i , j , max = 0 ;<br>  int msis [ ] = new int [ n ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) msis [ i ] = arr [ i ] ;<br>  for ( i = 1 ;<br>  i < n ;<br>  i ++ ) for ( j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int max = 0 ;<br>    int [ ] msis = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        msis [ i ] = arr [ i ] ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) || ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) ) {<br>                msis [ i ] = msis [ j ] + arr [ i ] ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( max < msis [ i ] ){<br>            int max = msis [ i ] ;<br>        }<br>    }<br>    return max ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n == 2 || n == 3 ) return ( n - 1 ) ;<br>  int res = 1 ;<br>  while ( n > 4 ) {<br>    n -= 3 ;<br>    res *= 3 ;<br>  }<br>  return ( n * res ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    if ( ( n == 2 || n == 3 ) && ( n == 4 ) ) {<br>        return ( n - 1 ) ;<br>    }<br>    int res = 1 ;<br>    while ( ( n > 4 ) && ( n > 5 ) ) {<br>        n -= 3 ;<br>        res *= 3 ;<br>    }<br>    return ( n * res ) ;<br>}</td>
  </tr><tr>
    <th>DYNAMIC_PROGRAMMING_SET_37_BOOLEAN_PARENTHESIZATION_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( char symb [ ] , char oper [ ] , int n ) {<br>  int F [ ] [ ] = new int [ n ] [ n ] ;<br>  int T [ ] [ ] = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ;<br>    T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ;<br>  }<br>  for ( int gap = 1 ;<br>  gap < n ;<br>  ++ gap ) {<br>    for ( int i = 0 , j = gap ;<br>    j < n ;<br>    ++ i , ++ j ) {<br>      T [ i ] [ j ] = F [ i ] [ j ] = 0 ;<br>      for ( int g = 0 ;<br>      g < gap ;<br>      g ++ ) {<br>        int k = i + g ;<br>        int tik = T [ i ] [ k ] + F [ i ] [ k ] ;<br>        int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;<br>        if ( oper [ k ] == '&' ) {<br>          T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;<br>          F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;<br>        }<br>        if ( oper [ k ] == '|' ) {<br>          F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;<br>          T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;<br>        }<br>        if ( oper [ k ] == '^' ) {<br>          T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ;<br>          F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ;<br>        }<br>      }<br>    }<br>  }<br>  return T [ 0 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( char [ ] symb , char oper , int n ) {<br>    F = new int [ n + 1 ] ;<br>    int [ ] T = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( symb . charAt ( i ) == 'F' ) {<br>            F [ i ] [ i ] = 1 ;<br>        }<br>        else{<br>            F [ i ] [ i ] = 0 ;<br>        }<br>        if ( symb . charAt ( i ) == 'T' ) {<br>            T [ i ] [ i ] = 1 ;<br>        }<br>        else{<br>            T [ i ] [ i ] = 0 ;<br>        }<br>    }<br>    for ( int gap = 1 ;  gap < n ;  gap ++ ) {<br>        int i = 0 ;<br>        for ( int j = gap ;  j < n ;  j ++ ) {<br>            T [ i ] [ j ] = F [ i ] [ j ] = 0 ;<br>            for ( int g = 0 ;  g < gap ;  g ++ ) {<br>                int k = i . get ( ) + g ;<br>                tik = T [ i ] [ k ] + F [ i ] [ k ] ;<br>                tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ;<br>                if ( oper . charAt ( k ) == '&' ){<br>                    T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ;<br>                    F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ;<br>                }<br>                if ( oper . charAt ( k ) == '|' ){<br>                    F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ;<br>                    T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;<br>                }<br>                if ( oper . charAt ( k ) == '^' ){<br>                    T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;<br>                    F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ;<br>                }<br>            }<br>            i ++ ;<br>        }<br>    }<br>    return T [ 0 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRESENT_IN_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  HashSet < Integer > s = new HashSet < > ( ) ;<br>  int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    s . add ( arr [ i ] ) ;<br>    if ( arr [ i ] < minm ) minm = arr [ i ] ;<br>    if ( arr [ i ] > maxm ) maxm = arr [ i ] ;<br>  }<br>  for ( int i = minm ;<br>  i <= maxm ;<br>  i ++ ) if ( ! s . contains ( i ) ) count ++ ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    Map < Integer , Integer > s = Collections . emptyMap ( ) ;<br>    int count = 0 , maxm = - 10 * 9 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        s [ arr [ i ] ] = 1 ;<br>        if ( ( arr [ i ] < minm ) && ( arr [ i ] > minm ) ) {<br>            int minm = arr [ i ] ;<br>        }<br>        if ( ( arr [ i ] > maxm ) && ( arr [ i ] < maxn ) ){<br>            int maxm = arr [ i ] ;<br>        }<br>    }<br>    for ( int i = minm ;  i <= maxm ;  i ++ ) {<br>        if ( i != s . length ){<br>            count ++ ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>EVEN_FIBONACCI_NUMBERS_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int limit ) {<br>  if ( limit < 2 ) return 0 ;<br>  long ef1 = 0 , ef2 = 2 ;<br>  long sum = ef1 + ef2 ;<br>  while ( ef2 <= limit ) {<br>    long ef3 = 4 * ef2 + ef1 ;<br>    if ( ef3 > limit ) break ;<br>    ef1 = ef2 ;<br>    ef2 = ef3 ;<br>    sum += ef2 ;<br>  }<br>  return ( int ) sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int limit ) {<br>    if ( ( limit < 2 ) && ( limit > 0 ) ) {<br>        return 0 ;<br>    }<br>    ef1 = 0 ;<br>    int ef2 = 2 ;<br>    sm = ef1 + ef2 ;<br>    while ( ( ef2 <= limit ) && ( ef3 <= limit ) ) {<br>        ef3 = 4 * ef2 + ef1 ;<br>        if ( ( ef3 > limit ) && ( ef3 < limit ) ) {<br>            break ;<br>        }<br>        ef1 = ef2 ;<br>        ef2 = ef3 ;<br>        sm = sm + ef2 ;<br>    }<br>    return sm ;<br>}</td>
  </tr><tr>
    <th>FIBONACCI_MODULO_P</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int p ) {<br>  int first = 1 , second = 1 , number = 2 , next = 1 ;<br>  while ( next > 0 ) {<br>    next = ( first + second ) % p ;<br>    first = second ;<br>    second = next ;<br>    number ++ ;<br>  }<br>  return number ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int p ) {<br>    first = 1 ;<br>    second = 1 ;<br>    int number = 2 ;<br>    next = 1 ;<br>    while ( ( next = p ) != 0 ) {<br>        next = ( first + second ) % p ;<br>        first = second ;<br>        second = next ;<br>        number = number + 1 ;<br>    }<br>    return number ;<br>}</td>
  </tr><tr>
    <th>FIND_A_FIXED_POINT_IN_A_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( arr [ i ] == i ) return i ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] == i ) {<br>            return i ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int brr [ ] = new int [ 2 * n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) brr [ i ] = arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) brr [ n + i ] = arr [ i ] ;<br>  int maxHam = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int currHam = 0 ;<br>    for ( int j = i , k = 0 ;<br>    j < ( i + n ) ;<br>    j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;<br>    if ( currHam == n ) return n ;<br>    maxHam = Math . max ( maxHam , currHam ) ;<br>  }<br>  return maxHam ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int [ ] brr = new int [ 2 * n + 1 ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        brr [ i ] = arr [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        brr [ n + i ] = arr [ i ] ;<br>    }<br>    int maxHam = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        currHam = 0 ;<br>        int k = 0 ;<br>        for ( int j = i ;  j < i + n ;  j ++ ) {<br>            if ( brr [ j ] != arr [ k ] ){<br>                currHam ++ ;<br>                k = k + 1 ;<br>            }<br>        }<br>        if ( currHam == n ) {<br>            return n ;<br>        }<br>        maxHam = Math . max ( maxHam , currHam ) ;<br>    }<br>    return maxHam ;<br>}</td>
  </tr><tr>
    <th>FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int A [ ] , int arr_size , int sum ) {<br>  int l , r ;<br>  for ( int i = 0 ;<br>  i < arr_size - 2 ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < arr_size - 1 ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < arr_size ;<br>      k ++ ) {<br>        if ( A [ i ] + A [ j ] + A [ k ] == sum ) {<br>          System . out . print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ;<br>          return true ;<br>        }<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] A , int arr_size , int sum ) {<br>    for ( int i = 0 ;  i <= arrSize - 2 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < arrSize - 1 ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < arrSize ;  k ++ ) {<br>                if ( A [ i ] + A [ j ] + A [ k ] == sum ) {<br>                    System . out . println ( "Triplet is" + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ;<br>                    return f_gold ( A , arr_size , sum , null ) ;<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String s ) {<br>  Stack < Character > Stack = new Stack < > ( ) ;<br>  char [ ] str = s . toCharArray ( ) ;<br>  for ( char ch : str ) {<br>    if ( ch == ')' ) {<br>      char top = Stack . peek ( ) ;<br>      Stack . pop ( ) ;<br>      int elementsInside = 0 ;<br>      while ( top != '(' ) {<br>        elementsInside ++ ;<br>        top = Stack . peek ( ) ;<br>        Stack . pop ( ) ;<br>      }<br>      if ( elementsInside < 1 ) {<br>        return true ;<br>      }<br>    }<br>    else {<br>      Stack . push ( ch ) ;<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( String string ) {<br>    Stack < String > stack = new Stack < String > ( ) ;<br>    for ( int i = 0 ;  i < string . length ( ) ;  i ++ ) {    char ch = string . charAt ( i ) ;{<br>        if ( ch == ')' ) {<br>            Stack top = new Stack ( ) ;<br>            elementsInside = 0 ;<br>            while ( top != '(' ) {<br>                elementsInside ++ ;<br>                Stack top = new Stack ( ) ;<br>            }<br>            if ( elementsInside < 1 ) {<br>                return fGoldString ( string , true ) ;<br>            }<br>        }<br>        }<br>            Stack . add ( ch ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  float fibo = 2.078087F * ( float ) Math . log ( n ) + 1.672276F ;<br>  return Math . round ( fibo ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenN ( double n ) {<br>    double fibo = 2.078087 * Math . log ( n ) + 1.672276 ;<br>    return Math . round ( fibo ) ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr1 [ ] , int arr2 [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;<br>  return n ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr1 [ i ] != arr2 [ i ] ) && ( arr1 [ i ] != arr2 [ i ] ) ) {<br>            return i ;<br>        }<br>    }<br>    return n ;<br>}</td>
  </tr><tr>
    <th>FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr1 [ ] , int arr2 [ ] , int n ) {<br>  int index = n ;<br>  int left = 0 , right = n - 1 ;<br>  while ( left <= right ) {<br>    int mid = ( left + right ) / 2 ;<br>    if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ;<br>    else {<br>      index = mid ;<br>      right = mid - 1 ;<br>    }<br>  }<br>  return index ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr1 , int [ ] arr2 , int n ) {<br>    int index = n ;<br>    int left = 0 ;<br>    int right = n - 1 ;<br>    while ( ( left <= right ) && ( right > arr1 ) ) {<br>        int mid = ( int ) ( ( left + right ) / 2 ) ;<br>        if ( ( arr2 [ mid ] == arr1 [ mid ] ) && ( arr1 [ mid ] == arr2 [ mid ] ) ) {<br>            left = mid + 1 ;<br>        }<br>        else {<br>            index = mid ;<br>            int right = mid - 1 ;<br>        }<br>    }<br>    return index ;<br>}</td>
  </tr><tr>
    <th>FIND_LARGEST_PRIME_FACTOR_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( long n ) {<br>  long maxPrime = - 1 ;<br>  while ( n % 2 == 0 ) {<br>    maxPrime = 2 ;<br>    n >>= 1 ;<br>  }<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i += 2 ) {<br>    while ( n % i == 0 ) {<br>      maxPrime = i ;<br>      n = n / i ;<br>    }<br>  }<br>  if ( n > 2 ) maxPrime = n ;<br>  return maxPrime ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    maxPrime = - 1 ;<br>    while ( n % 2 == 0 ) {<br>        int maxPrime = 2 ;<br>        n >>= 1 ;<br>    }<br>    for ( int i = 3 ;  i < ( int ) Math . sqrt ( n ) + 1 ;  i += 2 ) {<br>        while ( n % i == 0 ){<br>            maxPrime = i ;<br>            n = n / i ;<br>        }<br>    }<br>    if ( n > 2 ) {<br>        maxPrime = n ;<br>    }<br>    return ( int ) maxPrime ;<br>}</td>
  </tr><tr>
    <th>FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( long A , long B ) {<br>  int variable = 1 ;<br>  if ( A == B ) return 1 ;<br>  else if ( ( B - A ) >= 5 ) return 0 ;<br>  else {<br>    for ( long i = A + 1 ;<br>    i <= B ;<br>    i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ;<br>    return variable % 10 ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int A , int B ) {<br>    int variable = 1 ;<br>    if ( ( A == B ) && ( A != 0 ) ) {<br>        return 1 ;<br>    }<br>    else if ( ( ( B - A ) >= 5 ) && ( ( B - A ) <= 5 ) ) {<br>        return 0 ;<br>    }<br>    }<br>        for ( int i = A + 1 ;  i <= B ;  i ++ ) {<br>            variable = ( variable * ( i % 10 ) ) % 10 ;<br>        }<br>        return variable % 10 ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  if ( n < 3 ) return - 1 ;<br>  int max_product = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n - 2 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n - 1 ;<br>  j ++ ) for ( int k = j + 1 ;<br>  k < n ;<br>  k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ;<br>  return max_product ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    if ( n < 3 ) {<br>        return - 1 ;<br>    }<br>    int maxProduct = - ( Integer . MAX_VALUE - 1 ) ;<br>    for ( int i = 0 ;  i <= n - 2 ;  i ++ ) {<br>        for ( int j = i + 1 ;  j <= n - 1 ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < n ;  k ++ ) {<br>                maxProduct = Math . max ( maxProduct , arr [ i ] * arr [ j ] * arr [ k ] ) ;<br>            }<br>        }<br>    }<br>    return maxProduct ;<br>}</td>
  </tr><tr>
    <th>FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) {<br>  int sum1 = 0 , sum2 = 0 , sum3 = 0 ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) sum1 += stack1 [ i ] ;<br>  for ( int i = 0 ;<br>  i < n2 ;<br>  i ++ ) sum2 += stack2 [ i ] ;<br>  for ( int i = 0 ;<br>  i < n3 ;<br>  i ++ ) sum3 += stack3 [ i ] ;<br>  int top1 = 0 , top2 = 0 , top3 = 0 ;<br>  int ans = 0 ;<br>  while ( true ) {<br>    if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;<br>    if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;<br>    if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ;<br>    else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ;<br>    else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] stack1 , int [ ] stack2 , int [ ] stack3 , int n1 , int n2 , int n3 ) {<br>    int sum1 = 0 , sum2 = 0 , sum3 = 0 ;<br>    for ( int i = 0 ;  i < n1 ;  i ++ ) {<br>        sum1 += stack1 [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n2 ;  i ++ ) {<br>        sum2 += stack2 [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n3 ;  i ++ ) {<br>        sum3 += stack3 [ i ] ;<br>    }<br>    int top1 = 0 , top2 = 0 , top3 = 0 ;<br>    int ans = 0 ;<br>    while ( ( 1 ) ) {<br>        if ( ( top1 == n1 || top2 == n2 || top3 == n3 ) && ( stack1 == stack2 || stack3 == n3 ) ) {<br>            return 0 ;<br>        }<br>        if ( ( sum1 == sum2 && sum2 == sum3 ) || ( sum1 == sum2 && sum3 == sum3 ) ) {<br>            return sum1 ;<br>        }<br>        if ( ( sum1 >= sum2 && sum1 >= sum3 ) || ( sum2 >= sum3 && sum2 >= sum4 ) ) {<br>            sum1 -= stack1 [ top1 ] ;<br>            top1 = top1 + 1 ;<br>        }<br>        }<br>            sum2 -= stack2 [ top2 ] ;<br>            top2 = top2 + 1 ;<br>        }<br>            sum3 -= stack3 [ top3 ] ;<br>            top3 = top3 + 1 ;<br>    }<br>}</td>
  </tr><tr>
    <th>FIND_MINIMUM_DIFFERENCE_PAIR_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  Arrays . sort ( arr ) ;<br>  int diff = Integer . MAX_VALUE ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ;<br>  return diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    arr = Collections . sort ( arr ) ;<br>    int diff = 10 * 20 ;<br>    for ( int i = 0 ;  i < n - 1 ;  i ++ ) {<br>        if ( arr [ i + 1 ] - arr [ i ] < diff ){<br>            int diff = arr [ i + 1 ] - arr [ i ] ;<br>        }<br>    }<br>    return diff ;<br>}</td>
  </tr><tr>
    <th>FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String a , String b ) {<br>  int m = a . length ( ) ;<br>  int n = b . length ( ) ;<br>  int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  ++ i ) lookup [ 0 ] [ i ] = 0 ;<br>  for ( int i = 0 ;<br>  i <= m ;<br>  ++ i ) lookup [ i ] [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= m ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= n ;<br>    j ++ ) {<br>      if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ;<br>      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  return lookup [ m ] [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int [ ] b ) {<br>    int m = a . length ( ) ;<br>    int n = b . length ( ) ;<br>    int [ ] lookup = new int [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;{<br>        lookup [ 0 ] [ i ] = 0 ;<br>    }<br>    for ( int i = 0 ;  i < m + 1 ;{<br>        lookup [ i ] [ 0 ] = 1 ;<br>    }<br>    for ( int i = 1 ;  i <= m ;{<br>        for ( int j = 1 ;  j <= n ;{<br>            if ( a [ i - 1 ] == b [ j - 1 ] ) a [ i - 1 ] = 5 ;<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ;<br>            }<br>                lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;<br>        }<br>    }<br>    return lookup [ m ] [ n ] ;<br>}</td>
  </tr><tr>
    <th>FIND_ONE_EXTRA_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char f_gold ( String strA , String strB ) {<br>  int res = 0 , i ;<br>  for ( i = 0 ;<br>  i < strA . length ( ) ;<br>  i ++ ) {<br>    res ^= strA . charAt ( i ) ;<br>  }<br>  for ( i = 0 ;<br>  i < strB . length ( ) ;<br>  i ++ ) {<br>    res ^= strB . charAt ( i ) ;<br>  }<br>  return ( ( char ) ( res ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static byte fGold ( String strA , String strB ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i <= strA . length ( ) ;  i ++ ) {<br>        res = res ^ ( ( byte ) ( strA . charAt ( i ) ) ) ;<br>    }<br>    for ( int i = 0 ;  i <= strB . length ( ) ;  i ++ ) {<br>        res = res ^ ( ( byte ) strB . charAt ( i ) ) ;<br>    }<br>    return ( ( char ) ( res ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_PERIMETER_CYLINDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int diameter , int height ) {<br>  return 2 * ( diameter + height ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int diameter , int height ) {<br>    return 2 * ( diameter + height ) ;<br>}</td>
  </tr><tr>
    <th>FIND_REPETITIVE_ELEMENT_1_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += arr [ i ] ;<br>  return sum - ( ( ( n - 1 ) * n ) / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    return Arrays . hashCode ( arr ) - ( ( ( n - 1 ) * n ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return ( 1 << ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    return ( 1 << ( n - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int N , int K ) {<br>  int ans = 0 ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) ans += ( i % K ) ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int N , int K ) {<br>    int ans = 0 ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        ans += ( i % K ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_ODD_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int res = 1 ;<br>  while ( n % 2 == 0 ) n = n / 2 ;<br>  for ( int i = 3 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    int count = 0 , curr_sum = 1 ;<br>    int curr_term = 1 ;<br>    while ( n % i == 0 ) {<br>      count ++ ;<br>      n = n / i ;<br>      curr_term *= i ;<br>      curr_sum += curr_term ;<br>    }<br>    res *= curr_sum ;<br>  }<br>  if ( n >= 2 ) res *= ( 1 + n ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int res = 1 ;<br>    while ( n % 2 == 0 ) {<br>        n = n / 2 ;<br>    }<br>    for ( int i = 3 ;  i < ( int ) ( Math . sqrt ( n ) + 1 ) ;  i ++ ) {<br>        int count = 0 ;<br>        currSum = 1 ;<br>        curr_term = 1 ;<br>        while ( n % i == 0 ){<br>            count ++ ;<br>            n = n / i ;<br>            currTerm *= i ;<br>            currSum += currTerm ;<br>        }<br>        res *= currSum ;<br>    }<br>    if ( n >= 2 ) {<br>        res *= ( 1 + n ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  int res = 0 ;<br>  HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int sum = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      sum += arr [ j ] ;<br>      if ( m . containsKey ( sum ) ) {<br>        m . put ( sum , m . get ( sum ) + 1 ) ;<br>      }<br>      else {<br>        m . put ( sum , 1 ) ;<br>      }<br>    }<br>  }<br>  for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) if ( x . getValue ( ) == 1 ) res += x . getKey ( ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int res = 0 ;<br>    Map < Integer , Integer > m = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int Sum = 0 ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            Sum += arr [ j ] ;<br>            m . put ( Sum . class , m . get ( Sum . class ) + 1 ) ;<br>        }<br>    }<br>    for ( int x = 0 ;  x < m ;  x ++ ) {<br>        if ( m [ x ] == 1 ) {<br>            res += x ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_IT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  int [ ] leftMax = new int [ n ] ;<br>  leftMax [ 0 ] = Integer . MIN_VALUE ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ;<br>  int rightMin = Integer . MAX_VALUE ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ;<br>    rightMin = Math . min ( rightMin , arr [ i ] ) ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n ) {<br>    int [ ] leftMax = new int [ n ] ;<br>    leftMax [ 0 ] = Integer . MAX_VALUE ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ;<br>    }<br>    float rightMin = Float . MAX_VALUE ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ){<br>            return i ;<br>        }<br>        rightMin = Math . min ( rightMin , arr [ i ] ) ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASING_AND_THEN_DECREASING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int low , int high ) {<br>  int max = arr [ low ] ;<br>  int i ;<br>  for ( i = low ;<br>  i <= high ;<br>  i ++ ) {<br>    if ( arr [ i ] > max ) max = arr [ i ] ;<br>  }<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int low , int high ) {<br>    int max = arr [ low ] ;<br>    int i = low ;<br>    for ( int i = 0 ;  i < high + 1 ;  i ++ ) {<br>        if ( arr [ i ] > max ){<br>            int max = arr [ i ] ;<br>        }<br>    }<br>    return max ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  int total = 1 ;<br>  for ( int i = 2 ;<br>  i <= ( n + 1 ) ;<br>  i ++ ) {<br>    total += i ;<br>    total -= a [ i - 2 ] ;<br>  }<br>  return total ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int [ ] a , int n ) {<br>    int i = 0 , total = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i += 2 ) {<br>        total += i ;<br>        total -= a [ i - 2 ] ;<br>    }<br>    return total ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_MISSING_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  int x1 = a [ 0 ] ;<br>  int x2 = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) x1 = x1 ^ a [ i ] ;<br>  for ( int i = 2 ;<br>  i <= n + 1 ;<br>  i ++ ) x2 = x2 ^ i ;<br>  return ( x1 ^ x2 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int [ ] a , int n ) {<br>    int x1 = a [ 0 ] ;<br>    int x2 = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        x1 = x1 ^ a [ i ] ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i += 2 ) {<br>        x2 = x2 ^ i ;<br>    }<br>    return x1 ^ x2 ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int arr_size ) {<br>  int i ;<br>  for ( i = 0 ;<br>  i < arr_size ;<br>  i ++ ) {<br>    int count = 0 ;<br>    for ( int j = 0 ;<br>    j < arr_size ;<br>    j ++ ) {<br>      if ( arr [ i ] == arr [ j ] ) count ++ ;<br>    }<br>    if ( count % 2 != 0 ) return arr [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int arrSize ) {<br>    for ( int i = 0 ;  i != arrSize ;  i ++ ) {<br>        int count = 0 ;<br>        for ( int j = 0 ;  j <= arrSize ;  j ++ ) {<br>            if ( arr [ i ] == arr [ j ] ) {<br>                count ++ ;<br>            }<br>        }<br>        if ( ( count % 2 != 0 ) && ( count % 2 == 0 ) ) {<br>            return arr [ i ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  HashMap < Integer , Integer > hmap = new HashMap < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( hmap . containsKey ( arr [ i ] ) ) {<br>      int val = hmap . get ( arr [ i ] ) ;<br>      hmap . put ( arr [ i ] , val + 1 ) ;<br>    }<br>    else hmap . put ( arr [ i ] , 1 ) ;<br>  }<br>  for ( Integer a : hmap . keySet ( ) ) {<br>    if ( hmap . get ( a ) % 2 != 0 ) return a ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int arr [ ] , int size ) {<br>    HashMap < Integer , Integer > Hash = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    for ( int i = 0 ;  i < size ;  i ++ ) {<br>        Hash . put ( arr [ i ] , Hash . get ( arr [ i ] , 0 ) + 1 ) ;<br>    }<br>    for ( int i = 0 ;  i < Hash . length ;  i ++ ) {<br>        if ( ( Hash [ i ] % 2 != 0 ) && ( Hash [ i ] % 2 != 1 ) ){<br>            return i ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int n ) {<br>  return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ;<br>}<br></td>
    <td>translated code: <br><br> static boolean f_gold ( int n ) {<br>    return ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ) ;<br>}</td>
  </tr><tr>
    <th>FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char f_gold ( String str ) {<br>  for ( int i = 0 ;<br>  i < str . length ( ) ;<br>  i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ;<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String str ) {<br>    for ( int i = 0 ;  i <= str . length ( ) ;  i ++ ) {<br>        if ( ( str [ i ] . istitle ( ) ) && ( str [ i ] . istitle ( ) ) ) {<br>            return str . charAt ( i ++ ) ;<br>        }<br>    }<br>    return 0 ;<br>}</td>
  </tr><tr>
    <th>FLOOR_IN_A_SORTED_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int low , int high , int x ) {<br>  if ( low > high ) return - 1 ;<br>  if ( x >= arr [ high ] ) return high ;<br>  int mid = ( low + high ) / 2 ;<br>  if ( arr [ mid ] == x ) return mid ;<br>  if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ;<br>  if ( x < arr [ mid ] ) return f_gold ( arr , low , mid - 1 , x ) ;<br>  return f_gold ( arr , mid + 1 , high , x ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int low , int high , int x ) {<br>    if ( ( low > high ) && ( x > 0 ) ) {<br>        return - 1 ;<br>    }<br>    if ( ( x >= arr [ high ] ) && ( x <= arr [ low ] ) ) {<br>        return high ;<br>    }<br>    int mid = ( int ) ( ( low + high ) / 2 ) ;<br>    if ( ( arr [ mid ] == x ) && ( arr [ high ] == x ) ) {<br>        return mid ;<br>    }<br>    if ( ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) || ( mid > 0 && arr [ mid - 1 ] > x && x < arr [ mid ] ) ) {<br>        return mid - 1 ;<br>    }<br>    if ( ( x < arr [ mid ] ) && ( x > arr [ high ] ) ) {<br>        return fGold ( arr , low , mid - 1 , x ) ;<br>    }<br>    return fGold ( arr , mid + 1 , high , x ) ;<br>}</td>
  </tr><tr>
    <th>FUNCTION_COPY_STRING_ITERATIVE_RECURSIVE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void f_gold ( char s1 [ ] , char s2 [ ] , int index ) {<br>  s2 [ index ] = s1 [ index ] ;<br>  if ( index == s1 . length - 1 ) {<br>    return ;<br>  }<br>  f_gold ( s1 , s2 , index + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void fGold ( String s1 , String s2 , int index ) {<br>    s2 [ index ] = s1 [ index ] ;<br>    if ( ( index == s1 . length ( ) - 1 ) && ( index < s2 . length ( ) ) ) {<br>        }<br>    }<br>    fGold ( s1 , s2 , index + 1 ) ;<br>}</td>
  </tr><tr>
    <th>GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String str ) {<br>  int i , j , k , l = str . length ( ) ;<br>  int arr [ ] = new int [ l ] ;<br>  for ( i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    for ( j = i ;<br>    j < l ;<br>    j ++ ) {<br>      for ( k = j ;<br>      k < l ;<br>      k ++ ) {<br>        if ( arr [ i ] % 8 == 0 ) return true ;<br>        else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ;<br>        else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ;<br>      }<br>    }<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( String st ) {<br>    int l = st . length ( ) ;<br>    int [ ] arr = new int [ l ] ;<br>    for ( int i = 0 ;  i <= l ;  i ++ ) {<br>        for ( int j = i ;  j < l ;  j ++ ) {<br>            for ( int k = j ;  k < l ;  k ++ ) {<br>                if ( ( arr [ i ] % 8 == 0 ) && ( arr [ i ] % 8 == 0 ) ){<br>                    return fGold ( st , null ) ;<br>                }<br>                if ( ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) && ( i != j ) ) {<br>                    return fGold ( st , null ) ;<br>                }<br>                if ( ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) ){<br>                    return fGold ( st , null ) ;<br>                }<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>GOOGLE_CASE_GIVEN_SENTENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  String s1 = "" ;<br>  s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == ' ' && i < n ) {<br>      s1 = s1 + " " + Character . toLowerCase ( s . charAt ( i + 1 ) ) ;<br>      i ++ ;<br>    }<br>    else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ;<br>  }<br>  return s1 ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String s ) {<br>    int n = s . length ( ) ;<br>    String s1 = "" ;<br>    s1 = s1 + s . charAt ( 0 ) . toLowerCase ( ) ;<br>    int i = 1 ;<br>    while ( i < n ){<br>        if ( ( s . charAt ( i ) == ' ' && i <= n ) || ( s . charAt ( i ) == ' ' && i <= n ) ) {<br>            s1 = s1 + " " + ( s . charAt ( i + 1 ) ) . toLowerCase ( ) ;<br>            i = i + 1 ;<br>        }<br>        }<br>            s1 = s1 + ( s . charAt ( i ) ) . toUpperCase ( ) ;<br>        i = i + 1 ;<br>    }<br>    return s1 ;<br>}</td>
  </tr><tr>
    <th>HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int N ) {<br>  return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math . log ( 2 ) ) - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int N ) {<br>    return Math . ceil ( Math . log2 ( N + 1 ) ) - 1 ;<br>}</td>
  </tr><tr>
    <th>HEXAGONAL_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return n * ( 2 * n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    return n * ( 2 * n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEMENT_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int no ) {<br>  return no == 0 ? 0 : no % 10 + f_gold ( no / 10 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int no ) {<br>    return no == 0 ? 0 : ( int ) ( no % 10 ) + fGold ( ( int ) ( no / 10 ) ) ;<br>}</td>
  </tr><tr>
    <th>HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int i , int n ) {<br>  if ( i > ( n - 2 ) / 2 ) {<br>    return true ;<br>  }<br>  if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && f_gold ( arr , 2 * i + 1 , n ) && f_gold ( arr , 2 * i + 2 , n ) ) {<br>    return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int [ ] arr , int i , int n ) {<br>    if ( i > ( int ) ( ( n - 2 ) / 2 ) ) {<br>        return fGold ( arr , i , n , 0 ) ;<br>    }<br>    if ( ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && f_gold ( arr , 2 * i + 1 , n ) && f_gold ( arr , 2 * i + 2 , n ) ) ) {<br>        return fGold ( arr , i , n , 0 ) ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i <= ( n - 2 ) / 2 ;<br>  i ++ ) {<br>    if ( arr [ 2 * i + 1 ] > arr [ i ] ) {<br>      return false ;<br>    }<br>    if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i < ( int ) ( ( n - 2 ) / 2 ) + 1 ;  i ++ ) {<br>        if ( arr [ 2 * i + 1 ] > arr [ i ] ) {<br>            return false ;<br>        }<br>        if ( ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) || ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i + 1 ] ) ) {<br>            return false ;<br>        }<br>    }<br>    return fGold ( arr , 0 , n ) ;<br>}</td>
  </tr><tr>
    <th>HYPERCUBE_GRAPH</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n == 1 ) return 2 ;<br>  return 2 * f_gold ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    if ( n == 1 ) {<br>        return 2 ;<br>    }<br>    return 2 * fGoldCount ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>K_TH_DIGIT_RAISED_POWER_B</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int a , int b , int k ) {<br>  int p = ( int ) Math . pow ( a , b ) ;<br>  int count = 0 ;<br>  while ( p > 0 && count < k ) {<br>    int rem = p % 10 ;<br>    count ++ ;<br>    if ( count == k ) return rem ;<br>    p = p / 10 ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int a , int b , int k ) {<br>    int p = a * b ;<br>    int count = 0 ;<br>    while ( ( p > 0 && count < k ) || ( count < k ) ) {<br>        int rem = p % 10 ;<br>        count = count + 1 ;<br>        if ( ( count == k ) && ( a == 5 ) ) a = b ;<br>            return rem ;<br>        p = p / 10 ;<br>    }<br>}</td>
  </tr><tr>
    <th>K_TH_ELEMENT_TWO_SORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) {<br>  int [ ] sorted1 = new int [ m + n ] ;<br>  int i = 0 , j = 0 , d = 0 ;<br>  while ( i < m && j < n ) {<br>    if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;<br>    else sorted1 [ d ++ ] = arr2 [ j ++ ] ;<br>  }<br>  while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;<br>  while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ;<br>  return sorted1 [ k - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) {<br>    int [ ] sorted1 = new int [ m + n ] ;<br>    int i = 0 ;<br>    int j = 0 ;<br>    int d = 0 ;<br>    while ( ( i < m && j < n ) || ( i < k && j < k ) ) {<br>        if ( ( arr1 [ i ] < arr2 [ j ] ) && ( arr1 [ j ] > arr2 [ i ] ) ) {<br>            sorted1 [ d ] = arr1 [ i ] ;<br>            i ++ ;<br>        }<br>        else {<br>            sorted1 [ d ] = arr2 [ j ] ;<br>            j ++ ;<br>        }<br>        d ++ ;<br>    }<br>    while ( ( i < m ) && ( i < n ) ) {<br>        sorted1 [ d ] = arr1 [ i ] ;<br>        d ++ ;<br>        i ++ ;<br>    }<br>    while ( ( j < n ) && ( j < m ) ) {<br>        sorted1 [ d ] = arr2 [ j ] ;<br>        d ++ ;<br>        j ++ ;<br>    }<br>    return sorted1 [ k - 1 ] ;<br>}</td>
  </tr><tr>
    <th>K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int k ) {<br>  int sum [ ] = new int [ n + 1 ] ;<br>  sum [ 0 ] = 0 ;<br>  sum [ 1 ] = arr [ 0 ] ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;<br>  PriorityQueue < Integer > Q = new PriorityQueue < Integer > ( ) ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j <= n ;<br>    j ++ ) {<br>      int x = sum [ j ] - sum [ i - 1 ] ;<br>      if ( Q . size ( ) < k ) Q . add ( x ) ;<br>      else {<br>        if ( Q . peek ( ) < x ) {<br>          Q . poll ( ) ;<br>          Q . add ( x ) ;<br>        }<br>      }<br>    }<br>  }<br>  return Q . poll ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int k ) {<br>    int [ ] sum = new int [ k ] ;<br>    sum . add ( 0 ) ;<br>    sum . add ( arr [ 0 ] ) ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        sum . add ( sum [ i - 1 ] + arr [ i - 1 ] ) ;<br>    }<br>    int [ ] Q = new int [ n ] ;<br>    HeapUtils . heapify ( Q ) ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = i ;  j <= n ;  j ++ ) {<br>            int x = sum [ j ] - sum [ i - 1 ] ;<br>            if ( Q . length < k ){<br>                heappush ( Q , arr , n , k ) ;<br>            }<br>            else {<br>                if ( Q [ 0 ] < x ){<br>                    heapPop ( Q ) ;<br>                    heappush ( Q , arr , n , k ) ;<br>                }<br>            }<br>        }<br>    }<br>    return Q [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) {<br>  LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ;<br>  for ( int i = 0 ;<br>  i < n2 ;<br>  i ++ ) s . add ( b [ i ] ) ;<br>  int missing = 0 ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    if ( ! s . contains ( a [ i ] ) ) missing ++ ;<br>    if ( missing == k ) return a [ i ] ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] a , int [ ] b , int k , int n1 , int n2 ) {<br>    Set s = new HashSet ( ) ;<br>    for ( int i = 0 ;  i < n2 ;{<br>        s . add ( b [ i ] ) ;<br>    }<br>    int missing = 0 ;<br>    for ( int i = 0 ;  i < n1 ;{<br>        if ( a [ i ] != s ) a [ i ] = 5 ;<br>            missing ++ ;<br>        if ( missing == k ){<br>            return a [ i ] ;<br>        }<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int k , String s1 , String s2 ) {<br>  int n = s1 . length ( ) ;<br>  int m = s2 . length ( ) ;<br>  int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 1 ;<br>    j <= m ;<br>    j ++ ) {<br>      lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ;<br>      if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ;<br>      if ( cnt [ i ] [ j ] >= k ) {<br>        for ( int a = k ;<br>        a <= cnt [ i ] [ j ] ;<br>        a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ;<br>      }<br>    }<br>  }<br>  return lcs [ n ] [ m ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int k , String s1 , String s2 ) {<br>    int n = s1 . length ( ) ;<br>    int m = s2 . length ( ) ;<br>    int [ ] lcs = new int [ m + 1 ] ;<br>    int [ ] [ ] cnt = new int [ m + 1 ] [ n + 1 ] ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = 1 ;  j <= m ;  j ++ ) {<br>            lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ;<br>            if ( ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) && ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) ) {<br>                cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ;<br>            }<br>            if ( ( cnt [ i ] [ j ] >= k ) && ( cnt [ i ] [ j ] < k ) ){<br>                for ( int a = k ;  a < cnt [ i ] [ j ] + 1 ;  a ++ ) {<br>                    lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ;<br>                }<br>            }<br>        }<br>    }<br>    return lcs [ n ] [ m ] ;<br>}</td>
  </tr><tr>
    <th>LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int arr [ ] , int n ) {<br>  int [ ] lioes = new int [ n ] ;<br>  int maxLen = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) lioes [ i ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;<br>  return maxLen ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    List < Integer > lioes = Arrays . asList ( ) ;<br>    int maxLen = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        lioes . add ( 1 ) ;<br>    }<br>    int i = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) ){<br>                lioes [ i ] = lioes [ j ] + 1 ;<br>            }<br>        }<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( maxLen < lioes [ i ] ){<br>            int maxLen = lioes [ i ] ;<br>        }<br>    }<br>    return maxLen ;<br>}</td>
  </tr><tr>
    <th>LONGEST_PALINDROME_SUBSEQUENCE_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  int a [ ] = new int [ n ] ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    int back_up = 0 ;<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      if ( j == i ) a [ j ] = 1 ;<br>      else if ( s . charAt ( i ) == s . charAt ( j ) ) {<br>        int temp = a [ j ] ;<br>        a [ j ] = back_up + 2 ;<br>        back_up = temp ;<br>      }<br>      else {<br>        back_up = a [ j ] ;<br>        a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ;<br>      }<br>    }<br>  }<br>  return a [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int n = s . length ( ) ;<br>    int [ ] a = {<br>    }<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        backUp = 0 ;<br>        for ( int j = i ;  j < n ;  j ++ ) {<br>            if ( j == i ){<br>                a [ j ] = 1 ;<br>            }<br>            }<br>                int temp = a [ j ] ;<br>                a [ j ] = backUp + 2 ;<br>                back_up = temp ;<br>            }<br>                BackUp < String > a = a [ j ] ;<br>                a [ j ] = Math . max ( a [ j - 1 ] , a [ j ] ) ;<br>        }<br>    }<br>    return a [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>LONGEST_PREFIX_ALSO_SUFFIX_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  int lps [ ] = new int [ n ] ;<br>  lps [ 0 ] = 0 ;<br>  int len = 0 ;<br>  int i = 1 ;<br>  while ( i < n ) {<br>    if ( s . charAt ( i ) == s . charAt ( len ) ) {<br>      len ++ ;<br>      lps [ i ] = len ;<br>      i ++ ;<br>    }<br>    else {<br>      if ( len != 0 ) {<br>        len = lps [ len - 1 ] ;<br>      }<br>      else {<br>        lps [ i ] = 0 ;<br>        i ++ ;<br>      }<br>    }<br>  }<br>  int res = lps [ n - 1 ] ;<br>  return ( res > n / 2 ) ? n / 2 : res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int n = s . length ( ) ;<br>    int [ ] lps = new int [ n ] ;<br>    int l = 0 ;<br>    int i = 1 ;<br>    while ( ( i < n ) && ( i < a ) ) {<br>        if ( ( s . charAt ( i ) == s . charAt ( l ) ) && ( s . charAt ( i ) == s . charAt ( l ) ) ) {<br>            l = l + 1 ;<br>            lps [ i ] = l ;<br>            i = i + 1 ;<br>        }<br>        }<br>            if ( ( l != 0 ) && ( l != 1 ) ){<br>                int l = lps [ l - 1 ] ;<br>            }<br>            }<br>                lps [ i ++ ] = 0 ;<br>                i = i + 1 ;<br>    }<br>    int res = lps [ n - 1 ] ;<br>    if ( ( res > n / 2 ) && ( res > n / 3 ) ){<br>        return n / 2 ;<br>    }<br>    }<br>        return res ;<br>}</td>
  </tr><tr>
    <th>MAKING_ELEMENTS_OF_TWO_ARRAYS_SAME_WITH_MINIMUM_INCREMENTDECREMENT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int b [ ] , int n ) {<br>  Arrays . sort ( a ) ;<br>  Arrays . sort ( b ) ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ;<br>    else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int [ ] b , int n ) {<br>    Collections . sort ( a , b , false ) ;<br>    Arrays . sort ( b , 0 , n ) ;<br>    int result = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i += 1 ) {<br>        if ( ( a [ i ] > b [ i ] ) && ( a [ i ] < b [ i ] ) ) a [ i ] = 5 ;<br>            result = result + Math . abs ( a [ i ] - b [ i ] ) ;<br>        else if ( ( a [ i ] < b [ i ] ) && ( a [ i ] > b [ i ] ) ) a [ i ] = 5 ;<br>            result = result + Math . abs ( a [ i ] - b [ i ] ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MARKOV_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( double m [ ] [ ] ) {<br>  for ( int i = 0 ;<br>  i < m . length ;<br>  i ++ ) {<br>    double sum = 0 ;<br>    for ( int j = 0 ;<br>    j < m [ i ] . length ;<br>    j ++ ) sum = sum + m [ i ] [ j ] ;<br>    if ( sum != 1 ) return false ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int [ ] [ ] m ) {<br>    for ( int i = 0 ;  i != m . length ;  i ++ ) {<br>        int sm = 0 ;<br>        for ( int j = 0 ;  j <= m [ i ] . length ;  j ++ ) {<br>            sm = sm + m [ i ] [ j ] ;<br>        }<br>        if ( ( sm != 1 ) && ( sm != 0 ) ){<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>MAXIMIZE_SUM_CONSECUTIVE_DIFFERENCES_CIRCULAR_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int sum = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n / 2 ;<br>  i ++ ) {<br>    sum -= ( 2 * arr [ i ] ) ;<br>    sum += ( 2 * arr [ n - i - 1 ] ) ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int sum = 0 ;<br>    Arrays . sort ( arr ) ;<br>    for ( int i = 0 ;  i <= ( int ) ( n / 2 ) ;  i ++ ) {<br>        sum -= ( 2 * arr [ i ] ) ;<br>        sum += ( 2 * arr [ n - i - 1 ] ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  Set < Integer > s = new HashSet < > ( ) ;<br>  int first = 0 , second = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ! s . contains ( arr [ i ] ) ) {<br>      s . add ( arr [ i ] ) ;<br>      continue ;<br>    }<br>    if ( arr [ i ] > first ) {<br>      second = first ;<br>      first = arr [ i ] ;<br>    }<br>    else if ( arr [ i ] > second ) second = arr [ i ] ;<br>  }<br>  return ( first * second ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    String s = new String ( ) ;<br>    int first = 0 ;<br>    int second = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( arr [ i ] != s ){<br>            s . add ( arr [ i ] ) ;<br>            continue ;<br>        }<br>        if ( ( arr [ i ] > first ) && ( arr [ i ] < last ) ) {<br>            int second = first ;<br>            int first = arr [ i ] ;<br>        }<br>        if ( ( arr [ i ] > second ) && ( arr [ i ] < first ) ) {<br>            int second = arr [ i ++ ] ;<br>        }<br>    }<br>    return ( first * second ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double f_gold ( int [ ] A , int K ) {<br>  int n = A . length ;<br>  double [ ] pre_sum = new double [ n + 1 ] ;<br>  pre_sum [ 0 ] = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;<br>  double [ ] dp = new double [ n ] ;<br>  double sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ;<br>  for ( int k = 0 ;<br>  k < K - 1 ;<br>  k ++ ) for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ;<br>  return dp [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] A , int K ) {<br>    int n = A . length ;<br>    int [ ] preSum = new int [ n + 1 ] ;<br>    pre_sum [ 0 ] = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        preSum [ i + 1 ] = preSum [ i ] + A [ i ] ;<br>    }<br>    int [ ] dp = new int [ n ] ;<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;{<br>        dp [ i ] = ( preSum [ n ] - preSum [ i ] ) / ( n - i ) ;<br>    }<br>    for ( int k = 0 ;  k < K - 1 ;  k ++ ) {<br>        for ( int i = 0 ;  i < n ;{<br>            for ( int j = i + 1 ;  j < n ;{<br>                dp [ i ] = Math . max ( dp [ i ] , ( preSum [ j ] - preSum [ i ] ) / ( j - i ) + dp [ j ] ) ;<br>            }<br>        }<br>    }<br>    return Integer . parseInt ( dp [ 0 ] ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int maxvalue = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ;<br>  return maxvalue ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        for ( int j = 0 ;  j < Math . min ( i , n ) + 1 ;  j ++ ) {<br>            if ( ( j == 0 || j == i ) && ( j == 0 || j == i ) ) {<br>                C [ i ] [ j ] = 1 ;<br>            }<br>            }<br>                C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ;<br>        }<br>    }<br>    int maxvalue = 0 ;<br>    for ( int i = 0 ;  i < n + 1 ;  i ++ ) {<br>        maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ;<br>    }<br>    return maxvalue ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static char f_gold ( String str ) {<br>  int n = str . length ( ) ;<br>  int count = 0 ;<br>  char res = str . charAt ( 0 ) ;<br>  int cur_count = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ;<br>    else {<br>      if ( cur_count > count ) {<br>        count = cur_count ;<br>        res = str . charAt ( i ) ;<br>      }<br>      cur_count = 1 ;<br>    }<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String str ) {<br>    int n = str . length ( ) ;<br>    int count = 0 ;<br>    String res = str . charAt ( 0 ) ;<br>    curCount = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) || ( i < n - 1 && str . charAt ( i + 1 ) == str . charAt ( i + 2 ) ) ){<br>            curCount ++ ;<br>        }<br>        }<br>            if ( curCount > count ){<br>                count = curCount ;<br>                String res = str [ i ] ;<br>            }<br>            curCount = 1 ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int mat [ ] [ ] , int m , int n ) {<br>  int rowSum [ ] = new int [ m ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    int sum = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) sum += mat [ i ] [ j ] ;<br>    rowSum [ i ] = sum ;<br>  }<br>  int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ;<br>  int min_element = rowSum [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ;<br>    if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ;<br>  }<br>  return max_diff ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] mat , int m , int n ) {<br>    int [ ] rowSum = new int [ m ] ;<br>    for ( int i = 0 ;  i <= m ;  i ++ ) {<br>        int sum = 0 ;<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            sum += mat [ i ] [ j ] ;<br>        }<br>        rowSum [ i ] = sum ;<br>    }<br>    double maxDiff = rowSum [ 1 ] - rowSum [ 0 ] ;<br>    int minElement = rowSum [ 0 ] ;<br>    for ( int i = 1 ;  i < m ;  i ++ ) {<br>        if ( ( rowSum [ i ] - minElement > maxDiff ) && ( rowSum [ i ] - minElement < maxDiff ) ){<br>            double maxDiff = rowSum [ i ] - minElement ;<br>        }<br>        if ( ( rowSum [ i ] < minElement ) && ( rowSum [ i ] > maxElement ) ) {<br>            int minElement = rowSum [ i ] ;<br>        }<br>    }<br>    return maxDiff ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_GAMES_PLAYED_WINNER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int N ) {<br>  int [ ] dp = new int [ N ] ;<br>  dp [ 0 ] = 1 ;<br>  dp [ 1 ] = 2 ;<br>  int i = 2 ;<br>  do {<br>    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;<br>  }<br>  while ( dp [ i ++ ] <= N ) ;<br>  return ( i - 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int N ) {<br>    int [ ] dp = new int [ N ] ;<br>    dp [ 0 ] = 1 ;<br>    dp [ 1 ] = 2 ;<br>    int i = 1 ;<br>    while ( dp [ i ] <= N ){<br>        i = i + 1 ;<br>        dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;<br>    }<br>    return ( i - 1 ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_HEIGHT_OF_TRIANGULAR_ARRANGEMENT_OF_ARRAY_VALUES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] a , int n ) {<br>  int result = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  ++ i ) {<br>    int y = ( i * ( i + 1 ) ) / 2 ;<br>    if ( y < n ) result = i ;<br>    else break ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int a , int n ) {<br>    int result = 1 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        int y = ( i * ( i + 1 ) ) / 2 ;<br>        if ( ( y < n ) && ( y < a ) ){<br>            int result = i ;<br>        }<br>        if ( n > 0 ) {<br>            break ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s , String t ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < t . length ( ) ;<br>  i ++ ) {<br>    if ( count == t . length ( ) ) break ;<br>    if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s , String t ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i != t . length ( ) ;  i ++ ) {<br>        if ( ( count == s . length ( ) ) && ( t . length ( ) == s . length ( ) ) ) {<br>            break ;<br>        }<br>        if ( ( t [ i ] == s [ count ] ) && ( t [ i + 1 ] == s [ count ] ) ) {<br>            count = count + 1 ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int k ) {<br>  HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ;<br>  int [ ] sum = new int [ n ] ;<br>  int curr_rem ;<br>  int maxSum = 0 ;<br>  sum [ 0 ] = arr [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    curr_rem = sum [ i ] % k ;<br>    if ( curr_rem == 0 ) {<br>      if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ;<br>    }<br>    else if ( ! um . containsKey ( curr_rem ) ) um . put ( curr_rem , i ) ;<br>    else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_rem ) ] ) ) maxSum = sum [ i ] - sum [ um . get ( curr_rem ) ] ;<br>  }<br>  return ( maxSum / k ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int k ) {<br>    int um = 0 , currRem = 0 , maxSum = 0 ;<br>    int [ ] sm = new int [ n ] ;<br>    sm [ 0 ] = arr [ 0 ] ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        sm [ i ] = sm [ i - 1 ] + arr [ i ] ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int currRem = sm [ i ] % k ;<br>        if ( ( ! currRem && maxSum < sm [ i ] ) || ( ! currRem && maxSum < sm [ k ] ) ){<br>            int maxSum = sm [ i ] ;<br>        }<br>        else if ( ( ! currRem . contains ( um ) ) && ( ! currRem . contains ( um ) ) ) {<br>            um [ currRem ++ ] = i ;<br>        }<br>        if ( ( maxSum < ( sm [ i ] - sm [ um [ currRem ] ] ) ) && ( maxSum > ( sm [ um [ currRem ] ] - sm [ um [ currRem ] ] ) ) ) {<br>            int maxSum = sm [ i ] - sm [ um [ currRem ] ] ;<br>        }<br>    }<br>    return maxSum / k ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_ISOSCELES_TRIANGLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int b , int m ) {<br>  return ( b / m - 1 ) * ( b / m ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGold ( double b , double m ) {<br>    return ( b / m - 1 ) * ( b / m ) / 2 ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] arr , int n ) {<br>  int [ ] mpis = new int [ n ] ;<br>  int max = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) mpis [ i ] = arr [ i ] ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ;<br>  for ( int k = 0 ;<br>  k < mpis . length ;<br>  k ++ ) {<br>    if ( mpis [ k ] > max ) {<br>      max = mpis [ k ] ;<br>    }<br>  }<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int [ ] mpis = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        mpis [ i ] = arr [ i ] ;<br>    }<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) || ( arr [ i ] > arr [ j ] && mpis [ i ] > ( mpis [ j ] * arr [ i ] ) ) ) {<br>                mpis [ i ] = mpis [ j ] * arr [ i ] ;<br>            }<br>        }<br>    }<br>    return Math . max ( mpis , arr [ n ] ) ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_OF_4_ADJACENT_ELEMENTS_IN_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] [ ] , int n ) {<br>  int max = 0 , result ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      if ( ( j - 3 ) >= 0 ) {<br>        result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ;<br>        if ( max < result ) max = result ;<br>      }<br>      if ( ( i - 3 ) >= 0 ) {<br>        result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ;<br>        if ( max < result ) max = result ;<br>      }<br>      if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) {<br>        result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ;<br>        if ( max < result ) max = result ;<br>      }<br>    }<br>  }<br>  return max ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] arr , int n ) {<br>    int max = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            if ( ( ( j - 3 ) >= 0 ) && ( ( j - 2 ) >= 0 ) && ( ( j - 1 ) >= 0 ) && ( ( j - 0 ) >= 0 ) && ( ( j - 0 ) >= 0 ) && ( ( j - 0 ) >= 0 ) && ( ( j - 0 ) >= 0 ) && ( ( j - 0 ) >= 0 ) && ( ( j - 0 ) >=<br>                double result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) ;<br>                if ( ( max < result ) && ( max < n ) ) {<br>                    int max = result ;<br>                }<br>            if ( ( ( i - 3 ) >= 0 ) && ( ( i - 2 ) >= 0 ) && ( ( i - 1 ) >= 0 ) && ( ( i - 0 ) >= 0 ) ){<br>                double result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) ;<br>                if ( ( max < result ) && ( max < n ) ) {<br>                    int max = result ;<br>                }<br>            }<br>            if ( ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) || ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) ){<br>                double result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) ;<br>                if ( ( max < result ) && ( max < n ) ) {<br>                    int max = result ;<br>                }<br>            }<br>        }<br>    }<br>    return max ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_PRODUCT_SUBSET_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  if ( n == 1 ) {<br>    return a [ 0 ] ;<br>  }<br>  int max_neg = Integer . MIN_VALUE ;<br>  int count_neg = 0 , count_zero = 0 ;<br>  int prod = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] == 0 ) {<br>      count_zero ++ ;<br>      continue ;<br>    }<br>    if ( a [ i ] < 0 ) {<br>      count_neg ++ ;<br>      max_neg = Math . max ( max_neg , a [ i ] ) ;<br>    }<br>    prod = prod * a [ i ] ;<br>  }<br>  if ( count_zero == n ) {<br>    return 0 ;<br>  }<br>  if ( count_neg % 2 == 1 ) {<br>    if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) {<br>      return 0 ;<br>    }<br>    prod = prod / max_neg ;<br>  }<br>  return prod ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    if ( n == 1 ){<br>        return a [ 0 ] ;<br>    }<br>    int maxNeg = - 999999999999 ;<br>    int count_neg = 0 ;<br>    int count_zero = 0 ;<br>    int prod = 1 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( a [ i ] == 0 ) a [ i ] = 5 ;<br>            count_zero ++ ;<br>            continue ;<br>        if ( a [ i ] < 0 ) a [ i ] = 5 ;<br>            count_neg ++ ;<br>            maxNeg = Math . max ( maxNeg , a [ i ] ) ;<br>        prod = prod * a [ i ] ;<br>    }<br>    if ( countZero == n ){<br>        return 0 ;<br>    }<br>    if ( countNeg & 1 ){<br>        if ( ( countNeg == 1 && countZero > 0 && countZero + countNeg == n ) || ( countZero + countNeg == n ) ) {<br>            return 0 ;<br>        }<br>        int prod = ( int ) ( prod / maxNeg ) ;<br>    }<br>    return prod ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int res = Integer . MIN_VALUE ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    int curr_sum = 0 ;<br>    for ( int j = 0 ;<br>    j < n ;<br>    j ++ ) {<br>      int index = ( i + j ) % n ;<br>      curr_sum += j * arr [ index ] ;<br>    }<br>    res = Math . max ( res , curr_sum ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int res = - Integer . MAX_VALUE ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        int currSum = 0 ;<br>        for ( int j = 0 ;  j <= n ;  j ++ ) {<br>            int index = ( int ) ( ( i + j ) % n ) ;<br>            currSum += j * arr [ index ] ;<br>        }<br>        res = Math . max ( res , currSum ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int N , int k ) {<br>  int maxSum = 0 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = N - 1 ;<br>  i > 0 ;<br>  -- i ) {<br>    if ( arr [ i ] - arr [ i - 1 ] < k ) {<br>      maxSum += arr [ i ] ;<br>      maxSum += arr [ i - 1 ] ;<br>      -- i ;<br>    }<br>  }<br>  return maxSum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int N , int k ) {<br>    int maxSum = 0 ;<br>    Arrays . sort ( arr , 0 , N ) ;<br>    int i = N - 1 ;<br>    while ( ( i >= 0 ) && ( i < N ) ) {<br>        if ( ( arr [ i ] - arr [ i - 1 ] < k ) && ( arr [ i ] - arr [ i - 2 ] < k ) ) {<br>            maxSum += arr [ i ] ;<br>            maxSum += arr [ i - 1 ] ;<br>            i -- ;<br>        }<br>        i -- ;<br>    }<br>    return maxSum ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int N , int k ) {<br>  int MS [ ] = new int [ N ] ;<br>  MS [ N - 1 ] = arr [ N - 1 ] ;<br>  for ( int i = N - 2 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ;<br>    else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ;<br>  }<br>  return MS [ 0 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int N , int k ) {<br>    int [ ] MS = new int [ N ] ;<br>    MS [ N - 1 ] = arr [ N - 1 ] ;<br>    for ( int i = N - 2 ;  i >= 0 ;  i -- ) {<br>        if ( ( i + k + 1 >= N ) && ( i + k + 1 >= N ) ){<br>            MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ;<br>        }<br>        else {<br>            MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ;<br>        }<br>    }<br>    return MS [ 0 ] ;<br>}</td>
  </tr><tr>
    <th>MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int mat [ ] [ ] , int N ) {<br>  int dp [ ] [ ] = new int [ N ] [ N ] ;<br>  dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < N ;<br>  i ++ ) for ( int j = 1 ;<br>  j < i + 1 && j < N ;<br>  j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] mat , int N ) {<br>    int [ ] [ ] dp = new int [ N ] [ N ] ;<br>    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;<br>    for ( int i = 1 ;  i < N ;  i ++ ) {<br>        dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ;<br>    }<br>    for ( int i = 1 ;  i < N ;  i ++ ) {<br>        for ( int j = 1 ;  j < Math . min ( i + 1 , N ) ;  j ++ ) {<br>            dp [ i ] [ j ] = mat [ i ] [ j ] + \<br>                return Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;<br>        }<br>    }<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < N ;  i ++ ) {<br>        if ( ( result < dp [ N - 1 ] [ i ] ) && ( result > 0 ) ){<br>            int result = dp [ N - 1 ] [ i ] ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int A [ ] , int B [ ] , int n ) {<br>  Arrays . sort ( A ) ;<br>  Arrays . sort ( B ) ;<br>  int result = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGold ( double [ ] A , double [ ] B , int n ) {<br>    Arrays . sort ( A ) ;<br>    Arrays . sort ( B ) ;<br>    int result = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        result += ( A [ i ] * B [ n - i - 1 ] ) ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_CHARACTERS_ADDED_FRONT_MAKE_STRING_PALINDROME</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String s ) {<br>  int l = s . length ( ) ;<br>  for ( int i = 0 , j = l - 1 ;<br>  i <= j ;<br>  i ++ , j -- ) {<br>    if ( s . charAt ( i ) != s . charAt ( j ) ) {<br>      return false ;<br>    }<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( String s ) {<br>    int l = s . length ( ) ;<br>    int i = 0 ;<br>    int j = l - 1 ;<br>    while ( i <= j ) {<br>        if ( ( s [ i ] != s [ j ] ) && ( s [ i ] != s [ j ] ) ) {<br>            return false ;<br>        }<br>        i ++ ;<br>        j -- ;<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_FOR_ACQUIRING_ALL_COINS_WITH_K_EXTRA_COINS_ALLOWED_WITH_EVERY_COIN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int coin [ ] , int n , int k ) {<br>  Arrays . sort ( coin ) ;<br>  int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i <= coins_needed - 1 ;<br>  i ++ ) ans += coin [ i ] ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] coin , int n , int k ) {<br>    coin . forEach ( i -> fGoldcoin ( coin , n , k ) ) ;<br>    coinsNeeded = Math . ceil ( 1.0 * n / ( k + 1 ) ) ;<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < coinsNeeded - 1 + 1 ;  i ++ ) {<br>        ans += coin [ i ] ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int [ ] a , int n ) {<br>  int min = a [ 0 ] ;<br>  for ( int i = 1 ;<br>  i < a . length ;<br>  i ++ ) {<br>    if ( a [ i ] < min ) min = a [ i ] ;<br>  }<br>  return ( n - 1 ) * min ;<br>}<br></td>
    <td>translated code: <br><br> static double f_gold ( double [ ] a , int n ) {<br>    return ( ( n - 1 ) * Math . min ( a , a . length ) ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_DIFFERENCE_BETWEEN_GROUPS_OF_SIZE_TWO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( long a [ ] , int n ) {<br>  Arrays . sort ( a ) ;<br>  int i , j ;<br>  Vector < Long > s = new Vector < > ( ) ;<br>  for ( i = 0 , j = n - 1 ;<br>  i < j ;<br>  i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ;<br>  long mini = Collections . min ( s ) ;<br>  long maxi = Collections . max ( s ) ;<br>  return Math . abs ( maxi - mini ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    Arrays . sort ( a ) ;<br>    String s [ ] = new String [ n ] ;<br>    int i = 0 ;<br>    int j = n - 1 ;<br>    while ( ( i < j ) && ( i < n ) ) {<br>        s . add ( ( a [ i ] + a [ j ] ) ) ;<br>        i ++ ;<br>        j -- ;<br>    }<br>    int mini = Math . min ( s , n ) ;<br>    int maxi = Math . max ( s ) ;<br>    return Math . abs ( maxi - mini ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_DIFFERENCE_MAX_MIN_K_SIZE_SUBSETS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int N , int K ) {<br>  Arrays . sort ( arr ) ;<br>  int res = 2147483647 ;<br>  for ( int i = 0 ;<br>  i <= ( N - K ) ;<br>  i ++ ) {<br>    int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ;<br>    res = Math . min ( res , curSeqDiff ) ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int N , int K ) {<br>    Arrays . sort ( arr , 0 , N ) ;<br>    int res = 2147483647 ;<br>    for ( int i = 0 ;  i < ( N - K ) + 1 ;  i ++ ) {<br>        int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ;<br>        res = Math . min ( res , curSeqDiff ) ;<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int mat [ ] [ ] , int n ) {<br>  int flip = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < i ;<br>  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;<br>  return flip ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] mat , int n ) {<br>    int flip = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < i ;  j ++ ) {<br>            if ( mat [ i ] [ j ] != mat [ j ] [ i ] ){<br>                flip ++ ;<br>            }<br>        }<br>    }<br>    return flip ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int k ) {<br>  Arrays . sort ( arr ) ;<br>  int max = arr [ arr . length - 1 ] ;<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;<br>    else res += ( max - arr [ i ] ) / k ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int n , int k ) {<br>    int max1 = Math . max ( arr ) ;<br>    int res = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( ( max1 - arr [ i ] ) % k != 0 ) && ( ( max1 - arr [ i ] ) % k != 0 ) ){<br>            return - 1 ;<br>        }<br>        else {<br>            res += ( max1 - arr [ i ] ) / k ;<br>        }<br>    }<br>    return ( int ) res ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int x ) {<br>  int curr_sum = 0 , min_len = n + 1 ;<br>  int start = 0 , end = 0 ;<br>  while ( end < n ) {<br>    while ( curr_sum <= x && end < n ) {<br>      if ( curr_sum <= 0 && x > 0 ) {<br>        start = end ;<br>        curr_sum = 0 ;<br>      }<br>      curr_sum += arr [ end ++ ] ;<br>    }<br>    while ( curr_sum > x && start < n ) {<br>      if ( end - start < min_len ) min_len = end - start ;<br>      curr_sum -= arr [ start ++ ] ;<br>    }<br>  }<br>  return min_len ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int x ) {<br>    int currSum = 0 ;<br>    int minLen = n + 1 ;<br>    int start = 0 ;<br>    int end = 0 ;<br>    while ( ( end < n ) && ( end < arr . length ) ) {<br>        while ( ( currSum <= x && end < n ) || ( currSum > x && end < n ) ) {<br>            if ( ( currSum <= 0 && x > 0 ) || ( currSum > n && x < n ) ) {<br>                int start = end ;<br>                int currSum = 0 ;<br>            }<br>            currSum += arr [ end ] ;<br>            end ++ ;<br>        }<br>        while ( ( currSum > x && start < n ) || ( currSum < x && start < n ) ) {<br>            if ( ( end - start ) < minLen ){<br>                int min_len = end - start ;<br>            }<br>            currSum -= arr [ start ] ;<br>            start ++ ;<br>        }<br>    }<br>    return minLen ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_NUMBER_PLATFORMS_REQUIRED_RAILWAYBUS_STATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int dep [ ] , int n ) {<br>  Arrays . sort ( arr ) ;<br>  Arrays . sort ( dep ) ;<br>  int plat_needed = 1 , result = 1 ;<br>  int i = 1 , j = 0 ;<br>  while ( i < n && j < n ) {<br>    if ( arr [ i ] <= dep [ j ] ) {<br>      plat_needed ++ ;<br>      i ++ ;<br>      if ( plat_needed > result ) result = plat_needed ;<br>    }<br>    else {<br>      plat_needed -- ;<br>      j ++ ;<br>    }<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int [ ] dep , int n ) {<br>    Arrays . sort ( arr , dep , n ) ;<br>    Arrays . sort ( dep ) ;<br>    plat_needed = 1 ;<br>    int result = 1 ;<br>    int i = 1 ;<br>    int j = 0 ;<br>    while ( ( i < n && j < n ) || ( i < n && j < n ) ) {<br>        if ( ( arr [ i ] < dep [ j ] ) && ( arr [ i ] > dep [ j ] ) ) {<br>            plat_needed ++ ;<br>            i ++ ;<br>            if ( ( plat_needed > result ) && ( dep > n ) ) {<br>                int result = plat_needed ;<br>            }<br>        }<br>        else {<br>            plat_needed -- ;<br>            j ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_PRODUCT_SUBSET_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  if ( n == 1 ) return a [ 0 ] ;<br>  int negmax = Integer . MIN_VALUE ;<br>  int posmin = Integer . MAX_VALUE ;<br>  int count_neg = 0 , count_zero = 0 ;<br>  int product = 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( a [ i ] == 0 ) {<br>      count_zero ++ ;<br>      continue ;<br>    }<br>    if ( a [ i ] < 0 ) {<br>      count_neg ++ ;<br>      negmax = Math . max ( negmax , a [ i ] ) ;<br>    }<br>    if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ;<br>    product *= a [ i ] ;<br>  }<br>  if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ;<br>  if ( count_neg == 0 ) return posmin ;<br>  if ( count_neg % 2 == 0 && count_neg != 0 ) {<br>    product = product / negmax ;<br>  }<br>  return product ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    if ( ( n == 1 ) && ( a == 5 ) ) {<br>        return a [ 0 ] ;<br>    }<br>    float maxNeg = Float . NEGATIVE_INFINITY ;<br>    int minPos = Integer . MAX_VALUE ;<br>    int count_neg = 0 ;<br>    int count_zero = 0 ;<br>    int prod = 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( a [ i ] == 0 ) && ( n > 0 ) ) {<br>            count_zero = count_zero + 1 ;<br>            continue ;<br>        }<br>        if ( ( a [ i ] < 0 ) && ( a [ i ] > n ) ) a [ i ] = 5 ;<br>            count_neg = count_neg + 1 ;<br>            maxNeg = Math . max ( maxNeg , a [ i ] ) ;<br>        if ( ( a [ i ] > 0 ) && ( a [ i ] < n ) ) a [ i ] = 5 ;<br>            min_pos = Math . min ( min_pos , a [ i ] ) ;<br>        prod = prod * a [ i ] ;<br>    }<br>    if ( ( countZero == n || ( countNeg == 0 && countZero > 0 ) ) && ( countNeg == 0 || countZero == 0 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( countNeg == 0 ) && ( n > 0 ) ){<br>        return minPos ;<br>    }<br>    if ( ( ( countNeg & 1 ) == 0 && countNeg != 0 ) || ( ( countNeg & 1 ) == 0 && countNeg != 1 ) ){<br>        int prod = ( int ) ( prod / maxNeg ) ;<br>    }<br>    return prod ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int input , int unlock_code ) {<br>  int rotation = 0 ;<br>  int input_digit , code_digit ;<br>  while ( input > 0 || unlock_code > 0 ) {<br>    input_digit = input % 10 ;<br>    code_digit = unlock_code % 10 ;<br>    rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ;<br>    input /= 10 ;<br>    unlock_code /= 10 ;<br>  }<br>  return rotation ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGoldenCode ( int input , int unlockCode ) {<br>    int rotation = 0 ;<br>    while ( ( input > 0 || unlockCode > 0 ) && ( input > 0 || unlockCode > 0 ) ) {<br>        int inputDigit = input % 10 ;<br>        int codeDigit = unlockCode % 10 ;<br>        rotation += Math . min ( Math . abs ( inputDigit - codeDigit ) , 10 - Math . abs ( inputDigit - codeDigit ) ) ;<br>        input = ( int ) ( input / 10 ) ;<br>        unLockCode = ( int ) ( unLockCode / 10 ) ;<br>    }<br>    return rotation ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEMENTS_PICKED_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int ar [ ] , int n ) {<br>  if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ;<br>  int [ ] sum = new int [ n ] ;<br>  sum [ 0 ] = ar [ 0 ] ;<br>  sum [ 1 ] = ar [ 1 ] ;<br>  sum [ 2 ] = ar [ 2 ] ;<br>  sum [ 3 ] = ar [ 3 ] ;<br>  for ( int i = 4 ;<br>  i < n ;<br>  i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ;<br>  return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] ar , int n ) {<br>    if ( ( n <= 4 ) && ( ar > 0 ) ) {<br>        return Math . min ( ar . length , n ) ;<br>    }<br>    int [ ] sum = new int [ n ] ;<br>    sum [ 0 ] = ar [ 0 ] ;<br>    sum [ 1 ] = ar [ 1 ] ;<br>    sum [ 2 ] = ar [ 2 ] ;<br>    sum [ 3 ] = ar [ 3 ] ;<br>    for ( int i = 4 ;  i < n ;  i ++ ) {<br>        sum [ i ] = ar [ i ] + Math . min ( sum [ i - 4 ] , ar [ i ] ) ;<br>    }<br>    return Math . min ( sum [ n - 4 ] , ar [ n - 4 ] ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  Arrays . sort ( a ) ;<br>  int num1 = 0 ;<br>  int num2 = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ;<br>    else num2 = num2 * 10 + a [ i ] ;<br>  }<br>  return num2 + num1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    a = Collections . sort ( a ) ;<br>    int num1 = 0 , num2 = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( i % 2 == 0 ){<br>            num1 = num1 * 10 + a [ i ] ;<br>        }<br>        if ( n > 0 ) {<br>            num2 = num2 * 10 + a [ i ] ;<br>        }<br>    }<br>    return num2 + num1 ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_SWAPS_REQUIRED_BRING_ELEMENTS_LESS_EQUAL_K_TOGETHER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int k ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) if ( arr [ i ] <= k ) ++ count ;<br>  int bad = 0 ;<br>  for ( int i = 0 ;<br>  i < count ;<br>  ++ i ) if ( arr [ i ] > k ) ++ bad ;<br>  int ans = bad ;<br>  for ( int i = 0 , j = count ;<br>  j < n ;<br>  ++ i , ++ j ) {<br>    if ( arr [ i ] > k ) -- bad ;<br>    if ( arr [ j ] > k ) ++ bad ;<br>    ans = Math . min ( ans , bad ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int arr [ ] , int n , int k ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] <= k ) && ( arr [ i ] > 0 ) ) {<br>            count = count + 1 ;<br>        }<br>    }<br>    int bad = 0 ;<br>    for ( int i = 0 ;  i <= count ;  i ++ ) {<br>        if ( ( arr [ i ] > k ) && ( arr [ i ] < n ) ) {<br>            bad = bad + 1 ;<br>        }<br>    }<br>    int ans = bad ;<br>    int j = count ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( j == n ) && ( k == n ) ) {<br>            break ;<br>        }<br>        if ( ( arr [ i ] > k ) && ( arr [ i ] < n ) ) {<br>            bad = bad - 1 ;<br>        }<br>        if ( ( arr [ j ] > k ) && ( arr [ j ] > n ) ) {<br>            bad = bad + 1 ;<br>        }<br>        ans = Math . min ( ans , bad ) ;<br>        j = j + 1 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_TIME_TO_FINISH_TASKS_WITHOUT_SKIPPING_TWO_CONSECUTIVE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  if ( n <= 0 ) return 0 ;<br>  int incl = arr [ 0 ] ;<br>  int excl = 0 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    int incl_new = arr [ i ] + Math . min ( excl , incl ) ;<br>    int excl_new = incl ;<br>    incl = incl_new ;<br>    excl = excl_new ;<br>  }<br>  return Math . min ( incl , excl ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    if ( ( n <= 0 ) && ( n > 0 ) ) {<br>        return 0 ;<br>    }<br>    int incl = arr [ 0 ] ;<br>    int excl = 0 ;<br>    for ( int i = 1 ;  i < n ;  i ++ ) {<br>        int inclNew = arr [ i ] + Math . min ( excl , incl ) ;<br>        excl_new = incl ;<br>        Incl incl = inclNew ;<br>        Excl excl = new Excl ( ) ;<br>    }<br>    return Math . min ( incl , excl ) ;<br>}</td>
  </tr><tr>
    <th>MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int N , int insert , int remove , int copy ) {<br>  if ( N == 0 ) return 0 ;<br>  if ( N == 1 ) return insert ;<br>  int dp [ ] = new int [ N + 1 ] ;<br>  for ( int i = 1 ;<br>  i <= N ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ;<br>    else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ;<br>  }<br>  return dp [ N ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int N , int insrt , int remov , int cpy ) {<br>    if ( N == 0 ) {<br>        return 0 ;<br>    }<br>    if ( N == 1 ) {<br>        return insrt ;<br>    }<br>    int [ ] dp = new int [ N + 1 ] ;<br>    for ( int i = 1 ;  i <= N ;  i ++ ) {<br>        if ( i % 2 == 0 ){<br>            dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ i / 2 ] + cpy ) ;<br>        }<br>        else {<br>            dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) / 2 ] + cpy + remov ) ;<br>        }<br>    }<br>    return dp [ N ] ;<br>}</td>
  </tr><tr>
    <th>MOBILE_NUMERIC_KEYPAD_PROBLEM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( char keypad [ ] [ ] , int n ) {<br>  if ( keypad == null || n <= 0 ) return 0 ;<br>  if ( n == 1 ) return 10 ;<br>  int [ ] odd = new int [ 10 ] ;<br>  int [ ] even = new int [ 10 ] ;<br>  int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ;<br>  for ( i = 0 ;<br>  i <= 9 ;<br>  i ++ ) odd [ i ] = 1 ;<br>  for ( j = 2 ;<br>  j <= n ;<br>  j ++ ) {<br>    useOdd = 1 - useOdd ;<br>    if ( useOdd == 1 ) {<br>      even [ 0 ] = odd [ 0 ] + odd [ 8 ] ;<br>      even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ;<br>      even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ;<br>      even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ;<br>      even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ;<br>      even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ;<br>      even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ;<br>      even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ;<br>      even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ;<br>      even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ;<br>    }<br>    else {<br>      odd [ 0 ] = even [ 0 ] + even [ 8 ] ;<br>      odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ;<br>      odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ;<br>      odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ;<br>      odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ;<br>      odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ;<br>      odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ;<br>      odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ;<br>      odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ;<br>      odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ;<br>    }<br>  }<br>  totalCount = 0 ;<br>  if ( useOdd == 1 ) {<br>    for ( i = 0 ;<br>    i <= 9 ;<br>    i ++ ) totalCount += even [ i ] ;<br>  }<br>  else {<br>    for ( i = 0 ;<br>    i <= 9 ;<br>    i ++ ) totalCount += odd [ i ] ;<br>  }<br>  return totalCount ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( boolean keypad , int n ) {<br>    if ( ( ! keypad || n <= 0 ) && ( keypad || n > 1 ) ) {<br>        return 0 ;<br>    }<br>    if ( ( n == 1 ) && ( keypad . getKeypad ( ) == keypad ) ) {<br>        return 10 ;<br>    }<br>    int [ ] odd = new int [ 10 ] ;<br>    even = new int [ 10 ] ;<br>    int i = 0 ;<br>    int j = 0 ;<br>    useOdd = 0 ;<br>    int totalCount = 0 ;<br>    for ( int i = 0 ;  i < 10 ;  i ++ ) {<br>        odd [ i ++ ] = 1 ;<br>    }<br>    for ( int j = 2 ;  j <= n ;  j ++ ) {<br>        useOdd = 1 - useOdd ;<br>        if ( ( useOdd == 1 ) && ( n > 0 ) ) {<br>            even [ 0 ] = odd [ 0 ] + odd [ 8 ] ;<br>            even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ;<br>            even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ;<br>            even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ;<br>            even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ;<br>            even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ;<br>            even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ;<br>            even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ;<br>            even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ;<br>            even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ;<br>        }<br>        else {<br>            odd [ 0 ] = even [ 0 ] + even [ 8 ] ;<br>            odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ;<br>            odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ;<br>            odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ;<br>            odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ;<br>            odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ;<br>            odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ;<br>            odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ;<br>            odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ;<br>            odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ;<br>        }<br>    }<br>    int totalCount = 0 ;<br>    if ( ( useOdd == 1 ) && ( n > 0 ) ) {<br>        for ( int i = 0 ;  i < 10 ;  i ++ ) {<br>            totalCount += even [ i ] ;<br>        }<br>    }<br>    else {<br>        for ( int i = 0 ;  i < 10 ;  i ++ ) {<br>            totalCount += odd [ i ] ;<br>        }<br>    }<br>    return totalCount ;<br>}</td>
  </tr><tr>
    <th>MULTIPLY_AN_INTEGER_WITH_3_5</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x ) {<br>  return ( x << 1 ) + x + ( x >> 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int x ) {<br>    return ( x << 1 ) + x + ( x >> 1 ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_IS_DIVISIBLE_BY_29_OR_NOT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( long n ) {<br>  while ( n / 100 > 0 ) {<br>    int last_digit = ( int ) n % 10 ;<br>    n /= 10 ;<br>    n += last_digit * 3 ;<br>  }<br>  return ( n % 29 == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int n ) {<br>    while ( ( int ) ( n / 100 ) ) {<br>        lastDigit = ( int ) ( n % 10 ) ;<br>        n = ( int ) ( n / 10 ) ;<br>        n += last_digit * 3 ;<br>    }<br>    return ( n % 29 == 0 ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_N_DIGIT_STEPPING_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( int n ) {<br>  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;<br>  if ( n == 1 ) return 10 ;<br>  for ( int j = 0 ;<br>  j <= 9 ;<br>  j ++ ) dp [ 1 ] [ j ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= 9 ;<br>    j ++ ) {<br>      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ;<br>    }<br>  }<br>  long sum = 0 ;<br>  for ( int j = 1 ;<br>  j <= 9 ;<br>  j ++ ) sum += dp [ n ] [ j ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] [ ] dp = new int [ 10 ] [ n + 1 ] ;<br>    if ( ( n == 1 ) && ( n == 2 ) ) {<br>        return 10 ;<br>    }<br>    for ( int j = 0 ;  j < 10 ;  j ++ ) {<br>        dp [ 1 ] [ j ] = 1 ;<br>    }<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j < 10 ;  j ++ ) {<br>            if ( ( j == 0 ) && ( n == 0 ) ) {<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;<br>            }<br>            }<br>                dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;<br>            }<br>                dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ;<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int j = 1 ;  j <= 10 ;  j ++ ) {<br>        sum = sum + dp [ n ] [ j ] ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>NUMBER_OF_SUBSTRINGS_WITH_ODD_DECIMAL_VALUE_IN_A_BINARY_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  int [ ] auxArr = new int [ n ] ;<br>  if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ;<br>    else auxArr [ i ] = auxArr [ i - 1 ] ;<br>  }<br>  int count = 0 ;<br>  for ( int i = n - 1 ;<br>  i >= 0 ;<br>  i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ;<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int n = s . length ( ) ;<br>    int [ ] auxArr = new int [ n ] ;<br>    if ( ( s . charAt ( 0 ) == '1' ) && ( s . charAt ( 1 ) == '1' ) ) {<br>        auxArr [ 0 ] = 1 ;<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == '1' ) && ( s . charAt ( i + 1 ) == '2' ) ) {<br>            auxArr [ i ] = auxArr [ i - 1 ] + 1 ;<br>        }<br>        }<br>            auxArr [ i ] = auxArr [ i - 1 ] ;<br>    }<br>    int count = 0 ;<br>    for ( int i = n - 1 ;  i >= 0 ;  i -- ) {<br>        if ( ( s . charAt ( i ) == '1' ) && ( s . charAt ( i + 1 ) == '2' ) ) {<br>            count += auxArr [ i ] ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>NUMBER_OF_TRIANGLES_IN_A_PLANE_IF_NO_MORE_THAN_TWO_POINTS_ARE_COLLINEAR</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return n * ( n - 1 ) * ( n - 2 ) / 6 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    return ( n * ( n - 1 ) * ( n - 2 ) / 6 ) ;<br>}</td>
  </tr><tr>
    <th>NUMBER_ORDERED_PAIRS_AI_AJ_0</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a [ ] , int n ) {<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < n ;{<br>            if ( ( a [ i ] & a [ j ] ) == 0 ) a [ i ] = 5 ;<br>                count += 2 ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>NUMBER_SUBSTRINGS_DIVISIBLE_4_STRING_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  int count = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) if ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) count ++ ;<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  ++ i ) {<br>    int h = ( s . charAt ( i ) - '0' ) * 10 + ( s . charAt ( i + 1 ) - '0' ) ;<br>    if ( h % 4 == 0 ) count = count + i + 1 ;<br>  }<br>  return count ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s ) {<br>    int n = s . length ( ) ;<br>    int count = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i += 1 ) {<br>        if ( ( s . charAt ( i ) == '4' || s . charAt ( i ) == '8' || s . charAt ( i ) == '0' ) && ( s . charAt ( i ) == 'a' || s . charAt ( i ) == 'b' || s . charAt ( i ) == 'c' ) ) {<br>            count ++ ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n - 1 ;  i += 1 ) {<br>        int h = ( Character . digit ( s . charAt ( i ) , 16 ) - '0' ) * 10 + ( Character . digit ( s . charAt ( i + 1 ) , 16 ) - '0' ) ;<br>        if ( ( h % 4 == 0 ) && ( h % 5 == 0 ) ) {<br>            count = count + i + 1 ;<br>        }<br>    }<br>    return count ;<br>}</td>
  </tr><tr>
    <th>NUMBER_TRIANGLES_N_MOVES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n ) {<br>  int [ ] answer = new int [ n + 1 ] ;<br>  answer [ 0 ] = 1 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) answer [ i ] = answer [ i - 1 ] * 3 + 2 ;<br>  return answer [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    Object [ ] answer = {<br>    }<br>    answer [ 0 ] = 1 ;<br>    int i = 1 ;<br>    while ( i <= n ) {<br>        answer [ i ] = answer [ i - 1 ] * 3 + 2 ;<br>        i = i + 1 ;<br>    }<br>    return answer [ n ] ;<br>}</td>
  </tr><tr>
    <th>NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int ans = 0 ;<br>  for ( int length = 1 ;<br>  length <= Math . sqrt ( n ) ;<br>  ++ length ) for ( int height = length ;<br>  height * length <= n ;<br>  ++ height ) ans ++ ;<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int ans = 0 ;<br>    for ( int length = 1 ;  length <= Integer . MAX_VALUE ;  length ++ ) {<br>        height = length ;<br>        while ( ( height * length <= n ) && ( height * length <= n ) ) {<br>            ans ++ ;<br>            height ++ ;<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>NUMBER_WAYS_NODE_MAKE_LOOP_SIZE_K_UNDIRECTED_COMPLETE_CONNECTED_GRAPH_N_NODES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int k ) {<br>  int p = 1 ;<br>  if ( k % 2 != 0 ) p = - 1 ;<br>  return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenN ( int n , int k ) {<br>    int p = 1 ;<br>    if ( ( k % 2 ) != 0 ){<br>        int p = - 1 ;<br>    }<br>    return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ;<br>}</td>
  </tr><tr>
    <th>N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n ) {<br>  int nthElement = 19 + ( n - 1 ) * 9 ;<br>  int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ;<br>  nthElement += 9 * outliersCount ;<br>  return nthElement ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    int nthElement = 19 + ( n - 1 ) * 9 ;<br>    outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ;<br>    nthElement += 9 * outliersCount ;<br>    return nthElement ;<br>}</td>
  </tr><tr>
    <th>N_TH_TERM_SERIES_2_12_36_80_150</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int n ) {<br>  return ( n * n ) + ( n * n * n ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    return ( n * n ) + ( n * n * n ) ;<br>}</td>
  </tr><tr>
    <th>PAINTING_FENCE_ALGORITHM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( int n , int k ) {<br>  long total = k ;<br>  int mod = 1000000007 ;<br>  int same = 0 , diff = k ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) {<br>    same = diff ;<br>    diff = ( int ) total * ( k - 1 ) ;<br>    diff = diff % mod ;<br>    total = ( same + diff ) % mod ;<br>  }<br>  return total ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n , int k ) {<br>    total = k ;<br>    int mod = 1000000007 ;<br>    int same = 0 , diff = k ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        same = diff ;<br>        int diff = total * ( k - 1 ) ;<br>        diff = diff % mod ;<br>        total = ( same + diff ) % mod ;<br>    }<br>    return total ;<br>}</td>
  </tr><tr>
    <th>PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int arr [ ] , int n , int x ) {<br>  for ( int i = 0 ;<br>  i < n - 1 ;<br>  i ++ ) for ( int j = i + 1 ;<br>  j < n ;<br>  j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ;<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( int [ ] arr , int n , int x ) {<br>    for ( int i = 0 ;  i < arr . length ;  i ++ ) {<br>        for ( int j = 0 ;  j < arr . length ;  j ++ ) {<br>            if ( i * j == x ) {<br>                return f_gold ( arr , n , x , null ) ;<br>            }<br>        }<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>PERFECT_REVERSIBLE_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String str ) {<br>  int i = 0 , j = str . length ( ) - 1 ;<br>  while ( i < j ) {<br>    if ( str . charAt ( i ) != str . charAt ( j ) ) return false ;<br>    i ++ ;<br>    j -- ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( String str ) {<br>    int i = 0 ;<br>    while ( ( i < j ) && ( i < j ) ) {<br>        if ( ( str . charAt ( i ) != str . charAt ( j ) ) && ( str . charAt ( i ) != str . charAt ( j ) ) ) {<br>            return false ;<br>        }<br>        i ++ ;<br>        j -- ;<br>    }<br>    return fGoldString ( str , true ) ;<br>}</td>
  </tr><tr>
    <th>PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return 1 + n * ( n + 1 ) / 2 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGoldenN ( int n ) {<br>    return ( int ) ( 1 + n * ( n + 1 ) / 2 ) ;<br>}</td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int n ) {<br>  if ( n <= 1 ) return false ;<br>  if ( n <= 3 ) return true ;<br>  if ( n % 2 == 0 || n % 3 == 0 ) return false ;<br>  for ( int i = 5 ;<br>  i * i <= n ;<br>  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int n ) {<br>    if ( ( n <= 1 ) && ( n > 2 ) ) {<br>        return false ;<br>    }<br>    if ( ( n <= 3 ) && ( n > 0 ) ) {<br>        return fGoldenNum ( n , true ) ;<br>    }<br>    if ( ( n % 2 == 0 || n % 3 == 0 ) && ( n % 4 == 0 ) ) {<br>        return false ;<br>    }<br>    int i = 5 ;<br>    while ( ( i * i <= n ) && ( i * i <= n ) ){<br>        if ( ( n % i == 0 || n % ( i + 2 ) == 0 ) && ( n % i == 0 || n % i == 0 ) ) {<br>            return false ;<br>        }<br>        i = i + 6 ;<br>    }<br>    return fGoldenNum ( n , true ) ;<br>}</td>
  </tr><tr>
    <th>PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int p ) {<br>  double checkNumber = Math . pow ( 2 , p ) - 1 ;<br>  double nextval = 4 % checkNumber ;<br>  for ( int i = 1 ;<br>  i < p - 1 ;<br>  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;<br>  return ( nextval == 0 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int p ) {<br>    int checkNumber = 2 * p - 1 ;<br>    nextval = 4 % checkNumber ;<br>    for ( int i = 1 ;  i <= p - 1 ;  i ++ ) {<br>        nextval = ( nextval * nextval - 2 ) % checkNumber ;<br>    }<br>    if ( ( nextval == 0 ) && ( p > 0 ) ) {<br>        return true ;<br>    }<br>    }<br>        return false ;<br>}</td>
  </tr><tr>
    <th>PRINT_WORDS_STRING_REVERSE_ORDER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String f_gold ( String str ) {<br>  int i = str . length ( ) - 1 ;<br>  int start , end = i + 1 ;<br>  String result = "" ;<br>  while ( i >= 0 ) {<br>    if ( str . charAt ( i ) == ' ' ) {<br>      start = i + 1 ;<br>      while ( start != end ) result += str . charAt ( start ++ ) ;<br>      result += ' ' ;<br>      end = i ;<br>    }<br>    i -- ;<br>  }<br>  start = 0 ;<br>  while ( start != end ) result += str . charAt ( start ++ ) ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String str ) {<br>    int i = str . length ( ) - 1 ;<br>    start = end = i ++ ;<br>    String result = "" ;<br>    while ( i >= 0 ) {<br>        if ( str . charAt ( i ) == ' ' ) {<br>            int start = i ++ ;<br>            while ( start != end ) {<br>                result += str . charAt ( start ) ;<br>                start ++ ;<br>            }<br>            result += " " ;<br>            int end = i ;<br>        }<br>        i -- ;<br>    }<br>    int start = 0 ;<br>    while ( start != end ) {<br>        result += str . charAt ( start ) ;<br>        start ++ ;<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_BINARY_DECIMAL_CONVERSION_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String n ) {<br>  String num = n ;<br>  int dec_value = 0 ;<br>  int base = 1 ;<br>  int len = num . length ( ) ;<br>  for ( int i = len - 1 ;<br>  i >= 0 ;<br>  i -- ) {<br>    if ( num . charAt ( i ) == '1' ) dec_value += base ;<br>    base = base * 2 ;<br>  }<br>  return dec_value ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    int num = n ;<br>    int decValue = 0 ;<br>    int base1 = 1 ;<br>    int len1 = num . length ;<br>    for ( int i = len1 - 1 ;  i >= 0 ;  i -- ) {<br>        if ( ( num [ i ] == '1' ) && ( num [ i ] != '0' ) ) {<br>            decValue ++ ;<br>        }<br>        base1 = base1 * 2 ;<br>    }<br>    return decValue ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_AREA_OCTAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double f_gold ( double side ) {<br>  return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldSquare ( double side ) {<br>    return ( 2 * ( 1 + ( Math . sqrt ( 2 ) ) ) * side * side ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_VOLUME_ELLIPSOID</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static float f_gold ( float r1 , float r2 , float r3 ) {<br>  float pi = ( float ) 3.14 ;<br>  return ( float ) 1.33 * pi * r1 * r2 * r3 ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenRatio ( double r1 , double r2 , double r3 ) {<br>    return 1.33 * Math . PI * r1 * r2 * r3 ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CALCULATE_VOLUME_OCTAHEDRON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static double f_gold ( double side ) {<br>  return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static float fGold ( int side ) {<br>    return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_CIRCUMFERENCE_PARALLELOGRAM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float f_gold ( float a , float b ) {<br>  return ( ( 2 * a ) + ( 2 * b ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int a , int b ) {<br>    return ( ( 2 * a ) + ( 2 * b ) ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( String s , char c ) {<br>  int res = 0 ;<br>  for ( int i = 0 ;<br>  i < s . length ( ) ;<br>  i ++ ) {<br>    if ( s . charAt ( i ) == c ) res ++ ;<br>  }<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( String s , char c ) {<br>    int res = 0 ;<br>    for ( int i = 0 ;  i < s . length ( ) ;  i ++ ) {<br>        if ( ( s . charAt ( i ) == c ) && ( s . charAt ( i + 1 ) == c ) ) {<br>            res = res + 1 ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n == 0 ) return 1 ;<br>  return n * f_gold ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? 0 : n * fGold ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int res = 1 , i ;<br>  for ( i = 2 ;<br>  i <= n ;<br>  i ++ ) res *= i ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? 0 : n * fGold ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return ( n == 1 || n == 0 ) ? 1 : n * f_gold ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return 1 == ( n == 1 || n == 0 ) ? 0 : n * fGold ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_PAGE_REPLACEMENT_ALGORITHMS_SET_2_FIFO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int pages [ ] , int n , int capacity ) {<br>  HashSet < Integer > s = new HashSet < > ( capacity ) ;<br>  Queue < Integer > indexes = new LinkedList < > ( ) ;<br>  int page_faults = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( s . size ( ) < capacity ) {<br>      if ( ! s . contains ( pages [ i ] ) ) {<br>        s . add ( pages [ i ] ) ;<br>        page_faults ++ ;<br>        indexes . add ( pages [ i ] ) ;<br>      }<br>    }<br>    else {<br>      if ( ! s . contains ( pages [ i ] ) ) {<br>        int val = indexes . peek ( ) ;<br>        indexes . poll ( ) ;<br>        s . remove ( val ) ;<br>        s . add ( pages [ i ] ) ;<br>        indexes . add ( pages [ i ] ) ;<br>        page_faults ++ ;<br>      }<br>    }<br>  }<br>  return page_faults ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] pages , int n , int capacity ) {<br>    Set s = new HashSet ( ) ;<br>    Queue < Integer > indexes = new Queue < > ( ) ;<br>    pageFaults = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( s . length ( ) < capacity ) && ( s . length ( ) > n ) ) {<br>            if ( ( pages [ i ] != s ) && ( n > 0 ) ) {<br>                s . add ( pages [ i ] ) ;<br>                pageFaults ++ ;<br>                indexes . put ( pages [ i ] , capacity ) ;<br>            }<br>        }<br>        else {<br>            if ( ( pages [ i ] != s ) && ( n > 0 ) ) {<br>                val index = indexes . queue . get ( 0 ) ;<br>                indexes . get ( ) ;<br>                s . remove ( val ) ;<br>                s . add ( pages [ i ] ) ;<br>                indexes . put ( pages [ i ] , capacity ) ;<br>                pageFaults ++ ;<br>            }<br>        }<br>    }<br>    return new PageFaults ( pages , n , capacity ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( long n ) {<br>  return ( int ) Math . pow ( n , 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGoldenN ( double n ) {<br>    return Math . pow ( n , 2 ) ;<br>}</td>
  </tr><tr>
    <th>PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static float f_gold ( float a ) {<br>  float area ;<br>  area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ;<br>  return area ;<br>}<br></td>
    <td>translated code: <br><br> public static double f_gold ( double a ) {<br>    double area = ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) ) * a * a ) / 4 ;<br>    return area ;<br>}</td>
  </tr><tr>
    <th>PYTHAGOREAN_QUADRUPLE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static Boolean f_gold ( int a , int b , int c , int d ) {<br>  int sum = a * a + b * b + c * c ;<br>  if ( d * d == sum ) return true ;<br>  else return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( double a , double b , double c , double d ) {<br>    int sum = a * a + b * b + c * c ;<br>    if ( ( d * d == sum ) && ( a == 5 ) ){<br>        return true ;<br>    }<br>    }<br>        return false ;<br>}</td>
  </tr><tr>
    <th>PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int l , int w ) {<br>  return ( 2 * ( l + w ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int l , int w ) {<br>    return ( 2 * ( l + w ) ) ;<br>}</td>
  </tr><tr>
    <th>QUICK_WAY_CHECK_CHARACTERS_STRING</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( String s ) {<br>  int n = s . length ( ) ;<br>  for ( int i = 1 ;<br>  i < n ;<br>  i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ;<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean fGold ( String s ) {<br>    int n = s . length ( ) ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        if ( s . charAt ( i ) != s . charAt ( 0 ) ){<br>            return false ;<br>        }<br>    }<br>    return true ;<br>}</td>
  </tr><tr>
    <th>REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static void f_gold ( int arr [ ] , int n ) {<br>  int max_idx = n - 1 , min_idx = 0 ;<br>  int max_elem = arr [ n - 1 ] + 1 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( i % 2 == 0 ) {<br>      arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ;<br>      max_idx -- ;<br>    }<br>    else {<br>      arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ;<br>      min_idx ++ ;<br>    }<br>  }<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = arr [ i ] / max_elem ;<br>}<br></td>
    <td>translated code: <br><br> public static void f_gold ( int arr [ ] , int n ) {<br>    int maxIdx = n - 1 ;<br>    int minIdx = 0 ;<br>    int maxElem = arr [ n - 1 ] + 1 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( i % 2 == 0 ) {<br>            arr [ i ] += ( arr [ maxIdx ] % maxElem ) * maxElem ;<br>            maxIdx -- ;<br>        }<br>        if ( n > 0 ) {<br>            arr [ i ] += ( arr [ minIdx ] % maxElem ) * maxElem ;<br>            minIdx ++ ;<br>        }<br>    }<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        arr [ i ] = arr [ i ] / maxElem ;<br>    }<br>}</td>
  </tr><tr>
    <th>RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n == 0 || n == 1 ) return n ;<br>  return Math . max ( ( f_gold ( n / 2 ) + f_gold ( n / 3 ) + f_gold ( n / 4 ) ) , n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGoldCount ( int n ) {<br>    if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) {<br>        return n ;<br>    }<br>    return Math . max ( ( fGoldenCount ( n / 2 ) + fGoldenCount ( n / 3 ) + fGoldenCount ( n / 4 ) ) , n ) ;<br>}</td>
  </tr><tr>
    <th>RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int dp [ ] = new int [ n + 1 ] ;<br>  dp [ 0 ] = 0 ;<br>  dp [ 1 ] = 1 ;<br>  for ( int i = 2 ;<br>  i <= n ;<br>  i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ;<br>  return dp [ n ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    int [ ] dp = new int [ n + 1 ] ;<br>    dp [ 0 ] = 0 ;<br>    dp [ 1 ] = 1 ;<br>    for ( int i = 2 ;  i <= n ;  i ++ ) {<br>        dp [ i ] = Math . max ( dp [ ( int ) ( i / 2 ) ] + dp [ ( int ) ( i / 3 ) ] + dp [ ( int ) ( i / 4 ) ] , i ) ;<br>    }<br>    return dp [ n ] ;<br>}</td>
  </tr><tr>
    <th>RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int l , int r , int x ) {<br>  if ( r < l ) return - 1 ;<br>  if ( arr [ l ] == x ) return l ;<br>  if ( arr [ r ] == x ) return r ;<br>  return f_gold ( arr , l + 1 , r - 1 , x ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] arr , int l , int r , int x ) {<br>    if ( r < l ){<br>        return - 1 ;<br>    }<br>    if ( arr [ l ] == x ) {<br>        return l ;<br>    }<br>    if ( arr [ r ] == x ) {<br>        return r ;<br>    }<br>    return fGold ( arr , l + 1 , r - 1 , x ) ;<br>}</td>
  </tr><tr>
    <th>REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) {<br>  if ( low == high ) {<br>    return a [ low ] * turn ;<br>  }<br>  if ( dp [ low ] [ high ] != 0 ) {<br>    return dp [ low ] [ high ] ;<br>  }<br>  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + f_gold ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + f_gold ( dp , a , low , high - 1 , turn + 1 ) ) ;<br>  return dp [ low ] [ high ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] [ ] dp , int [ ] a , int low , int high , int turn ) {<br>    if ( ( low == high ) && ( turn == 0 ) ) {<br>        return a [ low ] * turn ;<br>    }<br>    if ( ( dp [ low ] [ high ] != 0 ) && ( dp [ high ] [ turn ] != 0 ) ){<br>        return dp [ low ] [ high ] ;<br>    }<br>    dp [ low ] [ high ] = Math . max ( a [ low ] * turn + fGold ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + fGold ( dp , a , low , high - 1 , turn + 1 ) ) ;<br>    return dp [ low ] [ high ] ;<br>}</td>
  </tr><tr>
    <th>REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int longest_start = - 1 , longest_end = 0 ;<br>  for ( int start = 0 ;<br>  start < n ;<br>  start ++ ) {<br>    int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ;<br>    for ( int end = start ;<br>    end < n ;<br>    end ++ ) {<br>      int val = arr [ end ] ;<br>      if ( val < min ) {<br>        min = val ;<br>      }<br>      if ( val > max ) {<br>        max = val ;<br>      }<br>      if ( 2 * min <= max ) {<br>        break ;<br>      }<br>      if ( end - start > longest_end - longest_start || longest_start == - 1 ) {<br>        longest_start = start ;<br>        longest_end = end ;<br>      }<br>    }<br>  }<br>  if ( longest_start == - 1 ) {<br>    return n ;<br>  }<br>  return ( n - ( longest_end - longest_start + 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    long longestStart = - 1 ;<br>    int longestEnd = 0 ;<br>    for ( int start = 0 ;  start < n ;  start ++ ) {<br>        int min = Integer . MAX_VALUE ;<br>        int max = - Integer . MAX_VALUE ;<br>        for ( int end = start ;  end < n ;  end ++ ) {<br>            int val = arr [ end ] ;<br>            if ( ( val < min ) && ( val > max ) ){<br>                int min = val ;<br>            }<br>            if ( ( val > max ) && ( val < min ) ){<br>                int max = val ;<br>            }<br>            if ( ( 2 * min <= max ) && ( n > 0 ) ) {<br>                break ;<br>            }<br>            if ( ( end - start > longestEnd - longestStart || longestStart == - 1 ) && ( end - start > longestEnd - longestStart ) ) {<br>                longestStart = start ;<br>                longestEnd = end ;<br>            }<br>        }<br>    }<br>    if ( ( longestStart == - 1 ) && ( n > 0 ) ) {<br>        return n ;<br>    }<br>    return ( n - ( longestEnd - longestStart + 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>REMOVE_MINIMUM_NUMBER_ELEMENTS_NO_COMMON_ELEMENT_EXIST_ARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int a [ ] , int b [ ] , int n , int m ) {<br>  HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ;<br>  HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ;<br>    else countA . put ( a [ i ] , 1 ) ;<br>  }<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ;<br>    else countB . put ( b [ i ] , 1 ) ;<br>  }<br>  int res = 0 ;<br>  Set < Integer > s = countA . keySet ( ) ;<br>  for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ;<br>  return res ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int [ ] a , int [ ] b , int n , int m ) {<br>    Map < Integer , Integer > countA = Collections . emptyMap ( ) ;<br>    Map < Integer , Integer > countB = Collections . emptyMap ( ) ;<br>    for ( int i = 0 ;  i < n ;{<br>        countA [ a [ i ] ] = countA . get ( a [ i ] ) + 1 ;<br>    }<br>    for ( int i = 0 ;  i < n ;{<br>        countB [ b [ i ] ] = countB . get ( b [ i ] ) + 1 ;<br>    }<br>    int res = 0 ;<br>    for ( int x = countA ;  x < n ;{<br>        if ( x == countB . keySet ( ) ){<br>            res += Math . min ( countA [ x ] , countB [ x ] ) ;<br>        }<br>    }<br>    return res ;<br>}</td>
  </tr><tr>
    <th>REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String f_gold ( String s , char c1 , char c2 ) {<br>  int l = s . length ( ) ;<br>  char [ ] arr = s . toCharArray ( ) ;<br>  for ( int i = 0 ;<br>  i < l ;<br>  i ++ ) {<br>    if ( arr [ i ] == c1 ) arr [ i ] = c2 ;<br>    else if ( arr [ i ] == c2 ) arr [ i ] = c1 ;<br>  }<br>  return String . valueOf ( arr ) ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String s , char c1 , char c2 ) {<br>    int l = s . length ( ) ;<br>    for ( int i = 0 ;  i < l ;  i ++ ) {<br>        if ( ( s . charAt ( i ++ ) == c1 ) && ( s . charAt ( i ++ ) == c2 ) ) {<br>            s = s . substring ( 0 , i ) + c2 + s . substring ( i + 1 ) ;<br>        }<br>        else if ( ( s . charAt ( i ) == c2 ) && ( c1 == c2 ) ) {<br>            s = s . substring ( 0 , i ) + c1 + s . substring ( i + 1 ) ;<br>        }<br>    }<br>    return s ;<br>}</td>
  </tr><tr>
    <th>ROUND_THE_GIVEN_NUMBER_TO_NEAREST_MULTIPLE_OF_10</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int a = ( n / 10 ) * 10 ;<br>  int b = a + 10 ;<br>  return ( n - a > b - n ) ? b : a ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    int a = ( n / 10 ) * 10 ;<br>    int b = a + 10 ;<br>    return ( b == 0 ? n - a > b - n ? a : b ) ;<br>}</td>
  </tr><tr>
    <th>SEARCHING_ARRAY_ADJACENT_DIFFER_K</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int x , int k ) {<br>  int i = 0 ;<br>  while ( i < n ) {<br>    if ( arr [ i ] == x ) return i ;<br>    i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ;<br>  }<br>  System . out . println ( "number is " + "not present!" ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int x , int k ) {<br>    int i = 0 ;<br>    while ( ( i < n ) && ( i < k ) ) {<br>        if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == x ) ) {<br>            return i ;<br>        }<br>        i = i + Math . max ( 1 , ( int ) Math . abs ( arr [ i ] - x ) / k ) ;<br>    }<br>    System . out . println ( "number is not present!" ) ;<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACENT_ELEMENTS_IS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n , int x ) {<br>  int i = 0 ;<br>  while ( i < n ) {<br>    if ( arr [ i ] == x ) return i ;<br>    i = i + Math . abs ( arr [ i ] - x ) ;<br>  }<br>  System . out . println ( "number is not" + " present!" ) ;<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n , int x ) {<br>    int i = 0 ;<br>    while ( ( i < n ) && ( i < arr . length ) ) {<br>        if ( ( arr [ i ] == x ) && ( arr [ i ] != 0 ) ) {<br>            return i ;<br>        }<br>        i = i + Math . abs ( arr [ i ] - x ) ;<br>    }<br>    System . out . println ( "number is not present!" ) ;<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int A [ ] , int B [ ] , int m , int n ) {<br>  Arrays . sort ( A ) ;<br>  Arrays . sort ( B ) ;<br>  int a = 0 , b = 0 ;<br>  int result = Integer . MAX_VALUE ;<br>  while ( a < m && b < n ) {<br>    if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ;<br>    if ( A [ a ] < B [ b ] ) a ++ ;<br>    else b ++ ;<br>  }<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] A , int [ ] B , int m , int n ) {<br>    Arrays . sort ( A ) ;<br>    Arrays . sort ( B ) ;<br>    int a = 0 ;<br>    int b = 0 ;<br>    double result = Double . MAX_VALUE ;<br>    while ( ( a < m && b < n ) || ( a < n && b < m && a < m && b < n ) ) {<br>        if ( ( Math . abs ( A [ a ] - B [ b ] ) < result ) && ( Math . abs ( A [ b ] - B [ a ] ) < result ) ){<br>            int result = Math . abs ( A [ a ] - B [ b ] ) ;<br>        }<br>        if ( ( A [ a ] < B [ b ] ) && ( A [ b ] > B [ a ] ) ) {<br>            a ++ ;<br>        }<br>        else{<br>            b ++ ;<br>        }<br>    }<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x , int y , int z ) {<br>  int c = 0 ;<br>  while ( x != 0 && y != 0 && z != 0 ) {<br>    x -- ;<br>    y -- ;<br>    z -- ;<br>    c ++ ;<br>  }<br>  return c ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int x , int y , int z ) {<br>    int c = 0 ;<br>    while ( ( x && y && z ) || ( x && y && z ) ) {<br>        x = x - 1 ;<br>        y = y - 1 ;<br>        z = z - 1 ;<br>        c = c + 1 ;<br>    }<br>    return c ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int count = 0 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( n != 0 ) {<br>    n >>= 1 ;<br>    count += 1 ;<br>  }<br>  return 1 << count ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    int count = 0 ;<br>    if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) {<br>        return n ;<br>    }<br>    while ( ( n != 0 ) && ( n != 1 ) ) {<br>        n >>= 1 ;<br>        count ++ ;<br>    }<br>    return 1 << count ++ ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int p = 1 ;<br>  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;<br>  while ( p < n ) p <<= 1 ;<br>  return p ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    int p = 1 ;<br>    if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) {<br>        return n ;<br>    }<br>    while ( ( p < n ) && ( p < n ) ) {<br>        p <<= 1 ;<br>    }<br>    return p ;<br>}</td>
  </tr><tr>
    <th>SMALLEST_SUM_CONTIGUOUS_SUBARRAY</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int arr [ ] , int n ) {<br>  int min_ending_here = 2147483647 ;<br>  int min_so_far = 2147483647 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ;<br>    else min_ending_here += arr [ i ] ;<br>    min_so_far = Math . min ( min_so_far , min_ending_here ) ;<br>  }<br>  return min_so_far ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    int minEndingHere = Integer . MAX_VALUE ;<br>    int minSoFar = Integer . MAX_VALUE ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( ( minEndingHere > 0 ) && ( n > 0 ) ) {<br>            int minEndingHere = arr [ i ] ;<br>        }<br>        if ( n > 0 ) {<br>            minEndingHere += arr [ i ] ;<br>        }<br>        minSoFar = Math . min ( minSoFar , minEndingHere ) ;<br>    }<br>    return minSoFar ;<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_APPLYING_GIVEN_EQUATION</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void f_gold ( int arr [ ] , int n , int A , int B , int C ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ;<br>  int index = - 1 ;<br>  int maximum = - 999999 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    if ( maximum < arr [ i ] ) {<br>      index = i ;<br>      maximum = arr [ i ] ;<br>    }<br>  }<br>  int i = 0 , j = n - 1 ;<br>  int [ ] new_arr = new int [ n ] ;<br>  int k = 0 ;<br>  while ( i < index && j > index ) {<br>    if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ;<br>    else new_arr [ k ++ ] = arr [ j -- ] ;<br>  }<br>  while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ;<br>  while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ;<br>  new_arr [ n - 1 ] = maximum ;<br>  for ( int p = 0 ;<br>  p < n ;<br>  p ++ ) arr [ p ] = new_arr [ p ] ;<br>}<br></td>
    <td>translated code: <br><br> public static void f_gold ( int [ ] arr , int n , int A , int B , int C ) {<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ) ;<br>    }<br>    int index = - ( Integer . MAX_VALUE - 1 ) ;<br>    int maximum = - ( Integer . MAX_VALUE - 1 ) ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        if ( maximum < arr [ i ] ){<br>            int index = i ;<br>            int maximum = arr [ i ] ;<br>        }<br>    }<br>    int i = 0 ;<br>    int [ ] newArr = new int [ n ] ;<br>    int k = 0 ;<br>    while ( i < index && j > index ){<br>        if ( arr [ i ] < arr [ j ] ){<br>            new_arr [ k ] = arr [ i ] ;<br>            k ++ ;<br>            i ++ ;<br>        }<br>        else {<br>            newArr [ k ] = arr [ j ] ;<br>            k ++ ;<br>            j -- ;<br>        }<br>    }<br>    while ( i < index ){<br>        new_arr [ k ] = arr [ i ] ;<br>        k ++ ;<br>        i ++ ;<br>    }<br>    while ( j > index ){<br>        newArr [ k ] = arr [ j ] ;<br>        k ++ ;<br>        j -- ;<br>        new_arr [ n - 1 ] = maximum ;<br>    }<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        arr [ i ] = new_arr [ i ] ;<br>    }<br>}</td>
  </tr><tr>
    <th>SORT_ARRAY_TWO_HALVES_SORTED</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void f_gold ( int [ ] A , int n ) {<br>  Arrays . sort ( A ) ;<br>}<br></td>
    <td>translated code: <br><br> public static void f_gold ( int [ ] A , int n ) {<br>    Arrays . sort ( A ) ;<br>}</td>
  </tr><tr>
    <th>SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void f_gold ( int arr [ ] , int n ) {<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;<br>  Arrays . sort ( arr ) ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static void f_gold ( int [ ] arr , int n ) {<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] & 1 ) != 0 ){<br>            arr [ i ] *= - 1 ;<br>        }<br>    }<br>    Arrays . sort ( arr ) ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        if ( ( arr [ i ] & 1 ) != 0 ){<br>            arr [ i ] *= - 1 ;<br>        }<br>    }<br>}</td>
  </tr><tr>
    <th>SPLIT_N_MAXIMUM_COMPOSITE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  if ( n < 4 ) return - 1 ;<br>  int rem = n % 4 ;<br>  if ( rem == 0 ) return n / 4 ;<br>  if ( rem == 1 ) {<br>    if ( n < 9 ) return - 1 ;<br>    return ( n - 9 ) / 4 + 1 ;<br>  }<br>  if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ;<br>  if ( rem == 3 ) {<br>    if ( n < 15 ) return - 1 ;<br>    return ( n - 15 ) / 4 + 2 ;<br>  }<br>  return 0 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    if ( ( n < 4 ) && ( n > 0 ) ) {<br>        return - 1 ;<br>    }<br>    int rem = n % 4 ;<br>    if ( ( rem == 0 ) && ( n > 0 ) ) {<br>        return n / 4 ;<br>    }<br>    if ( ( rem == 1 ) && ( n == 1 ) ) {<br>        if ( ( n < 9 ) && ( n > 0 ) ) {<br>            return - 1 ;<br>        }<br>        return ( n - 9 ) / 4 + 1 ;<br>    }<br>    if ( ( rem == 2 ) && ( n == 1 ) ) {<br>        return ( n - 6 ) / 4 + 1 ;<br>    }<br>    if ( ( rem == 3 ) && ( n == 5 ) ) {<br>        if ( ( n < 15 ) && ( n > 0 ) ) {<br>            return - 1 ;<br>        }<br>        return ( n - 15 ) / 4 + 2 ;<br>    }<br>}</td>
  </tr><tr>
    <th>SQUARED_TRIANGULAR_NUMBER_SUM_CUBES</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int s ) {<br>  int sum = 0 ;<br>  for ( int n = 1 ;<br>  sum < s ;<br>  n ++ ) {<br>    sum += n * n * n ;<br>    if ( sum == s ) return n ;<br>  }<br>  return - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int s ) {<br>    _sum = 0 ;<br>    int n = 1 ;<br>    while ( ( _sum < s ) && ( _sum < s ) ) {<br>        _sum += n * n * n ;<br>        n ++ ;<br>    }<br>    n -- ;<br>    if ( _sum == s ) {<br>        return n ;<br>    }<br>    return - 1 ;<br>}</td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_AN_INTEGER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x ) {<br>  if ( x == 0 || x == 1 ) return x ;<br>  int i = 1 , result = 1 ;<br>  while ( result <= x ) {<br>    i ++ ;<br>    result = i * i ;<br>  }<br>  return i - 1 ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int x ) {<br>    if ( ( x == 0 || x == 1 ) && ( x == 0 || x == 1 ) ) {<br>        return x ;<br>    }<br>    int i = 1 ;<br>    while ( ( result <= x ) && ( result > 0 ) ) {<br>        i ++ ;<br>        int result = i * i ;<br>    }<br>    return i - 1 ;<br>}</td>
  </tr><tr>
    <th>SQUARE_ROOT_OF_AN_INTEGER_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int x ) {<br>  if ( x == 0 || x == 1 ) return x ;<br>  int start = 1 , end = x , ans = 0 ;<br>  while ( start <= end ) {<br>    int mid = ( start + end ) / 2 ;<br>    if ( mid * mid == x ) return mid ;<br>    if ( mid * mid < x ) {<br>      start = mid + 1 ;<br>      ans = mid ;<br>    }<br>    else end = mid - 1 ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int x ) {<br>    if ( ( x == 0 || x == 1 ) && ( x == 0 || x == 1 ) ) {<br>        return x ;<br>    }<br>    int start = 1 ;<br>    int end = x ;<br>    while ( ( start <= end ) && ( start <= end ) ) {<br>        int mid = ( start + end ) / 2 ;<br>        if ( ( mid * mid == x ) && ( mid * mid == x ) ){<br>            return mid ;<br>        }<br>        if ( ( mid * mid < x ) && ( mid * mid < x ) ){<br>            start = mid + 1 ;<br>            ans = mid ;<br>        }<br>        }<br>            int end = mid - 1 ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>STEINS_ALGORITHM_FOR_FINDING_GCD</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int a , int b ) {<br>  if ( a == 0 ) return b ;<br>  if ( b == 0 ) return a ;<br>  int k ;<br>  for ( k = 0 ;<br>  ( ( a | b ) & 1 ) == 0 ;<br>  ++ k ) {<br>    a >>= 1 ;<br>    b >>= 1 ;<br>  }<br>  while ( ( a & 1 ) == 0 ) a >>= 1 ;<br>  do {<br>    while ( ( b & 1 ) == 0 ) b >>= 1 ;<br>    if ( a > b ) {<br>      int temp = a ;<br>      a = b ;<br>      b = temp ;<br>    }<br>    b = ( b - a ) ;<br>  }<br>  while ( b != 0 ) ;<br>  return a << k ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int a , int b ) {<br>    if ( ( a == 0 ) && ( b == 0 ) ) {<br>        return b ;<br>    }<br>    if ( ( b == 0 ) && ( a == 5 ) ) {<br>        return a ;<br>    }<br>    int k = 0 ;<br>    while ( ( ( ( a | b ) & 1 ) == 0 ) && ( ( ( a | b ) & 2 ) == 0 ) ) {<br>        a = a >>> 1 ;<br>        b = b >> 1 ;<br>        k = k + 1 ;<br>    }<br>    while ( ( ( a & 1 ) == 0 ) && ( ( b & 1 ) == 0 ) ) {<br>        a = a >>> 1 ;<br>    }<br>    while ( ( b != 0 ) && ( a != 0 ) ) {<br>        while ( ( ( b & 1 ) == 0 ) && ( ( a & 1 ) == 0 ) ) {<br>            b = b >> 1 ;<br>        }<br>        if ( ( a > b ) && ( a < b ) ) {<br>            int temp = a ;<br>            a = b ;<br>            b = temp ;<br>        }<br>        b = ( b - a ) ;<br>    }<br>    return ( a << k ) ;<br>}</td>
  </tr><tr>
    <th>STOOGE_SORT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static void f_gold ( int arr [ ] , int l , int h ) {<br>  if ( l >= h ) return ;<br>  if ( arr [ l ] > arr [ h ] ) {<br>    int t = arr [ l ] ;<br>    arr [ l ] = arr [ h ] ;<br>    arr [ h ] = t ;<br>  }<br>  if ( h - l + 1 > 2 ) {<br>    int t = ( h - l + 1 ) / 3 ;<br>    f_gold ( arr , l , h - t ) ;<br>    f_gold ( arr , l + t , h ) ;<br>    f_gold ( arr , l , h - t ) ;<br>  }<br>}<br></td>
    <td>translated code: <br><br> public static void f_gold ( int [ ] arr , int l , int h ) {<br>    if ( l >= h ) {<br>        }<br>    }<br>    if ( arr [ l ] > arr [ h ] ) {<br>        int t = arr [ l ] ;<br>        arr [ l ] = arr [ h ] ;<br>        arr [ h ] = t ;<br>    }<br>    if ( h - l + 1 > 2 ) {<br>        int t = ( int ) ( ( h - l + 1 ) / 3 ) ;<br>        fGold ( arr , l , ( h - t ) ) ;<br>        f_gold ( arr , l + t , ( h ) ) ;<br>        fGold ( arr , l , ( h - t ) ) ;<br>    }<br>}</td>
  </tr><tr>
    <th>SUBARRAYS_DISTINCT_ELEMENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>  Set < Integer > s = new HashSet < > ( ) ;<br>  int j = 0 , ans = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    while ( j < n && ! s . contains ( arr [ j ] ) ) {<br>      s . add ( arr [ i ] ) ;<br>      j ++ ;<br>    }<br>    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;<br>    s . remove ( arr [ i ] ) ;<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] arr , int n ) {<br>    String s = new String ( ) ;<br>    int j = 0 ;<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        while ( ( j < n ) && ( arr [ j ] != s ) ) {<br>            s . add ( arr [ j ] ) ;<br>            j ++ ;<br>        }<br>        ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;<br>        s . remove ( arr [ i ] ) ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SUBSEQUENCES_SIZE_THREE_ARRAY_WHOSE_SUM_DIVISIBLE_M</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int A [ ] , int N , int M ) {<br>  int sum = 0 ;<br>  int ans = 0 ;<br>  for ( int i = 0 ;<br>  i < N ;<br>  i ++ ) {<br>    for ( int j = i + 1 ;<br>    j < N ;<br>    j ++ ) {<br>      for ( int k = j + 1 ;<br>      k < N ;<br>      k ++ ) {<br>        sum = A [ i ] + A [ j ] + A [ k ] ;<br>        if ( sum % M == 0 ) ans ++ ;<br>      }<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int A [ ] , int N , int M ) {<br>    int sum = 0 ;<br>    int ans = 0 ;<br>    for ( int i = 0 ;  i <= N ;  i ++ ) {<br>        for ( int j = i + 1 ;  j < N ;  j ++ ) {<br>            for ( int k = j + 1 ;  k < N ;  k ++ ) {<br>                int sum = A [ i ] + A [ j ] + A [ k ] ;<br>                if ( ( sum % M == 0 ) && ( sum % M == 0 ) ) {<br>                    ans = ans + 1 ;<br>                }<br>            }<br>        }<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SUM_BINOMIAL_COEFFICIENTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) {<br>    for ( int j = 0 ;<br>    j <= Math . min ( i , n ) ;<br>    j ++ ) {<br>      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;<br>      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>    }<br>  }<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i <= n ;<br>  i ++ ) sum += C [ n ] [ i ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] [ ] C = new int [ n + 2 ] [ n + 2 ] ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        for ( int j = 0 ;  j <= Math . min ( i , n ) ;  j ++ ) {<br>            if ( ( j == 0 || j == i ) && ( j == 0 || j == i ) ) {<br>                C [ i ] [ j ] = 1 ;<br>            }<br>            }<br>                C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ;<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i <= n ;  i ++ ) {<br>        sum += C [ n ] [ i ] ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>SUM_BINOMIAL_COEFFICIENTS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return ( 1 << n ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    return ( 1 << n ) ;<br>}</td>
  </tr><tr>
    <th>SUM_DIVISORS_1_N_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int sum = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  ++ i ) sum += ( n / i ) * i ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGoldenN ( int n ) {<br>    int sum = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        sum += ( int ) ( n / i ) * i ;<br>    }<br>    return ( int ) sum ;<br>}</td>
  </tr><tr>
    <th>SUM_FACTORS_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int result = 0 ;<br>  for ( int i = 2 ;<br>  i <= Math . sqrt ( n ) ;<br>  i ++ ) {<br>    if ( n % i == 0 ) {<br>      if ( i == ( n / i ) ) result += i ;<br>      else result += ( i + n / i ) ;<br>    }<br>  }<br>  return ( result + n + 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int result = 0 ;<br>    for ( int i = 2 ;  i <= ( int ) ( Math . sqrt ( n ) ) ;  i ++ ) {<br>        if ( ( n % i == 0 ) && ( n % i == 0 ) ) {<br>            if ( ( i == ( n / i ) ) && ( i != ( n / i ) ) ) {<br>                result = result + i ;<br>            }<br>            }<br>                result = result + ( i + n / i ) ;<br>        }<br>    }<br>    return ( result + n + 1 ) ;<br>}</td>
  </tr><tr>
    <th>SUM_FAI_AJ_PAIRS_ARRAY_N_INTEGERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> public static int f_gold ( int a [ ] , int n ) {<br>  Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ;<br>  int ans = 0 , pre_sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) {<br>    ans += ( i * a [ i ] ) - pre_sum ;<br>    pre_sum += a [ i ] ;<br>    if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ;<br>    if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ;<br>    if ( cnt . containsKey ( a [ i ] ) ) {<br>      cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ;<br>    }<br>    else {<br>      cnt . put ( a [ i ] , 1 ) ;<br>    }<br>  }<br>  return ans ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int n ) {<br>    Map < Integer , Integer > cnt = Collections . synchronizedMap ( new HashMap < Integer , Integer > ( ) ) ;<br>    int ans = 0 ;<br>    int preSum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        ans += ( i * a [ i ] ) - preSum ;<br>        pre_sum += a [ i ] ;<br>        if ( ( a [ i ] - 1 ) == cnt ) a [ i ] = 5 ;<br>            ans -= cnt [ a [ i ] - 1 ] ;<br>        if ( ( a [ i ] + 1 ) == cnt ) a [ i ] = 5 ;<br>            ans += cnt [ a [ i ] + 1 ] ;<br>        if ( a [ i ] != cnt ) a [ i ] = 5 ;<br>            cnt [ a [ i ] ] = 0 ;<br>        cnt [ a [ i ] ] ++ ;<br>    }<br>    return ans ;<br>}</td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int [ ] [ ] arr = new int [ n ] [ n ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ;<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < n ;<br>  j ++ ) sum += arr [ i ] [ j ] ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int [ ] arr = new int [ n ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            arr [ i ] [ j ] = Math . abs ( i - j ) ;<br>        }<br>    }<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < n ;  j ++ ) {<br>            sum += arr [ i ] [ j ] ;<br>        }<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) sum += i * ( n - i ) ;<br>  return 2 * sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        sum += i * ( n - i ) ;<br>    }<br>    return 2 * sum ;<br>}</td>
  </tr><tr>
    <th>SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  n -- ;<br>  int sum = 0 ;<br>  sum += ( n * ( n + 1 ) ) / 2 ;<br>  sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    n -- ;<br>    int sum = 0 ;<br>    sum += ( n * ( n + 1 ) ) / 2 ;<br>    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;<br>    return ( int ) sum ;<br>}</td>
  </tr><tr>
    <th>SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( int n ) {<br>  long sum = 0 ;<br>  sum = 1 << n ;<br>  return ( sum - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int sum = 0 ;<br>    int sum = 1 << n ;<br>    return ( sum - 1 ) ;<br>}</td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int sum = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) for ( int j = i ;<br>  j <= n ;<br>  j ++ ) sum = sum + i * j ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    int sm = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        for ( int j = i ;  j <= n ;  j ++ ) {<br>            sm = sm + i * j ;<br>        }<br>    }<br>    return sm ;<br>}</td>
  </tr><tr>
    <th>SUM_PAIRWISE_PRODUCTS_2</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGold ( int n ) {<br>    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;<br>}</td>
  </tr><tr>
    <th>SUM_SERIES_12_32_52_2N_12</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  int sum = 0 ;<br>  for ( int i = 1 ;<br>  i <= n ;<br>  i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n ) {<br>    int sum = 0 ;<br>    for ( int i = 1 ;  i <= n ;  i ++ ) {<br>        sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>SUM_SERIES_555555_N_TERMS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ;<br>}<br></td>
    <td>translated code: <br><br> public static int fGoldenN ( int n ) {<br>    return ( int ) ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ;<br>}</td>
  </tr><tr>
    <th>SUM_SUBSETS_SET_FORMED_FIRST_N_NATURAL_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static long f_gold ( int n ) {<br>  return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ;<br>}<br></td>
    <td>translated code: <br><br> static long f_gold ( int n ) {<br>    return ( n * ( n + 1 ) / 2 ) * ( 1L << ( n - 1 ) ) ;<br>}</td>
  </tr><tr>
    <th>SUM_TWO_LARGE_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static String f_gold ( String str1 , String str2 ) {<br>  if ( str1 . length ( ) > str2 . length ( ) ) {<br>    String t = str1 ;<br>    str1 = str2 ;<br>    str2 = t ;<br>  }<br>  String str = "" ;<br>  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;<br>  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString ( ) ;<br>  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString ( ) ;<br>  int carry = 0 ;<br>  for ( int i = 0 ;<br>  i < n1 ;<br>  i ++ ) {<br>    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  for ( int i = n1 ;<br>  i < n2 ;<br>  i ++ ) {<br>    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry ) ;<br>    str += ( char ) ( sum % 10 + '0' ) ;<br>    carry = sum / 10 ;<br>  }<br>  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;<br>  str = new StringBuilder ( str ) . reverse ( ) . toString ( ) ;<br>  return str ;<br>}<br></td>
    <td>translated code: <br><br> public static String f_gold ( String str1 , String str2 ) {<br>    if ( ( str1 . length ( ) > str2 . length ( ) ) && ( str1 . length ( ) > str2 . length ( ) ) ) {<br>        String t = str1 ;<br>        str1 = str2 ;<br>        str2 = t ;<br>    }<br>    String str = "" ;<br>    int n1 = str1 . length ( ) ;<br>    int n2 = str2 . length ( ) ;<br>    str1 = str1 . substring ( 0 , str1 . length ( ) - 1 ) ;<br>    str2 = str2 . substring ( 0 , str2 . length ( ) - 1 ) ;<br>    int carry = 0 ;<br>    for ( int i = 0 ;  i < n1 ;  i ++ ) {<br>        int sum = ( ( ( int ) str1 . charAt ( i ) ) - 48 ) + ( ( ( int ) str2 . charAt ( i ) ) - 48 ) + carry ;<br>        str += ( char ) ( sum % 10 + 48 ) ;<br>        int carry = ( int ) ( sum / 10 ) ;<br>    }<br>    for ( int i = n1 ;  i < n2 ;  i ++ ) {<br>        int sum = ( ( Character . digit ( str2 . charAt ( i ) , 48 ) - 48 ) + carry ) ;<br>        str += ( char ) ( sum % 10 + 48 ) ;<br>        carry = ( int ) ( sum / 10 ) ;<br>    }<br>    if ( ( carry ) && ( str1 != null ) && ( str2 != null ) ) {<br>        str += ( char ) ( carry + 48 ) ;<br>    }<br>    String str = str1 ;<br>    return String . valueOf ( str1 ) ;<br>}</td>
  </tr><tr>
    <th>SWAP_BITS_IN_A_GIVEN_NUMBER</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x , int p1 , int p2 , int n ) {<br>  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;<br>  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;<br>  int xor = ( set1 ^ set2 ) ;<br>  xor = ( xor << p1 ) | ( xor << p2 ) ;<br>  int result = x ^ xor ;<br>  return result ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int x , int p1 , int p2 , int n ) {<br>    int set1 = ( x >>> p1 ) & ( ( 1 << n ) - 1 ) ;<br>    int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;<br>    int xor = ( set1 ^ set2 ) . length ;<br>    xor = ( xor << p1 ) | ( xor << p2 ) ;<br>    int result = x ^ xor ;<br>    return result ;<br>}</td>
  </tr><tr>
    <th>SWAP_TWO_NIBBLES_BYTE</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x ) {<br>  return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int x ) {<br>    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >>> 4 ) ;<br>}</td>
  </tr><tr>
    <th>TEMPLE_OFFERINGS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n , int templeHeight [ ] ) {<br>  int sum = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  ++ i ) {<br>    int left = 0 , right = 0 ;<br>    for ( int j = i - 1 ;<br>    j >= 0 ;<br>    -- j ) {<br>      if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ;<br>      else break ;<br>    }<br>    for ( int j = i + 1 ;<br>    j < n ;<br>    ++ j ) {<br>      if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ;<br>      else break ;<br>    }<br>    sum += Math . max ( right , left ) + 1 ;<br>  }<br>  return sum ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int n , int [ ] templeHeight ) {<br>    int sum = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        int left = 0 ;<br>        int right = 0 ;<br>        for ( int j = i - 1 ;  j >= 0 ;  j -- ) {<br>            if ( ( templeHeight [ j ] < templeHeight [ j + 1 ] ) && ( templeHeight [ j + 1 ] > templeHeight [ j ] ) ) {<br>                left ++ ;<br>            }<br>            else {<br>                break ;<br>            }<br>        }<br>        for ( int j = i + 1 ;  j < n ;  j ++ ) {<br>            if ( ( templeHeight [ j ] < templeHeight [ j - 1 ] ) && ( templeHeight [ j ] > templeHeight [ j - 2 ] ) ) {<br>                right ++ ;<br>            }<br>            else {<br>                break ;<br>            }<br>        }<br>        sum += Math . max ( right , left ) + 1 ;<br>    }<br>    return sum ;<br>}</td>
  </tr><tr>
    <th>TRIANGULAR_NUMBERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int num ) {<br>  if ( num < 0 ) return false ;<br>  int sum = 0 ;<br>  for ( int n = 1 ;<br>  sum <= num ;<br>  n ++ ) {<br>    sum = sum + n ;<br>    if ( sum == num ) return true ;<br>  }<br>  return false ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int num ) {<br>    if ( ( num < 0 ) || ( num > 5 ) ) {<br>        return false ;<br>    }<br>    int sum = 0 , n = 1 ;<br>    while ( ( sum <= num ) && ( sum <= num ) ) {<br>        sum = sum + n ;<br>        if ( ( sum == num ) && ( sum == num ) ) {<br>            return fGold ( num , true ) ;<br>        }<br>        n ++ ;<br>    }<br>    return false ;<br>}</td>
  </tr><tr>
    <th>TURN_OFF_THE_RIGHTMOST_SET_BIT</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int n ) {<br>  return n & ( n - 1 ) ;<br>}<br></td>
    <td>translated code: <br><br> static int f_gold ( int n ) {<br>    return n & ( n - 1 ) ;<br>}</td>
  </tr><tr>
    <th>UNIQUE_CELLS_BINARY_MATRIX</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int mat [ ] [ ] , int n , int m ) {<br>  int [ ] rowsum = new int [ n ] ;<br>  int [ ] colsum = new int [ m ] ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( mat [ i ] [ j ] != 0 ) {<br>    rowsum [ i ] ++ ;<br>    colsum [ j ] ++ ;<br>  }<br>  int uniquecount = 0 ;<br>  for ( int i = 0 ;<br>  i < n ;<br>  i ++ ) for ( int j = 0 ;<br>  j < m ;<br>  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ;<br>  return uniquecount ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] [ ] mat , int n , int m ) {<br>    int [ ] rowsum = new int [ n ] ;<br>    int [ ] colsum = new int [ m ] ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] != 0 ) && ( mat [ j ] [ i ] != 0 ) ){<br>                rowsum [ i ] ++ ;<br>                colsum [ j ] ++ ;<br>            }<br>        }<br>    }<br>    int uniquecount = 0 ;<br>    for ( int i = 0 ;  i < n ;  i ++ ) {<br>        for ( int j = 0 ;  j < m ;  j ++ ) {<br>            if ( ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) || ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) ){<br>                uniquecount ++ ;<br>            }<br>        }<br>    }<br>    return uniquecount ;<br>}</td>
  </tr><tr>
    <th>WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( String a , String b ) {<br>  int n = a . length ( ) , m = b . length ( ) ;<br>  if ( m == 0 ) {<br>    return 1 ;<br>  }<br>  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;<br>  for ( int i = 0 ;<br>  i < m ;<br>  i ++ ) {<br>    for ( int j = i ;<br>    j < n ;<br>    j ++ ) {<br>      if ( i == 0 ) {<br>        if ( j == 0 ) {<br>          dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0 ;<br>        }<br>        else if ( a . charAt ( j ) == b . charAt ( i ) ) {<br>          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;<br>        }<br>        else {<br>          dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;<br>        }<br>      }<br>      else if ( a . charAt ( j ) == b . charAt ( i ) ) {<br>        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ;<br>      }<br>      else {<br>        dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;<br>      }<br>    }<br>  }<br>  return dp [ m - 1 ] [ n - 1 ] ;<br>}<br></td>
    <td>translated code: <br><br> public static int f_gold ( int [ ] a , int [ ] b ) {<br>    int n = a . length ( ) ;<br>    int m = b . length ;<br>    if ( m == 0 ){<br>        return 1 ;<br>    }<br>    int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;<br>    for ( int i = 0 ;  i < m ;{<br>        for ( int j = i ;  j < n ;{<br>            if ( i == 0 ){<br>                if ( j == 0 ){<br>                    if ( a [ j ] == b [ i ] ) a [ j ] = 5 ;<br>                        dp [ i ] [ j ] = 1 ;<br>                    }<br>                        dp [ i ] [ j ] = 0 ;<br>                }<br>                else if ( a [ j ] == b [ i ] ) a [ j ] = 5 ;<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;<br>                }<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;<br>            }<br>            }<br>                if ( a [ j ] == b [ i ] ) a [ j ] = 5 ;<br>                    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ;<br>                }<br>                    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;<br>        }<br>    }<br>    return dp [ m - 1 ] [ n - 1 ] ;<br>}</td>
  </tr><tr>
    <th>WRITE_A_C_PROGRAM_TO_CALCULATE_POWXN</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static int f_gold ( int x , int y ) {<br>  if ( y == 0 ) return 1 ;<br>  else if ( y % 2 == 0 ) return f_gold ( x , y / 2 ) * f_gold ( x , y / 2 ) ;<br>  else return x * f_gold ( x , y / 2 ) * f_gold ( x , y / 2 ) ;<br>}<br></td>
    <td>translated code: <br><br> public static double fGold ( double x , double y ) {<br>    if ( ( y == 0 ) && ( x == 0 ) ) {<br>        return 1 ;<br>    }<br>    }<br>        return ( fGoldenSquared ( x , ( int ) ( y / 2 ) ) * fGoldenSquared ( x , ( int ) ( y / 2 ) ) ) ;<br>    }<br>        return ( x * fGoldenSquared ( x , ( int ) ( y / 2 ) ) * fGoldenSquared ( x , ( int ) ( y / 2 ) ) ) ;<br>}</td>
  </tr><tr>
    <th>WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TWO</th>
    <th></th>
  </tr><tr>
    <td>origin code: <br><br> static boolean f_gold ( int n ) {<br>  if ( n == 0 ) return false ;<br>  while ( n != 1 ) {<br>    if ( n % 2 != 0 ) return false ;<br>    n = n / 2 ;<br>  }<br>  return true ;<br>}<br></td>
    <td>translated code: <br><br> public static boolean f_gold ( int n ) {<br>    if ( ( n == 0 ) && ( n == 1 ) ) {<br>        return false ;<br>    }<br>    while ( ( n != 1 ) && ( n != 2 ) ) {<br>        if ( ( n % 2 != 0 ) && ( n % 2 == 0 ) ) {<br>            return false ;<br>        }<br>        n = n / 2 ;<br>    }<br>    return fGoldenNum ( n , true ) ;<br>}</td>
  </tr></table>
</body>
</html>
